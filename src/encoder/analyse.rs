#[c2rust::header_src = "internal:0"]
pub mod internal {
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "0:0"]
    pub struct __va_list_tag {
        pub gp_offset: ::core::ffi::c_uint,
        pub fp_offset: ::core::ffi::c_uint,
        pub overflow_arg_area: *mut ::core::ffi::c_void,
        pub reg_save_area: *mut ::core::ffi::c_void,
    }
    #[c2rust::src_loc = "3:9"]
    pub const BIT_DEPTH: ::core::ffi::c_int = 10 as ::core::ffi::c_int;
    #[c2rust::src_loc = "61:9"]
    pub const __INT_MAX__: ::core::ffi::c_int = 2147483647 as ::core::ffi::c_int;
}
#[c2rust::header_src = "/usr/lib/clang/21/include/__stddef_size_t.h:28"]
pub mod __stddef_size_t_h {
    #[c2rust::src_loc = "18:1"]
    pub type size_t = usize;
}
#[c2rust::header_src = "/usr/include/bits/types.h:28"]
pub mod types_h {
    #[c2rust::src_loc = "37:1"]
    pub type __int8_t = i8;
    #[c2rust::src_loc = "38:1"]
    pub type __uint8_t = u8;
    #[c2rust::src_loc = "39:1"]
    pub type __int16_t = i16;
    #[c2rust::src_loc = "40:1"]
    pub type __uint16_t = u16;
    #[c2rust::src_loc = "41:1"]
    pub type __int32_t = i32;
    #[c2rust::src_loc = "42:1"]
    pub type __uint32_t = u32;
    #[c2rust::src_loc = "44:1"]
    pub type __int64_t = i64;
    #[c2rust::src_loc = "45:1"]
    pub type __uint64_t = u64;
}
#[c2rust::header_src = "/usr/include/bits/stdint-intn.h:28"]
pub mod stdint_intn_h {
    #[c2rust::src_loc = "24:1"]
    pub type int8_t = __int8_t;
    #[c2rust::src_loc = "25:1"]
    pub type int16_t = __int16_t;
    #[c2rust::src_loc = "26:1"]
    pub type int32_t = __int32_t;
    #[c2rust::src_loc = "27:1"]
    pub type int64_t = __int64_t;
    use super::types_h::{__int16_t, __int32_t, __int64_t, __int8_t};
}
#[c2rust::header_src = "/usr/include/bits/stdint-uintn.h:28"]
pub mod stdint_uintn_h {
    #[c2rust::src_loc = "24:1"]
    pub type uint8_t = __uint8_t;
    #[c2rust::src_loc = "25:1"]
    pub type uint16_t = __uint16_t;
    #[c2rust::src_loc = "26:1"]
    pub type uint32_t = __uint32_t;
    #[c2rust::src_loc = "27:1"]
    pub type uint64_t = __uint64_t;
    use super::types_h::{__uint16_t, __uint32_t, __uint64_t, __uint8_t};
}
#[c2rust::header_src = "/usr/include/stdint.h:28"]
pub mod stdint_h {
    #[c2rust::src_loc = "76:1"]
    pub type intptr_t = isize;
    #[c2rust::src_loc = "79:1"]
    pub type uintptr_t = usize;
}
#[c2rust::header_src = "/usr/include/bits/atomic_wide_counter.h:28"]
pub mod atomic_wide_counter_h {
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "25:9"]
    pub union __atomic_wide_counter {
        pub __value64: ::core::ffi::c_ulonglong,
        pub __value32: C2RustUnnamed,
    }
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "28:3"]
    pub struct C2RustUnnamed {
        pub __low: ::core::ffi::c_uint,
        pub __high: ::core::ffi::c_uint,
    }
}
#[c2rust::header_src = "/usr/include/bits/thread-shared-types.h:28"]
pub mod thread_shared_types_h {
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "51:16"]
    pub struct __pthread_internal_list {
        pub __prev: *mut __pthread_internal_list,
        pub __next: *mut __pthread_internal_list,
    }
    #[c2rust::src_loc = "51:1"]
    pub type __pthread_list_t = __pthread_internal_list;
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "94:8"]
    pub struct __pthread_cond_s {
        pub __wseq: __atomic_wide_counter,
        pub __g1_start: __atomic_wide_counter,
        pub __g_size: [::core::ffi::c_uint; 2],
        pub __g1_orig_size: ::core::ffi::c_uint,
        pub __wrefs: ::core::ffi::c_uint,
        pub __g_signals: [::core::ffi::c_uint; 2],
        pub __unused_initialized_1: ::core::ffi::c_uint,
        pub __unused_initialized_2: ::core::ffi::c_uint,
    }
    use super::atomic_wide_counter_h::__atomic_wide_counter;
}
#[c2rust::header_src = "/usr/include/bits/struct_mutex.h:28"]
pub mod struct_mutex_h {
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "22:8"]
    pub struct __pthread_mutex_s {
        pub __lock: ::core::ffi::c_int,
        pub __count: ::core::ffi::c_uint,
        pub __owner: ::core::ffi::c_int,
        pub __nusers: ::core::ffi::c_uint,
        pub __kind: ::core::ffi::c_int,
        pub __spins: ::core::ffi::c_short,
        pub __elision: ::core::ffi::c_short,
        pub __list: __pthread_list_t,
    }
    use super::thread_shared_types_h::__pthread_list_t;
}
#[c2rust::header_src = "/usr/include/bits/pthreadtypes.h:28"]
pub mod pthreadtypes_h {
    #[c2rust::src_loc = "27:1"]
    pub type pthread_t = ::core::ffi::c_ulong;
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "67:9"]
    pub union pthread_mutex_t {
        pub __data: __pthread_mutex_s,
        pub __size: [::core::ffi::c_char; 40],
        pub __align: ::core::ffi::c_long,
    }
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "75:9"]
    pub union pthread_cond_t {
        pub __data: __pthread_cond_s,
        pub __size: [::core::ffi::c_char; 48],
        pub __align: ::core::ffi::c_longlong,
    }
    use super::struct_mutex_h::__pthread_mutex_s;
    use super::thread_shared_types_h::__pthread_cond_s;
}
#[c2rust::header_src = "/home/nwplayer123/Hacks/hex264/x264/common/common.h:28"]
pub mod common_h {
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "270:8"]
    pub struct x264_t {
        pub param: x264_param_t,
        pub api: *mut ::core::ffi::c_void,
        pub thread: [*mut x264_t; 129],
        pub lookahead_thread: [*mut x264_t; 16],
        pub b_thread_active: ::core::ffi::c_int,
        pub i_thread_phase: ::core::ffi::c_int,
        pub i_thread_idx: ::core::ffi::c_int,
        pub i_threadslice_start: ::core::ffi::c_int,
        pub i_threadslice_end: ::core::ffi::c_int,
        pub i_threadslice_pass: ::core::ffi::c_int,
        pub threadpool: *mut x264_threadpool_t,
        pub lookaheadpool: *mut x264_threadpool_t,
        pub mutex: pthread_mutex_t,
        pub cv: pthread_cond_t,
        pub out: C2RustUnnamed_18,
        pub nal_buffer: *mut uint8_t,
        pub nal_buffer_size: ::core::ffi::c_int,
        pub reconfig_h: *mut x264_t,
        pub reconfig: ::core::ffi::c_int,
        pub i_frame: ::core::ffi::c_int,
        pub i_frame_num: ::core::ffi::c_int,
        pub i_thread_frames: ::core::ffi::c_int,
        pub i_nal_type: ::core::ffi::c_int,
        pub i_nal_ref_idc: ::core::ffi::c_int,
        pub i_disp_fields: int64_t,
        pub i_disp_fields_last_frame: ::core::ffi::c_int,
        pub i_prev_duration: int64_t,
        pub i_coded_fields: int64_t,
        pub i_cpb_delay: int64_t,
        pub i_coded_fields_lookahead: int64_t,
        pub i_cpb_delay_lookahead: int64_t,
        pub i_cpb_delay_pir_offset: int64_t,
        pub i_cpb_delay_pir_offset_next: int64_t,
        pub b_queued_intra_refresh: ::core::ffi::c_int,
        pub i_last_idr_pts: int64_t,
        pub i_idr_pic_id: ::core::ffi::c_int,
        pub dequant4_mf: [*mut [::core::ffi::c_int; 16]; 4],
        pub dequant8_mf: [*mut [::core::ffi::c_int; 64]; 4],
        pub unquant4_mf: [*mut [::core::ffi::c_int; 16]; 4],
        pub unquant8_mf: [*mut [::core::ffi::c_int; 64]; 4],
        pub quant4_mf: [*mut [udctcoef; 16]; 4],
        pub quant8_mf: [*mut [udctcoef; 64]; 4],
        pub quant4_bias: [*mut [udctcoef; 16]; 4],
        pub quant8_bias: [*mut [udctcoef; 64]; 4],
        pub quant4_bias0: [*mut [udctcoef; 16]; 4],
        pub quant8_bias0: [*mut [udctcoef; 64]; 4],
        pub nr_offset_emergency: *mut [[udctcoef; 64]; 4],
        pub cost_mv: [*mut uint16_t; 82],
        pub cost_mv_fpel: [[*mut uint16_t; 4]; 82],
        pub cost_table: *mut C2RustUnnamed_17,
        pub chroma_qp_table: *const uint8_t,
        pub sh: x264_slice_header_t,
        pub sps: [x264_sps_t; 1],
        pub pps: [x264_pps_t; 1],
        pub b_sh_backup: ::core::ffi::c_int,
        pub sh_backup: x264_slice_header_t,
        pub cabac: x264_cabac_t,
        pub frames: C2RustUnnamed_11,
        pub fenc: *mut x264_frame_t,
        pub fdec: *mut x264_frame_t,
        pub i_ref: [::core::ffi::c_int; 2],
        pub fref: [[*mut x264_frame_t; 19]; 2],
        pub fref_nearest: [*mut x264_frame_t; 2],
        pub b_ref_reorder: [::core::ffi::c_int; 2],
        pub initial_cpb_removal_delay: ::core::ffi::c_int,
        pub initial_cpb_removal_delay_offset: ::core::ffi::c_int,
        pub i_reordered_pts_delay: int64_t,
        pub dct: C2RustUnnamed_10,
        pub mb: C2RustUnnamed_7,
        pub rc: *mut x264_ratecontrol_t,
        pub stat: C2RustUnnamed_6,
        pub nr_offset: *mut [udctcoef; 64],
        pub nr_residual_sum: *mut [uint32_t; 64],
        pub nr_count: *mut uint32_t,
        pub nr_offset_denoise: [[udctcoef; 64]; 4],
        pub nr_residual_sum_buf: [[[uint32_t; 64]; 4]; 2],
        pub nr_count_buf: [[uint32_t; 4]; 2],
        pub luma2chroma_pixel: [uint8_t; 7],
        pub scratch_buffer: *mut ::core::ffi::c_void,
        pub scratch_buffer2: *mut ::core::ffi::c_void,
        pub intra_border_backup: [[*mut pixel; 3]; 5],
        pub deblock_strength: [*mut [[[uint8_t; 4]; 8]; 2]; 2],
        pub predict_16x16: [x264_predict_t; 7],
        pub predict_8x8: [x264_predict8x8_t; 12],
        pub predict_4x4: [x264_predict_t; 12],
        pub predict_chroma: [x264_predict_t; 7],
        pub predict_8x8c: [x264_predict_t; 7],
        pub predict_8x16c: [x264_predict_t; 7],
        pub predict_8x8_filter: x264_predict_8x8_filter_t,
        pub pixf: x264_pixel_function_t,
        pub mc: x264_mc_functions_t,
        pub dctf: x264_dct_function_t,
        pub zigzagf: x264_zigzag_function_t,
        pub zigzagf_interlaced: x264_zigzag_function_t,
        pub zigzagf_progressive: x264_zigzag_function_t,
        pub quantf: x264_quant_function_t,
        pub loopf: x264_deblock_function_t,
        pub bsf: x264_bitstream_function_t,
        pub lookahead: *mut x264_lookahead_t,
    }
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "217:16"]
    pub struct x264_lookahead_t {
        pub b_exit_thread: uint8_t,
        pub b_thread_active: uint8_t,
        pub b_analyse_keyframe: uint8_t,
        pub i_last_keyframe: ::core::ffi::c_int,
        pub i_slicetype_length: ::core::ffi::c_int,
        pub last_nonb: *mut x264_frame_t,
        pub thread_handle: pthread_t,
        pub ifbuf: x264_sync_frame_list_t,
        pub next: x264_sync_frame_list_t,
        pub ofbuf: x264_sync_frame_list_t,
    }
    #[c2rust::src_loc = "94:5"]
    pub type pixel = uint16_t;
    #[c2rust::src_loc = "96:5"]
    pub type dctcoef = int32_t;
    #[c2rust::src_loc = "97:5"]
    pub type udctcoef = uint32_t;
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "685:5"]
    pub struct C2RustUnnamed_6 {
        pub i_frame_count: [::core::ffi::c_int; 3],
        pub i_frame_size: [int64_t; 3],
        pub f_frame_qp: [::core::ffi::c_double; 3],
        pub i_consecutive_bframes: [::core::ffi::c_int; 17],
        pub f_ssd_global: [::core::ffi::c_double; 3],
        pub f_psnr_average: [::core::ffi::c_double; 3],
        pub f_psnr_mean_y: [::core::ffi::c_double; 3],
        pub f_psnr_mean_u: [::core::ffi::c_double; 3],
        pub f_psnr_mean_v: [::core::ffi::c_double; 3],
        pub f_ssim_mean_y: [::core::ffi::c_double; 3],
        pub f_frame_duration: [::core::ffi::c_double; 3],
        pub i_mb_count: [[int64_t; 19]; 3],
        pub i_mb_partition: [[int64_t; 17]; 2],
        pub i_mb_count_8x8dct: [int64_t; 2],
        pub i_mb_count_ref: [[[int64_t; 32]; 2]; 2],
        pub i_mb_cbp: [int64_t; 6],
        pub i_mb_pred_mode: [[int64_t; 13]; 4],
        pub i_mb_field: [int64_t; 3],
        pub i_direct_score: [::core::ffi::c_int; 2],
        pub i_direct_frames: [::core::ffi::c_int; 2],
        pub i_wpred: [::core::ffi::c_int; 2],
        pub frame: x264_frame_stat_t,
    }
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "243:9"]
    pub struct x264_frame_stat_t {
        pub i_mv_bits: ::core::ffi::c_int,
        pub i_tex_bits: ::core::ffi::c_int,
        pub i_misc_bits: ::core::ffi::c_int,
        pub i_mb_count: [::core::ffi::c_int; 19],
        pub i_mb_count_i: ::core::ffi::c_int,
        pub i_mb_count_p: ::core::ffi::c_int,
        pub i_mb_count_skip: ::core::ffi::c_int,
        pub i_mb_count_8x8dct: [::core::ffi::c_int; 2],
        pub i_mb_count_ref: [[::core::ffi::c_int; 32]; 2],
        pub i_mb_partition: [::core::ffi::c_int; 17],
        pub i_mb_cbp: [::core::ffi::c_int; 6],
        pub i_mb_pred_mode: [[::core::ffi::c_int; 13]; 4],
        pub i_mb_field: [::core::ffi::c_int; 3],
        pub i_direct_score: [::core::ffi::c_int; 2],
        pub i_ssd: [int64_t; 3],
        pub f_ssim: ::core::ffi::c_double,
        pub i_ssim_cnt: ::core::ffi::c_int,
    }
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "438:5"]
    pub struct C2RustUnnamed_7 {
        pub i_mb_width: ::core::ffi::c_int,
        pub i_mb_height: ::core::ffi::c_int,
        pub i_mb_count: ::core::ffi::c_int,
        pub chroma_h_shift: ::core::ffi::c_int,
        pub chroma_v_shift: ::core::ffi::c_int,
        pub i_mb_stride: ::core::ffi::c_int,
        pub i_b8_stride: ::core::ffi::c_int,
        pub i_b4_stride: ::core::ffi::c_int,
        pub left_b8: [::core::ffi::c_int; 2],
        pub left_b4: [::core::ffi::c_int; 2],
        pub i_mb_x: ::core::ffi::c_int,
        pub i_mb_y: ::core::ffi::c_int,
        pub i_mb_xy: ::core::ffi::c_int,
        pub i_b8_xy: ::core::ffi::c_int,
        pub i_b4_xy: ::core::ffi::c_int,
        pub i_me_method: ::core::ffi::c_int,
        pub i_subpel_refine: ::core::ffi::c_int,
        pub b_chroma_me: ::core::ffi::c_int,
        pub b_trellis: ::core::ffi::c_int,
        pub b_noise_reduction: ::core::ffi::c_int,
        pub b_dct_decimate: ::core::ffi::c_int,
        pub i_psy_rd: ::core::ffi::c_int,
        pub i_psy_trellis: ::core::ffi::c_int,
        pub b_interlaced: ::core::ffi::c_int,
        pub b_adaptive_mbaff: ::core::ffi::c_int,
        pub mv_min: [::core::ffi::c_int; 2],
        pub mv_max: [::core::ffi::c_int; 2],
        pub mv_miny_row: [::core::ffi::c_int; 3],
        pub mv_maxy_row: [::core::ffi::c_int; 3],
        pub mv_min_spel: [::core::ffi::c_int; 2],
        pub mv_max_spel: [::core::ffi::c_int; 2],
        pub mv_miny_spel_row: [::core::ffi::c_int; 3],
        pub mv_maxy_spel_row: [::core::ffi::c_int; 3],
        pub mv_limit_fpel: [[int16_t; 2]; 2],
        pub mv_miny_fpel_row: [::core::ffi::c_int; 3],
        pub mv_maxy_fpel_row: [::core::ffi::c_int; 3],
        pub i_neighbour: ::core::ffi::c_uint,
        pub i_neighbour8: [::core::ffi::c_uint; 4],
        pub i_neighbour4: [::core::ffi::c_uint; 16],
        pub i_neighbour_intra: ::core::ffi::c_uint,
        pub i_neighbour_frame: ::core::ffi::c_uint,
        pub i_mb_type_top: ::core::ffi::c_int,
        pub i_mb_type_left: [::core::ffi::c_int; 2],
        pub i_mb_type_topleft: ::core::ffi::c_int,
        pub i_mb_type_topright: ::core::ffi::c_int,
        pub i_mb_prev_xy: ::core::ffi::c_int,
        pub i_mb_left_xy: [::core::ffi::c_int; 2],
        pub i_mb_top_xy: ::core::ffi::c_int,
        pub i_mb_topleft_xy: ::core::ffi::c_int,
        pub i_mb_topright_xy: ::core::ffi::c_int,
        pub i_mb_top_y: ::core::ffi::c_int,
        pub i_mb_topleft_y: ::core::ffi::c_int,
        pub i_mb_topright_y: ::core::ffi::c_int,
        pub left_index_table: *const x264_left_table_t,
        pub i_mb_top_mbpair_xy: ::core::ffi::c_int,
        pub topleft_partition: ::core::ffi::c_int,
        pub b_allow_skip: ::core::ffi::c_int,
        pub field_decoding_flag: ::core::ffi::c_int,
        pub base: *mut uint8_t,
        pub type_0: *mut int8_t,
        pub partition: *mut uint8_t,
        pub qp: *mut int8_t,
        pub cbp: *mut int16_t,
        pub intra4x4_pred_mode: *mut [int8_t; 8],
        pub non_zero_count: *mut [uint8_t; 48],
        pub chroma_pred_mode: *mut int8_t,
        pub mv: [*mut [int16_t; 2]; 2],
        pub mvd: [*mut [[uint8_t; 2]; 8]; 2],
        pub ref_0: [*mut int8_t; 2],
        pub mvr: [[*mut [int16_t; 2]; 32]; 2],
        pub skipbp: *mut int8_t,
        pub mb_transform_size: *mut int8_t,
        pub slice_table: *mut int32_t,
        pub field: *mut uint8_t,
        pub p_weight_buf: [*mut pixel; 16],
        pub i_type: ::core::ffi::c_int,
        pub i_partition: ::core::ffi::c_int,
        pub i_sub_partition: [uint8_t; 4],
        pub b_transform_8x8: ::core::ffi::c_int,
        pub i_cbp_luma: ::core::ffi::c_int,
        pub i_cbp_chroma: ::core::ffi::c_int,
        pub i_intra16x16_pred_mode: ::core::ffi::c_int,
        pub i_chroma_pred_mode: ::core::ffi::c_int,
        pub i_skip_intra: ::core::ffi::c_int,
        pub b_skip_mc: ::core::ffi::c_int,
        pub b_reencode_mb: ::core::ffi::c_int,
        pub ip_offset: ::core::ffi::c_int,
        pub b_deblock_rdo: ::core::ffi::c_int,
        pub b_overflow: ::core::ffi::c_int,
        pub pic: C2RustUnnamed_9,
        pub cache: C2RustUnnamed_8,
        pub i_qp: ::core::ffi::c_int,
        pub i_chroma_qp: ::core::ffi::c_int,
        pub i_last_qp: ::core::ffi::c_int,
        pub i_last_dqp: ::core::ffi::c_int,
        pub b_variable_qp: ::core::ffi::c_int,
        pub b_lossless: ::core::ffi::c_int,
        pub b_direct_auto_read: ::core::ffi::c_int,
        pub b_direct_auto_write: ::core::ffi::c_int,
        pub i_trellis_lambda2: [[::core::ffi::c_int; 2]; 2],
        pub i_psy_rd_lambda: ::core::ffi::c_int,
        pub i_chroma_lambda2_offset: ::core::ffi::c_int,
        pub dist_scale_factor_buf: [[[[int16_t; 4]; 32]; 2]; 2],
        pub dist_scale_factor: *mut [int16_t; 4],
        pub bipred_weight_buf: [[[[int8_t; 4]; 32]; 2]; 2],
        pub bipred_weight: *mut [int8_t; 4],
        pub map_col_to_list0: [int8_t; 18],
        pub ref_blind_dupe: ::core::ffi::c_int,
        pub deblock_ref_table: [int8_t; 34],
    }
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "614:9"]
    pub struct C2RustUnnamed_8 {
        pub intra4x4_pred_mode: [int8_t; 40],
        pub non_zero_count: [uint8_t; 120],
        pub ref_0: [[int8_t; 40]; 2],
        pub mv: [[[int16_t; 2]; 40]; 2],
        pub mvd: [[[uint8_t; 2]; 40]; 2],
        pub skip: [int8_t; 40],
        pub direct_mv: [[[int16_t; 2]; 4]; 2],
        pub direct_ref: [[int8_t; 4]; 2],
        pub direct_partition: ::core::ffi::c_int,
        pub pskip_mv: [int16_t; 2],
        pub i_neighbour_transform_size: ::core::ffi::c_int,
        pub i_neighbour_skip: ::core::ffi::c_int,
        pub i_cbp_top: ::core::ffi::c_int,
        pub i_cbp_left: ::core::ffi::c_int,
        pub topright_mv: [[[int16_t; 2]; 3]; 2],
        pub topright_ref: [[int8_t; 3]; 2],
        pub deblock_strength: *mut [[uint8_t; 4]; 8],
    }
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "567:9"]
    pub struct C2RustUnnamed_9 {
        pub fenc_buf: [pixel; 768],
        pub fdec_buf: [pixel; 1728],
        pub i4x4_fdec_buf: [pixel; 256],
        pub i8x8_fdec_buf: [pixel; 256],
        pub i8x8_dct_buf: [[dctcoef; 64]; 3],
        pub i4x4_dct_buf: [[dctcoef; 16]; 15],
        pub i4x4_nnz_buf: [uint32_t; 4],
        pub i8x8_nnz_buf: [uint32_t; 4],
        pub fenc_dct8: [[dctcoef; 64]; 4],
        pub fenc_dct4: [[dctcoef; 16]; 16],
        pub fenc_satd_cache: [uint32_t; 32],
        pub fenc_hadamard_cache: [uint64_t; 9],
        pub i4x4_cbp: ::core::ffi::c_int,
        pub i8x8_cbp: ::core::ffi::c_int,
        pub p_fenc: [*mut pixel; 3],
        pub p_fenc_plane: [*mut pixel; 3],
        pub p_fdec: [*mut pixel; 3],
        pub i_fref: [::core::ffi::c_int; 2],
        pub p_fref: [[[*mut pixel; 12]; 32]; 2],
        pub p_fref_w: [*mut pixel; 32],
        pub p_integral: [[*mut uint16_t; 16]; 2],
        pub i_stride: [::core::ffi::c_int; 3],
    }
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "233:16"]
    pub struct x264_left_table_t {
        pub intra: [uint8_t; 4],
        pub nnz: [uint8_t; 4],
        pub nnz_chroma: [uint8_t; 4],
        pub mv: [uint8_t; 4],
        pub ref_0: [uint8_t; 4],
    }
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "428:5"]
    pub struct C2RustUnnamed_10 {
        pub luma16x16_dc: [[dctcoef; 16]; 3],
        pub chroma_dc: [[dctcoef; 8]; 2],
        pub luma8x8: [[dctcoef; 64]; 12],
        pub luma4x4: [[dctcoef; 16]; 48],
    }
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "375:5"]
    pub struct C2RustUnnamed_11 {
        pub current: *mut *mut x264_frame_t,
        pub unused: [*mut *mut x264_frame_t; 2],
        pub blank_unused: *mut *mut x264_frame_t,
        pub reference: [*mut x264_frame_t; 18],
        pub i_last_keyframe: ::core::ffi::c_int,
        pub i_last_idr: ::core::ffi::c_int,
        pub i_poc_last_open_gop: ::core::ffi::c_int,
        pub i_input: ::core::ffi::c_int,
        pub i_max_dpb: ::core::ffi::c_int,
        pub i_max_ref0: ::core::ffi::c_int,
        pub i_max_ref1: ::core::ffi::c_int,
        pub i_delay: ::core::ffi::c_int,
        pub i_bframe_delay: ::core::ffi::c_int,
        pub i_bframe_delay_time: int64_t,
        pub i_first_pts: int64_t,
        pub i_prev_reordered_pts: [int64_t; 2],
        pub i_largest_pts: int64_t,
        pub i_second_largest_pts: int64_t,
        pub b_have_lowres: ::core::ffi::c_int,
        pub b_have_sub8x8_esa: ::core::ffi::c_int,
    }
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "153:9"]
    pub struct x264_slice_header_t {
        pub sps: *mut x264_sps_t,
        pub pps: *mut x264_pps_t,
        pub i_type: ::core::ffi::c_int,
        pub i_first_mb: ::core::ffi::c_int,
        pub i_last_mb: ::core::ffi::c_int,
        pub i_pps_id: ::core::ffi::c_int,
        pub i_frame_num: ::core::ffi::c_int,
        pub b_mbaff: ::core::ffi::c_int,
        pub b_field_pic: ::core::ffi::c_int,
        pub b_bottom_field: ::core::ffi::c_int,
        pub i_idr_pic_id: ::core::ffi::c_int,
        pub i_poc: ::core::ffi::c_int,
        pub i_delta_poc_bottom: ::core::ffi::c_int,
        pub i_delta_poc: [::core::ffi::c_int; 2],
        pub i_redundant_pic_cnt: ::core::ffi::c_int,
        pub b_direct_spatial_mv_pred: ::core::ffi::c_int,
        pub b_num_ref_idx_override: ::core::ffi::c_int,
        pub i_num_ref_idx_l0_active: ::core::ffi::c_int,
        pub i_num_ref_idx_l1_active: ::core::ffi::c_int,
        pub b_ref_pic_list_reordering: [::core::ffi::c_int; 2],
        pub ref_pic_list_order: [[C2RustUnnamed_13; 16]; 2],
        pub b_weighted_pred: ::core::ffi::c_int,
        pub weight: [[x264_weight_t; 3]; 32],
        pub i_mmco_remove_from_end: ::core::ffi::c_int,
        pub i_mmco_command_count: ::core::ffi::c_int,
        pub mmco: [C2RustUnnamed_12; 16],
        pub i_cabac_init_idc: ::core::ffi::c_int,
        pub i_qp: ::core::ffi::c_int,
        pub i_qp_delta: ::core::ffi::c_int,
        pub b_sp_for_swidth: ::core::ffi::c_int,
        pub i_qs_delta: ::core::ffi::c_int,
        pub i_disable_deblocking_filter_idc: ::core::ffi::c_int,
        pub i_alpha_c0_offset: ::core::ffi::c_int,
        pub i_beta_offset: ::core::ffi::c_int,
    }
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "197:5"]
    pub struct C2RustUnnamed_12 {
        pub i_difference_of_pic_nums: ::core::ffi::c_int,
        pub i_poc: ::core::ffi::c_int,
    }
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "185:5"]
    pub struct C2RustUnnamed_13 {
        pub idc: ::core::ffi::c_int,
        pub arg: ::core::ffi::c_int,
    }
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "353:5"]
    pub struct C2RustUnnamed_17 {
        pub ref_0: [[[uint16_t; 33]; 3]; 82],
        pub i4x4_mode: [[uint16_t; 17]; 82],
    }
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "291:5"]
    pub struct C2RustUnnamed_18 {
        pub i_nal: ::core::ffi::c_int,
        pub i_nals_allocated: ::core::ffi::c_int,
        pub nal: *mut x264_nal_t,
        pub i_bitstream: ::core::ffi::c_int,
        pub p_bitstream: *mut uint8_t,
        pub bs: bs_t,
    }
    #[c2rust::src_loc = "95:5"]
    pub type pixel4 = uint64_t;
    #[c2rust::src_loc = "58:9"]
    pub const QP_BD_OFFSET: ::core::ffi::c_int =
        6 as ::core::ffi::c_int * (BIT_DEPTH - 8 as ::core::ffi::c_int);
    #[c2rust::src_loc = "59:9"]
    pub const QP_MAX_SPEC: ::core::ffi::c_int = 51 as ::core::ffi::c_int + QP_BD_OFFSET;
    #[c2rust::src_loc = "60:9"]
    pub const QP_MAX: ::core::ffi::c_int = QP_MAX_SPEC + 18 as ::core::ffi::c_int;
    #[c2rust::src_loc = "63:9"]
    pub const X264_LOOKAHEAD_QP: ::core::ffi::c_int = 12 as ::core::ffi::c_int + QP_BD_OFFSET;
    #[c2rust::src_loc = "111:9"]
    pub const SIZEOF_PIXEL: ::core::ffi::c_int =
        ::core::mem::size_of::<pixel>() as ::core::ffi::c_int;
    #[c2rust::src_loc = "570:9"]
    pub const FENC_STRIDE: ::core::ffi::c_int = 16 as ::core::ffi::c_int;
    #[c2rust::src_loc = "571:9"]
    pub const FDEC_STRIDE: ::core::ffi::c_int = 32 as ::core::ffi::c_int;
    use super::bitstream_h::{bs_t, x264_bitstream_function_t};
    use super::cabac_h::x264_cabac_t;
    use super::dct_h::{x264_dct_function_t, x264_zigzag_function_t};
    use super::frame_h::{x264_deblock_function_t, x264_frame_t, x264_sync_frame_list_t};
    use super::internal::BIT_DEPTH;
    use super::mc_h::{x264_mc_functions_t, x264_weight_t};
    use super::pixel_h::x264_pixel_function_t;
    use super::predict_h::{x264_predict8x8_t, x264_predict_8x8_filter_t, x264_predict_t};
    use super::pthreadtypes_h::{pthread_cond_t, pthread_mutex_t, pthread_t};
    use super::quant_h::x264_quant_function_t;
    use super::set_h::{x264_pps_t, x264_sps_t};
    use super::stdint_intn_h::{int16_t, int32_t, int64_t, int8_t};
    use super::stdint_uintn_h::{uint16_t, uint32_t, uint64_t, uint8_t};
    use super::threadpool_h::x264_threadpool_t;
    use super::x264_h::{x264_nal_t, x264_param_t};
    extern "C" {
        #[c2rust::src_loc = "231:16"]
        pub type x264_ratecontrol_t;
        #[c2rust::src_loc = "138:1"]
        pub fn x264_10_log(
            h: *mut x264_t,
            i_level: ::core::ffi::c_int,
            psz_fmt: *const ::core::ffi::c_char,
            ...
        );
    }
}
#[c2rust::header_src = "/home/nwplayer123/Hacks/hex264/x264/common/frame.h:28"]
pub mod frame_h {
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "186:9"]
    pub struct x264_sync_frame_list_t {
        pub list: *mut *mut x264_frame_t,
        pub i_max_size: ::core::ffi::c_int,
        pub i_size: ::core::ffi::c_int,
        pub mutex: pthread_mutex_t,
        pub cv_fill: pthread_cond_t,
        pub cv_empty: pthread_cond_t,
    }
    #[c2rust::src_loc = "37:1"]
    pub type x264_frame_t = x264_frame;
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "37:16"]
    pub struct x264_frame {
        pub base: *mut uint8_t,
        pub i_poc: ::core::ffi::c_int,
        pub i_delta_poc: [::core::ffi::c_int; 2],
        pub i_type: ::core::ffi::c_int,
        pub i_forced_type: ::core::ffi::c_int,
        pub i_qpplus1: ::core::ffi::c_int,
        pub i_pts: int64_t,
        pub i_dts: int64_t,
        pub i_reordered_pts: int64_t,
        pub i_duration: int64_t,
        pub f_duration: ::core::ffi::c_float,
        pub i_cpb_duration: int64_t,
        pub i_cpb_delay: int64_t,
        pub i_dpb_output_delay: int64_t,
        pub param: *mut x264_param_t,
        pub i_frame: ::core::ffi::c_int,
        pub i_coded: ::core::ffi::c_int,
        pub i_field_cnt: int64_t,
        pub i_frame_num: ::core::ffi::c_int,
        pub b_kept_as_ref: ::core::ffi::c_int,
        pub i_pic_struct: ::core::ffi::c_int,
        pub b_keyframe: ::core::ffi::c_int,
        pub b_fdec: uint8_t,
        pub b_last_minigop_bframe: uint8_t,
        pub i_bframes: uint8_t,
        pub f_qp_avg_rc: ::core::ffi::c_float,
        pub f_qp_avg_aq: ::core::ffi::c_float,
        pub f_crf_avg: ::core::ffi::c_float,
        pub i_poc_l0ref0: ::core::ffi::c_int,
        pub i_csp: ::core::ffi::c_int,
        pub i_plane: ::core::ffi::c_int,
        pub i_stride: [::core::ffi::c_int; 3],
        pub i_width: [::core::ffi::c_int; 3],
        pub i_lines: [::core::ffi::c_int; 3],
        pub i_stride_lowres: ::core::ffi::c_int,
        pub i_width_lowres: ::core::ffi::c_int,
        pub i_lines_lowres: ::core::ffi::c_int,
        pub plane: [*mut pixel; 3],
        pub plane_fld: [*mut pixel; 3],
        pub filtered: [[*mut pixel; 4]; 3],
        pub filtered_fld: [[*mut pixel; 4]; 3],
        pub lowres: [*mut pixel; 4],
        pub integral: *mut uint16_t,
        pub buffer: [*mut pixel; 4],
        pub buffer_fld: [*mut pixel; 4],
        pub buffer_lowres: *mut pixel,
        pub weight: [[x264_weight_t; 3]; 16],
        pub weighted: [*mut pixel; 16],
        pub b_duplicate: ::core::ffi::c_int,
        pub orig: *mut x264_frame,
        pub mb_type: *mut int8_t,
        pub mb_partition: *mut uint8_t,
        pub mv: [*mut [int16_t; 2]; 2],
        pub mv16x16: *mut [int16_t; 2],
        pub lowres_mvs: [[*mut [int16_t; 2]; 17]; 2],
        pub field: *mut uint8_t,
        pub effective_qp: *mut uint8_t,
        pub lowres_costs: [[*mut uint16_t; 18]; 18],
        pub lowres_mv_costs: [[*mut ::core::ffi::c_int; 17]; 2],
        pub ref_0: [*mut int8_t; 2],
        pub i_ref: [::core::ffi::c_int; 2],
        pub ref_poc: [[::core::ffi::c_int; 16]; 2],
        pub inv_ref_poc: [int16_t; 2],
        pub i_cost_est: [[::core::ffi::c_int; 18]; 18],
        pub i_cost_est_aq: [[::core::ffi::c_int; 18]; 18],
        pub i_satd: ::core::ffi::c_int,
        pub i_intra_mbs: [::core::ffi::c_int; 18],
        pub i_row_satds: [[*mut ::core::ffi::c_int; 18]; 18],
        pub i_row_satd: *mut ::core::ffi::c_int,
        pub i_row_bits: *mut ::core::ffi::c_int,
        pub f_row_qp: *mut ::core::ffi::c_float,
        pub f_row_qscale: *mut ::core::ffi::c_float,
        pub f_qp_offset: *mut ::core::ffi::c_float,
        pub f_qp_offset_aq: *mut ::core::ffi::c_float,
        pub b_intra_calculated: ::core::ffi::c_int,
        pub i_intra_cost: *mut uint16_t,
        pub i_propagate_cost: *mut uint16_t,
        pub i_inv_qscale_factor: *mut uint16_t,
        pub b_scenecut: ::core::ffi::c_int,
        pub f_weighted_cost_delta: [::core::ffi::c_float; 18],
        pub i_pixel_sum: [uint32_t; 3],
        pub i_pixel_ssd: [uint64_t; 3],
        pub hrd_timing: x264_hrd_t,
        pub i_planned_type: [uint8_t; 251],
        pub i_planned_satd: [::core::ffi::c_int; 251],
        pub f_planned_cpb_duration: [::core::ffi::c_double; 251],
        pub i_coded_fields_lookahead: int64_t,
        pub i_cpb_delay_lookahead: int64_t,
        pub i_lines_completed: ::core::ffi::c_int,
        pub i_lines_weighted: ::core::ffi::c_int,
        pub i_reference_count: ::core::ffi::c_int,
        pub mutex: pthread_mutex_t,
        pub cv: pthread_cond_t,
        pub i_slice_count: ::core::ffi::c_int,
        pub f_pir_position: ::core::ffi::c_float,
        pub i_pir_start_col: ::core::ffi::c_int,
        pub i_pir_end_col: ::core::ffi::c_int,
        pub i_frames_since_pir: ::core::ffi::c_int,
        pub b_corrupt: ::core::ffi::c_int,
        pub extra_sei: x264_sei_t,
        pub opaque: *mut ::core::ffi::c_void,
        pub mb_info: *mut uint8_t,
        pub mb_info_free: Option<unsafe extern "C" fn(*mut ::core::ffi::c_void) -> ()>,
    }
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "198:9"]
    pub struct x264_deblock_function_t {
        pub deblock_luma: [x264_deblock_inter_t; 2],
        pub deblock_chroma: [x264_deblock_inter_t; 2],
        pub deblock_h_chroma_420: x264_deblock_inter_t,
        pub deblock_h_chroma_422: x264_deblock_inter_t,
        pub deblock_luma_intra: [x264_deblock_intra_t; 2],
        pub deblock_chroma_intra: [x264_deblock_intra_t; 2],
        pub deblock_h_chroma_420_intra: x264_deblock_intra_t,
        pub deblock_h_chroma_422_intra: x264_deblock_intra_t,
        pub deblock_luma_mbaff: x264_deblock_inter_t,
        pub deblock_chroma_mbaff: x264_deblock_inter_t,
        pub deblock_chroma_420_mbaff: x264_deblock_inter_t,
        pub deblock_chroma_422_mbaff: x264_deblock_inter_t,
        pub deblock_luma_intra_mbaff: x264_deblock_intra_t,
        pub deblock_chroma_intra_mbaff: x264_deblock_intra_t,
        pub deblock_chroma_420_intra_mbaff: x264_deblock_intra_t,
        pub deblock_chroma_422_intra_mbaff: x264_deblock_intra_t,
        pub deblock_strength: Option<
            unsafe extern "C" fn(
                *mut uint8_t,
                *mut [int8_t; 40],
                *mut [[int16_t; 2]; 40],
                *mut [[uint8_t; 4]; 8],
                ::core::ffi::c_int,
                ::core::ffi::c_int,
            ) -> (),
        >,
    }
    #[c2rust::src_loc = "197:1"]
    pub type x264_deblock_intra_t = Option<
        unsafe extern "C" fn(*mut pixel, intptr_t, ::core::ffi::c_int, ::core::ffi::c_int) -> (),
    >;
    #[c2rust::src_loc = "196:1"]
    pub type x264_deblock_inter_t = Option<
        unsafe extern "C" fn(
            *mut pixel,
            intptr_t,
            ::core::ffi::c_int,
            ::core::ffi::c_int,
            *mut int8_t,
        ) -> (),
    >;
    #[c2rust::src_loc = "32:9"]
    pub const PADH: ::core::ffi::c_int = 32 as ::core::ffi::c_int;
    #[c2rust::src_loc = "33:9"]
    pub const PADV: ::core::ffi::c_int = 32 as ::core::ffi::c_int;
    #[c2rust::src_loc = "111:13"]
    pub const LOWRES_COST_MASK: ::core::ffi::c_int =
        ((1 as ::core::ffi::c_int) << 14 as ::core::ffi::c_int) - 1 as ::core::ffi::c_int;
    #[c2rust::src_loc = "112:13"]
    pub const LOWRES_COST_SHIFT: ::core::ffi::c_int = 14 as ::core::ffi::c_int;
    use super::common_h::{pixel, x264_t};
    use super::mc_h::x264_weight_t;
    use super::pthreadtypes_h::{pthread_cond_t, pthread_mutex_t};
    use super::stdint_h::intptr_t;
    use super::stdint_intn_h::{int16_t, int64_t, int8_t};
    use super::stdint_uintn_h::{uint16_t, uint32_t, uint64_t, uint8_t};
    use super::x264_h::{x264_hrd_t, x264_param_t, x264_sei_t};
    extern "C" {
        #[c2rust::src_loc = "234:1"]
        pub fn x264_10_frame_expand_border_chroma(
            h: *mut x264_t,
            frame: *mut x264_frame_t,
            plane: ::core::ffi::c_int,
        );
        #[c2rust::src_loc = "243:1"]
        pub fn x264_10_macroblock_deblock(h: *mut x264_t);
        #[c2rust::src_loc = "256:1"]
        pub fn x264_10_frame_cond_wait(
            frame: *mut x264_frame_t,
            i_lines_completed: ::core::ffi::c_int,
        ) -> ::core::ffi::c_int;
        #[c2rust::src_loc = "281:1"]
        pub fn x264_10_weight_scale_plane(
            h: *mut x264_t,
            dst: *mut pixel,
            i_dst_stride: intptr_t,
            src: *mut pixel,
            i_src_stride: intptr_t,
            i_width: ::core::ffi::c_int,
            i_height: ::core::ffi::c_int,
            w: *mut x264_weight_t,
        );
    }
}
#[c2rust::header_src = "/home/nwplayer123/Hacks/hex264/x264/x264.h:28"]
pub mod x264_h {
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "795:16"]
    pub struct x264_sei_t {
        pub num_payloads: ::core::ffi::c_int,
        pub payloads: *mut x264_sei_payload_t,
        pub sei_free: Option<unsafe extern "C" fn(*mut ::core::ffi::c_void) -> ()>,
    }
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "788:16"]
    pub struct x264_sei_payload_t {
        pub payload_size: ::core::ffi::c_int,
        pub payload_type: ::core::ffi::c_int,
        pub payload: *mut uint8_t,
    }
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "770:16"]
    pub struct x264_hrd_t {
        pub cpb_initial_arrival_time: ::core::ffi::c_double,
        pub cpb_final_arrival_time: ::core::ffi::c_double,
        pub cpb_removal_time: ::core::ffi::c_double,
        pub dpb_output_time: ::core::ffi::c_double,
    }
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "315:16"]
    pub struct x264_param_t {
        pub cpu: uint32_t,
        pub i_threads: ::core::ffi::c_int,
        pub i_lookahead_threads: ::core::ffi::c_int,
        pub b_sliced_threads: ::core::ffi::c_int,
        pub b_deterministic: ::core::ffi::c_int,
        pub b_cpu_independent: ::core::ffi::c_int,
        pub i_sync_lookahead: ::core::ffi::c_int,
        pub i_width: ::core::ffi::c_int,
        pub i_height: ::core::ffi::c_int,
        pub i_csp: ::core::ffi::c_int,
        pub i_bitdepth: ::core::ffi::c_int,
        pub i_level_idc: ::core::ffi::c_int,
        pub i_frame_total: ::core::ffi::c_int,
        pub i_nal_hrd: ::core::ffi::c_int,
        pub vui: C2RustUnnamed_5,
        pub i_frame_reference: ::core::ffi::c_int,
        pub i_dpb_size: ::core::ffi::c_int,
        pub i_keyint_max: ::core::ffi::c_int,
        pub i_keyint_min: ::core::ffi::c_int,
        pub i_scenecut_threshold: ::core::ffi::c_int,
        pub b_intra_refresh: ::core::ffi::c_int,
        pub i_bframe: ::core::ffi::c_int,
        pub i_bframe_adaptive: ::core::ffi::c_int,
        pub i_bframe_bias: ::core::ffi::c_int,
        pub i_bframe_pyramid: ::core::ffi::c_int,
        pub b_open_gop: ::core::ffi::c_int,
        pub b_bluray_compat: ::core::ffi::c_int,
        pub i_avcintra_class: ::core::ffi::c_int,
        pub i_avcintra_flavor: ::core::ffi::c_int,
        pub b_deblocking_filter: ::core::ffi::c_int,
        pub i_deblocking_filter_alphac0: ::core::ffi::c_int,
        pub i_deblocking_filter_beta: ::core::ffi::c_int,
        pub b_cabac: ::core::ffi::c_int,
        pub i_cabac_init_idc: ::core::ffi::c_int,
        pub b_interlaced: ::core::ffi::c_int,
        pub b_constrained_intra: ::core::ffi::c_int,
        pub i_cqm_preset: ::core::ffi::c_int,
        pub psz_cqm_file: *mut ::core::ffi::c_char,
        pub cqm_4iy: [uint8_t; 16],
        pub cqm_4py: [uint8_t; 16],
        pub cqm_4ic: [uint8_t; 16],
        pub cqm_4pc: [uint8_t; 16],
        pub cqm_8iy: [uint8_t; 64],
        pub cqm_8py: [uint8_t; 64],
        pub cqm_8ic: [uint8_t; 64],
        pub cqm_8pc: [uint8_t; 64],
        pub pf_log: Option<
            unsafe extern "C" fn(
                *mut ::core::ffi::c_void,
                ::core::ffi::c_int,
                *const ::core::ffi::c_char,
                ::core::ffi::VaList,
            ) -> (),
        >,
        pub p_log_private: *mut ::core::ffi::c_void,
        pub i_log_level: ::core::ffi::c_int,
        pub b_full_recon: ::core::ffi::c_int,
        pub psz_dump_yuv: *mut ::core::ffi::c_char,
        pub analyse: C2RustUnnamed_4,
        pub rc: C2RustUnnamed_3,
        pub crop_rect: C2RustUnnamed_2,
        pub i_frame_packing: ::core::ffi::c_int,
        pub mastering_display: C2RustUnnamed_1,
        pub content_light_level: C2RustUnnamed_0,
        pub i_alternative_transfer: ::core::ffi::c_int,
        pub b_aud: ::core::ffi::c_int,
        pub b_repeat_headers: ::core::ffi::c_int,
        pub b_annexb: ::core::ffi::c_int,
        pub i_sps_id: ::core::ffi::c_int,
        pub b_vfr_input: ::core::ffi::c_int,
        pub b_pulldown: ::core::ffi::c_int,
        pub i_fps_num: uint32_t,
        pub i_fps_den: uint32_t,
        pub i_timebase_num: uint32_t,
        pub i_timebase_den: uint32_t,
        pub b_tff: ::core::ffi::c_int,
        pub b_pic_struct: ::core::ffi::c_int,
        pub b_fake_interlaced: ::core::ffi::c_int,
        pub b_stitchable: ::core::ffi::c_int,
        pub b_opencl: ::core::ffi::c_int,
        pub i_opencl_device: ::core::ffi::c_int,
        pub opencl_device_id: *mut ::core::ffi::c_void,
        pub psz_clbin_file: *mut ::core::ffi::c_char,
        pub i_slice_max_size: ::core::ffi::c_int,
        pub i_slice_max_mbs: ::core::ffi::c_int,
        pub i_slice_min_mbs: ::core::ffi::c_int,
        pub i_slice_count: ::core::ffi::c_int,
        pub i_slice_count_max: ::core::ffi::c_int,
        pub param_free: Option<unsafe extern "C" fn(*mut ::core::ffi::c_void) -> ()>,
        pub nalu_process: Option<
            unsafe extern "C" fn(*mut x264_t, *mut x264_nal_t, *mut ::core::ffi::c_void) -> (),
        >,
        pub opaque: *mut ::core::ffi::c_void,
    }
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "114:16"]
    pub struct x264_nal_t {
        pub i_ref_idc: ::core::ffi::c_int,
        pub i_type: ::core::ffi::c_int,
        pub b_long_startcode: ::core::ffi::c_int,
        pub i_first_mb: ::core::ffi::c_int,
        pub i_last_mb: ::core::ffi::c_int,
        pub i_payload: ::core::ffi::c_int,
        pub p_payload: *mut uint8_t,
        pub i_padding: ::core::ffi::c_int,
    }
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "517:5"]
    pub struct C2RustUnnamed_0 {
        pub b_cll: ::core::ffi::c_int,
        pub i_max_cll: ::core::ffi::c_int,
        pub i_max_fall: ::core::ffi::c_int,
    }
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "501:5"]
    pub struct C2RustUnnamed_1 {
        pub b_mastering_display: ::core::ffi::c_int,
        pub i_green_x: ::core::ffi::c_int,
        pub i_green_y: ::core::ffi::c_int,
        pub i_blue_x: ::core::ffi::c_int,
        pub i_blue_y: ::core::ffi::c_int,
        pub i_red_x: ::core::ffi::c_int,
        pub i_red_y: ::core::ffi::c_int,
        pub i_white_x: ::core::ffi::c_int,
        pub i_white_y: ::core::ffi::c_int,
        pub i_display_max: int64_t,
        pub i_display_min: int64_t,
    }
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "488:5"]
    pub struct C2RustUnnamed_2 {
        pub i_left: ::core::ffi::c_int,
        pub i_top: ::core::ffi::c_int,
        pub i_right: ::core::ffi::c_int,
        pub i_bottom: ::core::ffi::c_int,
    }
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "443:5"]
    pub struct C2RustUnnamed_3 {
        pub i_rc_method: ::core::ffi::c_int,
        pub i_qp_constant: ::core::ffi::c_int,
        pub i_qp_min: ::core::ffi::c_int,
        pub i_qp_max: ::core::ffi::c_int,
        pub i_qp_step: ::core::ffi::c_int,
        pub i_bitrate: ::core::ffi::c_int,
        pub f_rf_constant: ::core::ffi::c_float,
        pub f_rf_constant_max: ::core::ffi::c_float,
        pub f_rate_tolerance: ::core::ffi::c_float,
        pub i_vbv_max_bitrate: ::core::ffi::c_int,
        pub i_vbv_buffer_size: ::core::ffi::c_int,
        pub f_vbv_buffer_init: ::core::ffi::c_float,
        pub f_ip_factor: ::core::ffi::c_float,
        pub f_pb_factor: ::core::ffi::c_float,
        pub b_filler: ::core::ffi::c_int,
        pub i_aq_mode: ::core::ffi::c_int,
        pub f_aq_strength: ::core::ffi::c_float,
        pub b_mb_tree: ::core::ffi::c_int,
        pub i_lookahead: ::core::ffi::c_int,
        pub b_stat_write: ::core::ffi::c_int,
        pub psz_stat_out: *mut ::core::ffi::c_char,
        pub b_stat_read: ::core::ffi::c_int,
        pub psz_stat_in: *mut ::core::ffi::c_char,
        pub f_qcompress: ::core::ffi::c_float,
        pub f_qblur: ::core::ffi::c_float,
        pub f_complexity_blur: ::core::ffi::c_float,
        pub zones: *mut x264_zone_t,
        pub i_zones: ::core::ffi::c_int,
        pub psz_zones: *mut ::core::ffi::c_char,
    }
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "306:16"]
    pub struct x264_zone_t {
        pub i_start: ::core::ffi::c_int,
        pub i_end: ::core::ffi::c_int,
        pub b_force_qp: ::core::ffi::c_int,
        pub i_qp: ::core::ffi::c_int,
        pub f_bitrate_factor: ::core::ffi::c_float,
        pub param: *mut x264_param_t,
    }
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "406:5"]
    pub struct C2RustUnnamed_4 {
        pub intra: ::core::ffi::c_uint,
        pub inter: ::core::ffi::c_uint,
        pub b_transform_8x8: ::core::ffi::c_int,
        pub i_weighted_pred: ::core::ffi::c_int,
        pub b_weighted_bipred: ::core::ffi::c_int,
        pub i_direct_mv_pred: ::core::ffi::c_int,
        pub i_chroma_qp_offset: ::core::ffi::c_int,
        pub i_me_method: ::core::ffi::c_int,
        pub i_me_range: ::core::ffi::c_int,
        pub i_mv_range: ::core::ffi::c_int,
        pub i_mv_range_thread: ::core::ffi::c_int,
        pub i_subpel_refine: ::core::ffi::c_int,
        pub b_chroma_me: ::core::ffi::c_int,
        pub b_mixed_references: ::core::ffi::c_int,
        pub i_trellis: ::core::ffi::c_int,
        pub b_fast_pskip: ::core::ffi::c_int,
        pub b_dct_decimate: ::core::ffi::c_int,
        pub i_noise_reduction: ::core::ffi::c_int,
        pub f_psy_rd: ::core::ffi::c_float,
        pub f_psy_trellis: ::core::ffi::c_float,
        pub b_psy: ::core::ffi::c_int,
        pub b_mb_info: ::core::ffi::c_int,
        pub b_mb_info_update: ::core::ffi::c_int,
        pub i_luma_deadzone: [::core::ffi::c_int; 2],
        pub b_psnr: ::core::ffi::c_int,
        pub b_ssim: ::core::ffi::c_int,
    }
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "342:5"]
    pub struct C2RustUnnamed_5 {
        pub i_sar_height: ::core::ffi::c_int,
        pub i_sar_width: ::core::ffi::c_int,
        pub i_overscan: ::core::ffi::c_int,
        pub i_vidformat: ::core::ffi::c_int,
        pub b_fullrange: ::core::ffi::c_int,
        pub i_colorprim: ::core::ffi::c_int,
        pub i_transfer: ::core::ffi::c_int,
        pub i_colmatrix: ::core::ffi::c_int,
        pub i_chroma_loc: ::core::ffi::c_int,
    }
    #[c2rust::src_loc = "196:9"]
    pub const X264_ANALYSE_I4x4: ::core::ffi::c_uint = 0x1 as ::core::ffi::c_uint;
    #[c2rust::src_loc = "197:9"]
    pub const X264_ANALYSE_I8x8: ::core::ffi::c_uint = 0x2 as ::core::ffi::c_uint;
    #[c2rust::src_loc = "198:9"]
    pub const X264_ANALYSE_PSUB16x16: ::core::ffi::c_uint = 0x10 as ::core::ffi::c_uint;
    #[c2rust::src_loc = "199:9"]
    pub const X264_ANALYSE_PSUB8x8: ::core::ffi::c_uint = 0x20 as ::core::ffi::c_uint;
    #[c2rust::src_loc = "200:9"]
    pub const X264_ANALYSE_BSUB16x16: ::core::ffi::c_uint = 0x100 as ::core::ffi::c_uint;
    #[c2rust::src_loc = "206:9"]
    pub const X264_ME_DIA: ::core::ffi::c_int = 0 as ::core::ffi::c_int;
    #[c2rust::src_loc = "209:9"]
    pub const X264_ME_ESA: ::core::ffi::c_int = 3 as ::core::ffi::c_int;
    #[c2rust::src_loc = "214:9"]
    pub const X264_RC_CQP: ::core::ffi::c_int = 0 as ::core::ffi::c_int;
    #[c2rust::src_loc = "223:9"]
    pub const X264_B_ADAPT_FAST: ::core::ffi::c_int = 1 as ::core::ffi::c_int;
    #[c2rust::src_loc = "224:9"]
    pub const X264_B_ADAPT_TRELLIS: ::core::ffi::c_int = 2 as ::core::ffi::c_int;
    #[c2rust::src_loc = "226:9"]
    pub const X264_WEIGHTP_SIMPLE: ::core::ffi::c_int = 1 as ::core::ffi::c_int;
    #[c2rust::src_loc = "230:9"]
    pub const X264_B_PYRAMID_NORMAL: ::core::ffi::c_int = 2 as ::core::ffi::c_int;
    #[c2rust::src_loc = "240:27"]
    pub static mut x264_b_pyramid_names: [*const ::core::ffi::c_char; 4] = [
        b"none\0" as *const u8 as *const ::core::ffi::c_char,
        b"strict\0" as *const u8 as *const ::core::ffi::c_char,
        b"normal\0" as *const u8 as *const ::core::ffi::c_char,
        0 as *const ::core::ffi::c_char,
    ];
    #[c2rust::src_loc = "277:9"]
    pub const X264_TYPE_AUTO: ::core::ffi::c_int = 0 as ::core::ffi::c_int;
    #[c2rust::src_loc = "278:9"]
    pub const X264_TYPE_IDR: ::core::ffi::c_int = 0x1 as ::core::ffi::c_int;
    #[c2rust::src_loc = "279:9"]
    pub const X264_TYPE_I: ::core::ffi::c_int = 0x2 as ::core::ffi::c_int;
    #[c2rust::src_loc = "280:9"]
    pub const X264_TYPE_P: ::core::ffi::c_int = 0x3 as ::core::ffi::c_int;
    #[c2rust::src_loc = "281:9"]
    pub const X264_TYPE_BREF: ::core::ffi::c_int = 0x4 as ::core::ffi::c_int;
    #[c2rust::src_loc = "282:9"]
    pub const X264_TYPE_B: ::core::ffi::c_int = 0x5 as ::core::ffi::c_int;
    #[c2rust::src_loc = "283:9"]
    pub const X264_TYPE_KEYFRAME: ::core::ffi::c_int = 0x6 as ::core::ffi::c_int;
    #[c2rust::src_loc = "289:9"]
    pub const X264_LOG_ERROR: ::core::ffi::c_int = 0 as ::core::ffi::c_int;
    #[c2rust::src_loc = "290:9"]
    pub const X264_LOG_WARNING: ::core::ffi::c_int = 1 as ::core::ffi::c_int;
    #[c2rust::src_loc = "292:9"]
    pub const X264_LOG_DEBUG: ::core::ffi::c_int = 3 as ::core::ffi::c_int;
    #[c2rust::src_loc = "853:13"]
    pub const X264_MBINFO_CONSTANT: ::core::ffi::c_uint =
        (1 as ::core::ffi::c_uint) << 0 as ::core::ffi::c_int;
    use super::common_h::x264_t;
    use super::internal::__va_list_tag;
    use super::stdint_intn_h::int64_t;
    use super::stdint_uintn_h::{uint32_t, uint8_t};
}
#[c2rust::header_src = "/home/nwplayer123/Hacks/hex264/x264/common/mc.h:28"]
pub mod mc_h {
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "235:16"]
    pub struct x264_weight_t {
        pub cachea: [int16_t; 8],
        pub cacheb: [int16_t; 8],
        pub i_denom: int32_t,
        pub i_scale: int32_t,
        pub i_offset: int32_t,
        pub weightfn: *mut weight_fn_t,
    }
    #[c2rust::src_loc = "234:1"]
    pub type weight_fn_t = Option<
        unsafe extern "C" fn(
            *mut pixel,
            intptr_t,
            *mut pixel,
            intptr_t,
            *const x264_weight_t,
            ::core::ffi::c_int,
        ) -> (),
    >;
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "267:9"]
    pub struct x264_mc_functions_t {
        pub mc_luma: Option<
            unsafe extern "C" fn(
                *mut pixel,
                intptr_t,
                *mut *mut pixel,
                intptr_t,
                ::core::ffi::c_int,
                ::core::ffi::c_int,
                ::core::ffi::c_int,
                ::core::ffi::c_int,
                *const x264_weight_t,
            ) -> (),
        >,
        pub get_ref: Option<
            unsafe extern "C" fn(
                *mut pixel,
                *mut intptr_t,
                *mut *mut pixel,
                intptr_t,
                ::core::ffi::c_int,
                ::core::ffi::c_int,
                ::core::ffi::c_int,
                ::core::ffi::c_int,
                *const x264_weight_t,
            ) -> *mut pixel,
        >,
        pub mc_chroma: Option<
            unsafe extern "C" fn(
                *mut pixel,
                *mut pixel,
                intptr_t,
                *mut pixel,
                intptr_t,
                ::core::ffi::c_int,
                ::core::ffi::c_int,
                ::core::ffi::c_int,
                ::core::ffi::c_int,
            ) -> (),
        >,
        pub avg: [Option<
            unsafe extern "C" fn(
                *mut pixel,
                intptr_t,
                *mut pixel,
                intptr_t,
                *mut pixel,
                intptr_t,
                ::core::ffi::c_int,
            ) -> (),
        >; 12],
        pub copy: [Option<
            unsafe extern "C" fn(
                *mut pixel,
                intptr_t,
                *mut pixel,
                intptr_t,
                ::core::ffi::c_int,
            ) -> (),
        >; 7],
        pub copy_16x16_unaligned: Option<
            unsafe extern "C" fn(
                *mut pixel,
                intptr_t,
                *mut pixel,
                intptr_t,
                ::core::ffi::c_int,
            ) -> (),
        >,
        pub store_interleave_chroma: Option<
            unsafe extern "C" fn(
                *mut pixel,
                intptr_t,
                *mut pixel,
                *mut pixel,
                ::core::ffi::c_int,
            ) -> (),
        >,
        pub load_deinterleave_chroma_fenc: Option<
            unsafe extern "C" fn(*mut pixel, *mut pixel, intptr_t, ::core::ffi::c_int) -> (),
        >,
        pub load_deinterleave_chroma_fdec: Option<
            unsafe extern "C" fn(*mut pixel, *mut pixel, intptr_t, ::core::ffi::c_int) -> (),
        >,
        pub plane_copy: Option<
            unsafe extern "C" fn(
                *mut pixel,
                intptr_t,
                *mut pixel,
                intptr_t,
                ::core::ffi::c_int,
                ::core::ffi::c_int,
            ) -> (),
        >,
        pub plane_copy_swap: Option<
            unsafe extern "C" fn(
                *mut pixel,
                intptr_t,
                *mut pixel,
                intptr_t,
                ::core::ffi::c_int,
                ::core::ffi::c_int,
            ) -> (),
        >,
        pub plane_copy_interleave: Option<
            unsafe extern "C" fn(
                *mut pixel,
                intptr_t,
                *mut pixel,
                intptr_t,
                *mut pixel,
                intptr_t,
                ::core::ffi::c_int,
                ::core::ffi::c_int,
            ) -> (),
        >,
        pub plane_copy_deinterleave: Option<
            unsafe extern "C" fn(
                *mut pixel,
                intptr_t,
                *mut pixel,
                intptr_t,
                *mut pixel,
                intptr_t,
                ::core::ffi::c_int,
                ::core::ffi::c_int,
            ) -> (),
        >,
        pub plane_copy_deinterleave_yuyv: Option<
            unsafe extern "C" fn(
                *mut pixel,
                intptr_t,
                *mut pixel,
                intptr_t,
                *mut pixel,
                intptr_t,
                ::core::ffi::c_int,
                ::core::ffi::c_int,
            ) -> (),
        >,
        pub plane_copy_deinterleave_rgb: Option<
            unsafe extern "C" fn(
                *mut pixel,
                intptr_t,
                *mut pixel,
                intptr_t,
                *mut pixel,
                intptr_t,
                *mut pixel,
                intptr_t,
                ::core::ffi::c_int,
                ::core::ffi::c_int,
                ::core::ffi::c_int,
            ) -> (),
        >,
        pub plane_copy_deinterleave_v210: Option<
            unsafe extern "C" fn(
                *mut pixel,
                intptr_t,
                *mut pixel,
                intptr_t,
                *mut uint32_t,
                intptr_t,
                ::core::ffi::c_int,
                ::core::ffi::c_int,
            ) -> (),
        >,
        pub hpel_filter: Option<
            unsafe extern "C" fn(
                *mut pixel,
                *mut pixel,
                *mut pixel,
                *mut pixel,
                intptr_t,
                ::core::ffi::c_int,
                ::core::ffi::c_int,
                *mut int16_t,
            ) -> (),
        >,
        pub prefetch_fenc: Option<
            unsafe extern "C" fn(
                *mut pixel,
                intptr_t,
                *mut pixel,
                intptr_t,
                ::core::ffi::c_int,
            ) -> (),
        >,
        pub prefetch_fenc_400: Option<
            unsafe extern "C" fn(
                *mut pixel,
                intptr_t,
                *mut pixel,
                intptr_t,
                ::core::ffi::c_int,
            ) -> (),
        >,
        pub prefetch_fenc_420: Option<
            unsafe extern "C" fn(
                *mut pixel,
                intptr_t,
                *mut pixel,
                intptr_t,
                ::core::ffi::c_int,
            ) -> (),
        >,
        pub prefetch_fenc_422: Option<
            unsafe extern "C" fn(
                *mut pixel,
                intptr_t,
                *mut pixel,
                intptr_t,
                ::core::ffi::c_int,
            ) -> (),
        >,
        pub prefetch_ref:
            Option<unsafe extern "C" fn(*mut pixel, intptr_t, ::core::ffi::c_int) -> ()>,
        pub memcpy_aligned: Option<
            unsafe extern "C" fn(
                *mut ::core::ffi::c_void,
                *const ::core::ffi::c_void,
                size_t,
            ) -> *mut ::core::ffi::c_void,
        >,
        pub memzero_aligned: Option<unsafe extern "C" fn(*mut ::core::ffi::c_void, size_t) -> ()>,
        pub integral_init4h:
            Option<unsafe extern "C" fn(*mut uint16_t, *mut pixel, intptr_t) -> ()>,
        pub integral_init8h:
            Option<unsafe extern "C" fn(*mut uint16_t, *mut pixel, intptr_t) -> ()>,
        pub integral_init4v:
            Option<unsafe extern "C" fn(*mut uint16_t, *mut uint16_t, intptr_t) -> ()>,
        pub integral_init8v: Option<unsafe extern "C" fn(*mut uint16_t, intptr_t) -> ()>,
        pub frame_init_lowres_core: Option<
            unsafe extern "C" fn(
                *mut pixel,
                *mut pixel,
                *mut pixel,
                *mut pixel,
                *mut pixel,
                intptr_t,
                intptr_t,
                ::core::ffi::c_int,
                ::core::ffi::c_int,
            ) -> (),
        >,
        pub weight: *mut weight_fn_t,
        pub offsetadd: *mut weight_fn_t,
        pub offsetsub: *mut weight_fn_t,
        pub weight_cache: Option<unsafe extern "C" fn(*mut x264_t, *mut x264_weight_t) -> ()>,
        pub mbtree_propagate_cost: Option<
            unsafe extern "C" fn(
                *mut int16_t,
                *mut uint16_t,
                *mut uint16_t,
                *mut uint16_t,
                *mut uint16_t,
                *mut ::core::ffi::c_float,
                ::core::ffi::c_int,
            ) -> (),
        >,
        pub mbtree_propagate_list: Option<
            unsafe extern "C" fn(
                *mut x264_t,
                *mut uint16_t,
                *mut [int16_t; 2],
                *mut int16_t,
                *mut uint16_t,
                ::core::ffi::c_int,
                ::core::ffi::c_int,
                ::core::ffi::c_int,
                ::core::ffi::c_int,
            ) -> (),
        >,
        pub mbtree_fix8_pack: Option<
            unsafe extern "C" fn(
                *mut uint16_t,
                *mut ::core::ffi::c_float,
                ::core::ffi::c_int,
            ) -> (),
        >,
        pub mbtree_fix8_unpack: Option<
            unsafe extern "C" fn(
                *mut ::core::ffi::c_float,
                *mut uint16_t,
                ::core::ffi::c_int,
            ) -> (),
        >,
    }
    use super::__stddef_size_t_h::size_t;
    use super::common_h::{pixel, x264_t};
    use super::stdint_h::intptr_t;
    use super::stdint_intn_h::{int16_t, int32_t};
    use super::stdint_uintn_h::{uint16_t, uint32_t};
}
#[c2rust::header_src = "/home/nwplayer123/Hacks/hex264/x264/common/bitstream.h:28"]
pub mod bitstream_h {
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "57:9"]
    pub struct x264_bitstream_function_t {
        pub nal_escape:
            Option<unsafe extern "C" fn(*mut uint8_t, *mut uint8_t, *mut uint8_t) -> *mut uint8_t>,
        pub cabac_block_residual_internal: Option<
            unsafe extern "C" fn(
                *mut dctcoef,
                ::core::ffi::c_int,
                intptr_t,
                *mut x264_cabac_t,
            ) -> (),
        >,
        pub cabac_block_residual_rd_internal: Option<
            unsafe extern "C" fn(
                *mut dctcoef,
                ::core::ffi::c_int,
                intptr_t,
                *mut x264_cabac_t,
            ) -> (),
        >,
        pub cabac_block_residual_8x8_rd_internal: Option<
            unsafe extern "C" fn(
                *mut dctcoef,
                ::core::ffi::c_int,
                intptr_t,
                *mut x264_cabac_t,
            ) -> (),
        >,
    }
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "50:9"]
    pub struct x264_run_level_t {
        pub last: int32_t,
        pub mask: int32_t,
        pub level: [dctcoef; 18],
    }
    #[c2rust::src_loc = "39:1"]
    pub type bs_t = bs_s;
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "39:16"]
    pub struct bs_s {
        pub p_start: *mut uint8_t,
        pub p: *mut uint8_t,
        pub p_end: *mut uint8_t,
        pub cur_bits: uintptr_t,
        pub i_left: ::core::ffi::c_int,
        pub i_bits_encoded: ::core::ffi::c_int,
    }
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "31:9"]
    pub struct vlc_large_t {
        pub i_bits: uint16_t,
        pub i_size: uint8_t,
        pub i_next: uint8_t,
    }
    #[c2rust::src_loc = "76:9"]
    pub const LEVEL_TABLE_SIZE: ::core::ffi::c_int = 128 as ::core::ffi::c_int;
    #[c2rust::src_loc = "201:22"]
    pub static mut x264_ue_size_tab: [uint8_t; 256] = [
        1 as ::core::ffi::c_int as uint8_t,
        1 as ::core::ffi::c_int as uint8_t,
        3 as ::core::ffi::c_int as uint8_t,
        3 as ::core::ffi::c_int as uint8_t,
        5 as ::core::ffi::c_int as uint8_t,
        5 as ::core::ffi::c_int as uint8_t,
        5 as ::core::ffi::c_int as uint8_t,
        5 as ::core::ffi::c_int as uint8_t,
        7 as ::core::ffi::c_int as uint8_t,
        7 as ::core::ffi::c_int as uint8_t,
        7 as ::core::ffi::c_int as uint8_t,
        7 as ::core::ffi::c_int as uint8_t,
        7 as ::core::ffi::c_int as uint8_t,
        7 as ::core::ffi::c_int as uint8_t,
        7 as ::core::ffi::c_int as uint8_t,
        7 as ::core::ffi::c_int as uint8_t,
        9 as ::core::ffi::c_int as uint8_t,
        9 as ::core::ffi::c_int as uint8_t,
        9 as ::core::ffi::c_int as uint8_t,
        9 as ::core::ffi::c_int as uint8_t,
        9 as ::core::ffi::c_int as uint8_t,
        9 as ::core::ffi::c_int as uint8_t,
        9 as ::core::ffi::c_int as uint8_t,
        9 as ::core::ffi::c_int as uint8_t,
        9 as ::core::ffi::c_int as uint8_t,
        9 as ::core::ffi::c_int as uint8_t,
        9 as ::core::ffi::c_int as uint8_t,
        9 as ::core::ffi::c_int as uint8_t,
        9 as ::core::ffi::c_int as uint8_t,
        9 as ::core::ffi::c_int as uint8_t,
        9 as ::core::ffi::c_int as uint8_t,
        9 as ::core::ffi::c_int as uint8_t,
        11 as ::core::ffi::c_int as uint8_t,
        11 as ::core::ffi::c_int as uint8_t,
        11 as ::core::ffi::c_int as uint8_t,
        11 as ::core::ffi::c_int as uint8_t,
        11 as ::core::ffi::c_int as uint8_t,
        11 as ::core::ffi::c_int as uint8_t,
        11 as ::core::ffi::c_int as uint8_t,
        11 as ::core::ffi::c_int as uint8_t,
        11 as ::core::ffi::c_int as uint8_t,
        11 as ::core::ffi::c_int as uint8_t,
        11 as ::core::ffi::c_int as uint8_t,
        11 as ::core::ffi::c_int as uint8_t,
        11 as ::core::ffi::c_int as uint8_t,
        11 as ::core::ffi::c_int as uint8_t,
        11 as ::core::ffi::c_int as uint8_t,
        11 as ::core::ffi::c_int as uint8_t,
        11 as ::core::ffi::c_int as uint8_t,
        11 as ::core::ffi::c_int as uint8_t,
        11 as ::core::ffi::c_int as uint8_t,
        11 as ::core::ffi::c_int as uint8_t,
        11 as ::core::ffi::c_int as uint8_t,
        11 as ::core::ffi::c_int as uint8_t,
        11 as ::core::ffi::c_int as uint8_t,
        11 as ::core::ffi::c_int as uint8_t,
        11 as ::core::ffi::c_int as uint8_t,
        11 as ::core::ffi::c_int as uint8_t,
        11 as ::core::ffi::c_int as uint8_t,
        11 as ::core::ffi::c_int as uint8_t,
        11 as ::core::ffi::c_int as uint8_t,
        11 as ::core::ffi::c_int as uint8_t,
        11 as ::core::ffi::c_int as uint8_t,
        11 as ::core::ffi::c_int as uint8_t,
        13 as ::core::ffi::c_int as uint8_t,
        13 as ::core::ffi::c_int as uint8_t,
        13 as ::core::ffi::c_int as uint8_t,
        13 as ::core::ffi::c_int as uint8_t,
        13 as ::core::ffi::c_int as uint8_t,
        13 as ::core::ffi::c_int as uint8_t,
        13 as ::core::ffi::c_int as uint8_t,
        13 as ::core::ffi::c_int as uint8_t,
        13 as ::core::ffi::c_int as uint8_t,
        13 as ::core::ffi::c_int as uint8_t,
        13 as ::core::ffi::c_int as uint8_t,
        13 as ::core::ffi::c_int as uint8_t,
        13 as ::core::ffi::c_int as uint8_t,
        13 as ::core::ffi::c_int as uint8_t,
        13 as ::core::ffi::c_int as uint8_t,
        13 as ::core::ffi::c_int as uint8_t,
        13 as ::core::ffi::c_int as uint8_t,
        13 as ::core::ffi::c_int as uint8_t,
        13 as ::core::ffi::c_int as uint8_t,
        13 as ::core::ffi::c_int as uint8_t,
        13 as ::core::ffi::c_int as uint8_t,
        13 as ::core::ffi::c_int as uint8_t,
        13 as ::core::ffi::c_int as uint8_t,
        13 as ::core::ffi::c_int as uint8_t,
        13 as ::core::ffi::c_int as uint8_t,
        13 as ::core::ffi::c_int as uint8_t,
        13 as ::core::ffi::c_int as uint8_t,
        13 as ::core::ffi::c_int as uint8_t,
        13 as ::core::ffi::c_int as uint8_t,
        13 as ::core::ffi::c_int as uint8_t,
        13 as ::core::ffi::c_int as uint8_t,
        13 as ::core::ffi::c_int as uint8_t,
        13 as ::core::ffi::c_int as uint8_t,
        13 as ::core::ffi::c_int as uint8_t,
        13 as ::core::ffi::c_int as uint8_t,
        13 as ::core::ffi::c_int as uint8_t,
        13 as ::core::ffi::c_int as uint8_t,
        13 as ::core::ffi::c_int as uint8_t,
        13 as ::core::ffi::c_int as uint8_t,
        13 as ::core::ffi::c_int as uint8_t,
        13 as ::core::ffi::c_int as uint8_t,
        13 as ::core::ffi::c_int as uint8_t,
        13 as ::core::ffi::c_int as uint8_t,
        13 as ::core::ffi::c_int as uint8_t,
        13 as ::core::ffi::c_int as uint8_t,
        13 as ::core::ffi::c_int as uint8_t,
        13 as ::core::ffi::c_int as uint8_t,
        13 as ::core::ffi::c_int as uint8_t,
        13 as ::core::ffi::c_int as uint8_t,
        13 as ::core::ffi::c_int as uint8_t,
        13 as ::core::ffi::c_int as uint8_t,
        13 as ::core::ffi::c_int as uint8_t,
        13 as ::core::ffi::c_int as uint8_t,
        13 as ::core::ffi::c_int as uint8_t,
        13 as ::core::ffi::c_int as uint8_t,
        13 as ::core::ffi::c_int as uint8_t,
        13 as ::core::ffi::c_int as uint8_t,
        13 as ::core::ffi::c_int as uint8_t,
        13 as ::core::ffi::c_int as uint8_t,
        13 as ::core::ffi::c_int as uint8_t,
        13 as ::core::ffi::c_int as uint8_t,
        13 as ::core::ffi::c_int as uint8_t,
        13 as ::core::ffi::c_int as uint8_t,
        13 as ::core::ffi::c_int as uint8_t,
        15 as ::core::ffi::c_int as uint8_t,
        15 as ::core::ffi::c_int as uint8_t,
        15 as ::core::ffi::c_int as uint8_t,
        15 as ::core::ffi::c_int as uint8_t,
        15 as ::core::ffi::c_int as uint8_t,
        15 as ::core::ffi::c_int as uint8_t,
        15 as ::core::ffi::c_int as uint8_t,
        15 as ::core::ffi::c_int as uint8_t,
        15 as ::core::ffi::c_int as uint8_t,
        15 as ::core::ffi::c_int as uint8_t,
        15 as ::core::ffi::c_int as uint8_t,
        15 as ::core::ffi::c_int as uint8_t,
        15 as ::core::ffi::c_int as uint8_t,
        15 as ::core::ffi::c_int as uint8_t,
        15 as ::core::ffi::c_int as uint8_t,
        15 as ::core::ffi::c_int as uint8_t,
        15 as ::core::ffi::c_int as uint8_t,
        15 as ::core::ffi::c_int as uint8_t,
        15 as ::core::ffi::c_int as uint8_t,
        15 as ::core::ffi::c_int as uint8_t,
        15 as ::core::ffi::c_int as uint8_t,
        15 as ::core::ffi::c_int as uint8_t,
        15 as ::core::ffi::c_int as uint8_t,
        15 as ::core::ffi::c_int as uint8_t,
        15 as ::core::ffi::c_int as uint8_t,
        15 as ::core::ffi::c_int as uint8_t,
        15 as ::core::ffi::c_int as uint8_t,
        15 as ::core::ffi::c_int as uint8_t,
        15 as ::core::ffi::c_int as uint8_t,
        15 as ::core::ffi::c_int as uint8_t,
        15 as ::core::ffi::c_int as uint8_t,
        15 as ::core::ffi::c_int as uint8_t,
        15 as ::core::ffi::c_int as uint8_t,
        15 as ::core::ffi::c_int as uint8_t,
        15 as ::core::ffi::c_int as uint8_t,
        15 as ::core::ffi::c_int as uint8_t,
        15 as ::core::ffi::c_int as uint8_t,
        15 as ::core::ffi::c_int as uint8_t,
        15 as ::core::ffi::c_int as uint8_t,
        15 as ::core::ffi::c_int as uint8_t,
        15 as ::core::ffi::c_int as uint8_t,
        15 as ::core::ffi::c_int as uint8_t,
        15 as ::core::ffi::c_int as uint8_t,
        15 as ::core::ffi::c_int as uint8_t,
        15 as ::core::ffi::c_int as uint8_t,
        15 as ::core::ffi::c_int as uint8_t,
        15 as ::core::ffi::c_int as uint8_t,
        15 as ::core::ffi::c_int as uint8_t,
        15 as ::core::ffi::c_int as uint8_t,
        15 as ::core::ffi::c_int as uint8_t,
        15 as ::core::ffi::c_int as uint8_t,
        15 as ::core::ffi::c_int as uint8_t,
        15 as ::core::ffi::c_int as uint8_t,
        15 as ::core::ffi::c_int as uint8_t,
        15 as ::core::ffi::c_int as uint8_t,
        15 as ::core::ffi::c_int as uint8_t,
        15 as ::core::ffi::c_int as uint8_t,
        15 as ::core::ffi::c_int as uint8_t,
        15 as ::core::ffi::c_int as uint8_t,
        15 as ::core::ffi::c_int as uint8_t,
        15 as ::core::ffi::c_int as uint8_t,
        15 as ::core::ffi::c_int as uint8_t,
        15 as ::core::ffi::c_int as uint8_t,
        15 as ::core::ffi::c_int as uint8_t,
        15 as ::core::ffi::c_int as uint8_t,
        15 as ::core::ffi::c_int as uint8_t,
        15 as ::core::ffi::c_int as uint8_t,
        15 as ::core::ffi::c_int as uint8_t,
        15 as ::core::ffi::c_int as uint8_t,
        15 as ::core::ffi::c_int as uint8_t,
        15 as ::core::ffi::c_int as uint8_t,
        15 as ::core::ffi::c_int as uint8_t,
        15 as ::core::ffi::c_int as uint8_t,
        15 as ::core::ffi::c_int as uint8_t,
        15 as ::core::ffi::c_int as uint8_t,
        15 as ::core::ffi::c_int as uint8_t,
        15 as ::core::ffi::c_int as uint8_t,
        15 as ::core::ffi::c_int as uint8_t,
        15 as ::core::ffi::c_int as uint8_t,
        15 as ::core::ffi::c_int as uint8_t,
        15 as ::core::ffi::c_int as uint8_t,
        15 as ::core::ffi::c_int as uint8_t,
        15 as ::core::ffi::c_int as uint8_t,
        15 as ::core::ffi::c_int as uint8_t,
        15 as ::core::ffi::c_int as uint8_t,
        15 as ::core::ffi::c_int as uint8_t,
        15 as ::core::ffi::c_int as uint8_t,
        15 as ::core::ffi::c_int as uint8_t,
        15 as ::core::ffi::c_int as uint8_t,
        15 as ::core::ffi::c_int as uint8_t,
        15 as ::core::ffi::c_int as uint8_t,
        15 as ::core::ffi::c_int as uint8_t,
        15 as ::core::ffi::c_int as uint8_t,
        15 as ::core::ffi::c_int as uint8_t,
        15 as ::core::ffi::c_int as uint8_t,
        15 as ::core::ffi::c_int as uint8_t,
        15 as ::core::ffi::c_int as uint8_t,
        15 as ::core::ffi::c_int as uint8_t,
        15 as ::core::ffi::c_int as uint8_t,
        15 as ::core::ffi::c_int as uint8_t,
        15 as ::core::ffi::c_int as uint8_t,
        15 as ::core::ffi::c_int as uint8_t,
        15 as ::core::ffi::c_int as uint8_t,
        15 as ::core::ffi::c_int as uint8_t,
        15 as ::core::ffi::c_int as uint8_t,
        15 as ::core::ffi::c_int as uint8_t,
        15 as ::core::ffi::c_int as uint8_t,
        15 as ::core::ffi::c_int as uint8_t,
        15 as ::core::ffi::c_int as uint8_t,
        15 as ::core::ffi::c_int as uint8_t,
        15 as ::core::ffi::c_int as uint8_t,
        15 as ::core::ffi::c_int as uint8_t,
        15 as ::core::ffi::c_int as uint8_t,
        15 as ::core::ffi::c_int as uint8_t,
        15 as ::core::ffi::c_int as uint8_t,
        15 as ::core::ffi::c_int as uint8_t,
        15 as ::core::ffi::c_int as uint8_t,
        15 as ::core::ffi::c_int as uint8_t,
        15 as ::core::ffi::c_int as uint8_t,
        15 as ::core::ffi::c_int as uint8_t,
        15 as ::core::ffi::c_int as uint8_t,
        15 as ::core::ffi::c_int as uint8_t,
        15 as ::core::ffi::c_int as uint8_t,
        15 as ::core::ffi::c_int as uint8_t,
        15 as ::core::ffi::c_int as uint8_t,
        15 as ::core::ffi::c_int as uint8_t,
        15 as ::core::ffi::c_int as uint8_t,
        15 as ::core::ffi::c_int as uint8_t,
    ];
    #[inline(always)]
    #[c2rust::src_loc = "278:1"]
    pub unsafe extern "C" fn bs_size_ue(mut val: ::core::ffi::c_uint) -> ::core::ffi::c_int {
        return x264_ue_size_tab[val.wrapping_add(1 as ::core::ffi::c_uint) as usize]
            as ::core::ffi::c_int;
    }
    #[inline(always)]
    #[c2rust::src_loc = "283:1"]
    pub unsafe extern "C" fn bs_size_ue_big(mut val: ::core::ffi::c_uint) -> ::core::ffi::c_int {
        if val < 255 as ::core::ffi::c_uint {
            return x264_ue_size_tab[val.wrapping_add(1 as ::core::ffi::c_uint) as usize]
                as ::core::ffi::c_int;
        } else {
            return x264_ue_size_tab
                [(val.wrapping_add(1 as ::core::ffi::c_uint) >> 8 as ::core::ffi::c_int) as usize]
                as ::core::ffi::c_int
                + 16 as ::core::ffi::c_int;
        };
    }
    #[inline(always)]
    #[c2rust::src_loc = "291:1"]
    pub unsafe extern "C" fn bs_size_se(mut val: ::core::ffi::c_int) -> ::core::ffi::c_int {
        let mut tmp: ::core::ffi::c_int = 1 as ::core::ffi::c_int - val * 2 as ::core::ffi::c_int;
        if tmp < 0 as ::core::ffi::c_int {
            tmp = val * 2 as ::core::ffi::c_int;
        }
        if tmp < 256 as ::core::ffi::c_int {
            return x264_ue_size_tab[tmp as usize] as ::core::ffi::c_int;
        } else {
            return x264_ue_size_tab[(tmp >> 8 as ::core::ffi::c_int) as usize]
                as ::core::ffi::c_int
                + 16 as ::core::ffi::c_int;
        };
    }
    #[inline(always)]
    #[c2rust::src_loc = "301:1"]
    pub unsafe extern "C" fn bs_size_te(
        mut x: ::core::ffi::c_int,
        mut val: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int {
        if x == 1 as ::core::ffi::c_int {
            return 1 as ::core::ffi::c_int;
        } else {
            return x264_ue_size_tab[(val + 1 as ::core::ffi::c_int) as usize] as ::core::ffi::c_int;
        };
    }
    use super::cabac_h::x264_cabac_t;
    use super::common_h::dctcoef;
    use super::stdint_h::{intptr_t, uintptr_t};
    use super::stdint_intn_h::int32_t;
    use super::stdint_uintn_h::{uint16_t, uint32_t, uint8_t};
    extern "C" {
        #[c2rust::src_loc = "78:20"]
        pub static mut x264_10_level_token: [[vlc_large_t; 128]; 7];
        #[c2rust::src_loc = "84:17"]
        pub static mut x264_10_run_before: [uint32_t; 65536];
    }
}
#[c2rust::header_src = "/home/nwplayer123/Hacks/hex264/x264/common/cabac.h:28"]
pub mod cabac_h {
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "30:9"]
    pub struct x264_cabac_t {
        pub i_low: ::core::ffi::c_int,
        pub i_range: ::core::ffi::c_int,
        pub i_queue: ::core::ffi::c_int,
        pub i_bytes_outstanding: ::core::ffi::c_int,
        pub p_start: *mut uint8_t,
        pub p: *mut uint8_t,
        pub p_end: *mut uint8_t,
        pub f8_bits_encoded: ::core::ffi::c_int,
        pub state: [uint8_t; 1024],
        pub padding: [uint8_t; 12],
    }
    #[inline(always)]
    #[c2rust::src_loc = "101:1"]
    pub unsafe extern "C" fn x264_cabac_size_decision(
        mut cb: *mut x264_cabac_t,
        mut i_ctx: ::core::ffi::c_long,
        mut b: ::core::ffi::c_long,
    ) {
        let mut i_state: ::core::ffi::c_int = (*cb).state[i_ctx as usize] as ::core::ffi::c_int;
        (*cb).state[i_ctx as usize] = x264_cabac_transition[i_state as usize][b as usize];
        (*cb).f8_bits_encoded +=
            x264_cabac_entropy[(i_state as ::core::ffi::c_long ^ b) as usize] as ::core::ffi::c_int;
    }
    #[inline(always)]
    #[c2rust::src_loc = "108:1"]
    pub unsafe extern "C" fn x264_cabac_size_decision2(
        mut state: *mut uint8_t,
        mut b: ::core::ffi::c_long,
    ) -> ::core::ffi::c_int {
        let mut i_state: ::core::ffi::c_int = *state as ::core::ffi::c_int;
        *state = x264_cabac_transition[i_state as usize][b as usize];
        return x264_cabac_entropy[(i_state as ::core::ffi::c_long ^ b) as usize]
            as ::core::ffi::c_int;
    }
    #[inline(always)]
    #[c2rust::src_loc = "115:1"]
    pub unsafe extern "C" fn x264_cabac_size_decision_noup(
        mut cb: *mut x264_cabac_t,
        mut i_ctx: ::core::ffi::c_long,
        mut b: ::core::ffi::c_long,
    ) {
        let mut i_state: ::core::ffi::c_int = (*cb).state[i_ctx as usize] as ::core::ffi::c_int;
        (*cb).f8_bits_encoded +=
            x264_cabac_entropy[(i_state as ::core::ffi::c_long ^ b) as usize] as ::core::ffi::c_int;
    }
    #[inline(always)]
    #[c2rust::src_loc = "121:1"]
    pub unsafe extern "C" fn x264_cabac_size_decision_noup2(
        mut state: *mut uint8_t,
        mut b: ::core::ffi::c_long,
    ) -> ::core::ffi::c_int {
        return x264_cabac_entropy[(*state as ::core::ffi::c_long ^ b) as usize]
            as ::core::ffi::c_int;
    }
    use super::stdint_uintn_h::{uint16_t, uint8_t};
    use super::tables_h::{x264_cabac_entropy, x264_cabac_transition};
}
#[c2rust::header_src = "/home/nwplayer123/Hacks/hex264/x264/common/quant.h:28"]
pub mod quant_h {
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "30:9"]
    pub struct x264_quant_function_t {
        pub quant_8x8: Option<
            unsafe extern "C" fn(*mut dctcoef, *mut udctcoef, *mut udctcoef) -> ::core::ffi::c_int,
        >,
        pub quant_4x4: Option<
            unsafe extern "C" fn(*mut dctcoef, *mut udctcoef, *mut udctcoef) -> ::core::ffi::c_int,
        >,
        pub quant_4x4x4: Option<
            unsafe extern "C" fn(
                *mut [dctcoef; 16],
                *mut udctcoef,
                *mut udctcoef,
            ) -> ::core::ffi::c_int,
        >,
        pub quant_4x4_dc: Option<
            unsafe extern "C" fn(
                *mut dctcoef,
                ::core::ffi::c_int,
                ::core::ffi::c_int,
            ) -> ::core::ffi::c_int,
        >,
        pub quant_2x2_dc: Option<
            unsafe extern "C" fn(
                *mut dctcoef,
                ::core::ffi::c_int,
                ::core::ffi::c_int,
            ) -> ::core::ffi::c_int,
        >,
        pub dequant_8x8: Option<
            unsafe extern "C" fn(
                *mut dctcoef,
                *mut [::core::ffi::c_int; 64],
                ::core::ffi::c_int,
            ) -> (),
        >,
        pub dequant_4x4: Option<
            unsafe extern "C" fn(
                *mut dctcoef,
                *mut [::core::ffi::c_int; 16],
                ::core::ffi::c_int,
            ) -> (),
        >,
        pub dequant_4x4_dc: Option<
            unsafe extern "C" fn(
                *mut dctcoef,
                *mut [::core::ffi::c_int; 16],
                ::core::ffi::c_int,
            ) -> (),
        >,
        pub idct_dequant_2x4_dc: Option<
            unsafe extern "C" fn(
                *mut dctcoef,
                *mut [dctcoef; 16],
                *mut [::core::ffi::c_int; 16],
                ::core::ffi::c_int,
            ) -> (),
        >,
        pub idct_dequant_2x4_dconly: Option<
            unsafe extern "C" fn(
                *mut dctcoef,
                *mut [::core::ffi::c_int; 16],
                ::core::ffi::c_int,
            ) -> (),
        >,
        pub optimize_chroma_2x2_dc:
            Option<unsafe extern "C" fn(*mut dctcoef, ::core::ffi::c_int) -> ::core::ffi::c_int>,
        pub optimize_chroma_2x4_dc:
            Option<unsafe extern "C" fn(*mut dctcoef, ::core::ffi::c_int) -> ::core::ffi::c_int>,
        pub denoise_dct: Option<
            unsafe extern "C" fn(
                *mut dctcoef,
                *mut uint32_t,
                *mut udctcoef,
                ::core::ffi::c_int,
            ) -> (),
        >,
        pub decimate_score15: Option<unsafe extern "C" fn(*mut dctcoef) -> ::core::ffi::c_int>,
        pub decimate_score16: Option<unsafe extern "C" fn(*mut dctcoef) -> ::core::ffi::c_int>,
        pub decimate_score64: Option<unsafe extern "C" fn(*mut dctcoef) -> ::core::ffi::c_int>,
        pub coeff_last: [Option<unsafe extern "C" fn(*mut dctcoef) -> ::core::ffi::c_int>; 14],
        pub coeff_last4: Option<unsafe extern "C" fn(*mut dctcoef) -> ::core::ffi::c_int>,
        pub coeff_last8: Option<unsafe extern "C" fn(*mut dctcoef) -> ::core::ffi::c_int>,
        pub coeff_level_run: [Option<
            unsafe extern "C" fn(*mut dctcoef, *mut x264_run_level_t) -> ::core::ffi::c_int,
        >; 13],
        pub coeff_level_run4:
            Option<unsafe extern "C" fn(*mut dctcoef, *mut x264_run_level_t) -> ::core::ffi::c_int>,
        pub coeff_level_run8:
            Option<unsafe extern "C" fn(*mut dctcoef, *mut x264_run_level_t) -> ::core::ffi::c_int>,
        pub trellis_cabac_4x4: Option<
            unsafe extern "C" fn(
                *const ::core::ffi::c_int,
                *const uint8_t,
                ::core::ffi::c_int,
                ::core::ffi::c_int,
                *mut dctcoef,
                *mut dctcoef,
                *mut dctcoef,
                *mut uint8_t,
                *mut uint8_t,
                uint64_t,
                uint16_t,
                ::core::ffi::c_int,
            ) -> ::core::ffi::c_int,
        >,
        pub trellis_cabac_8x8: Option<
            unsafe extern "C" fn(
                *const ::core::ffi::c_int,
                *const uint8_t,
                ::core::ffi::c_int,
                ::core::ffi::c_int,
                *mut dctcoef,
                *mut dctcoef,
                *mut dctcoef,
                *mut uint8_t,
                *mut uint8_t,
                uint64_t,
                uint16_t,
                ::core::ffi::c_int,
            ) -> ::core::ffi::c_int,
        >,
        pub trellis_cabac_4x4_psy: Option<
            unsafe extern "C" fn(
                *const ::core::ffi::c_int,
                *const uint8_t,
                ::core::ffi::c_int,
                ::core::ffi::c_int,
                *mut dctcoef,
                *mut dctcoef,
                *mut dctcoef,
                *mut uint8_t,
                *mut uint8_t,
                uint64_t,
                uint16_t,
                ::core::ffi::c_int,
                *mut dctcoef,
                ::core::ffi::c_int,
            ) -> ::core::ffi::c_int,
        >,
        pub trellis_cabac_8x8_psy: Option<
            unsafe extern "C" fn(
                *const ::core::ffi::c_int,
                *const uint8_t,
                ::core::ffi::c_int,
                ::core::ffi::c_int,
                *mut dctcoef,
                *mut dctcoef,
                *mut dctcoef,
                *mut uint8_t,
                *mut uint8_t,
                uint64_t,
                uint16_t,
                ::core::ffi::c_int,
                *mut dctcoef,
                ::core::ffi::c_int,
            ) -> ::core::ffi::c_int,
        >,
        pub trellis_cabac_dc: Option<
            unsafe extern "C" fn(
                *const ::core::ffi::c_int,
                *const uint8_t,
                ::core::ffi::c_int,
                ::core::ffi::c_int,
                *mut dctcoef,
                *mut dctcoef,
                *mut dctcoef,
                *mut uint8_t,
                *mut uint8_t,
                uint64_t,
                uint16_t,
                ::core::ffi::c_int,
            ) -> ::core::ffi::c_int,
        >,
        pub trellis_cabac_chroma_422_dc: Option<
            unsafe extern "C" fn(
                *const ::core::ffi::c_int,
                *const uint8_t,
                ::core::ffi::c_int,
                ::core::ffi::c_int,
                *mut dctcoef,
                *mut dctcoef,
                *mut dctcoef,
                *mut uint8_t,
                *mut uint8_t,
                uint64_t,
                uint16_t,
            ) -> ::core::ffi::c_int,
        >,
    }
    use super::bitstream_h::x264_run_level_t;
    use super::common_h::{dctcoef, udctcoef};
    use super::stdint_uintn_h::{uint16_t, uint32_t, uint64_t, uint8_t};
}
#[c2rust::header_src = "/home/nwplayer123/Hacks/hex264/x264/common/dct.h:28"]
pub mod dct_h {
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "61:9"]
    pub struct x264_zigzag_function_t {
        pub scan_8x8: Option<unsafe extern "C" fn(*mut dctcoef, *mut dctcoef) -> ()>,
        pub scan_4x4: Option<unsafe extern "C" fn(*mut dctcoef, *mut dctcoef) -> ()>,
        pub sub_8x8: Option<
            unsafe extern "C" fn(*mut dctcoef, *const pixel, *mut pixel) -> ::core::ffi::c_int,
        >,
        pub sub_4x4: Option<
            unsafe extern "C" fn(*mut dctcoef, *const pixel, *mut pixel) -> ::core::ffi::c_int,
        >,
        pub sub_4x4ac: Option<
            unsafe extern "C" fn(
                *mut dctcoef,
                *const pixel,
                *mut pixel,
                *mut dctcoef,
            ) -> ::core::ffi::c_int,
        >,
        pub interleave_8x8_cavlc:
            Option<unsafe extern "C" fn(*mut dctcoef, *mut dctcoef, *mut uint8_t) -> ()>,
    }
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "29:9"]
    pub struct x264_dct_function_t {
        pub sub4x4_dct: Option<unsafe extern "C" fn(*mut dctcoef, *mut pixel, *mut pixel) -> ()>,
        pub add4x4_idct: Option<unsafe extern "C" fn(*mut pixel, *mut dctcoef) -> ()>,
        pub sub8x8_dct:
            Option<unsafe extern "C" fn(*mut [dctcoef; 16], *mut pixel, *mut pixel) -> ()>,
        pub sub8x8_dct_dc: Option<unsafe extern "C" fn(*mut dctcoef, *mut pixel, *mut pixel) -> ()>,
        pub add8x8_idct: Option<unsafe extern "C" fn(*mut pixel, *mut [dctcoef; 16]) -> ()>,
        pub add8x8_idct_dc: Option<unsafe extern "C" fn(*mut pixel, *mut dctcoef) -> ()>,
        pub sub8x16_dct_dc:
            Option<unsafe extern "C" fn(*mut dctcoef, *mut pixel, *mut pixel) -> ()>,
        pub sub16x16_dct:
            Option<unsafe extern "C" fn(*mut [dctcoef; 16], *mut pixel, *mut pixel) -> ()>,
        pub add16x16_idct: Option<unsafe extern "C" fn(*mut pixel, *mut [dctcoef; 16]) -> ()>,
        pub add16x16_idct_dc: Option<unsafe extern "C" fn(*mut pixel, *mut dctcoef) -> ()>,
        pub sub8x8_dct8: Option<unsafe extern "C" fn(*mut dctcoef, *mut pixel, *mut pixel) -> ()>,
        pub add8x8_idct8: Option<unsafe extern "C" fn(*mut pixel, *mut dctcoef) -> ()>,
        pub sub16x16_dct8:
            Option<unsafe extern "C" fn(*mut [dctcoef; 64], *mut pixel, *mut pixel) -> ()>,
        pub add16x16_idct8: Option<unsafe extern "C" fn(*mut pixel, *mut [dctcoef; 64]) -> ()>,
        pub dct4x4dc: Option<unsafe extern "C" fn(*mut dctcoef) -> ()>,
        pub idct4x4dc: Option<unsafe extern "C" fn(*mut dctcoef) -> ()>,
        pub dct2x4dc: Option<unsafe extern "C" fn(*mut dctcoef, *mut [dctcoef; 16]) -> ()>,
    }
    use super::common_h::{dctcoef, pixel};
    use super::stdint_uintn_h::uint8_t;
}
#[c2rust::header_src = "/home/nwplayer123/Hacks/hex264/x264/common/pixel.h:28"]
pub mod pixel_h {
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "78:9"]
    pub struct x264_pixel_function_t {
        pub sad: [x264_pixel_cmp_t; 8],
        pub ssd: [x264_pixel_cmp_t; 8],
        pub satd: [x264_pixel_cmp_t; 8],
        pub ssim: [x264_pixel_cmp_t; 7],
        pub sa8d: [x264_pixel_cmp_t; 4],
        pub mbcmp: [x264_pixel_cmp_t; 8],
        pub mbcmp_unaligned: [x264_pixel_cmp_t; 8],
        pub fpelcmp: [x264_pixel_cmp_t; 8],
        pub fpelcmp_x3: [x264_pixel_cmp_x3_t; 7],
        pub fpelcmp_x4: [x264_pixel_cmp_x4_t; 7],
        pub sad_aligned: [x264_pixel_cmp_t; 8],
        pub vsad: Option<
            unsafe extern "C" fn(*mut pixel, intptr_t, ::core::ffi::c_int) -> ::core::ffi::c_int,
        >,
        pub asd8: Option<
            unsafe extern "C" fn(
                *mut pixel,
                intptr_t,
                *mut pixel,
                intptr_t,
                ::core::ffi::c_int,
            ) -> ::core::ffi::c_int,
        >,
        pub sa8d_satd: [Option<
            unsafe extern "C" fn(*mut pixel, intptr_t, *mut pixel, intptr_t) -> uint64_t,
        >; 1],
        pub var: [Option<unsafe extern "C" fn(*mut pixel, intptr_t) -> uint64_t>; 4],
        pub var2: [Option<
            unsafe extern "C" fn(
                *mut pixel,
                *mut pixel,
                *mut ::core::ffi::c_int,
            ) -> ::core::ffi::c_int,
        >; 4],
        pub hadamard_ac: [Option<unsafe extern "C" fn(*mut pixel, intptr_t) -> uint64_t>; 4],
        pub ssd_nv12_core: Option<
            unsafe extern "C" fn(
                *mut pixel,
                intptr_t,
                *mut pixel,
                intptr_t,
                ::core::ffi::c_int,
                ::core::ffi::c_int,
                *mut uint64_t,
                *mut uint64_t,
            ) -> (),
        >,
        pub ssim_4x4x2_core: Option<
            unsafe extern "C" fn(
                *const pixel,
                intptr_t,
                *const pixel,
                intptr_t,
                *mut [::core::ffi::c_int; 4],
            ) -> (),
        >,
        pub ssim_end4: Option<
            unsafe extern "C" fn(
                *mut [::core::ffi::c_int; 4],
                *mut [::core::ffi::c_int; 4],
                ::core::ffi::c_int,
            ) -> ::core::ffi::c_float,
        >,
        pub sad_x3: [x264_pixel_cmp_x3_t; 7],
        pub sad_x4: [x264_pixel_cmp_x4_t; 7],
        pub satd_x3: [x264_pixel_cmp_x3_t; 7],
        pub satd_x4: [x264_pixel_cmp_x4_t; 7],
        pub ads: [Option<
            unsafe extern "C" fn(
                *mut ::core::ffi::c_int,
                *mut uint16_t,
                ::core::ffi::c_int,
                *mut uint16_t,
                *mut int16_t,
                ::core::ffi::c_int,
                ::core::ffi::c_int,
            ) -> ::core::ffi::c_int,
        >; 7],
        pub intra_mbcmp_x3_16x16:
            Option<unsafe extern "C" fn(*mut pixel, *mut pixel, *mut ::core::ffi::c_int) -> ()>,
        pub intra_satd_x3_16x16:
            Option<unsafe extern "C" fn(*mut pixel, *mut pixel, *mut ::core::ffi::c_int) -> ()>,
        pub intra_sad_x3_16x16:
            Option<unsafe extern "C" fn(*mut pixel, *mut pixel, *mut ::core::ffi::c_int) -> ()>,
        pub intra_mbcmp_x3_4x4:
            Option<unsafe extern "C" fn(*mut pixel, *mut pixel, *mut ::core::ffi::c_int) -> ()>,
        pub intra_satd_x3_4x4:
            Option<unsafe extern "C" fn(*mut pixel, *mut pixel, *mut ::core::ffi::c_int) -> ()>,
        pub intra_sad_x3_4x4:
            Option<unsafe extern "C" fn(*mut pixel, *mut pixel, *mut ::core::ffi::c_int) -> ()>,
        pub intra_mbcmp_x3_chroma:
            Option<unsafe extern "C" fn(*mut pixel, *mut pixel, *mut ::core::ffi::c_int) -> ()>,
        pub intra_satd_x3_chroma:
            Option<unsafe extern "C" fn(*mut pixel, *mut pixel, *mut ::core::ffi::c_int) -> ()>,
        pub intra_sad_x3_chroma:
            Option<unsafe extern "C" fn(*mut pixel, *mut pixel, *mut ::core::ffi::c_int) -> ()>,
        pub intra_mbcmp_x3_8x16c:
            Option<unsafe extern "C" fn(*mut pixel, *mut pixel, *mut ::core::ffi::c_int) -> ()>,
        pub intra_satd_x3_8x16c:
            Option<unsafe extern "C" fn(*mut pixel, *mut pixel, *mut ::core::ffi::c_int) -> ()>,
        pub intra_sad_x3_8x16c:
            Option<unsafe extern "C" fn(*mut pixel, *mut pixel, *mut ::core::ffi::c_int) -> ()>,
        pub intra_mbcmp_x3_8x8c:
            Option<unsafe extern "C" fn(*mut pixel, *mut pixel, *mut ::core::ffi::c_int) -> ()>,
        pub intra_satd_x3_8x8c:
            Option<unsafe extern "C" fn(*mut pixel, *mut pixel, *mut ::core::ffi::c_int) -> ()>,
        pub intra_sad_x3_8x8c:
            Option<unsafe extern "C" fn(*mut pixel, *mut pixel, *mut ::core::ffi::c_int) -> ()>,
        pub intra_mbcmp_x3_8x8:
            Option<unsafe extern "C" fn(*mut pixel, *mut pixel, *mut ::core::ffi::c_int) -> ()>,
        pub intra_sa8d_x3_8x8:
            Option<unsafe extern "C" fn(*mut pixel, *mut pixel, *mut ::core::ffi::c_int) -> ()>,
        pub intra_sad_x3_8x8:
            Option<unsafe extern "C" fn(*mut pixel, *mut pixel, *mut ::core::ffi::c_int) -> ()>,
        pub intra_mbcmp_x9_4x4: Option<
            unsafe extern "C" fn(*mut pixel, *mut pixel, *mut uint16_t) -> ::core::ffi::c_int,
        >,
        pub intra_satd_x9_4x4: Option<
            unsafe extern "C" fn(*mut pixel, *mut pixel, *mut uint16_t) -> ::core::ffi::c_int,
        >,
        pub intra_sad_x9_4x4: Option<
            unsafe extern "C" fn(*mut pixel, *mut pixel, *mut uint16_t) -> ::core::ffi::c_int,
        >,
        pub intra_mbcmp_x9_8x8: Option<
            unsafe extern "C" fn(
                *mut pixel,
                *mut pixel,
                *mut pixel,
                *mut uint16_t,
                *mut uint16_t,
            ) -> ::core::ffi::c_int,
        >,
        pub intra_sa8d_x9_8x8: Option<
            unsafe extern "C" fn(
                *mut pixel,
                *mut pixel,
                *mut pixel,
                *mut uint16_t,
                *mut uint16_t,
            ) -> ::core::ffi::c_int,
        >,
        pub intra_sad_x9_8x8: Option<
            unsafe extern "C" fn(
                *mut pixel,
                *mut pixel,
                *mut pixel,
                *mut uint16_t,
                *mut uint16_t,
            ) -> ::core::ffi::c_int,
        >,
    }
    #[c2rust::src_loc = "35:1"]
    pub type x264_pixel_cmp_x4_t = Option<
        unsafe extern "C" fn(
            *mut pixel,
            *mut pixel,
            *mut pixel,
            *mut pixel,
            *mut pixel,
            intptr_t,
            *mut ::core::ffi::c_int,
        ) -> (),
    >;
    #[c2rust::src_loc = "34:1"]
    pub type x264_pixel_cmp_x3_t = Option<
        unsafe extern "C" fn(
            *mut pixel,
            *mut pixel,
            *mut pixel,
            *mut pixel,
            intptr_t,
            *mut ::core::ffi::c_int,
        ) -> (),
    >;
    #[c2rust::src_loc = "33:1"]
    pub type x264_pixel_cmp_t = Option<
        unsafe extern "C" fn(*mut pixel, intptr_t, *mut pixel, intptr_t) -> ::core::ffi::c_int,
    >;
    #[c2rust::src_loc = "37:1"]
    pub type C2RustUnnamed_19 = ::core::ffi::c_uint;
    #[c2rust::src_loc = "52:5"]
    pub const PIXEL_2x2: C2RustUnnamed_19 = 11;
    #[c2rust::src_loc = "51:5"]
    pub const PIXEL_2x4: C2RustUnnamed_19 = 10;
    #[c2rust::src_loc = "50:5"]
    pub const PIXEL_2x8: C2RustUnnamed_19 = 9;
    #[c2rust::src_loc = "49:5"]
    pub const PIXEL_4x2: C2RustUnnamed_19 = 8;
    #[c2rust::src_loc = "48:5"]
    pub const PIXEL_4x16: C2RustUnnamed_19 = 7;
    #[c2rust::src_loc = "45:5"]
    pub const PIXEL_4x4: C2RustUnnamed_19 = 6;
    #[c2rust::src_loc = "44:5"]
    pub const PIXEL_4x8: C2RustUnnamed_19 = 5;
    #[c2rust::src_loc = "43:5"]
    pub const PIXEL_8x4: C2RustUnnamed_19 = 4;
    #[c2rust::src_loc = "42:5"]
    pub const PIXEL_8x8: C2RustUnnamed_19 = 3;
    #[c2rust::src_loc = "41:5"]
    pub const PIXEL_8x16: C2RustUnnamed_19 = 2;
    #[c2rust::src_loc = "40:5"]
    pub const PIXEL_16x8: C2RustUnnamed_19 = 1;
    #[c2rust::src_loc = "39:5"]
    pub const PIXEL_16x16: C2RustUnnamed_19 = 0;
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "55:14"]
    pub struct C2RustUnnamed_20 {
        pub w: uint8_t,
        pub h: uint8_t,
    }
    #[c2rust::src_loc = "55:39"]
    pub static mut x264_pixel_size: [C2RustUnnamed_20; 12] = [
        {
            let mut init = C2RustUnnamed_20 {
                w: 16 as uint8_t,
                h: 16 as uint8_t,
            };
            init
        },
        {
            let mut init = C2RustUnnamed_20 {
                w: 16 as uint8_t,
                h: 8 as uint8_t,
            };
            init
        },
        {
            let mut init = C2RustUnnamed_20 {
                w: 8 as uint8_t,
                h: 16 as uint8_t,
            };
            init
        },
        {
            let mut init = C2RustUnnamed_20 {
                w: 8 as uint8_t,
                h: 8 as uint8_t,
            };
            init
        },
        {
            let mut init = C2RustUnnamed_20 {
                w: 8 as uint8_t,
                h: 4 as uint8_t,
            };
            init
        },
        {
            let mut init = C2RustUnnamed_20 {
                w: 4 as uint8_t,
                h: 8 as uint8_t,
            };
            init
        },
        {
            let mut init = C2RustUnnamed_20 {
                w: 4 as uint8_t,
                h: 4 as uint8_t,
            };
            init
        },
        {
            let mut init = C2RustUnnamed_20 {
                w: 4 as uint8_t,
                h: 16 as uint8_t,
            };
            init
        },
        {
            let mut init = C2RustUnnamed_20 {
                w: 4 as uint8_t,
                h: 2 as uint8_t,
            };
            init
        },
        {
            let mut init = C2RustUnnamed_20 {
                w: 2 as uint8_t,
                h: 8 as uint8_t,
            };
            init
        },
        {
            let mut init = C2RustUnnamed_20 {
                w: 2 as uint8_t,
                h: 4 as uint8_t,
            };
            init
        },
        {
            let mut init = C2RustUnnamed_20 {
                w: 2 as uint8_t,
                h: 2 as uint8_t,
            };
            init
        },
    ];
    use super::common_h::pixel;
    use super::stdint_h::intptr_t;
    use super::stdint_intn_h::int16_t;
    use super::stdint_uintn_h::{uint16_t, uint64_t, uint8_t};
}
#[c2rust::header_src = "/home/nwplayer123/Hacks/hex264/x264/common/predict.h:28"]
pub mod predict_h {
    #[c2rust::src_loc = "32:1"]
    pub type x264_predict_8x8_filter_t = Option<
        unsafe extern "C" fn(*mut pixel, *mut pixel, ::core::ffi::c_int, ::core::ffi::c_int) -> (),
    >;
    #[c2rust::src_loc = "30:1"]
    pub type x264_predict_t = Option<unsafe extern "C" fn(*mut pixel) -> ()>;
    #[c2rust::src_loc = "31:1"]
    pub type x264_predict8x8_t = Option<unsafe extern "C" fn(*mut pixel, *mut pixel) -> ()>;
    #[c2rust::src_loc = "34:1"]
    pub type intra_chroma_pred_e = ::core::ffi::c_uint;
    #[c2rust::src_loc = "43:5"]
    pub const I_PRED_CHROMA_DC_128: intra_chroma_pred_e = 6;
    #[c2rust::src_loc = "42:5"]
    pub const I_PRED_CHROMA_DC_TOP: intra_chroma_pred_e = 5;
    #[c2rust::src_loc = "41:5"]
    pub const I_PRED_CHROMA_DC_LEFT: intra_chroma_pred_e = 4;
    #[c2rust::src_loc = "39:5"]
    pub const I_PRED_CHROMA_P: intra_chroma_pred_e = 3;
    #[c2rust::src_loc = "38:5"]
    pub const I_PRED_CHROMA_V: intra_chroma_pred_e = 2;
    #[c2rust::src_loc = "37:5"]
    pub const I_PRED_CHROMA_H: intra_chroma_pred_e = 1;
    #[c2rust::src_loc = "36:5"]
    pub const I_PRED_CHROMA_DC: intra_chroma_pred_e = 0;
    #[c2rust::src_loc = "51:1"]
    pub type intra16x16_pred_e = ::core::ffi::c_uint;
    #[c2rust::src_loc = "60:5"]
    pub const I_PRED_16x16_DC_128: intra16x16_pred_e = 6;
    #[c2rust::src_loc = "59:5"]
    pub const I_PRED_16x16_DC_TOP: intra16x16_pred_e = 5;
    #[c2rust::src_loc = "58:5"]
    pub const I_PRED_16x16_DC_LEFT: intra16x16_pred_e = 4;
    #[c2rust::src_loc = "56:5"]
    pub const I_PRED_16x16_P: intra16x16_pred_e = 3;
    #[c2rust::src_loc = "55:5"]
    pub const I_PRED_16x16_DC: intra16x16_pred_e = 2;
    #[c2rust::src_loc = "54:5"]
    pub const I_PRED_16x16_H: intra16x16_pred_e = 1;
    #[c2rust::src_loc = "53:5"]
    pub const I_PRED_16x16_V: intra16x16_pred_e = 0;
    #[c2rust::src_loc = "68:1"]
    pub type intra4x4_pred_e = ::core::ffi::c_uint;
    #[c2rust::src_loc = "82:5"]
    pub const I_PRED_4x4_DC_128: intra4x4_pred_e = 11;
    #[c2rust::src_loc = "81:5"]
    pub const I_PRED_4x4_DC_TOP: intra4x4_pred_e = 10;
    #[c2rust::src_loc = "80:5"]
    pub const I_PRED_4x4_DC_LEFT: intra4x4_pred_e = 9;
    #[c2rust::src_loc = "78:5"]
    pub const I_PRED_4x4_HU: intra4x4_pred_e = 8;
    #[c2rust::src_loc = "77:5"]
    pub const I_PRED_4x4_VL: intra4x4_pred_e = 7;
    #[c2rust::src_loc = "76:5"]
    pub const I_PRED_4x4_HD: intra4x4_pred_e = 6;
    #[c2rust::src_loc = "75:5"]
    pub const I_PRED_4x4_VR: intra4x4_pred_e = 5;
    #[c2rust::src_loc = "74:5"]
    pub const I_PRED_4x4_DDR: intra4x4_pred_e = 4;
    #[c2rust::src_loc = "73:5"]
    pub const I_PRED_4x4_DDL: intra4x4_pred_e = 3;
    #[c2rust::src_loc = "72:5"]
    pub const I_PRED_4x4_DC: intra4x4_pred_e = 2;
    #[c2rust::src_loc = "71:5"]
    pub const I_PRED_4x4_H: intra4x4_pred_e = 1;
    #[c2rust::src_loc = "70:5"]
    pub const I_PRED_4x4_V: intra4x4_pred_e = 0;
    #[c2rust::src_loc = "45:22"]
    pub static mut x264_mb_chroma_pred_mode_fix: [uint8_t; 7] = [
        I_PRED_CHROMA_DC as ::core::ffi::c_int as uint8_t,
        I_PRED_CHROMA_H as ::core::ffi::c_int as uint8_t,
        I_PRED_CHROMA_V as ::core::ffi::c_int as uint8_t,
        I_PRED_CHROMA_P as ::core::ffi::c_int as uint8_t,
        I_PRED_CHROMA_DC as ::core::ffi::c_int as uint8_t,
        I_PRED_CHROMA_DC as ::core::ffi::c_int as uint8_t,
        I_PRED_CHROMA_DC as ::core::ffi::c_int as uint8_t,
    ];
    #[c2rust::src_loc = "62:22"]
    pub static mut x264_mb_pred_mode16x16_fix: [uint8_t; 7] = [
        I_PRED_16x16_V as ::core::ffi::c_int as uint8_t,
        I_PRED_16x16_H as ::core::ffi::c_int as uint8_t,
        I_PRED_16x16_DC as ::core::ffi::c_int as uint8_t,
        I_PRED_16x16_P as ::core::ffi::c_int as uint8_t,
        I_PRED_16x16_DC as ::core::ffi::c_int as uint8_t,
        I_PRED_16x16_DC as ::core::ffi::c_int as uint8_t,
        I_PRED_16x16_DC as ::core::ffi::c_int as uint8_t,
    ];
    #[c2rust::src_loc = "84:21"]
    pub static mut x264_mb_pred_mode4x4_fix: [int8_t; 13] = [
        -(1 as ::core::ffi::c_int) as int8_t,
        I_PRED_4x4_V as ::core::ffi::c_int as int8_t,
        I_PRED_4x4_H as ::core::ffi::c_int as int8_t,
        I_PRED_4x4_DC as ::core::ffi::c_int as int8_t,
        I_PRED_4x4_DDL as ::core::ffi::c_int as int8_t,
        I_PRED_4x4_DDR as ::core::ffi::c_int as int8_t,
        I_PRED_4x4_VR as ::core::ffi::c_int as int8_t,
        I_PRED_4x4_HD as ::core::ffi::c_int as int8_t,
        I_PRED_4x4_VL as ::core::ffi::c_int as int8_t,
        I_PRED_4x4_HU as ::core::ffi::c_int as int8_t,
        I_PRED_4x4_DC as ::core::ffi::c_int as int8_t,
        I_PRED_4x4_DC as ::core::ffi::c_int as int8_t,
        I_PRED_4x4_DC as ::core::ffi::c_int as int8_t,
    ];
    use super::common_h::pixel;
    use super::stdint_intn_h::int8_t;
    use super::stdint_uintn_h::uint8_t;
}
#[c2rust::header_src = "/home/nwplayer123/Hacks/hex264/x264/common/set.h:28"]
pub mod set_h {
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "150:9"]
    pub struct x264_pps_t {
        pub i_id: ::core::ffi::c_int,
        pub i_sps_id: ::core::ffi::c_int,
        pub b_cabac: ::core::ffi::c_int,
        pub b_pic_order: ::core::ffi::c_int,
        pub i_num_slice_groups: ::core::ffi::c_int,
        pub i_num_ref_idx_l0_default_active: ::core::ffi::c_int,
        pub i_num_ref_idx_l1_default_active: ::core::ffi::c_int,
        pub b_weighted_pred: ::core::ffi::c_int,
        pub b_weighted_bipred: ::core::ffi::c_int,
        pub i_pic_init_qp: ::core::ffi::c_int,
        pub i_pic_init_qs: ::core::ffi::c_int,
        pub i_chroma_qp_index_offset: ::core::ffi::c_int,
        pub b_deblocking_filter_control: ::core::ffi::c_int,
        pub b_constrained_intra_pred: ::core::ffi::c_int,
        pub b_redundant_pic_cnt: ::core::ffi::c_int,
        pub b_transform_8x8_mode: ::core::ffi::c_int,
    }
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "45:9"]
    pub struct x264_sps_t {
        pub i_id: ::core::ffi::c_int,
        pub i_profile_idc: ::core::ffi::c_int,
        pub i_level_idc: ::core::ffi::c_int,
        pub b_constraint_set0: ::core::ffi::c_int,
        pub b_constraint_set1: ::core::ffi::c_int,
        pub b_constraint_set2: ::core::ffi::c_int,
        pub b_constraint_set3: ::core::ffi::c_int,
        pub i_log2_max_frame_num: ::core::ffi::c_int,
        pub i_poc_type: ::core::ffi::c_int,
        pub i_log2_max_poc_lsb: ::core::ffi::c_int,
        pub i_num_ref_frames: ::core::ffi::c_int,
        pub b_gaps_in_frame_num_value_allowed: ::core::ffi::c_int,
        pub i_mb_width: ::core::ffi::c_int,
        pub i_mb_height: ::core::ffi::c_int,
        pub b_frame_mbs_only: ::core::ffi::c_int,
        pub b_mb_adaptive_frame_field: ::core::ffi::c_int,
        pub b_direct8x8_inference: ::core::ffi::c_int,
        pub b_crop: ::core::ffi::c_int,
        pub crop: C2RustUnnamed_16,
        pub b_vui: ::core::ffi::c_int,
        pub vui: C2RustUnnamed_14,
        pub b_qpprime_y_zero_transform_bypass: ::core::ffi::c_int,
        pub i_chroma_format_idc: ::core::ffi::c_int,
        pub b_avcintra_hd: ::core::ffi::c_int,
        pub b_avcintra_4k: ::core::ffi::c_int,
        pub i_cqm_preset: ::core::ffi::c_int,
        pub scaling_list: [*const uint8_t; 8],
    }
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "81:5"]
    pub struct C2RustUnnamed_14 {
        pub b_aspect_ratio_info_present: ::core::ffi::c_int,
        pub i_sar_width: ::core::ffi::c_int,
        pub i_sar_height: ::core::ffi::c_int,
        pub b_overscan_info_present: ::core::ffi::c_int,
        pub b_overscan_info: ::core::ffi::c_int,
        pub b_signal_type_present: ::core::ffi::c_int,
        pub i_vidformat: ::core::ffi::c_int,
        pub b_fullrange: ::core::ffi::c_int,
        pub b_color_description_present: ::core::ffi::c_int,
        pub i_colorprim: ::core::ffi::c_int,
        pub i_transfer: ::core::ffi::c_int,
        pub i_colmatrix: ::core::ffi::c_int,
        pub b_chroma_loc_info_present: ::core::ffi::c_int,
        pub i_chroma_loc_top: ::core::ffi::c_int,
        pub i_chroma_loc_bottom: ::core::ffi::c_int,
        pub b_timing_info_present: ::core::ffi::c_int,
        pub i_num_units_in_tick: uint32_t,
        pub i_time_scale: uint32_t,
        pub b_fixed_frame_rate: ::core::ffi::c_int,
        pub b_nal_hrd_parameters_present: ::core::ffi::c_int,
        pub b_vcl_hrd_parameters_present: ::core::ffi::c_int,
        pub hrd: C2RustUnnamed_15,
        pub b_pic_struct_present: ::core::ffi::c_int,
        pub b_bitstream_restriction: ::core::ffi::c_int,
        pub b_motion_vectors_over_pic_boundaries: ::core::ffi::c_int,
        pub i_max_bytes_per_pic_denom: ::core::ffi::c_int,
        pub i_max_bits_per_mb_denom: ::core::ffi::c_int,
        pub i_log2_max_mv_length_horizontal: ::core::ffi::c_int,
        pub i_log2_max_mv_length_vertical: ::core::ffi::c_int,
        pub i_num_reorder_frames: ::core::ffi::c_int,
        pub i_max_dec_frame_buffering: ::core::ffi::c_int,
    }
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "110:9"]
    pub struct C2RustUnnamed_15 {
        pub i_cpb_cnt: ::core::ffi::c_int,
        pub i_bit_rate_scale: ::core::ffi::c_int,
        pub i_cpb_size_scale: ::core::ffi::c_int,
        pub i_bit_rate_value: ::core::ffi::c_int,
        pub i_cpb_size_value: ::core::ffi::c_int,
        pub i_bit_rate_unscaled: ::core::ffi::c_int,
        pub i_cpb_size_unscaled: ::core::ffi::c_int,
        pub b_cbr_hrd: ::core::ffi::c_int,
        pub i_initial_cpb_removal_delay_length: ::core::ffi::c_int,
        pub i_cpb_removal_delay_length: ::core::ffi::c_int,
        pub i_dpb_output_delay_length: ::core::ffi::c_int,
        pub i_time_offset_length: ::core::ffi::c_int,
    }
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "72:5"]
    pub struct C2RustUnnamed_16 {
        pub i_left: ::core::ffi::c_int,
        pub i_right: ::core::ffi::c_int,
        pub i_top: ::core::ffi::c_int,
        pub i_bottom: ::core::ffi::c_int,
    }
    #[c2rust::src_loc = "30:1"]
    pub type cqm4_e = ::core::ffi::c_uint;
    #[c2rust::src_loc = "35:5"]
    pub const CQM_4PC: cqm4_e = 3;
    #[c2rust::src_loc = "34:5"]
    pub const CQM_4IC: cqm4_e = 2;
    #[c2rust::src_loc = "33:5"]
    pub const CQM_4PY: cqm4_e = 1;
    #[c2rust::src_loc = "32:5"]
    pub const CQM_4IY: cqm4_e = 0;
    #[c2rust::src_loc = "37:1"]
    pub type cqm8_e = ::core::ffi::c_uint;
    #[c2rust::src_loc = "42:5"]
    pub const CQM_8PC: cqm8_e = 3;
    #[c2rust::src_loc = "41:5"]
    pub const CQM_8IC: cqm8_e = 2;
    #[c2rust::src_loc = "40:5"]
    pub const CQM_8PY: cqm8_e = 1;
    #[c2rust::src_loc = "39:5"]
    pub const CQM_8IY: cqm8_e = 0;
    use super::stdint_uintn_h::{uint32_t, uint8_t};
}
#[c2rust::header_src = "/home/nwplayer123/Hacks/hex264/x264/common/threadpool.h:28"]
pub mod threadpool_h {
    extern "C" {
        #[c2rust::src_loc = "29:16"]
        pub type x264_threadpool_t;
        #[c2rust::src_loc = "35:10"]
        pub fn x264_10_threadpool_run(
            pool: *mut x264_threadpool_t,
            func: Option<
                unsafe extern "C" fn(*mut ::core::ffi::c_void) -> *mut ::core::ffi::c_void,
            >,
            arg: *mut ::core::ffi::c_void,
        );
        #[c2rust::src_loc = "37:10"]
        pub fn x264_10_threadpool_wait(
            pool: *mut x264_threadpool_t,
            arg: *mut ::core::ffi::c_void,
        ) -> *mut ::core::ffi::c_void;
    }
}
#[c2rust::header_src = "/home/nwplayer123/Hacks/hex264/x264/common/base.h:28"]
pub mod base_h {
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "64:9"]
    pub union x264_union16_t {
        pub i: uint16_t,
        pub b: [uint8_t; 2],
    }
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "65:9"]
    pub union x264_union32_t {
        pub i: uint32_t,
        pub w: [uint16_t; 2],
        pub b: [uint8_t; 4],
    }
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "66:9"]
    pub union x264_union64_t {
        pub i: uint64_t,
        pub d: [uint32_t; 2],
        pub w: [uint16_t; 4],
        pub b: [uint8_t; 8],
    }
    #[c2rust::src_loc = "93:1"]
    pub type profile_e = ::core::ffi::c_uint;
    #[c2rust::src_loc = "100:5"]
    pub const PROFILE_HIGH444_PREDICTIVE: profile_e = 244;
    #[c2rust::src_loc = "99:5"]
    pub const PROFILE_HIGH422: profile_e = 122;
    #[c2rust::src_loc = "98:5"]
    pub const PROFILE_HIGH10: profile_e = 110;
    #[c2rust::src_loc = "97:5"]
    pub const PROFILE_HIGH: profile_e = 100;
    #[c2rust::src_loc = "96:5"]
    pub const PROFILE_MAIN: profile_e = 77;
    #[c2rust::src_loc = "95:5"]
    pub const PROFILE_BASELINE: profile_e = 66;
    #[c2rust::src_loc = "103:1"]
    pub type chroma_format_e = ::core::ffi::c_uint;
    #[c2rust::src_loc = "108:5"]
    pub const CHROMA_444: chroma_format_e = 3;
    #[c2rust::src_loc = "107:5"]
    pub const CHROMA_422: chroma_format_e = 2;
    #[c2rust::src_loc = "106:5"]
    pub const CHROMA_420: chroma_format_e = 1;
    #[c2rust::src_loc = "105:5"]
    pub const CHROMA_400: chroma_format_e = 0;
    #[c2rust::src_loc = "111:1"]
    pub type slice_type_e = ::core::ffi::c_uint;
    #[c2rust::src_loc = "115:5"]
    pub const SLICE_TYPE_I: slice_type_e = 2;
    #[c2rust::src_loc = "114:5"]
    pub const SLICE_TYPE_B: slice_type_e = 1;
    #[c2rust::src_loc = "113:5"]
    pub const SLICE_TYPE_P: slice_type_e = 0;
    #[c2rust::src_loc = "136:9"]
    pub const X264_BFRAME_MAX: ::core::ffi::c_int = 16 as ::core::ffi::c_int;
    #[c2rust::src_loc = "151:9"]
    pub const X264_WEIGHTP_FAKE: ::core::ffi::c_int = -(1 as ::core::ffi::c_int);
    #[c2rust::src_loc = "155:9"]
    pub const X264_SCAN8_0: ::core::ffi::c_int =
        4 as ::core::ffi::c_int + 1 as ::core::ffi::c_int * 8 as ::core::ffi::c_int;
    #[c2rust::src_loc = "177:9"]
    pub const LUMA_DC: ::core::ffi::c_int = 48 as ::core::ffi::c_int;
    #[c2rust::src_loc = "178:9"]
    pub const CHROMA_DC: ::core::ffi::c_int = 49 as ::core::ffi::c_int;
    #[c2rust::src_loc = "180:22"]
    pub static mut x264_scan8: [uint8_t; 51] = [
        (4 as ::core::ffi::c_int + 1 as ::core::ffi::c_int * 8 as ::core::ffi::c_int) as uint8_t,
        (5 as ::core::ffi::c_int + 1 as ::core::ffi::c_int * 8 as ::core::ffi::c_int) as uint8_t,
        (4 as ::core::ffi::c_int + 2 as ::core::ffi::c_int * 8 as ::core::ffi::c_int) as uint8_t,
        (5 as ::core::ffi::c_int + 2 as ::core::ffi::c_int * 8 as ::core::ffi::c_int) as uint8_t,
        (6 as ::core::ffi::c_int + 1 as ::core::ffi::c_int * 8 as ::core::ffi::c_int) as uint8_t,
        (7 as ::core::ffi::c_int + 1 as ::core::ffi::c_int * 8 as ::core::ffi::c_int) as uint8_t,
        (6 as ::core::ffi::c_int + 2 as ::core::ffi::c_int * 8 as ::core::ffi::c_int) as uint8_t,
        (7 as ::core::ffi::c_int + 2 as ::core::ffi::c_int * 8 as ::core::ffi::c_int) as uint8_t,
        (4 as ::core::ffi::c_int + 3 as ::core::ffi::c_int * 8 as ::core::ffi::c_int) as uint8_t,
        (5 as ::core::ffi::c_int + 3 as ::core::ffi::c_int * 8 as ::core::ffi::c_int) as uint8_t,
        (4 as ::core::ffi::c_int + 4 as ::core::ffi::c_int * 8 as ::core::ffi::c_int) as uint8_t,
        (5 as ::core::ffi::c_int + 4 as ::core::ffi::c_int * 8 as ::core::ffi::c_int) as uint8_t,
        (6 as ::core::ffi::c_int + 3 as ::core::ffi::c_int * 8 as ::core::ffi::c_int) as uint8_t,
        (7 as ::core::ffi::c_int + 3 as ::core::ffi::c_int * 8 as ::core::ffi::c_int) as uint8_t,
        (6 as ::core::ffi::c_int + 4 as ::core::ffi::c_int * 8 as ::core::ffi::c_int) as uint8_t,
        (7 as ::core::ffi::c_int + 4 as ::core::ffi::c_int * 8 as ::core::ffi::c_int) as uint8_t,
        (4 as ::core::ffi::c_int + 6 as ::core::ffi::c_int * 8 as ::core::ffi::c_int) as uint8_t,
        (5 as ::core::ffi::c_int + 6 as ::core::ffi::c_int * 8 as ::core::ffi::c_int) as uint8_t,
        (4 as ::core::ffi::c_int + 7 as ::core::ffi::c_int * 8 as ::core::ffi::c_int) as uint8_t,
        (5 as ::core::ffi::c_int + 7 as ::core::ffi::c_int * 8 as ::core::ffi::c_int) as uint8_t,
        (6 as ::core::ffi::c_int + 6 as ::core::ffi::c_int * 8 as ::core::ffi::c_int) as uint8_t,
        (7 as ::core::ffi::c_int + 6 as ::core::ffi::c_int * 8 as ::core::ffi::c_int) as uint8_t,
        (6 as ::core::ffi::c_int + 7 as ::core::ffi::c_int * 8 as ::core::ffi::c_int) as uint8_t,
        (7 as ::core::ffi::c_int + 7 as ::core::ffi::c_int * 8 as ::core::ffi::c_int) as uint8_t,
        (4 as ::core::ffi::c_int + 8 as ::core::ffi::c_int * 8 as ::core::ffi::c_int) as uint8_t,
        (5 as ::core::ffi::c_int + 8 as ::core::ffi::c_int * 8 as ::core::ffi::c_int) as uint8_t,
        (4 as ::core::ffi::c_int + 9 as ::core::ffi::c_int * 8 as ::core::ffi::c_int) as uint8_t,
        (5 as ::core::ffi::c_int + 9 as ::core::ffi::c_int * 8 as ::core::ffi::c_int) as uint8_t,
        (6 as ::core::ffi::c_int + 8 as ::core::ffi::c_int * 8 as ::core::ffi::c_int) as uint8_t,
        (7 as ::core::ffi::c_int + 8 as ::core::ffi::c_int * 8 as ::core::ffi::c_int) as uint8_t,
        (6 as ::core::ffi::c_int + 9 as ::core::ffi::c_int * 8 as ::core::ffi::c_int) as uint8_t,
        (7 as ::core::ffi::c_int + 9 as ::core::ffi::c_int * 8 as ::core::ffi::c_int) as uint8_t,
        (4 as ::core::ffi::c_int + 11 as ::core::ffi::c_int * 8 as ::core::ffi::c_int) as uint8_t,
        (5 as ::core::ffi::c_int + 11 as ::core::ffi::c_int * 8 as ::core::ffi::c_int) as uint8_t,
        (4 as ::core::ffi::c_int + 12 as ::core::ffi::c_int * 8 as ::core::ffi::c_int) as uint8_t,
        (5 as ::core::ffi::c_int + 12 as ::core::ffi::c_int * 8 as ::core::ffi::c_int) as uint8_t,
        (6 as ::core::ffi::c_int + 11 as ::core::ffi::c_int * 8 as ::core::ffi::c_int) as uint8_t,
        (7 as ::core::ffi::c_int + 11 as ::core::ffi::c_int * 8 as ::core::ffi::c_int) as uint8_t,
        (6 as ::core::ffi::c_int + 12 as ::core::ffi::c_int * 8 as ::core::ffi::c_int) as uint8_t,
        (7 as ::core::ffi::c_int + 12 as ::core::ffi::c_int * 8 as ::core::ffi::c_int) as uint8_t,
        (4 as ::core::ffi::c_int + 13 as ::core::ffi::c_int * 8 as ::core::ffi::c_int) as uint8_t,
        (5 as ::core::ffi::c_int + 13 as ::core::ffi::c_int * 8 as ::core::ffi::c_int) as uint8_t,
        (4 as ::core::ffi::c_int + 14 as ::core::ffi::c_int * 8 as ::core::ffi::c_int) as uint8_t,
        (5 as ::core::ffi::c_int + 14 as ::core::ffi::c_int * 8 as ::core::ffi::c_int) as uint8_t,
        (6 as ::core::ffi::c_int + 13 as ::core::ffi::c_int * 8 as ::core::ffi::c_int) as uint8_t,
        (7 as ::core::ffi::c_int + 13 as ::core::ffi::c_int * 8 as ::core::ffi::c_int) as uint8_t,
        (6 as ::core::ffi::c_int + 14 as ::core::ffi::c_int * 8 as ::core::ffi::c_int) as uint8_t,
        (7 as ::core::ffi::c_int + 14 as ::core::ffi::c_int * 8 as ::core::ffi::c_int) as uint8_t,
        (0 as ::core::ffi::c_int + 0 as ::core::ffi::c_int * 8 as ::core::ffi::c_int) as uint8_t,
        (0 as ::core::ffi::c_int + 5 as ::core::ffi::c_int * 8 as ::core::ffi::c_int) as uint8_t,
        (0 as ::core::ffi::c_int + 10 as ::core::ffi::c_int * 8 as ::core::ffi::c_int) as uint8_t,
    ];
    #[inline(always)]
    #[c2rust::src_loc = "206:1"]
    pub unsafe extern "C" fn x264_clip3(
        mut v: ::core::ffi::c_int,
        mut i_min: ::core::ffi::c_int,
        mut i_max: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int {
        return if v < i_min {
            i_min
        } else if v > i_max {
            i_max
        } else {
            v
        };
    }
    #[inline(always)]
    #[c2rust::src_loc = "211:1"]
    pub unsafe extern "C" fn x264_clip3f(
        mut v: ::core::ffi::c_double,
        mut f_min: ::core::ffi::c_double,
        mut f_max: ::core::ffi::c_double,
    ) -> ::core::ffi::c_double {
        return if v < f_min {
            f_min
        } else if v > f_max {
            f_max
        } else {
            v
        };
    }
    #[inline(always)]
    #[c2rust::src_loc = "218:1"]
    pub unsafe extern "C" fn x264_exp2fix8(mut x: ::core::ffi::c_float) -> ::core::ffi::c_int {
        let mut i: ::core::ffi::c_int = (x * (-64.0f32 / 6.0f32) + 512.5f32) as ::core::ffi::c_int;
        if i < 0 as ::core::ffi::c_int {
            return 0 as ::core::ffi::c_int;
        }
        if i > 1023 as ::core::ffi::c_int {
            return 0xffff as ::core::ffi::c_int;
        }
        return (x264_exp2_lut[(i & 63 as ::core::ffi::c_int) as usize] as ::core::ffi::c_int
            + 256 as ::core::ffi::c_int)
            << (i >> 6 as ::core::ffi::c_int)
            >> 8 as ::core::ffi::c_int;
    }
    #[inline(always)]
    #[c2rust::src_loc = "226:1"]
    pub unsafe extern "C" fn x264_log2(mut x: uint32_t) -> ::core::ffi::c_float {
        let mut lz: ::core::ffi::c_int = x.leading_zeros() as i32;
        return x264_log2_lut[(x << lz >> 24 as ::core::ffi::c_int & 0x7f as uint32_t) as usize]
            + x264_log2_lz_lut[lz as usize];
    }
    #[inline(always)]
    #[c2rust::src_loc = "232:1"]
    pub unsafe extern "C" fn x264_median(
        mut a: ::core::ffi::c_int,
        mut b: ::core::ffi::c_int,
        mut c: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int {
        let mut t: ::core::ffi::c_int = a - b & a - b >> 31 as ::core::ffi::c_int;
        a -= t;
        b += t;
        b -= b - c & b - c >> 31 as ::core::ffi::c_int;
        b += a - b & a - b >> 31 as ::core::ffi::c_int;
        return b;
    }
    #[inline(always)]
    #[c2rust::src_loc = "242:1"]
    pub unsafe extern "C" fn x264_median_mv(
        mut dst: *mut int16_t,
        mut a: *mut int16_t,
        mut b: *mut int16_t,
        mut c: *mut int16_t,
    ) {
        *dst.offset(0 as ::core::ffi::c_int as isize) = x264_median(
            *a.offset(0 as ::core::ffi::c_int as isize) as ::core::ffi::c_int,
            *b.offset(0 as ::core::ffi::c_int as isize) as ::core::ffi::c_int,
            *c.offset(0 as ::core::ffi::c_int as isize) as ::core::ffi::c_int,
        ) as int16_t;
        *dst.offset(1 as ::core::ffi::c_int as isize) = x264_median(
            *a.offset(1 as ::core::ffi::c_int as isize) as ::core::ffi::c_int,
            *b.offset(1 as ::core::ffi::c_int as isize) as ::core::ffi::c_int,
            *c.offset(1 as ::core::ffi::c_int as isize) as ::core::ffi::c_int,
        ) as int16_t;
    }
    #[inline(always)]
    #[c2rust::src_loc = "259:1"]
    pub unsafe extern "C" fn x264_cabac_mvd_sum(
        mut mvdleft: *mut uint8_t,
        mut mvdtop: *mut uint8_t,
    ) -> uint16_t {
        let mut amvd0: ::core::ffi::c_int = *mvdleft.offset(0 as ::core::ffi::c_int as isize)
            as ::core::ffi::c_int
            + *mvdtop.offset(0 as ::core::ffi::c_int as isize) as ::core::ffi::c_int;
        let mut amvd1: ::core::ffi::c_int = *mvdleft.offset(1 as ::core::ffi::c_int as isize)
            as ::core::ffi::c_int
            + *mvdtop.offset(1 as ::core::ffi::c_int as isize) as ::core::ffi::c_int;
        amvd0 = (amvd0 > 2 as ::core::ffi::c_int) as ::core::ffi::c_int
            + (amvd0 > 32 as ::core::ffi::c_int) as ::core::ffi::c_int;
        amvd1 = (amvd1 > 2 as ::core::ffi::c_int) as ::core::ffi::c_int
            + (amvd1 > 32 as ::core::ffi::c_int) as ::core::ffi::c_int;
        return (amvd0 + (amvd1 << 8 as ::core::ffi::c_int)) as uint16_t;
    }
    use super::stdint_intn_h::{int16_t, int64_t};
    use super::stdint_uintn_h::{uint16_t, uint32_t, uint64_t, uint8_t};
    use super::tables_h::{x264_exp2_lut, x264_log2_lut, x264_log2_lz_lut};
    extern "C" {
        #[c2rust::src_loc = "279:10"]
        pub fn x264_malloc(_: int64_t) -> *mut ::core::ffi::c_void;
        #[c2rust::src_loc = "280:10"]
        pub fn x264_free(_: *mut ::core::ffi::c_void);
    }
}
#[c2rust::header_src = "/home/nwplayer123/Hacks/hex264/x264/common/tables.h:28"]
pub mod tables_h {
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "30:9"]
    pub struct vlc_t {
        pub i_bits: uint8_t,
        pub i_size: uint8_t,
    }
    use super::stdint_uintn_h::{uint16_t, uint32_t, uint8_t};
    extern "C" {
        #[c2rust::src_loc = "38:22"]
        pub static x264_exp2_lut: [uint8_t; 64];
        #[c2rust::src_loc = "39:22"]
        pub static x264_log2_lut: [::core::ffi::c_float; 128];
        #[c2rust::src_loc = "40:22"]
        pub static x264_log2_lz_lut: [::core::ffi::c_float; 32];
        #[c2rust::src_loc = "43:23"]
        pub static x264_lambda_tab: [uint16_t; 82];
        #[c2rust::src_loc = "44:23"]
        pub static x264_lambda2_tab: [::core::ffi::c_int; 82];
        #[c2rust::src_loc = "45:23"]
        pub static x264_trellis_lambda2_tab: [[::core::ffi::c_int; 82]; 2];
        #[c2rust::src_loc = "47:23"]
        pub static x264_chroma_lambda2_offset_tab: [uint16_t; 37];
        #[c2rust::src_loc = "73:23"]
        pub static x264_dct4_weight_tab: [uint32_t; 16];
        #[c2rust::src_loc = "74:23"]
        pub static x264_dct8_weight_tab: [uint32_t; 64];
        #[c2rust::src_loc = "75:23"]
        pub static x264_dct4_weight2_tab: [uint32_t; 16];
        #[c2rust::src_loc = "76:23"]
        pub static x264_dct8_weight2_tab: [uint32_t; 64];
        #[c2rust::src_loc = "81:23"]
        pub static x264_cabac_transition: [[uint8_t; 2]; 128];
        #[c2rust::src_loc = "83:23"]
        pub static x264_cabac_entropy: [uint16_t; 128];
        #[c2rust::src_loc = "85:23"]
        pub static x264_significant_coeff_flag_offset_8x8: [[uint8_t; 64]; 2];
        #[c2rust::src_loc = "86:23"]
        pub static x264_last_coeff_flag_offset_8x8: [uint8_t; 63];
        #[c2rust::src_loc = "87:23"]
        pub static x264_coeff_flag_offset_chroma_422_dc: [uint8_t; 7];
        #[c2rust::src_loc = "88:23"]
        pub static x264_significant_coeff_flag_offset: [[uint16_t; 16]; 2];
        #[c2rust::src_loc = "89:23"]
        pub static x264_last_coeff_flag_offset: [[uint16_t; 16]; 2];
        #[c2rust::src_loc = "90:23"]
        pub static x264_coeff_abs_level_m1_offset: [uint16_t; 16];
        #[c2rust::src_loc = "91:23"]
        pub static x264_count_cat_m1: [uint8_t; 14];
        #[c2rust::src_loc = "93:20"]
        pub static x264_coeff0_token: [vlc_t; 6];
        #[c2rust::src_loc = "94:20"]
        pub static x264_coeff_token: [[[vlc_t; 4]; 16]; 6];
        #[c2rust::src_loc = "95:20"]
        pub static x264_total_zeros: [[vlc_t; 16]; 15];
        #[c2rust::src_loc = "96:20"]
        pub static x264_total_zeros_2x2_dc: [[vlc_t; 4]; 3];
        #[c2rust::src_loc = "97:20"]
        pub static x264_total_zeros_2x4_dc: [[vlc_t; 8]; 7];
        #[c2rust::src_loc = "100:16"]
        pub static mut x264_zero: [uint8_t; 1024];
    }
}
#[c2rust::header_src = "/home/nwplayer123/Hacks/hex264/x264/common/macroblock.h:28"]
pub mod macroblock_h {
    #[c2rust::src_loc = "31:1"]
    pub type macroblock_position_e = ::core::ffi::c_uint;
    #[c2rust::src_loc = "40:5"]
    pub const ALL_NEIGHBORS: macroblock_position_e = 15;
    #[c2rust::src_loc = "38:5"]
    pub const MB_PRIVATE: macroblock_position_e = 16;
    #[c2rust::src_loc = "36:5"]
    pub const MB_TOPLEFT: macroblock_position_e = 8;
    #[c2rust::src_loc = "35:5"]
    pub const MB_TOPRIGHT: macroblock_position_e = 4;
    #[c2rust::src_loc = "34:5"]
    pub const MB_TOP: macroblock_position_e = 2;
    #[c2rust::src_loc = "33:5"]
    pub const MB_LEFT: macroblock_position_e = 1;
    #[c2rust::src_loc = "64:1"]
    pub type mb_class_e = ::core::ffi::c_uint;
    #[c2rust::src_loc = "88:5"]
    pub const X264_MBTYPE_MAX: mb_class_e = 19;
    #[c2rust::src_loc = "86:5"]
    pub const B_SKIP: mb_class_e = 18;
    #[c2rust::src_loc = "85:5"]
    pub const B_8x8: mb_class_e = 17;
    #[c2rust::src_loc = "84:5"]
    pub const B_BI_BI: mb_class_e = 16;
    #[c2rust::src_loc = "83:5"]
    pub const B_BI_L1: mb_class_e = 15;
    #[c2rust::src_loc = "82:5"]
    pub const B_BI_L0: mb_class_e = 14;
    #[c2rust::src_loc = "81:5"]
    pub const B_L1_BI: mb_class_e = 13;
    #[c2rust::src_loc = "80:5"]
    pub const B_L1_L1: mb_class_e = 12;
    #[c2rust::src_loc = "79:5"]
    pub const B_L1_L0: mb_class_e = 11;
    #[c2rust::src_loc = "78:5"]
    pub const B_L0_BI: mb_class_e = 10;
    #[c2rust::src_loc = "77:5"]
    pub const B_L0_L1: mb_class_e = 9;
    #[c2rust::src_loc = "76:5"]
    pub const B_L0_L0: mb_class_e = 8;
    #[c2rust::src_loc = "75:5"]
    pub const B_DIRECT: mb_class_e = 7;
    #[c2rust::src_loc = "73:5"]
    pub const P_SKIP: mb_class_e = 6;
    #[c2rust::src_loc = "72:5"]
    pub const P_8x8: mb_class_e = 5;
    #[c2rust::src_loc = "71:5"]
    pub const P_L0: mb_class_e = 4;
    #[c2rust::src_loc = "69:5"]
    pub const I_PCM: mb_class_e = 3;
    #[c2rust::src_loc = "68:5"]
    pub const I_16x16: mb_class_e = 2;
    #[c2rust::src_loc = "67:5"]
    pub const I_8x8: mb_class_e = 1;
    #[c2rust::src_loc = "66:5"]
    pub const I_4x4: mb_class_e = 0;
    #[c2rust::src_loc = "115:1"]
    pub type mb_partition_e = ::core::ffi::c_uint;
    #[c2rust::src_loc = "140:5"]
    pub const X264_PARTTYPE_MAX: mb_partition_e = 17;
    #[c2rust::src_loc = "139:5"]
    pub const D_16x16: mb_partition_e = 16;
    #[c2rust::src_loc = "138:5"]
    pub const D_8x16: mb_partition_e = 15;
    #[c2rust::src_loc = "137:5"]
    pub const D_16x8: mb_partition_e = 14;
    #[c2rust::src_loc = "136:5"]
    pub const D_8x8: mb_partition_e = 13;
    #[c2rust::src_loc = "133:5"]
    pub const D_DIRECT_8x8: mb_partition_e = 12;
    #[c2rust::src_loc = "132:5"]
    pub const D_BI_8x8: mb_partition_e = 11;
    #[c2rust::src_loc = "131:5"]
    pub const D_BI_4x8: mb_partition_e = 10;
    #[c2rust::src_loc = "130:5"]
    pub const D_BI_8x4: mb_partition_e = 9;
    #[c2rust::src_loc = "129:5"]
    pub const D_BI_4x4: mb_partition_e = 8;
    #[c2rust::src_loc = "127:5"]
    pub const D_L1_8x8: mb_partition_e = 7;
    #[c2rust::src_loc = "126:5"]
    pub const D_L1_4x8: mb_partition_e = 6;
    #[c2rust::src_loc = "125:5"]
    pub const D_L1_8x4: mb_partition_e = 5;
    #[c2rust::src_loc = "124:5"]
    pub const D_L1_4x4: mb_partition_e = 4;
    #[c2rust::src_loc = "121:5"]
    pub const D_L0_8x8: mb_partition_e = 3;
    #[c2rust::src_loc = "120:5"]
    pub const D_L0_4x8: mb_partition_e = 2;
    #[c2rust::src_loc = "119:5"]
    pub const D_L0_8x4: mb_partition_e = 1;
    #[c2rust::src_loc = "118:5"]
    pub const D_L0_4x4: mb_partition_e = 0;
    #[c2rust::src_loc = "273:1"]
    pub type cabac_ctx_block_cat_e = ::core::ffi::c_uint;
    #[c2rust::src_loc = "288:5"]
    pub const DCT_CHROMAV_8x8: cabac_ctx_block_cat_e = 13;
    #[c2rust::src_loc = "287:5"]
    pub const DCT_CHROMAV_4x4: cabac_ctx_block_cat_e = 12;
    #[c2rust::src_loc = "286:5"]
    pub const DCT_CHROMAV_AC: cabac_ctx_block_cat_e = 11;
    #[c2rust::src_loc = "285:5"]
    pub const DCT_CHROMAV_DC: cabac_ctx_block_cat_e = 10;
    #[c2rust::src_loc = "284:5"]
    pub const DCT_CHROMAU_8x8: cabac_ctx_block_cat_e = 9;
    #[c2rust::src_loc = "283:5"]
    pub const DCT_CHROMAU_4x4: cabac_ctx_block_cat_e = 8;
    #[c2rust::src_loc = "282:5"]
    pub const DCT_CHROMAU_AC: cabac_ctx_block_cat_e = 7;
    #[c2rust::src_loc = "281:5"]
    pub const DCT_CHROMAU_DC: cabac_ctx_block_cat_e = 6;
    #[c2rust::src_loc = "280:5"]
    pub const DCT_LUMA_8x8: cabac_ctx_block_cat_e = 5;
    #[c2rust::src_loc = "279:5"]
    pub const DCT_CHROMA_AC: cabac_ctx_block_cat_e = 4;
    #[c2rust::src_loc = "278:5"]
    pub const DCT_CHROMA_DC: cabac_ctx_block_cat_e = 3;
    #[c2rust::src_loc = "277:5"]
    pub const DCT_LUMA_4x4: cabac_ctx_block_cat_e = 2;
    #[c2rust::src_loc = "276:5"]
    pub const DCT_LUMA_AC: cabac_ctx_block_cat_e = 1;
    #[c2rust::src_loc = "275:5"]
    pub const DCT_LUMA_DC: cabac_ctx_block_cat_e = 0;
    #[c2rust::src_loc = "43:22"]
    pub static mut x264_pred_i4x4_neighbors: [uint8_t; 12] = [
        MB_TOP as ::core::ffi::c_int as uint8_t,
        MB_LEFT as ::core::ffi::c_int as uint8_t,
        (MB_LEFT as ::core::ffi::c_int | MB_TOP as ::core::ffi::c_int) as uint8_t,
        (MB_TOP as ::core::ffi::c_int | MB_TOPRIGHT as ::core::ffi::c_int) as uint8_t,
        (MB_LEFT as ::core::ffi::c_int
            | MB_TOPLEFT as ::core::ffi::c_int
            | MB_TOP as ::core::ffi::c_int) as uint8_t,
        (MB_LEFT as ::core::ffi::c_int
            | MB_TOPLEFT as ::core::ffi::c_int
            | MB_TOP as ::core::ffi::c_int) as uint8_t,
        (MB_LEFT as ::core::ffi::c_int
            | MB_TOPLEFT as ::core::ffi::c_int
            | MB_TOP as ::core::ffi::c_int) as uint8_t,
        (MB_TOP as ::core::ffi::c_int | MB_TOPRIGHT as ::core::ffi::c_int) as uint8_t,
        MB_LEFT as ::core::ffi::c_int as uint8_t,
        MB_LEFT as ::core::ffi::c_int as uint8_t,
        MB_TOP as ::core::ffi::c_int as uint8_t,
        0 as ::core::ffi::c_int as uint8_t,
    ];
    #[c2rust::src_loc = "97:22"]
    pub static mut x264_mb_type_list_table: [[[uint8_t; 2]; 2]; 19] = [
        [
            [
                0 as ::core::ffi::c_int as uint8_t,
                0 as ::core::ffi::c_int as uint8_t,
            ],
            [
                0 as ::core::ffi::c_int as uint8_t,
                0 as ::core::ffi::c_int as uint8_t,
            ],
        ],
        [
            [
                0 as ::core::ffi::c_int as uint8_t,
                0 as ::core::ffi::c_int as uint8_t,
            ],
            [
                0 as ::core::ffi::c_int as uint8_t,
                0 as ::core::ffi::c_int as uint8_t,
            ],
        ],
        [
            [
                0 as ::core::ffi::c_int as uint8_t,
                0 as ::core::ffi::c_int as uint8_t,
            ],
            [
                0 as ::core::ffi::c_int as uint8_t,
                0 as ::core::ffi::c_int as uint8_t,
            ],
        ],
        [
            [
                0 as ::core::ffi::c_int as uint8_t,
                0 as ::core::ffi::c_int as uint8_t,
            ],
            [
                0 as ::core::ffi::c_int as uint8_t,
                0 as ::core::ffi::c_int as uint8_t,
            ],
        ],
        [
            [
                1 as ::core::ffi::c_int as uint8_t,
                1 as ::core::ffi::c_int as uint8_t,
            ],
            [
                0 as ::core::ffi::c_int as uint8_t,
                0 as ::core::ffi::c_int as uint8_t,
            ],
        ],
        [
            [
                0 as ::core::ffi::c_int as uint8_t,
                0 as ::core::ffi::c_int as uint8_t,
            ],
            [
                0 as ::core::ffi::c_int as uint8_t,
                0 as ::core::ffi::c_int as uint8_t,
            ],
        ],
        [
            [
                1 as ::core::ffi::c_int as uint8_t,
                1 as ::core::ffi::c_int as uint8_t,
            ],
            [
                0 as ::core::ffi::c_int as uint8_t,
                0 as ::core::ffi::c_int as uint8_t,
            ],
        ],
        [
            [
                0 as ::core::ffi::c_int as uint8_t,
                0 as ::core::ffi::c_int as uint8_t,
            ],
            [
                0 as ::core::ffi::c_int as uint8_t,
                0 as ::core::ffi::c_int as uint8_t,
            ],
        ],
        [
            [
                1 as ::core::ffi::c_int as uint8_t,
                1 as ::core::ffi::c_int as uint8_t,
            ],
            [
                0 as ::core::ffi::c_int as uint8_t,
                0 as ::core::ffi::c_int as uint8_t,
            ],
        ],
        [
            [
                1 as ::core::ffi::c_int as uint8_t,
                0 as ::core::ffi::c_int as uint8_t,
            ],
            [
                0 as ::core::ffi::c_int as uint8_t,
                1 as ::core::ffi::c_int as uint8_t,
            ],
        ],
        [
            [
                1 as ::core::ffi::c_int as uint8_t,
                1 as ::core::ffi::c_int as uint8_t,
            ],
            [
                0 as ::core::ffi::c_int as uint8_t,
                1 as ::core::ffi::c_int as uint8_t,
            ],
        ],
        [
            [
                0 as ::core::ffi::c_int as uint8_t,
                1 as ::core::ffi::c_int as uint8_t,
            ],
            [
                1 as ::core::ffi::c_int as uint8_t,
                0 as ::core::ffi::c_int as uint8_t,
            ],
        ],
        [
            [
                0 as ::core::ffi::c_int as uint8_t,
                0 as ::core::ffi::c_int as uint8_t,
            ],
            [
                1 as ::core::ffi::c_int as uint8_t,
                1 as ::core::ffi::c_int as uint8_t,
            ],
        ],
        [
            [
                0 as ::core::ffi::c_int as uint8_t,
                1 as ::core::ffi::c_int as uint8_t,
            ],
            [
                1 as ::core::ffi::c_int as uint8_t,
                1 as ::core::ffi::c_int as uint8_t,
            ],
        ],
        [
            [
                1 as ::core::ffi::c_int as uint8_t,
                1 as ::core::ffi::c_int as uint8_t,
            ],
            [
                1 as ::core::ffi::c_int as uint8_t,
                0 as ::core::ffi::c_int as uint8_t,
            ],
        ],
        [
            [
                1 as ::core::ffi::c_int as uint8_t,
                0 as ::core::ffi::c_int as uint8_t,
            ],
            [
                1 as ::core::ffi::c_int as uint8_t,
                1 as ::core::ffi::c_int as uint8_t,
            ],
        ],
        [
            [
                1 as ::core::ffi::c_int as uint8_t,
                1 as ::core::ffi::c_int as uint8_t,
            ],
            [
                1 as ::core::ffi::c_int as uint8_t,
                1 as ::core::ffi::c_int as uint8_t,
            ],
        ],
        [
            [
                0 as ::core::ffi::c_int as uint8_t,
                0 as ::core::ffi::c_int as uint8_t,
            ],
            [
                0 as ::core::ffi::c_int as uint8_t,
                0 as ::core::ffi::c_int as uint8_t,
            ],
        ],
        [
            [
                0 as ::core::ffi::c_int as uint8_t,
                0 as ::core::ffi::c_int as uint8_t,
            ],
            [
                0 as ::core::ffi::c_int as uint8_t,
                0 as ::core::ffi::c_int as uint8_t,
            ],
        ],
    ];
    #[c2rust::src_loc = "143:22"]
    pub static mut x264_mb_partition_listX_table: [[uint8_t; 17]; 2] = [
        [
            1 as ::core::ffi::c_int as uint8_t,
            1 as ::core::ffi::c_int as uint8_t,
            1 as ::core::ffi::c_int as uint8_t,
            1 as ::core::ffi::c_int as uint8_t,
            0 as ::core::ffi::c_int as uint8_t,
            0 as ::core::ffi::c_int as uint8_t,
            0 as ::core::ffi::c_int as uint8_t,
            0 as ::core::ffi::c_int as uint8_t,
            1 as ::core::ffi::c_int as uint8_t,
            1 as ::core::ffi::c_int as uint8_t,
            1 as ::core::ffi::c_int as uint8_t,
            1 as ::core::ffi::c_int as uint8_t,
            0 as ::core::ffi::c_int as uint8_t,
            0 as ::core::ffi::c_int as uint8_t,
            0 as ::core::ffi::c_int as uint8_t,
            0 as ::core::ffi::c_int as uint8_t,
            0 as ::core::ffi::c_int as uint8_t,
        ],
        [
            0 as ::core::ffi::c_int as uint8_t,
            0 as ::core::ffi::c_int as uint8_t,
            0 as ::core::ffi::c_int as uint8_t,
            0 as ::core::ffi::c_int as uint8_t,
            1 as ::core::ffi::c_int as uint8_t,
            1 as ::core::ffi::c_int as uint8_t,
            1 as ::core::ffi::c_int as uint8_t,
            1 as ::core::ffi::c_int as uint8_t,
            1 as ::core::ffi::c_int as uint8_t,
            1 as ::core::ffi::c_int as uint8_t,
            1 as ::core::ffi::c_int as uint8_t,
            1 as ::core::ffi::c_int as uint8_t,
            0 as ::core::ffi::c_int as uint8_t,
            0 as ::core::ffi::c_int as uint8_t,
            0 as ::core::ffi::c_int as uint8_t,
            0 as ::core::ffi::c_int as uint8_t,
            0 as ::core::ffi::c_int as uint8_t,
        ],
    ];
    #[c2rust::src_loc = "181:22"]
    pub static mut x264_zigzag_scan4: [[uint8_t; 16]; 2] = [
        [
            0 as ::core::ffi::c_int as uint8_t,
            4 as ::core::ffi::c_int as uint8_t,
            1 as ::core::ffi::c_int as uint8_t,
            2 as ::core::ffi::c_int as uint8_t,
            5 as ::core::ffi::c_int as uint8_t,
            8 as ::core::ffi::c_int as uint8_t,
            12 as ::core::ffi::c_int as uint8_t,
            9 as ::core::ffi::c_int as uint8_t,
            6 as ::core::ffi::c_int as uint8_t,
            3 as ::core::ffi::c_int as uint8_t,
            7 as ::core::ffi::c_int as uint8_t,
            10 as ::core::ffi::c_int as uint8_t,
            13 as ::core::ffi::c_int as uint8_t,
            14 as ::core::ffi::c_int as uint8_t,
            11 as ::core::ffi::c_int as uint8_t,
            15 as ::core::ffi::c_int as uint8_t,
        ],
        [
            0 as ::core::ffi::c_int as uint8_t,
            1 as ::core::ffi::c_int as uint8_t,
            4 as ::core::ffi::c_int as uint8_t,
            2 as ::core::ffi::c_int as uint8_t,
            3 as ::core::ffi::c_int as uint8_t,
            5 as ::core::ffi::c_int as uint8_t,
            6 as ::core::ffi::c_int as uint8_t,
            7 as ::core::ffi::c_int as uint8_t,
            8 as ::core::ffi::c_int as uint8_t,
            9 as ::core::ffi::c_int as uint8_t,
            10 as ::core::ffi::c_int as uint8_t,
            11 as ::core::ffi::c_int as uint8_t,
            12 as ::core::ffi::c_int as uint8_t,
            13 as ::core::ffi::c_int as uint8_t,
            14 as ::core::ffi::c_int as uint8_t,
            15 as ::core::ffi::c_int as uint8_t,
        ],
    ];
    #[c2rust::src_loc = "188:22"]
    pub static mut x264_zigzag_scan8: [[uint8_t; 64]; 2] = [
        [
            0 as ::core::ffi::c_int as uint8_t,
            8 as ::core::ffi::c_int as uint8_t,
            1 as ::core::ffi::c_int as uint8_t,
            2 as ::core::ffi::c_int as uint8_t,
            9 as ::core::ffi::c_int as uint8_t,
            16 as ::core::ffi::c_int as uint8_t,
            24 as ::core::ffi::c_int as uint8_t,
            17 as ::core::ffi::c_int as uint8_t,
            10 as ::core::ffi::c_int as uint8_t,
            3 as ::core::ffi::c_int as uint8_t,
            4 as ::core::ffi::c_int as uint8_t,
            11 as ::core::ffi::c_int as uint8_t,
            18 as ::core::ffi::c_int as uint8_t,
            25 as ::core::ffi::c_int as uint8_t,
            32 as ::core::ffi::c_int as uint8_t,
            40 as ::core::ffi::c_int as uint8_t,
            33 as ::core::ffi::c_int as uint8_t,
            26 as ::core::ffi::c_int as uint8_t,
            19 as ::core::ffi::c_int as uint8_t,
            12 as ::core::ffi::c_int as uint8_t,
            5 as ::core::ffi::c_int as uint8_t,
            6 as ::core::ffi::c_int as uint8_t,
            13 as ::core::ffi::c_int as uint8_t,
            20 as ::core::ffi::c_int as uint8_t,
            27 as ::core::ffi::c_int as uint8_t,
            34 as ::core::ffi::c_int as uint8_t,
            41 as ::core::ffi::c_int as uint8_t,
            48 as ::core::ffi::c_int as uint8_t,
            56 as ::core::ffi::c_int as uint8_t,
            49 as ::core::ffi::c_int as uint8_t,
            42 as ::core::ffi::c_int as uint8_t,
            35 as ::core::ffi::c_int as uint8_t,
            28 as ::core::ffi::c_int as uint8_t,
            21 as ::core::ffi::c_int as uint8_t,
            14 as ::core::ffi::c_int as uint8_t,
            7 as ::core::ffi::c_int as uint8_t,
            15 as ::core::ffi::c_int as uint8_t,
            22 as ::core::ffi::c_int as uint8_t,
            29 as ::core::ffi::c_int as uint8_t,
            36 as ::core::ffi::c_int as uint8_t,
            43 as ::core::ffi::c_int as uint8_t,
            50 as ::core::ffi::c_int as uint8_t,
            57 as ::core::ffi::c_int as uint8_t,
            58 as ::core::ffi::c_int as uint8_t,
            51 as ::core::ffi::c_int as uint8_t,
            44 as ::core::ffi::c_int as uint8_t,
            37 as ::core::ffi::c_int as uint8_t,
            30 as ::core::ffi::c_int as uint8_t,
            23 as ::core::ffi::c_int as uint8_t,
            31 as ::core::ffi::c_int as uint8_t,
            38 as ::core::ffi::c_int as uint8_t,
            45 as ::core::ffi::c_int as uint8_t,
            52 as ::core::ffi::c_int as uint8_t,
            59 as ::core::ffi::c_int as uint8_t,
            60 as ::core::ffi::c_int as uint8_t,
            53 as ::core::ffi::c_int as uint8_t,
            46 as ::core::ffi::c_int as uint8_t,
            39 as ::core::ffi::c_int as uint8_t,
            47 as ::core::ffi::c_int as uint8_t,
            54 as ::core::ffi::c_int as uint8_t,
            61 as ::core::ffi::c_int as uint8_t,
            62 as ::core::ffi::c_int as uint8_t,
            55 as ::core::ffi::c_int as uint8_t,
            63 as ::core::ffi::c_int as uint8_t,
        ],
        [
            0 as ::core::ffi::c_int as uint8_t,
            1 as ::core::ffi::c_int as uint8_t,
            2 as ::core::ffi::c_int as uint8_t,
            8 as ::core::ffi::c_int as uint8_t,
            9 as ::core::ffi::c_int as uint8_t,
            3 as ::core::ffi::c_int as uint8_t,
            4 as ::core::ffi::c_int as uint8_t,
            10 as ::core::ffi::c_int as uint8_t,
            16 as ::core::ffi::c_int as uint8_t,
            11 as ::core::ffi::c_int as uint8_t,
            5 as ::core::ffi::c_int as uint8_t,
            6 as ::core::ffi::c_int as uint8_t,
            7 as ::core::ffi::c_int as uint8_t,
            12 as ::core::ffi::c_int as uint8_t,
            17 as ::core::ffi::c_int as uint8_t,
            24 as ::core::ffi::c_int as uint8_t,
            18 as ::core::ffi::c_int as uint8_t,
            13 as ::core::ffi::c_int as uint8_t,
            14 as ::core::ffi::c_int as uint8_t,
            15 as ::core::ffi::c_int as uint8_t,
            19 as ::core::ffi::c_int as uint8_t,
            25 as ::core::ffi::c_int as uint8_t,
            32 as ::core::ffi::c_int as uint8_t,
            26 as ::core::ffi::c_int as uint8_t,
            20 as ::core::ffi::c_int as uint8_t,
            21 as ::core::ffi::c_int as uint8_t,
            22 as ::core::ffi::c_int as uint8_t,
            23 as ::core::ffi::c_int as uint8_t,
            27 as ::core::ffi::c_int as uint8_t,
            33 as ::core::ffi::c_int as uint8_t,
            40 as ::core::ffi::c_int as uint8_t,
            34 as ::core::ffi::c_int as uint8_t,
            28 as ::core::ffi::c_int as uint8_t,
            29 as ::core::ffi::c_int as uint8_t,
            30 as ::core::ffi::c_int as uint8_t,
            31 as ::core::ffi::c_int as uint8_t,
            35 as ::core::ffi::c_int as uint8_t,
            41 as ::core::ffi::c_int as uint8_t,
            48 as ::core::ffi::c_int as uint8_t,
            42 as ::core::ffi::c_int as uint8_t,
            36 as ::core::ffi::c_int as uint8_t,
            37 as ::core::ffi::c_int as uint8_t,
            38 as ::core::ffi::c_int as uint8_t,
            39 as ::core::ffi::c_int as uint8_t,
            43 as ::core::ffi::c_int as uint8_t,
            49 as ::core::ffi::c_int as uint8_t,
            50 as ::core::ffi::c_int as uint8_t,
            44 as ::core::ffi::c_int as uint8_t,
            45 as ::core::ffi::c_int as uint8_t,
            46 as ::core::ffi::c_int as uint8_t,
            47 as ::core::ffi::c_int as uint8_t,
            51 as ::core::ffi::c_int as uint8_t,
            56 as ::core::ffi::c_int as uint8_t,
            57 as ::core::ffi::c_int as uint8_t,
            52 as ::core::ffi::c_int as uint8_t,
            53 as ::core::ffi::c_int as uint8_t,
            54 as ::core::ffi::c_int as uint8_t,
            55 as ::core::ffi::c_int as uint8_t,
            58 as ::core::ffi::c_int as uint8_t,
            59 as ::core::ffi::c_int as uint8_t,
            60 as ::core::ffi::c_int as uint8_t,
            61 as ::core::ffi::c_int as uint8_t,
            62 as ::core::ffi::c_int as uint8_t,
            63 as ::core::ffi::c_int as uint8_t,
        ],
    ];
    #[c2rust::src_loc = "202:22"]
    pub static mut block_idx_x: [uint8_t; 16] = [
        0 as ::core::ffi::c_int as uint8_t,
        1 as ::core::ffi::c_int as uint8_t,
        0 as ::core::ffi::c_int as uint8_t,
        1 as ::core::ffi::c_int as uint8_t,
        2 as ::core::ffi::c_int as uint8_t,
        3 as ::core::ffi::c_int as uint8_t,
        2 as ::core::ffi::c_int as uint8_t,
        3 as ::core::ffi::c_int as uint8_t,
        0 as ::core::ffi::c_int as uint8_t,
        1 as ::core::ffi::c_int as uint8_t,
        0 as ::core::ffi::c_int as uint8_t,
        1 as ::core::ffi::c_int as uint8_t,
        2 as ::core::ffi::c_int as uint8_t,
        3 as ::core::ffi::c_int as uint8_t,
        2 as ::core::ffi::c_int as uint8_t,
        3 as ::core::ffi::c_int as uint8_t,
    ];
    #[c2rust::src_loc = "206:22"]
    pub static mut block_idx_y: [uint8_t; 16] = [
        0 as ::core::ffi::c_int as uint8_t,
        0 as ::core::ffi::c_int as uint8_t,
        1 as ::core::ffi::c_int as uint8_t,
        1 as ::core::ffi::c_int as uint8_t,
        0 as ::core::ffi::c_int as uint8_t,
        0 as ::core::ffi::c_int as uint8_t,
        1 as ::core::ffi::c_int as uint8_t,
        1 as ::core::ffi::c_int as uint8_t,
        2 as ::core::ffi::c_int as uint8_t,
        2 as ::core::ffi::c_int as uint8_t,
        3 as ::core::ffi::c_int as uint8_t,
        3 as ::core::ffi::c_int as uint8_t,
        2 as ::core::ffi::c_int as uint8_t,
        2 as ::core::ffi::c_int as uint8_t,
        3 as ::core::ffi::c_int as uint8_t,
        3 as ::core::ffi::c_int as uint8_t,
    ];
    #[c2rust::src_loc = "225:22"]
    pub static mut block_idx_xy_fenc: [uint8_t; 16] = [
        (0 as ::core::ffi::c_int * 4 as ::core::ffi::c_int
            + 0 as ::core::ffi::c_int * 4 as ::core::ffi::c_int * FENC_STRIDE) as uint8_t,
        (1 as ::core::ffi::c_int * 4 as ::core::ffi::c_int
            + 0 as ::core::ffi::c_int * 4 as ::core::ffi::c_int * FENC_STRIDE) as uint8_t,
        (0 as ::core::ffi::c_int * 4 as ::core::ffi::c_int
            + 1 as ::core::ffi::c_int * 4 as ::core::ffi::c_int * FENC_STRIDE) as uint8_t,
        (1 as ::core::ffi::c_int * 4 as ::core::ffi::c_int
            + 1 as ::core::ffi::c_int * 4 as ::core::ffi::c_int * FENC_STRIDE) as uint8_t,
        (2 as ::core::ffi::c_int * 4 as ::core::ffi::c_int
            + 0 as ::core::ffi::c_int * 4 as ::core::ffi::c_int * FENC_STRIDE) as uint8_t,
        (3 as ::core::ffi::c_int * 4 as ::core::ffi::c_int
            + 0 as ::core::ffi::c_int * 4 as ::core::ffi::c_int * FENC_STRIDE) as uint8_t,
        (2 as ::core::ffi::c_int * 4 as ::core::ffi::c_int
            + 1 as ::core::ffi::c_int * 4 as ::core::ffi::c_int * FENC_STRIDE) as uint8_t,
        (3 as ::core::ffi::c_int * 4 as ::core::ffi::c_int
            + 1 as ::core::ffi::c_int * 4 as ::core::ffi::c_int * FENC_STRIDE) as uint8_t,
        (0 as ::core::ffi::c_int * 4 as ::core::ffi::c_int
            + 2 as ::core::ffi::c_int * 4 as ::core::ffi::c_int * FENC_STRIDE) as uint8_t,
        (1 as ::core::ffi::c_int * 4 as ::core::ffi::c_int
            + 2 as ::core::ffi::c_int * 4 as ::core::ffi::c_int * FENC_STRIDE) as uint8_t,
        (0 as ::core::ffi::c_int * 4 as ::core::ffi::c_int
            + 3 as ::core::ffi::c_int * 4 as ::core::ffi::c_int * FENC_STRIDE) as uint8_t,
        (1 as ::core::ffi::c_int * 4 as ::core::ffi::c_int
            + 3 as ::core::ffi::c_int * 4 as ::core::ffi::c_int * FENC_STRIDE) as uint8_t,
        (2 as ::core::ffi::c_int * 4 as ::core::ffi::c_int
            + 2 as ::core::ffi::c_int * 4 as ::core::ffi::c_int * FENC_STRIDE) as uint8_t,
        (3 as ::core::ffi::c_int * 4 as ::core::ffi::c_int
            + 2 as ::core::ffi::c_int * 4 as ::core::ffi::c_int * FENC_STRIDE) as uint8_t,
        (2 as ::core::ffi::c_int * 4 as ::core::ffi::c_int
            + 3 as ::core::ffi::c_int * 4 as ::core::ffi::c_int * FENC_STRIDE) as uint8_t,
        (3 as ::core::ffi::c_int * 4 as ::core::ffi::c_int
            + 3 as ::core::ffi::c_int * 4 as ::core::ffi::c_int * FENC_STRIDE) as uint8_t,
    ];
    #[c2rust::src_loc = "236:23"]
    pub static mut block_idx_xy_fdec: [uint16_t; 16] = [
        (0 as ::core::ffi::c_int * 4 as ::core::ffi::c_int
            + 0 as ::core::ffi::c_int * 4 as ::core::ffi::c_int * FDEC_STRIDE) as uint16_t,
        (1 as ::core::ffi::c_int * 4 as ::core::ffi::c_int
            + 0 as ::core::ffi::c_int * 4 as ::core::ffi::c_int * FDEC_STRIDE) as uint16_t,
        (0 as ::core::ffi::c_int * 4 as ::core::ffi::c_int
            + 1 as ::core::ffi::c_int * 4 as ::core::ffi::c_int * FDEC_STRIDE) as uint16_t,
        (1 as ::core::ffi::c_int * 4 as ::core::ffi::c_int
            + 1 as ::core::ffi::c_int * 4 as ::core::ffi::c_int * FDEC_STRIDE) as uint16_t,
        (2 as ::core::ffi::c_int * 4 as ::core::ffi::c_int
            + 0 as ::core::ffi::c_int * 4 as ::core::ffi::c_int * FDEC_STRIDE) as uint16_t,
        (3 as ::core::ffi::c_int * 4 as ::core::ffi::c_int
            + 0 as ::core::ffi::c_int * 4 as ::core::ffi::c_int * FDEC_STRIDE) as uint16_t,
        (2 as ::core::ffi::c_int * 4 as ::core::ffi::c_int
            + 1 as ::core::ffi::c_int * 4 as ::core::ffi::c_int * FDEC_STRIDE) as uint16_t,
        (3 as ::core::ffi::c_int * 4 as ::core::ffi::c_int
            + 1 as ::core::ffi::c_int * 4 as ::core::ffi::c_int * FDEC_STRIDE) as uint16_t,
        (0 as ::core::ffi::c_int * 4 as ::core::ffi::c_int
            + 2 as ::core::ffi::c_int * 4 as ::core::ffi::c_int * FDEC_STRIDE) as uint16_t,
        (1 as ::core::ffi::c_int * 4 as ::core::ffi::c_int
            + 2 as ::core::ffi::c_int * 4 as ::core::ffi::c_int * FDEC_STRIDE) as uint16_t,
        (0 as ::core::ffi::c_int * 4 as ::core::ffi::c_int
            + 3 as ::core::ffi::c_int * 4 as ::core::ffi::c_int * FDEC_STRIDE) as uint16_t,
        (1 as ::core::ffi::c_int * 4 as ::core::ffi::c_int
            + 3 as ::core::ffi::c_int * 4 as ::core::ffi::c_int * FDEC_STRIDE) as uint16_t,
        (2 as ::core::ffi::c_int * 4 as ::core::ffi::c_int
            + 2 as ::core::ffi::c_int * 4 as ::core::ffi::c_int * FDEC_STRIDE) as uint16_t,
        (3 as ::core::ffi::c_int * 4 as ::core::ffi::c_int
            + 2 as ::core::ffi::c_int * 4 as ::core::ffi::c_int * FDEC_STRIDE) as uint16_t,
        (2 as ::core::ffi::c_int * 4 as ::core::ffi::c_int
            + 3 as ::core::ffi::c_int * 4 as ::core::ffi::c_int * FDEC_STRIDE) as uint16_t,
        (3 as ::core::ffi::c_int * 4 as ::core::ffi::c_int
            + 3 as ::core::ffi::c_int * 4 as ::core::ffi::c_int * FDEC_STRIDE) as uint16_t,
    ];
    #[c2rust::src_loc = "291:22"]
    pub static mut ctx_cat_plane: [[uint8_t; 3]; 6] = [
        [
            DCT_LUMA_DC as ::core::ffi::c_int as uint8_t,
            DCT_CHROMAU_DC as ::core::ffi::c_int as uint8_t,
            DCT_CHROMAV_DC as ::core::ffi::c_int as uint8_t,
        ],
        [
            DCT_LUMA_AC as ::core::ffi::c_int as uint8_t,
            DCT_CHROMAU_AC as ::core::ffi::c_int as uint8_t,
            DCT_CHROMAV_AC as ::core::ffi::c_int as uint8_t,
        ],
        [
            DCT_LUMA_4x4 as ::core::ffi::c_int as uint8_t,
            DCT_CHROMAU_4x4 as ::core::ffi::c_int as uint8_t,
            DCT_CHROMAV_4x4 as ::core::ffi::c_int as uint8_t,
        ],
        [0 as ::core::ffi::c_int as uint8_t, 0, 0],
        [0 as ::core::ffi::c_int as uint8_t, 0, 0],
        [
            DCT_LUMA_8x8 as ::core::ffi::c_int as uint8_t,
            DCT_CHROMAU_8x8 as ::core::ffi::c_int as uint8_t,
            DCT_CHROMAV_8x8 as ::core::ffi::c_int as uint8_t,
        ],
    ];
    #[inline(always)]
    #[c2rust::src_loc = "371:1"]
    pub unsafe extern "C" fn pack16to32(mut a: uint32_t, mut b: uint32_t) -> uint32_t {
        return a.wrapping_add(b << 16 as ::core::ffi::c_int);
    }
    #[inline(always)]
    #[c2rust::src_loc = "379:1"]
    pub unsafe extern "C" fn pack8to16(mut a: uint32_t, mut b: uint32_t) -> uint32_t {
        return a.wrapping_add(b << 8 as ::core::ffi::c_int);
    }
    #[inline(always)]
    #[c2rust::src_loc = "420:1"]
    pub unsafe extern "C" fn x264_mb_predict_intra4x4_mode(
        mut h: *mut x264_t,
        mut idx: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int {
        let ma: ::core::ffi::c_int = (*h).mb.cache.intra4x4_pred_mode
            [(x264_scan8[idx as usize] as ::core::ffi::c_int - 1 as ::core::ffi::c_int) as usize]
            as ::core::ffi::c_int;
        let mb: ::core::ffi::c_int = (*h).mb.cache.intra4x4_pred_mode
            [(x264_scan8[idx as usize] as ::core::ffi::c_int - 8 as ::core::ffi::c_int) as usize]
            as ::core::ffi::c_int;
        let m: ::core::ffi::c_int = if (x264_mb_pred_mode4x4_fix
            [(ma + 1 as ::core::ffi::c_int) as usize]
            as ::core::ffi::c_int)
            < x264_mb_pred_mode4x4_fix[(mb + 1 as ::core::ffi::c_int) as usize]
                as ::core::ffi::c_int
        {
            x264_mb_pred_mode4x4_fix[(ma + 1 as ::core::ffi::c_int) as usize] as ::core::ffi::c_int
        } else {
            x264_mb_pred_mode4x4_fix[(mb + 1 as ::core::ffi::c_int) as usize] as ::core::ffi::c_int
        };
        if m < 0 as ::core::ffi::c_int {
            return I_PRED_4x4_DC as ::core::ffi::c_int;
        }
        return m;
    }
    #[inline(always)]
    #[c2rust::src_loc = "432:1"]
    pub unsafe extern "C" fn x264_mb_predict_non_zero_code(
        mut h: *mut x264_t,
        mut idx: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int {
        let za: ::core::ffi::c_int = (*h).mb.cache.non_zero_count
            [(x264_scan8[idx as usize] as ::core::ffi::c_int - 1 as ::core::ffi::c_int) as usize]
            as ::core::ffi::c_int;
        let zb: ::core::ffi::c_int = (*h).mb.cache.non_zero_count
            [(x264_scan8[idx as usize] as ::core::ffi::c_int - 8 as ::core::ffi::c_int) as usize]
            as ::core::ffi::c_int;
        let mut i_ret: ::core::ffi::c_int = za + zb;
        if i_ret < 0x80 as ::core::ffi::c_int {
            i_ret = i_ret + 1 as ::core::ffi::c_int >> 1 as ::core::ffi::c_int;
        }
        return i_ret & 0x7f as ::core::ffi::c_int;
    }
    #[c2rust::src_loc = "445:22"]
    pub static mut x264_transform_allowed: [uint8_t; 19] = [
        0 as ::core::ffi::c_int as uint8_t,
        0 as ::core::ffi::c_int as uint8_t,
        0 as ::core::ffi::c_int as uint8_t,
        0 as ::core::ffi::c_int as uint8_t,
        1 as ::core::ffi::c_int as uint8_t,
        2 as ::core::ffi::c_int as uint8_t,
        0 as ::core::ffi::c_int as uint8_t,
        1 as ::core::ffi::c_int as uint8_t,
        1 as ::core::ffi::c_int as uint8_t,
        1 as ::core::ffi::c_int as uint8_t,
        1 as ::core::ffi::c_int as uint8_t,
        1 as ::core::ffi::c_int as uint8_t,
        1 as ::core::ffi::c_int as uint8_t,
        1 as ::core::ffi::c_int as uint8_t,
        1 as ::core::ffi::c_int as uint8_t,
        1 as ::core::ffi::c_int as uint8_t,
        1 as ::core::ffi::c_int as uint8_t,
        1 as ::core::ffi::c_int as uint8_t,
        0 as ::core::ffi::c_int as uint8_t,
    ];
    #[inline(always)]
    #[c2rust::src_loc = "454:1"]
    pub unsafe extern "C" fn x264_mb_transform_8x8_allowed(
        mut h: *mut x264_t,
    ) -> ::core::ffi::c_int {
        if (*(*h).pps.as_mut_ptr()).b_transform_8x8_mode == 0 {
            return 0 as ::core::ffi::c_int;
        }
        if (*h).mb.i_type != P_8x8 as ::core::ffi::c_int {
            return x264_transform_allowed[(*h).mb.i_type as usize] as ::core::ffi::c_int;
        }
        return ((*((*h).mb.i_sub_partition.as_mut_ptr() as *mut x264_union32_t)).i
            == (D_L0_8x8 as ::core::ffi::c_int * 0x1010101 as ::core::ffi::c_int) as uint32_t)
            as ::core::ffi::c_int;
    }
    use super::base_h::{x264_scan8, x264_union32_t};
    use super::common_h::{x264_t, FDEC_STRIDE, FENC_STRIDE};
    use super::predict_h::{x264_mb_pred_mode4x4_fix, I_PRED_4x4_DC};
    use super::stdint_intn_h::{int16_t, int8_t};
    use super::stdint_uintn_h::{uint16_t, uint32_t, uint8_t};
    extern "C" {
        #[c2rust::src_loc = "339:1"]
        pub fn x264_10_mb_predict_mv_16x16(
            h: *mut x264_t,
            i_list: ::core::ffi::c_int,
            i_ref: ::core::ffi::c_int,
            mvp: *mut int16_t,
        );
        #[c2rust::src_loc = "350:1"]
        pub fn x264_10_mb_predict_mv(
            h: *mut x264_t,
            i_list: ::core::ffi::c_int,
            idx: ::core::ffi::c_int,
            i_width: ::core::ffi::c_int,
            mvp: *mut int16_t,
        );
        #[c2rust::src_loc = "358:1"]
        pub fn x264_10_mb_predict_mv_direct16x16(
            h: *mut x264_t,
            b_changed: *mut ::core::ffi::c_int,
        ) -> ::core::ffi::c_int;
        #[c2rust::src_loc = "364:1"]
        pub fn x264_10_mb_predict_mv_ref16x16(
            h: *mut x264_t,
            i_list: ::core::ffi::c_int,
            i_ref: ::core::ffi::c_int,
            mvc: *mut [int16_t; 2],
            i_mvc: *mut ::core::ffi::c_int,
        );
        #[c2rust::src_loc = "367:1"]
        pub fn x264_10_mb_mc(h: *mut x264_t);
    }
}
#[c2rust::header_src = "/usr/lib/clang/21/include/xmmintrin.h:28"]
pub mod xmmintrin_h {
    #[cfg(target_arch = "x86")]
    pub use ::core::arch::x86::__m128;
    #[cfg(target_arch = "x86_64")]
    pub use ::core::arch::x86_64::__m128;
}
#[c2rust::header_src = "/home/nwplayer123/Hacks/hex264/x264/common/x86/util.h:28"]
pub mod util_h {
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "36:9"]
    pub union x264_union128_sse_t {
        pub i: __m128,
        pub q: [uint64_t; 2],
        pub d: [uint32_t; 4],
        pub w: [uint16_t; 8],
        pub b: [uint8_t; 16],
    }
    #[c2rust::src_loc = "34:9"]
    pub const M128_ZERO: __m128 = unsafe { core::mem::transmute([0.0f32, 0.0f32, 0.0f32, 0.0f32]) };
    use super::stdint_uintn_h::{uint16_t, uint32_t, uint64_t, uint8_t};
    use super::xmmintrin_h::__m128;
    #[cfg(target_arch = "x86")]
    pub use ::core::arch::x86::_mm_setr_ps;
    #[cfg(target_arch = "x86_64")]
    pub use ::core::arch::x86_64::_mm_setr_ps;
}
#[c2rust::header_src = "/home/nwplayer123/Hacks/hex264/x264/encoder/rdo.c:28"]
pub mod rdo_c {
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "424:9"]
    pub struct trellis_level_t {
        pub next: uint16_t,
        pub abs_level: uint16_t,
    }
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "417:9"]
    pub struct trellis_node_t {
        pub score: uint64_t,
        pub level_idx: ::core::ffi::c_int,
        pub cabac_state: [uint8_t; 4],
    }
    #[no_mangle]
    #[c2rust::src_loc = "36:9"]
    pub static mut x264_10_cabac_transition_unary: [[uint8_t; 128]; 15] = [[0; 128]; 15];
    #[no_mangle]
    #[c2rust::src_loc = "38:10"]
    pub static mut x264_10_cabac_size_unary: [[uint16_t; 128]; 15] = [[0; 128]; 15];
    #[c2rust::src_loc = "41:16"]
    pub static mut cabac_transition_5ones: [uint8_t; 128] = [0; 128];
    #[c2rust::src_loc = "42:17"]
    pub static mut cabac_size_5ones: [uint16_t; 128] = [0; 128];
    #[inline(always)]
    #[c2rust::src_loc = "75:1"]
    pub unsafe extern "C" fn cached_hadamard(
        mut h: *mut x264_t,
        mut size: ::core::ffi::c_int,
        mut x: ::core::ffi::c_int,
        mut y: ::core::ffi::c_int,
    ) -> uint64_t {
        pub static mut hadamard_shift_x: [uint8_t; 4] = [
            4 as ::core::ffi::c_int as uint8_t,
            4 as ::core::ffi::c_int as uint8_t,
            3 as ::core::ffi::c_int as uint8_t,
            3 as ::core::ffi::c_int as uint8_t,
        ];
        pub static mut hadamard_shift_y: [uint8_t; 4] = [
            (4 as ::core::ffi::c_int - 0 as ::core::ffi::c_int) as uint8_t,
            (3 as ::core::ffi::c_int - 0 as ::core::ffi::c_int) as uint8_t,
            (4 as ::core::ffi::c_int - 1 as ::core::ffi::c_int) as uint8_t,
            (3 as ::core::ffi::c_int - 1 as ::core::ffi::c_int) as uint8_t,
        ];
        pub static mut hadamard_offset: [uint8_t; 4] = [
            0 as ::core::ffi::c_int as uint8_t,
            1 as ::core::ffi::c_int as uint8_t,
            3 as ::core::ffi::c_int as uint8_t,
            5 as ::core::ffi::c_int as uint8_t,
        ];
        let mut cache_index: ::core::ffi::c_int = (x
            >> hadamard_shift_x[size as usize] as ::core::ffi::c_int)
            + (y >> hadamard_shift_y[size as usize] as ::core::ffi::c_int)
            + hadamard_offset[size as usize] as ::core::ffi::c_int;
        let mut res: uint64_t = (*h).mb.pic.fenc_hadamard_cache[cache_index as usize];
        if res != 0 {
            return res.wrapping_sub(1 as uint64_t);
        } else {
            let mut fenc: *mut pixel = (*h).mb.pic.p_fenc[0 as ::core::ffi::c_int as usize]
                .offset(x as isize)
                .offset((y * FENC_STRIDE) as isize);
            res = (*h).pixf.hadamard_ac[size as usize].expect("non-null function pointer")(
                fenc,
                FENC_STRIDE as intptr_t,
            );
            (*h).mb.pic.fenc_hadamard_cache[cache_index as usize] = res.wrapping_add(1 as uint64_t);
            return res;
        };
    }
    #[inline(always)]
    #[c2rust::src_loc = "94:1"]
    pub unsafe extern "C" fn cached_satd(
        mut h: *mut x264_t,
        mut size: ::core::ffi::c_int,
        mut x: ::core::ffi::c_int,
        mut y: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int {
        pub static mut satd_shift_x: [uint8_t; 3] = [
            3 as ::core::ffi::c_int as uint8_t,
            2 as ::core::ffi::c_int as uint8_t,
            2 as ::core::ffi::c_int as uint8_t,
        ];
        pub static mut satd_shift_y: [uint8_t; 3] = [
            (2 as ::core::ffi::c_int - 1 as ::core::ffi::c_int) as uint8_t,
            (3 as ::core::ffi::c_int - 2 as ::core::ffi::c_int) as uint8_t,
            (2 as ::core::ffi::c_int - 2 as ::core::ffi::c_int) as uint8_t,
        ];
        pub static mut satd_offset: [uint8_t; 3] = [
            0 as ::core::ffi::c_int as uint8_t,
            8 as ::core::ffi::c_int as uint8_t,
            16 as ::core::ffi::c_int as uint8_t,
        ];
        let mut cache_index: ::core::ffi::c_int = (x
            >> satd_shift_x[(size - PIXEL_8x4 as ::core::ffi::c_int) as usize]
                as ::core::ffi::c_int)
            + (y >> satd_shift_y[(size - PIXEL_8x4 as ::core::ffi::c_int) as usize]
                as ::core::ffi::c_int)
            + satd_offset[(size - PIXEL_8x4 as ::core::ffi::c_int) as usize] as ::core::ffi::c_int;
        let mut res: ::core::ffi::c_int =
            (*h).mb.pic.fenc_satd_cache[cache_index as usize] as ::core::ffi::c_int;
        if res != 0 {
            return res - 1 as ::core::ffi::c_int;
        } else {
            let mut fenc: *mut pixel = (*h).mb.pic.p_fenc[0 as ::core::ffi::c_int as usize]
                .offset(x as isize)
                .offset((y * FENC_STRIDE) as isize);
            let mut dc: ::core::ffi::c_int = (*h).pixf.sad[size as usize]
                .expect("non-null function pointer")(
                fenc,
                FENC_STRIDE as intptr_t,
                x264_zero.as_mut_ptr() as *mut pixel,
                0 as intptr_t,
            ) >> 1 as ::core::ffi::c_int;
            res = (*h).pixf.satd[size as usize].expect("non-null function pointer")(
                fenc,
                FENC_STRIDE as intptr_t,
                x264_zero.as_mut_ptr() as *mut pixel,
                0 as intptr_t,
            ) - dc;
            (*h).mb.pic.fenc_satd_cache[cache_index as usize] =
                (res + 1 as ::core::ffi::c_int) as uint32_t;
            return res;
        };
    }
    #[inline]
    #[c2rust::src_loc = "123:1"]
    pub unsafe extern "C" fn ssd_plane(
        mut h: *mut x264_t,
        mut size: ::core::ffi::c_int,
        mut p: ::core::ffi::c_int,
        mut x: ::core::ffi::c_int,
        mut y: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int {
        let mut satd: ::core::ffi::c_int = 0 as ::core::ffi::c_int;
        let mut fdec: *mut pixel = (*h).mb.pic.p_fdec[p as usize]
            .offset(x as isize)
            .offset((y * FDEC_STRIDE) as isize);
        let mut fenc: *mut pixel = (*h).mb.pic.p_fenc[p as usize]
            .offset(x as isize)
            .offset((y * FENC_STRIDE) as isize);
        if p == 0 as ::core::ffi::c_int && (*h).mb.i_psy_rd != 0 {
            if size <= PIXEL_8x8 as ::core::ffi::c_int {
                let mut fdec_acs: uint64_t = (*h).pixf.hadamard_ac[size as usize]
                    .expect("non-null function pointer")(
                    fdec, FDEC_STRIDE as intptr_t
                );
                let mut fenc_acs: uint64_t = cached_hadamard(h, size, x, y);
                satd = abs(fdec_acs as ::core::ffi::c_int - fenc_acs as ::core::ffi::c_int)
                    + abs((fdec_acs >> 32 as ::core::ffi::c_int) as ::core::ffi::c_int
                        - (fenc_acs >> 32 as ::core::ffi::c_int) as ::core::ffi::c_int);
                satd >>= 1 as ::core::ffi::c_int;
            } else {
                let mut dc: ::core::ffi::c_int = (*h).pixf.sad[size as usize]
                    .expect("non-null function pointer")(
                    fdec,
                    FDEC_STRIDE as intptr_t,
                    x264_zero.as_mut_ptr() as *mut pixel,
                    0 as intptr_t,
                ) >> 1 as ::core::ffi::c_int;
                satd = abs(
                    (*h).pixf.satd[size as usize].expect("non-null function pointer")(
                        fdec,
                        FDEC_STRIDE as intptr_t,
                        x264_zero.as_mut_ptr() as *mut pixel,
                        0 as intptr_t,
                    ) - dc
                        - cached_satd(h, size, x, y),
                );
            }
            let mut tmp: int64_t =
                satd as int64_t * (*h).mb.i_psy_rd as int64_t * (*h).mb.i_psy_rd_lambda as int64_t
                    + 128 as int64_t
                    >> 8 as ::core::ffi::c_int;
            satd = (if tmp < ((1 as ::core::ffi::c_int) << 28 as ::core::ffi::c_int) as int64_t {
                tmp
            } else {
                ((1 as ::core::ffi::c_int) << 28 as ::core::ffi::c_int) as int64_t
            }) as ::core::ffi::c_int;
        }
        return (*h).pixf.ssd[size as usize].expect("non-null function pointer")(
            fenc,
            FENC_STRIDE as intptr_t,
            fdec,
            FDEC_STRIDE as intptr_t,
        ) + satd;
    }
    #[inline]
    #[c2rust::src_loc = "150:1"]
    pub unsafe extern "C" fn ssd_mb(mut h: *mut x264_t) -> ::core::ffi::c_int {
        let mut i_ssd: ::core::ffi::c_int = ssd_plane(
            h,
            PIXEL_16x16 as ::core::ffi::c_int,
            0 as ::core::ffi::c_int,
            0 as ::core::ffi::c_int,
            0 as ::core::ffi::c_int,
        );
        if (*(*h).sps.as_mut_ptr()).i_chroma_format_idc != 0 {
            let mut chroma_size: ::core::ffi::c_int = (*h).luma2chroma_pixel
                [PIXEL_16x16 as ::core::ffi::c_int as usize]
                as ::core::ffi::c_int;
            let mut chroma_ssd: ::core::ffi::c_int = ssd_plane(
                h,
                chroma_size,
                1 as ::core::ffi::c_int,
                0 as ::core::ffi::c_int,
                0 as ::core::ffi::c_int,
            ) + ssd_plane(
                h,
                chroma_size,
                2 as ::core::ffi::c_int,
                0 as ::core::ffi::c_int,
                0 as ::core::ffi::c_int,
            );
            i_ssd = (i_ssd as uint64_t).wrapping_add(
                (chroma_ssd as uint64_t)
                    .wrapping_mul((*h).mb.i_chroma_lambda2_offset as uint64_t)
                    .wrapping_add(128 as uint64_t)
                    >> 8 as ::core::ffi::c_int,
            ) as ::core::ffi::c_int as ::core::ffi::c_int;
        }
        return i_ssd;
    }
    #[c2rust::src_loc = "162:1"]
    pub unsafe extern "C" fn rd_cost_mb(
        mut h: *mut x264_t,
        mut i_lambda2: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int {
        let mut b_transform_bak: ::core::ffi::c_int = (*h).mb.b_transform_8x8;
        let mut i_ssd: ::core::ffi::c_int = 0;
        let mut i_bits: ::core::ffi::c_int = 0;
        let mut type_bak: ::core::ffi::c_int = (*h).mb.i_type;
        x264_10_macroblock_encode(h);
        if (*h).mb.b_deblock_rdo != 0 {
            x264_10_macroblock_deblock(h);
        }
        i_ssd = ssd_mb(h);
        if (*h).mb.i_type == P_SKIP as ::core::ffi::c_int
            || (*h).mb.i_type == B_SKIP as ::core::ffi::c_int
        {
            i_bits = 1 as ::core::ffi::c_int * i_lambda2 + 128 as ::core::ffi::c_int
                >> 8 as ::core::ffi::c_int;
        } else if (*h).param.b_cabac != 0 {
            let mut cabac_tmp: x264_cabac_t = x264_cabac_t {
                i_low: 0,
                i_range: 0,
                i_queue: 0,
                i_bytes_outstanding: 0,
                p_start: 0 as *mut uint8_t,
                p: 0 as *mut uint8_t,
                p_end: 0 as *mut uint8_t,
                f8_bits_encoded: 0,
                state: [0; 1024],
                padding: [0; 12],
            };
            (*h).mc.memcpy_aligned.expect("non-null function pointer")(
                &mut cabac_tmp.f8_bits_encoded as *mut ::core::ffi::c_int
                    as *mut ::core::ffi::c_void,
                &mut (*h).cabac.f8_bits_encoded as *mut ::core::ffi::c_int
                    as *const ::core::ffi::c_void,
                (::core::mem::size_of::<::core::ffi::c_int>() as size_t).wrapping_add(
                    (if (*(*h).sps.as_mut_ptr()).i_chroma_format_idc
                        == CHROMA_444 as ::core::ffi::c_int
                    {
                        1024 as ::core::ffi::c_int + 12 as ::core::ffi::c_int
                    } else {
                        460 as ::core::ffi::c_int
                    }) as size_t,
                ),
            );
            macroblock_size_cabac(h, &mut cabac_tmp);
            i_bits = ((cabac_tmp.f8_bits_encoded as uint64_t)
                .wrapping_mul(i_lambda2 as uint64_t)
                .wrapping_add(32768 as uint64_t)
                >> 16 as ::core::ffi::c_int) as ::core::ffi::c_int;
        } else {
            macroblock_size_cavlc(h);
            i_bits = (((*h).out.bs.i_bits_encoded as uint64_t)
                .wrapping_mul(i_lambda2 as uint64_t)
                .wrapping_add(128 as uint64_t)
                >> 8 as ::core::ffi::c_int) as ::core::ffi::c_int;
        }
        (*h).mb.b_transform_8x8 = b_transform_bak;
        (*h).mb.i_type = type_bak;
        return if i_ssd + i_bits < (1 as ::core::ffi::c_int) << 28 as ::core::ffi::c_int {
            i_ssd + i_bits
        } else {
            (1 as ::core::ffi::c_int) << 28 as ::core::ffi::c_int
        };
    }
    #[c2rust::src_loc = "201:1"]
    pub unsafe extern "C" fn rd_cost_subpart(
        mut h: *mut x264_t,
        mut i_lambda2: ::core::ffi::c_int,
        mut i4: ::core::ffi::c_int,
        mut i_pixel: ::core::ffi::c_int,
    ) -> uint64_t {
        let mut i_ssd: uint64_t = 0;
        let mut i_bits: uint64_t = 0;
        x264_10_macroblock_encode_p4x4(h, i4);
        if i_pixel == PIXEL_8x4 as ::core::ffi::c_int {
            x264_10_macroblock_encode_p4x4(h, i4 + 1 as ::core::ffi::c_int);
        }
        if i_pixel == PIXEL_4x8 as ::core::ffi::c_int {
            x264_10_macroblock_encode_p4x4(h, i4 + 2 as ::core::ffi::c_int);
        }
        i_ssd = ssd_plane(
            h,
            i_pixel,
            0 as ::core::ffi::c_int,
            block_idx_x[i4 as usize] as ::core::ffi::c_int * 4 as ::core::ffi::c_int,
            block_idx_y[i4 as usize] as ::core::ffi::c_int * 4 as ::core::ffi::c_int,
        ) as uint64_t;
        if (*(*h).sps.as_mut_ptr()).i_chroma_format_idc == CHROMA_444 as ::core::ffi::c_int {
            let mut chromassd: ::core::ffi::c_int = ssd_plane(
                h,
                i_pixel,
                1 as ::core::ffi::c_int,
                block_idx_x[i4 as usize] as ::core::ffi::c_int * 4 as ::core::ffi::c_int,
                block_idx_y[i4 as usize] as ::core::ffi::c_int * 4 as ::core::ffi::c_int,
            ) + ssd_plane(
                h,
                i_pixel,
                2 as ::core::ffi::c_int,
                block_idx_x[i4 as usize] as ::core::ffi::c_int * 4 as ::core::ffi::c_int,
                block_idx_y[i4 as usize] as ::core::ffi::c_int * 4 as ::core::ffi::c_int,
            );
            chromassd = ((chromassd as uint64_t)
                .wrapping_mul((*h).mb.i_chroma_lambda2_offset as uint64_t)
                .wrapping_add(128 as uint64_t)
                >> 8 as ::core::ffi::c_int) as ::core::ffi::c_int;
            i_ssd = i_ssd.wrapping_add(chromassd as uint64_t);
        }
        if (*h).param.b_cabac != 0 {
            let mut cabac_tmp: x264_cabac_t = x264_cabac_t {
                i_low: 0,
                i_range: 0,
                i_queue: 0,
                i_bytes_outstanding: 0,
                p_start: 0 as *mut uint8_t,
                p: 0 as *mut uint8_t,
                p_end: 0 as *mut uint8_t,
                f8_bits_encoded: 0,
                state: [0; 1024],
                padding: [0; 12],
            };
            (*h).mc.memcpy_aligned.expect("non-null function pointer")(
                &mut cabac_tmp.f8_bits_encoded as *mut ::core::ffi::c_int
                    as *mut ::core::ffi::c_void,
                &mut (*h).cabac.f8_bits_encoded as *mut ::core::ffi::c_int
                    as *const ::core::ffi::c_void,
                (::core::mem::size_of::<::core::ffi::c_int>() as size_t).wrapping_add(
                    (if (*(*h).sps.as_mut_ptr()).i_chroma_format_idc
                        == CHROMA_444 as ::core::ffi::c_int
                    {
                        1024 as ::core::ffi::c_int + 12 as ::core::ffi::c_int
                    } else {
                        460 as ::core::ffi::c_int
                    }) as size_t,
                ),
            );
            subpartition_size_cabac(h, &mut cabac_tmp, i4, i_pixel);
            i_bits = (cabac_tmp.f8_bits_encoded as uint64_t)
                .wrapping_mul(i_lambda2 as uint64_t)
                .wrapping_add(128 as uint64_t)
                >> 8 as ::core::ffi::c_int;
        } else {
            i_bits = subpartition_size_cavlc(h, i4, i_pixel) as uint64_t;
        }
        return (i_ssd << 8 as ::core::ffi::c_int).wrapping_add(i_bits);
    }
    #[no_mangle]
    #[c2rust::src_loc = "233:1"]
    pub unsafe extern "C" fn x264_10_rd_cost_part(
        mut h: *mut x264_t,
        mut i_lambda2: ::core::ffi::c_int,
        mut i4: ::core::ffi::c_int,
        mut i_pixel: ::core::ffi::c_int,
    ) -> uint64_t {
        let mut i_ssd: uint64_t = 0;
        let mut i_bits: uint64_t = 0;
        let mut i8: ::core::ffi::c_int = i4 >> 2 as ::core::ffi::c_int;
        if i_pixel == PIXEL_16x16 as ::core::ffi::c_int {
            let mut i_cost: ::core::ffi::c_int = rd_cost_mb(h, i_lambda2);
            return i_cost as uint64_t;
        }
        if i_pixel > PIXEL_8x8 as ::core::ffi::c_int {
            return rd_cost_subpart(h, i_lambda2, i4, i_pixel);
        }
        (*h).mb.i_cbp_luma = 0 as ::core::ffi::c_int;
        x264_10_macroblock_encode_p8x8(h, i8);
        if i_pixel == PIXEL_16x8 as ::core::ffi::c_int {
            x264_10_macroblock_encode_p8x8(h, i8 + 1 as ::core::ffi::c_int);
        }
        if i_pixel == PIXEL_8x16 as ::core::ffi::c_int {
            x264_10_macroblock_encode_p8x8(h, i8 + 2 as ::core::ffi::c_int);
        }
        let mut ssd_x: ::core::ffi::c_int =
            8 as ::core::ffi::c_int * (i8 & 1 as ::core::ffi::c_int);
        let mut ssd_y: ::core::ffi::c_int =
            8 as ::core::ffi::c_int * (i8 >> 1 as ::core::ffi::c_int);
        i_ssd = ssd_plane(h, i_pixel, 0 as ::core::ffi::c_int, ssd_x, ssd_y) as uint64_t;
        if (*(*h).sps.as_mut_ptr()).i_chroma_format_idc != 0 {
            let mut chroma_size: ::core::ffi::c_int =
                (*h).luma2chroma_pixel[i_pixel as usize] as ::core::ffi::c_int;
            let mut chroma_ssd: ::core::ffi::c_int = ssd_plane(
                h,
                chroma_size,
                1 as ::core::ffi::c_int,
                ssd_x >> (*h).mb.chroma_h_shift,
                ssd_y >> (*h).mb.chroma_v_shift,
            ) + ssd_plane(
                h,
                chroma_size,
                2 as ::core::ffi::c_int,
                ssd_x >> (*h).mb.chroma_h_shift,
                ssd_y >> (*h).mb.chroma_v_shift,
            );
            i_ssd = i_ssd.wrapping_add(
                (chroma_ssd as uint64_t)
                    .wrapping_mul((*h).mb.i_chroma_lambda2_offset as uint64_t)
                    .wrapping_add(128 as uint64_t)
                    >> 8 as ::core::ffi::c_int,
            );
        }
        if (*h).param.b_cabac != 0 {
            let mut cabac_tmp: x264_cabac_t = x264_cabac_t {
                i_low: 0,
                i_range: 0,
                i_queue: 0,
                i_bytes_outstanding: 0,
                p_start: 0 as *mut uint8_t,
                p: 0 as *mut uint8_t,
                p_end: 0 as *mut uint8_t,
                f8_bits_encoded: 0,
                state: [0; 1024],
                padding: [0; 12],
            };
            (*h).mc.memcpy_aligned.expect("non-null function pointer")(
                &mut cabac_tmp.f8_bits_encoded as *mut ::core::ffi::c_int
                    as *mut ::core::ffi::c_void,
                &mut (*h).cabac.f8_bits_encoded as *mut ::core::ffi::c_int
                    as *const ::core::ffi::c_void,
                (::core::mem::size_of::<::core::ffi::c_int>() as size_t).wrapping_add(
                    (if (*(*h).sps.as_mut_ptr()).i_chroma_format_idc
                        == CHROMA_444 as ::core::ffi::c_int
                    {
                        1024 as ::core::ffi::c_int + 12 as ::core::ffi::c_int
                    } else {
                        460 as ::core::ffi::c_int
                    }) as size_t,
                ),
            );
            partition_size_cabac(h, &mut cabac_tmp, i8, i_pixel);
            i_bits = (cabac_tmp.f8_bits_encoded as uint64_t)
                .wrapping_mul(i_lambda2 as uint64_t)
                .wrapping_add(128 as uint64_t)
                >> 8 as ::core::ffi::c_int;
        } else {
            i_bits = (partition_size_cavlc(h, i8, i_pixel) as uint64_t)
                .wrapping_mul(i_lambda2 as uint64_t);
        }
        return (i_ssd << 8 as ::core::ffi::c_int).wrapping_add(i_bits);
    }
    #[c2rust::src_loc = "279:1"]
    pub unsafe extern "C" fn rd_cost_i8x8(
        mut h: *mut x264_t,
        mut i_lambda2: ::core::ffi::c_int,
        mut i8: ::core::ffi::c_int,
        mut i_mode: ::core::ffi::c_int,
        mut edge: *mut [pixel; 32],
    ) -> uint64_t {
        let mut i_ssd: uint64_t = 0;
        let mut i_bits: uint64_t = 0;
        let mut plane_count: ::core::ffi::c_int =
            if (*(*h).sps.as_mut_ptr()).i_chroma_format_idc == CHROMA_444 as ::core::ffi::c_int {
                3 as ::core::ffi::c_int
            } else {
                1 as ::core::ffi::c_int
            };
        let mut i_qp: ::core::ffi::c_int = (*h).mb.i_qp;
        (*h).mb.i_cbp_luma &= !((1 as ::core::ffi::c_int) << i8);
        (*h).mb.b_transform_8x8 = 1 as ::core::ffi::c_int;
        let mut p: ::core::ffi::c_int = 0 as ::core::ffi::c_int;
        while p < plane_count {
            x264_mb_encode_i8x8(
                h,
                p,
                i8,
                i_qp,
                i_mode,
                (*edge.offset(p as isize)).as_mut_ptr(),
                1 as ::core::ffi::c_int,
            );
            i_qp = (*h).mb.i_chroma_qp;
            p += 1;
        }
        i_ssd = ssd_plane(
            h,
            PIXEL_8x8 as ::core::ffi::c_int,
            0 as ::core::ffi::c_int,
            (i8 & 1 as ::core::ffi::c_int) * 8 as ::core::ffi::c_int,
            (i8 >> 1 as ::core::ffi::c_int) * 8 as ::core::ffi::c_int,
        ) as uint64_t;
        if (*(*h).sps.as_mut_ptr()).i_chroma_format_idc == CHROMA_444 as ::core::ffi::c_int {
            let mut chromassd: ::core::ffi::c_int = ssd_plane(
                h,
                PIXEL_8x8 as ::core::ffi::c_int,
                1 as ::core::ffi::c_int,
                (i8 & 1 as ::core::ffi::c_int) * 8 as ::core::ffi::c_int,
                (i8 >> 1 as ::core::ffi::c_int) * 8 as ::core::ffi::c_int,
            ) + ssd_plane(
                h,
                PIXEL_8x8 as ::core::ffi::c_int,
                2 as ::core::ffi::c_int,
                (i8 & 1 as ::core::ffi::c_int) * 8 as ::core::ffi::c_int,
                (i8 >> 1 as ::core::ffi::c_int) * 8 as ::core::ffi::c_int,
            );
            chromassd = ((chromassd as uint64_t)
                .wrapping_mul((*h).mb.i_chroma_lambda2_offset as uint64_t)
                .wrapping_add(128 as uint64_t)
                >> 8 as ::core::ffi::c_int) as ::core::ffi::c_int;
            i_ssd = i_ssd.wrapping_add(chromassd as uint64_t);
        }
        if (*h).param.b_cabac != 0 {
            let mut cabac_tmp: x264_cabac_t = x264_cabac_t {
                i_low: 0,
                i_range: 0,
                i_queue: 0,
                i_bytes_outstanding: 0,
                p_start: 0 as *mut uint8_t,
                p: 0 as *mut uint8_t,
                p_end: 0 as *mut uint8_t,
                f8_bits_encoded: 0,
                state: [0; 1024],
                padding: [0; 12],
            };
            (*h).mc.memcpy_aligned.expect("non-null function pointer")(
                &mut cabac_tmp.f8_bits_encoded as *mut ::core::ffi::c_int
                    as *mut ::core::ffi::c_void,
                &mut (*h).cabac.f8_bits_encoded as *mut ::core::ffi::c_int
                    as *const ::core::ffi::c_void,
                (::core::mem::size_of::<::core::ffi::c_int>() as size_t).wrapping_add(
                    (if (*(*h).sps.as_mut_ptr()).i_chroma_format_idc
                        == CHROMA_444 as ::core::ffi::c_int
                    {
                        1024 as ::core::ffi::c_int + 12 as ::core::ffi::c_int
                    } else {
                        460 as ::core::ffi::c_int
                    }) as size_t,
                ),
            );
            partition_i8x8_size_cabac(h, &mut cabac_tmp, i8, i_mode);
            i_bits = (cabac_tmp.f8_bits_encoded as uint64_t)
                .wrapping_mul(i_lambda2 as uint64_t)
                .wrapping_add(128 as uint64_t)
                >> 8 as ::core::ffi::c_int;
        } else {
            i_bits = (partition_i8x8_size_cavlc(h, i8, i_mode) as uint64_t)
                .wrapping_mul(i_lambda2 as uint64_t);
        }
        return (i_ssd << 8 as ::core::ffi::c_int).wrapping_add(i_bits);
    }
    #[c2rust::src_loc = "315:1"]
    pub unsafe extern "C" fn rd_cost_i4x4(
        mut h: *mut x264_t,
        mut i_lambda2: ::core::ffi::c_int,
        mut i4: ::core::ffi::c_int,
        mut i_mode: ::core::ffi::c_int,
    ) -> uint64_t {
        let mut i_ssd: uint64_t = 0;
        let mut i_bits: uint64_t = 0;
        let mut plane_count: ::core::ffi::c_int =
            if (*(*h).sps.as_mut_ptr()).i_chroma_format_idc == CHROMA_444 as ::core::ffi::c_int {
                3 as ::core::ffi::c_int
            } else {
                1 as ::core::ffi::c_int
            };
        let mut i_qp: ::core::ffi::c_int = (*h).mb.i_qp;
        let mut p: ::core::ffi::c_int = 0 as ::core::ffi::c_int;
        while p < plane_count {
            x264_mb_encode_i4x4(h, p, i4, i_qp, i_mode, 1 as ::core::ffi::c_int);
            i_qp = (*h).mb.i_chroma_qp;
            p += 1;
        }
        i_ssd = ssd_plane(
            h,
            PIXEL_4x4 as ::core::ffi::c_int,
            0 as ::core::ffi::c_int,
            block_idx_x[i4 as usize] as ::core::ffi::c_int * 4 as ::core::ffi::c_int,
            block_idx_y[i4 as usize] as ::core::ffi::c_int * 4 as ::core::ffi::c_int,
        ) as uint64_t;
        if (*(*h).sps.as_mut_ptr()).i_chroma_format_idc == CHROMA_444 as ::core::ffi::c_int {
            let mut chromassd: ::core::ffi::c_int = ssd_plane(
                h,
                PIXEL_4x4 as ::core::ffi::c_int,
                1 as ::core::ffi::c_int,
                block_idx_x[i4 as usize] as ::core::ffi::c_int * 4 as ::core::ffi::c_int,
                block_idx_y[i4 as usize] as ::core::ffi::c_int * 4 as ::core::ffi::c_int,
            ) + ssd_plane(
                h,
                PIXEL_4x4 as ::core::ffi::c_int,
                2 as ::core::ffi::c_int,
                block_idx_x[i4 as usize] as ::core::ffi::c_int * 4 as ::core::ffi::c_int,
                block_idx_y[i4 as usize] as ::core::ffi::c_int * 4 as ::core::ffi::c_int,
            );
            chromassd = ((chromassd as uint64_t)
                .wrapping_mul((*h).mb.i_chroma_lambda2_offset as uint64_t)
                .wrapping_add(128 as uint64_t)
                >> 8 as ::core::ffi::c_int) as ::core::ffi::c_int;
            i_ssd = i_ssd.wrapping_add(chromassd as uint64_t);
        }
        if (*h).param.b_cabac != 0 {
            let mut cabac_tmp: x264_cabac_t = x264_cabac_t {
                i_low: 0,
                i_range: 0,
                i_queue: 0,
                i_bytes_outstanding: 0,
                p_start: 0 as *mut uint8_t,
                p: 0 as *mut uint8_t,
                p_end: 0 as *mut uint8_t,
                f8_bits_encoded: 0,
                state: [0; 1024],
                padding: [0; 12],
            };
            (*h).mc.memcpy_aligned.expect("non-null function pointer")(
                &mut cabac_tmp.f8_bits_encoded as *mut ::core::ffi::c_int
                    as *mut ::core::ffi::c_void,
                &mut (*h).cabac.f8_bits_encoded as *mut ::core::ffi::c_int
                    as *const ::core::ffi::c_void,
                (::core::mem::size_of::<::core::ffi::c_int>() as size_t).wrapping_add(
                    (if (*(*h).sps.as_mut_ptr()).i_chroma_format_idc
                        == CHROMA_444 as ::core::ffi::c_int
                    {
                        1024 as ::core::ffi::c_int + 12 as ::core::ffi::c_int
                    } else {
                        460 as ::core::ffi::c_int
                    }) as size_t,
                ),
            );
            partition_i4x4_size_cabac(h, &mut cabac_tmp, i4, i_mode);
            i_bits = (cabac_tmp.f8_bits_encoded as uint64_t)
                .wrapping_mul(i_lambda2 as uint64_t)
                .wrapping_add(128 as uint64_t)
                >> 8 as ::core::ffi::c_int;
        } else {
            i_bits = (partition_i4x4_size_cavlc(h, i4, i_mode) as uint64_t)
                .wrapping_mul(i_lambda2 as uint64_t);
        }
        return (i_ssd << 8 as ::core::ffi::c_int).wrapping_add(i_bits);
    }
    #[c2rust::src_loc = "349:1"]
    pub unsafe extern "C" fn rd_cost_chroma(
        mut h: *mut x264_t,
        mut i_lambda2: ::core::ffi::c_int,
        mut i_mode: ::core::ffi::c_int,
        mut b_dct: ::core::ffi::c_int,
    ) -> uint64_t {
        let mut i_ssd: uint64_t = 0;
        let mut i_bits: uint64_t = 0;
        if b_dct != 0 {
            x264_10_mb_encode_chroma(h, 0 as ::core::ffi::c_int, (*h).mb.i_chroma_qp);
        }
        let mut chromapix: ::core::ffi::c_int = (*h).luma2chroma_pixel
            [PIXEL_16x16 as ::core::ffi::c_int as usize]
            as ::core::ffi::c_int;
        i_ssd = (ssd_plane(
            h,
            chromapix,
            1 as ::core::ffi::c_int,
            0 as ::core::ffi::c_int,
            0 as ::core::ffi::c_int,
        ) + ssd_plane(
            h,
            chromapix,
            2 as ::core::ffi::c_int,
            0 as ::core::ffi::c_int,
            0 as ::core::ffi::c_int,
        )) as uint64_t;
        (*h).mb.i_chroma_pred_mode = i_mode;
        if (*h).param.b_cabac != 0 {
            let mut cabac_tmp: x264_cabac_t = x264_cabac_t {
                i_low: 0,
                i_range: 0,
                i_queue: 0,
                i_bytes_outstanding: 0,
                p_start: 0 as *mut uint8_t,
                p: 0 as *mut uint8_t,
                p_end: 0 as *mut uint8_t,
                f8_bits_encoded: 0,
                state: [0; 1024],
                padding: [0; 12],
            };
            (*h).mc.memcpy_aligned.expect("non-null function pointer")(
                &mut cabac_tmp.f8_bits_encoded as *mut ::core::ffi::c_int
                    as *mut ::core::ffi::c_void,
                &mut (*h).cabac.f8_bits_encoded as *mut ::core::ffi::c_int
                    as *const ::core::ffi::c_void,
                (::core::mem::size_of::<::core::ffi::c_int>() as size_t).wrapping_add(
                    (if (*(*h).sps.as_mut_ptr()).i_chroma_format_idc
                        == CHROMA_444 as ::core::ffi::c_int
                    {
                        1024 as ::core::ffi::c_int + 12 as ::core::ffi::c_int
                    } else {
                        460 as ::core::ffi::c_int
                    }) as size_t,
                ),
            );
            chroma_size_cabac(h, &mut cabac_tmp);
            i_bits = (cabac_tmp.f8_bits_encoded as uint64_t)
                .wrapping_mul(i_lambda2 as uint64_t)
                .wrapping_add(128 as uint64_t)
                >> 8 as ::core::ffi::c_int;
        } else {
            i_bits = (chroma_size_cavlc(h) as uint64_t).wrapping_mul(i_lambda2 as uint64_t);
        }
        return (i_ssd << 8 as ::core::ffi::c_int).wrapping_add(i_bits);
    }
    #[c2rust::src_loc = "378:9"]
    pub const TRELLIS_SCORE_MAX: ::core::ffi::c_ulonglong = !(0 as ::core::ffi::c_ulonglong);
    #[c2rust::src_loc = "379:9"]
    pub const TRELLIS_SCORE_BIAS: ::core::ffi::c_ulonglong =
        (1 as ::core::ffi::c_ulonglong) << 60 as ::core::ffi::c_int;
    #[c2rust::src_loc = "380:9"]
    pub const CABAC_SIZE_BITS: ::core::ffi::c_int = 8 as ::core::ffi::c_int;
    #[c2rust::src_loc = "381:9"]
    pub const LAMBDA_BITS: ::core::ffi::c_int = 4 as ::core::ffi::c_int;
    #[no_mangle]
    #[c2rust::src_loc = "384:1"]
    pub unsafe extern "C" fn x264_10_rdo_init() {
        let mut i_prefix: ::core::ffi::c_int = 0 as ::core::ffi::c_int;
        while i_prefix < 15 as ::core::ffi::c_int {
            let mut i_ctx: ::core::ffi::c_int = 0 as ::core::ffi::c_int;
            while i_ctx < 128 as ::core::ffi::c_int {
                let mut f8_bits: ::core::ffi::c_int = 0 as ::core::ffi::c_int;
                let mut ctx: uint8_t = i_ctx as uint8_t;
                let mut i: ::core::ffi::c_int = 1 as ::core::ffi::c_int;
                while i < i_prefix {
                    f8_bits += x264_cabac_size_decision2(&mut ctx, 1 as ::core::ffi::c_long);
                    i += 1;
                }
                if i_prefix > 0 as ::core::ffi::c_int && i_prefix < 14 as ::core::ffi::c_int {
                    f8_bits += x264_cabac_size_decision2(&mut ctx, 0 as ::core::ffi::c_long);
                }
                f8_bits += (1 as ::core::ffi::c_int) << CABAC_SIZE_BITS;
                x264_10_cabac_size_unary[i_prefix as usize][i_ctx as usize] = f8_bits as uint16_t;
                x264_10_cabac_transition_unary[i_prefix as usize][i_ctx as usize] = ctx;
                i_ctx += 1;
            }
            i_prefix += 1;
        }
        let mut i_ctx_0: ::core::ffi::c_int = 0 as ::core::ffi::c_int;
        while i_ctx_0 < 128 as ::core::ffi::c_int {
            let mut f8_bits_0: ::core::ffi::c_int = 0 as ::core::ffi::c_int;
            let mut ctx_0: uint8_t = i_ctx_0 as uint8_t;
            let mut i_0: ::core::ffi::c_int = 0 as ::core::ffi::c_int;
            while i_0 < 5 as ::core::ffi::c_int {
                f8_bits_0 += x264_cabac_size_decision2(&mut ctx_0, 1 as ::core::ffi::c_long);
                i_0 += 1;
            }
            f8_bits_0 += (1 as ::core::ffi::c_int) << CABAC_SIZE_BITS;
            cabac_size_5ones[i_ctx_0 as usize] = f8_bits_0 as uint16_t;
            cabac_transition_5ones[i_ctx_0 as usize] = ctx_0;
            i_ctx_0 += 1;
        }
    }
    #[inline(never)]
    #[c2rust::src_loc = "462:1"]
    pub unsafe extern "C" fn trellis_dc_shortcut(
        mut sign_coef: ::core::ffi::c_int,
        mut quant_coef: ::core::ffi::c_int,
        mut unquant_mf: ::core::ffi::c_int,
        mut coef_weight: ::core::ffi::c_int,
        mut lambda2: ::core::ffi::c_int,
        mut cabac_state: *mut uint8_t,
        mut cost_sig: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int {
        let mut bscore: uint64_t = TRELLIS_SCORE_MAX as uint64_t;
        let mut ret: ::core::ffi::c_int = 0 as ::core::ffi::c_int;
        let mut q: ::core::ffi::c_int = abs(quant_coef);
        let mut abs_level: ::core::ffi::c_int = q - 1 as ::core::ffi::c_int;
        while abs_level <= q {
            let mut unquant_abs_level: ::core::ffi::c_int =
                unquant_mf * abs_level + 128 as ::core::ffi::c_int >> 8 as ::core::ffi::c_int;
            let mut d: ::core::ffi::c_int = sign_coef
                - ((unquant_abs_level ^ sign_coef >> 31 as ::core::ffi::c_int)
                    - (sign_coef >> 31 as ::core::ffi::c_int)
                    + 8 as ::core::ffi::c_int
                    & !(15 as ::core::ffi::c_int));
            let mut score: uint64_t =
                (d as int64_t * d as int64_t * coef_weight as int64_t) as uint64_t;
            if abs_level != 0 {
                let mut f8_bits: ::core::ffi::c_uint = cost_sig as ::core::ffi::c_uint;
                let mut prefix: ::core::ffi::c_int =
                    if (abs_level - 1 as ::core::ffi::c_int) < 14 as ::core::ffi::c_int {
                        abs_level - 1 as ::core::ffi::c_int
                    } else {
                        14 as ::core::ffi::c_int
                    };
                f8_bits = f8_bits.wrapping_add(x264_cabac_size_decision_noup2(
                    cabac_state.offset(1 as ::core::ffi::c_int as isize),
                    (prefix > 0 as ::core::ffi::c_int) as ::core::ffi::c_int as ::core::ffi::c_long,
                ) as ::core::ffi::c_uint);
                f8_bits = f8_bits.wrapping_add(
                    x264_10_cabac_size_unary[prefix as usize]
                        [*cabac_state.offset(5 as ::core::ffi::c_int as isize) as usize]
                        as ::core::ffi::c_uint,
                );
                if abs_level >= 15 as ::core::ffi::c_int {
                    f8_bits = f8_bits.wrapping_add(
                        (bs_size_ue_big(
                            (abs_level - 15 as ::core::ffi::c_int) as ::core::ffi::c_uint,
                        ) << CABAC_SIZE_BITS) as ::core::ffi::c_uint,
                    );
                }
                score = score.wrapping_add(
                    (f8_bits as uint64_t).wrapping_mul(lambda2 as uint64_t)
                        >> CABAC_SIZE_BITS - LAMBDA_BITS,
                );
            }
            if score < bscore {
                bscore = score;
                ret = abs_level;
            }
            abs_level += 1;
        }
        return (ret ^ sign_coef >> 31 as ::core::ffi::c_int)
            - (sign_coef >> 31 as ::core::ffi::c_int);
    }
    #[inline(always)]
    #[c2rust::src_loc = "494:1"]
    pub unsafe extern "C" fn trellis_coef(
        mut j: ::core::ffi::c_int,
        mut const_level: ::core::ffi::c_int,
        mut abs_level: ::core::ffi::c_int,
        mut prefix: ::core::ffi::c_int,
        mut suffix_cost: ::core::ffi::c_int,
        mut node_ctx: ::core::ffi::c_int,
        mut level1_ctx: ::core::ffi::c_int,
        mut levelgt1_ctx: ::core::ffi::c_int,
        mut ssd: uint64_t,
        mut cost_siglast: *mut ::core::ffi::c_int,
        mut nodes_cur: *mut trellis_node_t,
        mut nodes_prev: *mut trellis_node_t,
        mut level_tree: *mut trellis_level_t,
        mut levels_used: ::core::ffi::c_int,
        mut lambda2: ::core::ffi::c_int,
        mut level_state: *mut uint8_t,
    ) -> ::core::ffi::c_int {
        let mut score: uint64_t = (*nodes_prev.offset(j as isize)).score.wrapping_add(ssd);
        let mut f8_bits: ::core::ffi::c_uint = *cost_siglast.offset(
            (if j != 0 {
                1 as ::core::ffi::c_int
            } else {
                2 as ::core::ffi::c_int
            }) as isize,
        ) as ::core::ffi::c_uint;
        let mut level1_state: uint8_t = (if j >= 3 as ::core::ffi::c_int {
            (*nodes_prev.offset(j as isize)).cabac_state
                [(level1_ctx >> 2 as ::core::ffi::c_int) as usize] as ::core::ffi::c_int
        } else {
            *level_state.offset(level1_ctx as isize) as ::core::ffi::c_int
        }) as uint8_t;
        f8_bits = f8_bits.wrapping_add(
            x264_cabac_entropy[(level1_state as ::core::ffi::c_int
                ^ (const_level > 1 as ::core::ffi::c_int) as ::core::ffi::c_int)
                as usize] as ::core::ffi::c_uint,
        );
        let mut levelgt1_state: uint8_t = 0;
        if const_level > 1 as ::core::ffi::c_int {
            levelgt1_state = (if j >= 6 as ::core::ffi::c_int {
                (*nodes_prev.offset(j as isize)).cabac_state
                    [(levelgt1_ctx - 6 as ::core::ffi::c_int) as usize]
                    as ::core::ffi::c_int
            } else {
                *level_state.offset(levelgt1_ctx as isize) as ::core::ffi::c_int
            }) as uint8_t;
            f8_bits = f8_bits.wrapping_add(
                (x264_10_cabac_size_unary[prefix as usize][levelgt1_state as usize]
                    as ::core::ffi::c_int
                    + suffix_cost) as ::core::ffi::c_uint,
            );
        } else {
            f8_bits = f8_bits.wrapping_add(
                ((1 as ::core::ffi::c_int) << CABAC_SIZE_BITS) as ::core::ffi::c_uint,
            );
        }
        score = score.wrapping_add(
            (f8_bits as uint64_t).wrapping_mul(lambda2 as uint64_t)
                >> CABAC_SIZE_BITS - LAMBDA_BITS,
        );
        if score < (*nodes_cur.offset(node_ctx as isize)).score {
            (*nodes_cur.offset(node_ctx as isize)).score = score;
            if j == 2 as ::core::ffi::c_int
                || j <= 3 as ::core::ffi::c_int && node_ctx == 4 as ::core::ffi::c_int
            {
                (*((*nodes_cur.offset(node_ctx as isize))
                    .cabac_state
                    .as_mut_ptr() as *mut x264_union32_t))
                    .i = (*(level_state.offset(12 as ::core::ffi::c_int as isize)
                    as *mut x264_union32_t))
                    .i;
            } else if j >= 3 as ::core::ffi::c_int {
                (*((*nodes_cur.offset(node_ctx as isize))
                    .cabac_state
                    .as_mut_ptr() as *mut x264_union32_t))
                    .i = (*((*nodes_prev.offset(j as isize)).cabac_state.as_mut_ptr()
                    as *mut x264_union32_t))
                    .i;
            }
            if j >= 3 as ::core::ffi::c_int {
                (*nodes_cur.offset(node_ctx as isize)).cabac_state
                    [(level1_ctx >> 2 as ::core::ffi::c_int) as usize] = x264_cabac_transition
                    [level1_state as usize]
                    [(const_level > 1 as ::core::ffi::c_int) as ::core::ffi::c_int as usize];
            }
            if const_level > 1 as ::core::ffi::c_int && node_ctx == 7 as ::core::ffi::c_int {
                (*nodes_cur.offset(node_ctx as isize)).cabac_state
                    [(levelgt1_ctx - 6 as ::core::ffi::c_int) as usize] =
                    x264_10_cabac_transition_unary[prefix as usize][levelgt1_state as usize];
            }
            (*nodes_cur.offset(node_ctx as isize)).level_idx =
                (*nodes_prev.offset(j as isize)).level_idx;
            if ::core::mem::size_of::<trellis_level_t>() as usize
                == ::core::mem::size_of::<uint32_t>() as usize
            {
                (*(&mut *level_tree.offset(levels_used as isize) as *mut trellis_level_t
                    as *mut x264_union32_t))
                    .i = pack16to32(
                    (*nodes_prev.offset(j as isize)).level_idx as uint32_t,
                    abs_level as uint32_t,
                );
            } else {
                *level_tree.offset(levels_used as isize) = {
                    let mut init = trellis_level_t {
                        next: (*nodes_prev.offset(j as isize)).level_idx as uint16_t,
                        abs_level: abs_level as uint16_t,
                    };
                    init
                };
            }
            (*nodes_cur.offset(node_ctx as isize)).level_idx = levels_used;
            levels_used += 1;
        }
        return levels_used;
    }
    #[inline(never)]
    #[c2rust::src_loc = "537:1"]
    pub unsafe extern "C" fn trellis_coef0_0(
        mut ssd0: uint64_t,
        mut nodes_cur: *mut trellis_node_t,
        mut nodes_prev: *mut trellis_node_t,
        mut level_tree: *mut trellis_level_t,
        mut levels_used: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int {
        (*nodes_cur.offset(0 as ::core::ffi::c_int as isize)).score = (*nodes_prev
            .offset(0 as ::core::ffi::c_int as isize))
        .score
        .wrapping_add(ssd0);
        (*nodes_cur.offset(0 as ::core::ffi::c_int as isize)).level_idx =
            (*nodes_prev.offset(0 as ::core::ffi::c_int as isize)).level_idx;
        let mut j: ::core::ffi::c_int = 1 as ::core::ffi::c_int;
        while j < 4 as ::core::ffi::c_int
            && (*nodes_prev.offset(j as isize)).score as int64_t >= 0 as int64_t
        {
            (*nodes_cur.offset(j as isize)).score = (*nodes_prev.offset(j as isize)).score;
            if j >= 3 as ::core::ffi::c_int {
                (*((*nodes_cur.offset(j as isize)).cabac_state.as_mut_ptr()
                    as *mut x264_union32_t))
                    .i = (*((*nodes_prev.offset(j as isize)).cabac_state.as_mut_ptr()
                    as *mut x264_union32_t))
                    .i;
            }
            if ::core::mem::size_of::<trellis_level_t>() as usize
                == ::core::mem::size_of::<uint32_t>() as usize
            {
                (*(&mut *level_tree.offset(levels_used as isize) as *mut trellis_level_t
                    as *mut x264_union32_t))
                    .i = pack16to32(
                    (*nodes_prev.offset(j as isize)).level_idx as uint32_t,
                    0 as uint32_t,
                );
            } else {
                *level_tree.offset(levels_used as isize) = {
                    let mut init = trellis_level_t {
                        next: (*nodes_prev.offset(j as isize)).level_idx as uint16_t,
                        abs_level: 0 as uint16_t,
                    };
                    init
                };
            }
            (*nodes_cur.offset(j as isize)).level_idx = levels_used;
            levels_used += 1;
            j += 1;
        }
        return levels_used;
    }
    #[inline(never)]
    #[c2rust::src_loc = "553:1"]
    pub unsafe extern "C" fn trellis_coef0_1(
        mut ssd0: uint64_t,
        mut nodes_cur: *mut trellis_node_t,
        mut nodes_prev: *mut trellis_node_t,
        mut level_tree: *mut trellis_level_t,
        mut levels_used: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int {
        let mut j: ::core::ffi::c_int = 1 as ::core::ffi::c_int;
        while j < 8 as ::core::ffi::c_int {
            if (*nodes_prev.offset(j as isize)).score as int64_t >= 0 as int64_t {
                (*nodes_cur.offset(j as isize)).score = (*nodes_prev.offset(j as isize)).score;
                if j >= 3 as ::core::ffi::c_int {
                    (*((*nodes_cur.offset(j as isize)).cabac_state.as_mut_ptr()
                        as *mut x264_union32_t))
                        .i = (*((*nodes_prev.offset(j as isize)).cabac_state.as_mut_ptr()
                        as *mut x264_union32_t))
                        .i;
                }
                if ::core::mem::size_of::<trellis_level_t>() as usize
                    == ::core::mem::size_of::<uint32_t>() as usize
                {
                    (*(&mut *level_tree.offset(levels_used as isize) as *mut trellis_level_t
                        as *mut x264_union32_t))
                        .i = pack16to32(
                        (*nodes_prev.offset(j as isize)).level_idx as uint32_t,
                        0 as uint32_t,
                    );
                } else {
                    *level_tree.offset(levels_used as isize) = {
                        let mut init = trellis_level_t {
                            next: (*nodes_prev.offset(j as isize)).level_idx as uint16_t,
                            abs_level: 0 as uint16_t,
                        };
                        init
                    };
                }
                (*nodes_cur.offset(j as isize)).level_idx = levels_used;
                levels_used += 1;
            }
            j += 1;
        }
        return levels_used;
    }
    #[inline(never)]
    #[c2rust::src_loc = "577:1"]
    pub unsafe extern "C" fn trellis_coef1_0(
        mut ssd0: uint64_t,
        mut ssd1: uint64_t,
        mut cost_siglast: *mut ::core::ffi::c_int,
        mut nodes_cur: *mut trellis_node_t,
        mut nodes_prev: *mut trellis_node_t,
        mut level_tree: *mut trellis_level_t,
        mut levels_used: ::core::ffi::c_int,
        mut lambda2: ::core::ffi::c_int,
        mut level_state: *mut uint8_t,
    ) -> ::core::ffi::c_int {
        let mut abs_level: ::core::ffi::c_int = 1 as ::core::ffi::c_int;
        let mut prefix: ::core::ffi::c_int = 1 as ::core::ffi::c_int;
        let mut suffix_cost: ::core::ffi::c_int = 0 as ::core::ffi::c_int;
        if 0 as ::core::ffi::c_int == 0
            || (*nodes_prev.offset(0 as ::core::ffi::c_int as isize)).score as int64_t
                >= 0 as int64_t
        {
            levels_used = trellis_coef(
                0 as ::core::ffi::c_int,
                1 as ::core::ffi::c_int,
                abs_level,
                prefix,
                suffix_cost,
                1 as ::core::ffi::c_int,
                1 as ::core::ffi::c_int,
                0 as ::core::ffi::c_int,
                if 0 as ::core::ffi::c_int != 0 {
                    ssd1
                } else {
                    ssd0
                },
                cost_siglast,
                nodes_cur,
                nodes_prev,
                level_tree,
                levels_used,
                lambda2,
                level_state,
            );
        } else if 0 as ::core::ffi::c_int == 0 {
            return levels_used;
        }
        if 1 as ::core::ffi::c_int == 0
            || (*nodes_prev.offset(1 as ::core::ffi::c_int as isize)).score as int64_t
                >= 0 as int64_t
        {
            levels_used = trellis_coef(
                1 as ::core::ffi::c_int,
                1 as ::core::ffi::c_int,
                abs_level,
                prefix,
                suffix_cost,
                2 as ::core::ffi::c_int,
                2 as ::core::ffi::c_int,
                0 as ::core::ffi::c_int,
                if 1 as ::core::ffi::c_int != 0 {
                    ssd1
                } else {
                    ssd0
                },
                cost_siglast,
                nodes_cur,
                nodes_prev,
                level_tree,
                levels_used,
                lambda2,
                level_state,
            );
        } else if 0 as ::core::ffi::c_int == 0 {
            return levels_used;
        }
        if 2 as ::core::ffi::c_int == 0
            || (*nodes_prev.offset(2 as ::core::ffi::c_int as isize)).score as int64_t
                >= 0 as int64_t
        {
            levels_used = trellis_coef(
                2 as ::core::ffi::c_int,
                1 as ::core::ffi::c_int,
                abs_level,
                prefix,
                suffix_cost,
                3 as ::core::ffi::c_int,
                3 as ::core::ffi::c_int,
                0 as ::core::ffi::c_int,
                if 2 as ::core::ffi::c_int != 0 {
                    ssd1
                } else {
                    ssd0
                },
                cost_siglast,
                nodes_cur,
                nodes_prev,
                level_tree,
                levels_used,
                lambda2,
                level_state,
            );
        } else if 0 as ::core::ffi::c_int == 0 {
            return levels_used;
        }
        if 3 as ::core::ffi::c_int == 0
            || (*nodes_prev.offset(3 as ::core::ffi::c_int as isize)).score as int64_t
                >= 0 as int64_t
        {
            levels_used = trellis_coef(
                3 as ::core::ffi::c_int,
                1 as ::core::ffi::c_int,
                abs_level,
                prefix,
                suffix_cost,
                3 as ::core::ffi::c_int,
                4 as ::core::ffi::c_int,
                0 as ::core::ffi::c_int,
                if 3 as ::core::ffi::c_int != 0 {
                    ssd1
                } else {
                    ssd0
                },
                cost_siglast,
                nodes_cur,
                nodes_prev,
                level_tree,
                levels_used,
                lambda2,
                level_state,
            );
        } else if 0 as ::core::ffi::c_int == 0 {
            return levels_used;
        }
        return levels_used;
    }
    #[inline(never)]
    #[c2rust::src_loc = "591:1"]
    pub unsafe extern "C" fn trellis_coef1_1(
        mut ssd0: uint64_t,
        mut ssd1: uint64_t,
        mut cost_siglast: *mut ::core::ffi::c_int,
        mut nodes_cur: *mut trellis_node_t,
        mut nodes_prev: *mut trellis_node_t,
        mut level_tree: *mut trellis_level_t,
        mut levels_used: ::core::ffi::c_int,
        mut lambda2: ::core::ffi::c_int,
        mut level_state: *mut uint8_t,
    ) -> ::core::ffi::c_int {
        let mut abs_level: ::core::ffi::c_int = 1 as ::core::ffi::c_int;
        let mut prefix: ::core::ffi::c_int = 1 as ::core::ffi::c_int;
        let mut suffix_cost: ::core::ffi::c_int = 0 as ::core::ffi::c_int;
        if 1 as ::core::ffi::c_int == 0
            || (*nodes_prev.offset(1 as ::core::ffi::c_int as isize)).score as int64_t
                >= 0 as int64_t
        {
            levels_used = trellis_coef(
                1 as ::core::ffi::c_int,
                1 as ::core::ffi::c_int,
                abs_level,
                prefix,
                suffix_cost,
                2 as ::core::ffi::c_int,
                2 as ::core::ffi::c_int,
                0 as ::core::ffi::c_int,
                if 1 as ::core::ffi::c_int != 0 {
                    ssd1
                } else {
                    ssd0
                },
                cost_siglast,
                nodes_cur,
                nodes_prev,
                level_tree,
                levels_used,
                lambda2,
                level_state,
            );
        } else if 1 as ::core::ffi::c_int == 0 {
            return levels_used;
        }
        if 2 as ::core::ffi::c_int == 0
            || (*nodes_prev.offset(2 as ::core::ffi::c_int as isize)).score as int64_t
                >= 0 as int64_t
        {
            levels_used = trellis_coef(
                2 as ::core::ffi::c_int,
                1 as ::core::ffi::c_int,
                abs_level,
                prefix,
                suffix_cost,
                3 as ::core::ffi::c_int,
                3 as ::core::ffi::c_int,
                0 as ::core::ffi::c_int,
                if 2 as ::core::ffi::c_int != 0 {
                    ssd1
                } else {
                    ssd0
                },
                cost_siglast,
                nodes_cur,
                nodes_prev,
                level_tree,
                levels_used,
                lambda2,
                level_state,
            );
        } else if 1 as ::core::ffi::c_int == 0 {
            return levels_used;
        }
        if 3 as ::core::ffi::c_int == 0
            || (*nodes_prev.offset(3 as ::core::ffi::c_int as isize)).score as int64_t
                >= 0 as int64_t
        {
            levels_used = trellis_coef(
                3 as ::core::ffi::c_int,
                1 as ::core::ffi::c_int,
                abs_level,
                prefix,
                suffix_cost,
                3 as ::core::ffi::c_int,
                4 as ::core::ffi::c_int,
                0 as ::core::ffi::c_int,
                if 3 as ::core::ffi::c_int != 0 {
                    ssd1
                } else {
                    ssd0
                },
                cost_siglast,
                nodes_cur,
                nodes_prev,
                level_tree,
                levels_used,
                lambda2,
                level_state,
            );
        } else if 1 as ::core::ffi::c_int == 0 {
            return levels_used;
        }
        if 4 as ::core::ffi::c_int == 0
            || (*nodes_prev.offset(4 as ::core::ffi::c_int as isize)).score as int64_t
                >= 0 as int64_t
        {
            levels_used = trellis_coef(
                4 as ::core::ffi::c_int,
                1 as ::core::ffi::c_int,
                abs_level,
                prefix,
                suffix_cost,
                4 as ::core::ffi::c_int,
                0 as ::core::ffi::c_int,
                0 as ::core::ffi::c_int,
                if 4 as ::core::ffi::c_int != 0 {
                    ssd1
                } else {
                    ssd0
                },
                cost_siglast,
                nodes_cur,
                nodes_prev,
                level_tree,
                levels_used,
                lambda2,
                level_state,
            );
        } else if 1 as ::core::ffi::c_int == 0 {
            return levels_used;
        }
        if 5 as ::core::ffi::c_int == 0
            || (*nodes_prev.offset(5 as ::core::ffi::c_int as isize)).score as int64_t
                >= 0 as int64_t
        {
            levels_used = trellis_coef(
                5 as ::core::ffi::c_int,
                1 as ::core::ffi::c_int,
                abs_level,
                prefix,
                suffix_cost,
                5 as ::core::ffi::c_int,
                0 as ::core::ffi::c_int,
                0 as ::core::ffi::c_int,
                if 5 as ::core::ffi::c_int != 0 {
                    ssd1
                } else {
                    ssd0
                },
                cost_siglast,
                nodes_cur,
                nodes_prev,
                level_tree,
                levels_used,
                lambda2,
                level_state,
            );
        } else if 1 as ::core::ffi::c_int == 0 {
            return levels_used;
        }
        if 6 as ::core::ffi::c_int == 0
            || (*nodes_prev.offset(6 as ::core::ffi::c_int as isize)).score as int64_t
                >= 0 as int64_t
        {
            levels_used = trellis_coef(
                6 as ::core::ffi::c_int,
                1 as ::core::ffi::c_int,
                abs_level,
                prefix,
                suffix_cost,
                6 as ::core::ffi::c_int,
                0 as ::core::ffi::c_int,
                0 as ::core::ffi::c_int,
                if 6 as ::core::ffi::c_int != 0 {
                    ssd1
                } else {
                    ssd0
                },
                cost_siglast,
                nodes_cur,
                nodes_prev,
                level_tree,
                levels_used,
                lambda2,
                level_state,
            );
        } else if 1 as ::core::ffi::c_int == 0 {
            return levels_used;
        }
        if 7 as ::core::ffi::c_int == 0
            || (*nodes_prev.offset(7 as ::core::ffi::c_int as isize)).score as int64_t
                >= 0 as int64_t
        {
            levels_used = trellis_coef(
                7 as ::core::ffi::c_int,
                1 as ::core::ffi::c_int,
                abs_level,
                prefix,
                suffix_cost,
                7 as ::core::ffi::c_int,
                0 as ::core::ffi::c_int,
                0 as ::core::ffi::c_int,
                if 7 as ::core::ffi::c_int != 0 {
                    ssd1
                } else {
                    ssd0
                },
                cost_siglast,
                nodes_cur,
                nodes_prev,
                level_tree,
                levels_used,
                lambda2,
                level_state,
            );
        } else if 1 as ::core::ffi::c_int == 0 {
            return levels_used;
        }
        return levels_used;
    }
    #[inline(never)]
    #[c2rust::src_loc = "608:1"]
    pub unsafe extern "C" fn trellis_coefn_0(
        mut abs_level: ::core::ffi::c_int,
        mut ssd0: uint64_t,
        mut ssd1: uint64_t,
        mut cost_siglast: *mut ::core::ffi::c_int,
        mut nodes_cur: *mut trellis_node_t,
        mut nodes_prev: *mut trellis_node_t,
        mut level_tree: *mut trellis_level_t,
        mut levels_used: ::core::ffi::c_int,
        mut lambda2: ::core::ffi::c_int,
        mut level_state: *mut uint8_t,
        mut levelgt1_ctx: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int {
        let mut prefix: ::core::ffi::c_int =
            if (abs_level - 1 as ::core::ffi::c_int) < 14 as ::core::ffi::c_int {
                abs_level - 1 as ::core::ffi::c_int
            } else {
                14 as ::core::ffi::c_int
            };
        let mut suffix_cost: ::core::ffi::c_int = if abs_level >= 15 as ::core::ffi::c_int {
            bs_size_ue_big((abs_level - 15 as ::core::ffi::c_int) as ::core::ffi::c_uint)
                << CABAC_SIZE_BITS
        } else {
            0 as ::core::ffi::c_int
        };
        if 0 as ::core::ffi::c_int == 0
            || (*nodes_prev.offset(0 as ::core::ffi::c_int as isize)).score as int64_t
                >= 0 as int64_t
        {
            levels_used = trellis_coef(
                0 as ::core::ffi::c_int,
                2 as ::core::ffi::c_int,
                abs_level,
                prefix,
                suffix_cost,
                4 as ::core::ffi::c_int,
                1 as ::core::ffi::c_int,
                5 as ::core::ffi::c_int,
                if 0 as ::core::ffi::c_int != 0 {
                    ssd1
                } else {
                    ssd0
                },
                cost_siglast,
                nodes_cur,
                nodes_prev,
                level_tree,
                levels_used,
                lambda2,
                level_state,
            );
        } else if 0 as ::core::ffi::c_int == 0 {
            return levels_used;
        }
        if 1 as ::core::ffi::c_int == 0
            || (*nodes_prev.offset(1 as ::core::ffi::c_int as isize)).score as int64_t
                >= 0 as int64_t
        {
            levels_used = trellis_coef(
                1 as ::core::ffi::c_int,
                2 as ::core::ffi::c_int,
                abs_level,
                prefix,
                suffix_cost,
                4 as ::core::ffi::c_int,
                2 as ::core::ffi::c_int,
                5 as ::core::ffi::c_int,
                if 1 as ::core::ffi::c_int != 0 {
                    ssd1
                } else {
                    ssd0
                },
                cost_siglast,
                nodes_cur,
                nodes_prev,
                level_tree,
                levels_used,
                lambda2,
                level_state,
            );
        } else if 0 as ::core::ffi::c_int == 0 {
            return levels_used;
        }
        if 2 as ::core::ffi::c_int == 0
            || (*nodes_prev.offset(2 as ::core::ffi::c_int as isize)).score as int64_t
                >= 0 as int64_t
        {
            levels_used = trellis_coef(
                2 as ::core::ffi::c_int,
                2 as ::core::ffi::c_int,
                abs_level,
                prefix,
                suffix_cost,
                4 as ::core::ffi::c_int,
                3 as ::core::ffi::c_int,
                5 as ::core::ffi::c_int,
                if 2 as ::core::ffi::c_int != 0 {
                    ssd1
                } else {
                    ssd0
                },
                cost_siglast,
                nodes_cur,
                nodes_prev,
                level_tree,
                levels_used,
                lambda2,
                level_state,
            );
        } else if 0 as ::core::ffi::c_int == 0 {
            return levels_used;
        }
        if 3 as ::core::ffi::c_int == 0
            || (*nodes_prev.offset(3 as ::core::ffi::c_int as isize)).score as int64_t
                >= 0 as int64_t
        {
            levels_used = trellis_coef(
                3 as ::core::ffi::c_int,
                2 as ::core::ffi::c_int,
                abs_level,
                prefix,
                suffix_cost,
                4 as ::core::ffi::c_int,
                4 as ::core::ffi::c_int,
                5 as ::core::ffi::c_int,
                if 3 as ::core::ffi::c_int != 0 {
                    ssd1
                } else {
                    ssd0
                },
                cost_siglast,
                nodes_cur,
                nodes_prev,
                level_tree,
                levels_used,
                lambda2,
                level_state,
            );
        } else if 0 as ::core::ffi::c_int == 0 {
            return levels_used;
        }
        return levels_used;
    }
    #[inline(never)]
    #[c2rust::src_loc = "623:1"]
    pub unsafe extern "C" fn trellis_coefn_1(
        mut abs_level: ::core::ffi::c_int,
        mut ssd0: uint64_t,
        mut ssd1: uint64_t,
        mut cost_siglast: *mut ::core::ffi::c_int,
        mut nodes_cur: *mut trellis_node_t,
        mut nodes_prev: *mut trellis_node_t,
        mut level_tree: *mut trellis_level_t,
        mut levels_used: ::core::ffi::c_int,
        mut lambda2: ::core::ffi::c_int,
        mut level_state: *mut uint8_t,
        mut levelgt1_ctx: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int {
        let mut prefix: ::core::ffi::c_int =
            if (abs_level - 1 as ::core::ffi::c_int) < 14 as ::core::ffi::c_int {
                abs_level - 1 as ::core::ffi::c_int
            } else {
                14 as ::core::ffi::c_int
            };
        let mut suffix_cost: ::core::ffi::c_int = if abs_level >= 15 as ::core::ffi::c_int {
            bs_size_ue_big((abs_level - 15 as ::core::ffi::c_int) as ::core::ffi::c_uint)
                << CABAC_SIZE_BITS
        } else {
            0 as ::core::ffi::c_int
        };
        if 1 as ::core::ffi::c_int == 0
            || (*nodes_prev.offset(1 as ::core::ffi::c_int as isize)).score as int64_t
                >= 0 as int64_t
        {
            levels_used = trellis_coef(
                1 as ::core::ffi::c_int,
                2 as ::core::ffi::c_int,
                abs_level,
                prefix,
                suffix_cost,
                4 as ::core::ffi::c_int,
                2 as ::core::ffi::c_int,
                5 as ::core::ffi::c_int,
                if 1 as ::core::ffi::c_int != 0 {
                    ssd1
                } else {
                    ssd0
                },
                cost_siglast,
                nodes_cur,
                nodes_prev,
                level_tree,
                levels_used,
                lambda2,
                level_state,
            );
        } else if 1 as ::core::ffi::c_int == 0 {
            return levels_used;
        }
        if 2 as ::core::ffi::c_int == 0
            || (*nodes_prev.offset(2 as ::core::ffi::c_int as isize)).score as int64_t
                >= 0 as int64_t
        {
            levels_used = trellis_coef(
                2 as ::core::ffi::c_int,
                2 as ::core::ffi::c_int,
                abs_level,
                prefix,
                suffix_cost,
                4 as ::core::ffi::c_int,
                3 as ::core::ffi::c_int,
                5 as ::core::ffi::c_int,
                if 2 as ::core::ffi::c_int != 0 {
                    ssd1
                } else {
                    ssd0
                },
                cost_siglast,
                nodes_cur,
                nodes_prev,
                level_tree,
                levels_used,
                lambda2,
                level_state,
            );
        } else if 1 as ::core::ffi::c_int == 0 {
            return levels_used;
        }
        if 3 as ::core::ffi::c_int == 0
            || (*nodes_prev.offset(3 as ::core::ffi::c_int as isize)).score as int64_t
                >= 0 as int64_t
        {
            levels_used = trellis_coef(
                3 as ::core::ffi::c_int,
                2 as ::core::ffi::c_int,
                abs_level,
                prefix,
                suffix_cost,
                4 as ::core::ffi::c_int,
                4 as ::core::ffi::c_int,
                5 as ::core::ffi::c_int,
                if 3 as ::core::ffi::c_int != 0 {
                    ssd1
                } else {
                    ssd0
                },
                cost_siglast,
                nodes_cur,
                nodes_prev,
                level_tree,
                levels_used,
                lambda2,
                level_state,
            );
        } else if 1 as ::core::ffi::c_int == 0 {
            return levels_used;
        }
        if 4 as ::core::ffi::c_int == 0
            || (*nodes_prev.offset(4 as ::core::ffi::c_int as isize)).score as int64_t
                >= 0 as int64_t
        {
            levels_used = trellis_coef(
                4 as ::core::ffi::c_int,
                2 as ::core::ffi::c_int,
                abs_level,
                prefix,
                suffix_cost,
                5 as ::core::ffi::c_int,
                0 as ::core::ffi::c_int,
                6 as ::core::ffi::c_int,
                if 4 as ::core::ffi::c_int != 0 {
                    ssd1
                } else {
                    ssd0
                },
                cost_siglast,
                nodes_cur,
                nodes_prev,
                level_tree,
                levels_used,
                lambda2,
                level_state,
            );
        } else if 1 as ::core::ffi::c_int == 0 {
            return levels_used;
        }
        if 5 as ::core::ffi::c_int == 0
            || (*nodes_prev.offset(5 as ::core::ffi::c_int as isize)).score as int64_t
                >= 0 as int64_t
        {
            levels_used = trellis_coef(
                5 as ::core::ffi::c_int,
                2 as ::core::ffi::c_int,
                abs_level,
                prefix,
                suffix_cost,
                6 as ::core::ffi::c_int,
                0 as ::core::ffi::c_int,
                7 as ::core::ffi::c_int,
                if 5 as ::core::ffi::c_int != 0 {
                    ssd1
                } else {
                    ssd0
                },
                cost_siglast,
                nodes_cur,
                nodes_prev,
                level_tree,
                levels_used,
                lambda2,
                level_state,
            );
        } else if 1 as ::core::ffi::c_int == 0 {
            return levels_used;
        }
        if 6 as ::core::ffi::c_int == 0
            || (*nodes_prev.offset(6 as ::core::ffi::c_int as isize)).score as int64_t
                >= 0 as int64_t
        {
            levels_used = trellis_coef(
                6 as ::core::ffi::c_int,
                2 as ::core::ffi::c_int,
                abs_level,
                prefix,
                suffix_cost,
                7 as ::core::ffi::c_int,
                0 as ::core::ffi::c_int,
                8 as ::core::ffi::c_int,
                if 6 as ::core::ffi::c_int != 0 {
                    ssd1
                } else {
                    ssd0
                },
                cost_siglast,
                nodes_cur,
                nodes_prev,
                level_tree,
                levels_used,
                lambda2,
                level_state,
            );
        } else if 1 as ::core::ffi::c_int == 0 {
            return levels_used;
        }
        if 7 as ::core::ffi::c_int == 0
            || (*nodes_prev.offset(7 as ::core::ffi::c_int as isize)).score as int64_t
                >= 0 as int64_t
        {
            levels_used = trellis_coef(
                7 as ::core::ffi::c_int,
                2 as ::core::ffi::c_int,
                abs_level,
                prefix,
                suffix_cost,
                7 as ::core::ffi::c_int,
                0 as ::core::ffi::c_int,
                levelgt1_ctx,
                if 7 as ::core::ffi::c_int != 0 {
                    ssd1
                } else {
                    ssd0
                },
                cost_siglast,
                nodes_cur,
                nodes_prev,
                level_tree,
                levels_used,
                lambda2,
                level_state,
            );
        } else if 1 as ::core::ffi::c_int == 0 {
            return levels_used;
        }
        return levels_used;
    }
    #[inline(always)]
    #[c2rust::src_loc = "641:1"]
    pub unsafe extern "C" fn quant_trellis_cabac(
        mut h: *mut x264_t,
        mut dct: *mut dctcoef,
        mut quant_mf: *mut udctcoef,
        mut quant_bias: *mut udctcoef,
        mut unquant_mf: *const ::core::ffi::c_int,
        mut zigzag: *const uint8_t,
        mut ctx_block_cat: ::core::ffi::c_int,
        mut lambda2: ::core::ffi::c_int,
        mut b_ac: ::core::ffi::c_int,
        mut b_chroma: ::core::ffi::c_int,
        mut dc: ::core::ffi::c_int,
        mut num_coefs: ::core::ffi::c_int,
        mut idx: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int {
        let mut current_block: u64;
        let mut orig_coefs: [dctcoef; 64] = [0; 64];
        let mut quant_coefs: [dctcoef; 64] = [0; 64];
        let mut coef_weight1: *const uint32_t = if num_coefs == 64 as ::core::ffi::c_int {
            x264_dct8_weight_tab.as_ptr()
        } else {
            x264_dct4_weight_tab.as_ptr()
        };
        let mut coef_weight2: *const uint32_t = if num_coefs == 64 as ::core::ffi::c_int {
            x264_dct8_weight2_tab.as_ptr()
        } else {
            x264_dct4_weight2_tab.as_ptr()
        };
        let b_interlaced: ::core::ffi::c_int = (*h).mb.b_interlaced;
        let mut cabac_state_sig: *mut uint8_t = &mut *(*h).cabac.state.as_mut_ptr().offset(
            *(*x264_significant_coeff_flag_offset
                .as_ptr()
                .offset(b_interlaced as isize))
            .as_ptr()
            .offset(ctx_block_cat as isize) as isize,
        ) as *mut uint8_t;
        let mut cabac_state_last: *mut uint8_t = &mut *(*h).cabac.state.as_mut_ptr().offset(
            *(*x264_last_coeff_flag_offset
                .as_ptr()
                .offset(b_interlaced as isize))
            .as_ptr()
            .offset(ctx_block_cat as isize) as isize,
        ) as *mut uint8_t;
        let mut levelgt1_ctx: ::core::ffi::c_int = if b_chroma != 0 && dc != 0 {
            8 as ::core::ffi::c_int
        } else {
            9 as ::core::ffi::c_int
        };
        if dc != 0 {
            if num_coefs == 16 as ::core::ffi::c_int {
                memcpy(
                    orig_coefs.as_mut_ptr() as *mut ::core::ffi::c_void,
                    dct as *const ::core::ffi::c_void,
                    (::core::mem::size_of::<dctcoef>() as size_t).wrapping_mul(16 as size_t),
                );
                if (*h).quantf.quant_4x4_dc.expect("non-null function pointer")(
                    dct as *mut dctcoef,
                    (*quant_mf.offset(0 as ::core::ffi::c_int as isize) >> 1 as ::core::ffi::c_int)
                        as ::core::ffi::c_int,
                    (*quant_bias.offset(0 as ::core::ffi::c_int as isize)
                        << 1 as ::core::ffi::c_int) as ::core::ffi::c_int,
                ) == 0
                {
                    return 0 as ::core::ffi::c_int;
                }
                (*h).zigzagf.scan_4x4.expect("non-null function pointer")(
                    quant_coefs.as_mut_ptr(),
                    dct as *mut dctcoef,
                );
            } else {
                memcpy(
                    orig_coefs.as_mut_ptr() as *mut ::core::ffi::c_void,
                    dct as *const ::core::ffi::c_void,
                    (::core::mem::size_of::<dctcoef>() as size_t).wrapping_mul(num_coefs as size_t),
                );
                let mut nz: ::core::ffi::c_int = (*h)
                    .quantf
                    .quant_2x2_dc
                    .expect("non-null function pointer")(
                    &mut *dct.offset(0 as ::core::ffi::c_int as isize),
                    (*quant_mf.offset(0 as ::core::ffi::c_int as isize) >> 1 as ::core::ffi::c_int)
                        as ::core::ffi::c_int,
                    (*quant_bias.offset(0 as ::core::ffi::c_int as isize)
                        << 1 as ::core::ffi::c_int) as ::core::ffi::c_int,
                );
                if num_coefs == 8 as ::core::ffi::c_int {
                    nz |= (*h).quantf.quant_2x2_dc.expect("non-null function pointer")(
                        &mut *dct.offset(4 as ::core::ffi::c_int as isize),
                        (*quant_mf.offset(0 as ::core::ffi::c_int as isize)
                            >> 1 as ::core::ffi::c_int)
                            as ::core::ffi::c_int,
                        (*quant_bias.offset(0 as ::core::ffi::c_int as isize)
                            << 1 as ::core::ffi::c_int)
                            as ::core::ffi::c_int,
                    );
                }
                if nz == 0 {
                    return 0 as ::core::ffi::c_int;
                }
                let mut i: ::core::ffi::c_int = 0 as ::core::ffi::c_int;
                while i < num_coefs {
                    quant_coefs[i as usize] = *dct.offset(*zigzag.offset(i as isize) as isize);
                    i += 1;
                }
            }
        } else if num_coefs == 64 as ::core::ffi::c_int {
            (*h).mc.memcpy_aligned.expect("non-null function pointer")(
                orig_coefs.as_mut_ptr() as *mut ::core::ffi::c_void,
                dct as *const ::core::ffi::c_void,
                (::core::mem::size_of::<dctcoef>() as size_t).wrapping_mul(64 as size_t),
            );
            if (*h).quantf.quant_8x8.expect("non-null function pointer")(
                dct as *mut dctcoef,
                quant_mf as *mut udctcoef,
                quant_bias as *mut udctcoef,
            ) == 0
            {
                return 0 as ::core::ffi::c_int;
            }
            (*h).zigzagf.scan_8x8.expect("non-null function pointer")(
                quant_coefs.as_mut_ptr(),
                dct as *mut dctcoef,
            );
        } else {
            memcpy(
                orig_coefs.as_mut_ptr() as *mut ::core::ffi::c_void,
                dct as *const ::core::ffi::c_void,
                (::core::mem::size_of::<dctcoef>() as size_t).wrapping_mul(16 as size_t),
            );
            if (*h).quantf.quant_4x4.expect("non-null function pointer")(
                dct as *mut dctcoef,
                quant_mf as *mut udctcoef,
                quant_bias as *mut udctcoef,
            ) == 0
            {
                return 0 as ::core::ffi::c_int;
            }
            (*h).zigzagf.scan_4x4.expect("non-null function pointer")(
                quant_coefs.as_mut_ptr(),
                dct as *mut dctcoef,
            );
        }
        let mut last_nnz: ::core::ffi::c_int = (*h).quantf.coeff_last[ctx_block_cat as usize]
            .expect("non-null function pointer")(
            quant_coefs.as_mut_ptr().offset(b_ac as isize)
        ) + b_ac;
        let mut cabac_state: *mut uint8_t = &mut *(*h).cabac.state.as_mut_ptr().offset(
            *x264_coeff_abs_level_m1_offset
                .as_ptr()
                .offset(ctx_block_cat as isize) as isize,
        ) as *mut uint8_t;
        if last_nnz == 0 as ::core::ffi::c_int && dc == 0 {
            let mut cost_sig: ::core::ffi::c_int = x264_cabac_size_decision_noup2(
                &mut *cabac_state_sig.offset(0 as ::core::ffi::c_int as isize),
                1 as ::core::ffi::c_long,
            ) + x264_cabac_size_decision_noup2(
                &mut *cabac_state_last.offset(0 as ::core::ffi::c_int as isize),
                1 as ::core::ffi::c_long,
            );
            *dct.offset(0 as ::core::ffi::c_int as isize) = trellis_dc_shortcut(
                orig_coefs[0 as ::core::ffi::c_int as usize],
                quant_coefs[0 as ::core::ffi::c_int as usize],
                *unquant_mf.offset(0 as ::core::ffi::c_int as isize),
                *coef_weight2.offset(0 as ::core::ffi::c_int as isize) as ::core::ffi::c_int,
                lambda2,
                cabac_state,
                cost_sig,
            ) as dctcoef;
            return (*dct.offset(0 as ::core::ffi::c_int as isize) != 0) as ::core::ffi::c_int;
        }
        let mut level_tree: [trellis_level_t; 1024] = [trellis_level_t {
            next: 0,
            abs_level: 0,
        }; 1024];
        let mut levels_used: ::core::ffi::c_int = 1 as ::core::ffi::c_int;
        let mut nodes: [[trellis_node_t; 8]; 2] = [
            [
                {
                    let mut init = trellis_node_t {
                        score: 0 as uint64_t,
                        level_idx: 0,
                        cabac_state: [0; 4],
                    };
                    init
                },
                trellis_node_t {
                    score: 0,
                    level_idx: 0,
                    cabac_state: [0; 4],
                },
                trellis_node_t {
                    score: 0,
                    level_idx: 0,
                    cabac_state: [0; 4],
                },
                trellis_node_t {
                    score: 0,
                    level_idx: 0,
                    cabac_state: [0; 4],
                },
                trellis_node_t {
                    score: 0,
                    level_idx: 0,
                    cabac_state: [0; 4],
                },
                trellis_node_t {
                    score: 0,
                    level_idx: 0,
                    cabac_state: [0; 4],
                },
                trellis_node_t {
                    score: 0,
                    level_idx: 0,
                    cabac_state: [0; 4],
                },
                trellis_node_t {
                    score: 0,
                    level_idx: 0,
                    cabac_state: [0; 4],
                },
            ],
            [trellis_node_t {
                score: 0,
                level_idx: 0,
                cabac_state: [0; 4],
            }; 8],
        ];
        let mut nodes_cur: *mut trellis_node_t =
            (*nodes.as_mut_ptr().offset(0 as ::core::ffi::c_int as isize)).as_mut_ptr();
        let mut nodes_prev: *mut trellis_node_t =
            (*nodes.as_mut_ptr().offset(1 as ::core::ffi::c_int as isize)).as_mut_ptr();
        let mut bnode: *mut trellis_node_t = 0 as *mut trellis_node_t;
        let mut j: ::core::ffi::c_int = 1 as ::core::ffi::c_int;
        while j < 8 as ::core::ffi::c_int {
            (*nodes_cur.offset(j as isize)).score = TRELLIS_SCORE_MAX as uint64_t;
            j += 1;
        }
        (*nodes_cur.offset(0 as ::core::ffi::c_int as isize)).score =
            TRELLIS_SCORE_BIAS as uint64_t;
        (*nodes_cur.offset(0 as ::core::ffi::c_int as isize)).level_idx = 0 as ::core::ffi::c_int;
        level_tree[0 as ::core::ffi::c_int as usize].abs_level = 0 as uint16_t;
        level_tree[0 as ::core::ffi::c_int as usize].next = 0 as uint16_t;
        let mut level_state: [uint8_t; 16] = [0; 16];
        memcpy(
            level_state.as_mut_ptr() as *mut ::core::ffi::c_void,
            cabac_state as *const ::core::ffi::c_void,
            10 as size_t,
        );
        level_state[12 as ::core::ffi::c_int as usize] =
            *cabac_state.offset(0 as ::core::ffi::c_int as isize);
        level_state[13 as ::core::ffi::c_int as usize] =
            *cabac_state.offset(4 as ::core::ffi::c_int as isize);
        level_state[14 as ::core::ffi::c_int as usize] =
            *cabac_state.offset(8 as ::core::ffi::c_int as isize);
        level_state[15 as ::core::ffi::c_int as usize] =
            *cabac_state.offset(9 as ::core::ffi::c_int as isize);
        idx &= if num_coefs == 64 as ::core::ffi::c_int {
            3 as ::core::ffi::c_int
        } else {
            15 as ::core::ffi::c_int
        };
        let mut i_0: ::core::ffi::c_int = last_nnz;
        loop {
            if !(i_0 >= b_ac) {
                current_block = 10369920510435091891;
                break;
            }
            if quant_coefs[i_0 as usize] == 0 {
                if 0 as ::core::ffi::c_int == 0 {
                    let mut sigindex: ::core::ffi::c_int =
                        if dc == 0 && num_coefs == 64 as ::core::ffi::c_int {
                            x264_significant_coeff_flag_offset_8x8[b_interlaced as usize]
                                [i_0 as usize] as ::core::ffi::c_int
                        } else if b_chroma != 0 && dc != 0 && num_coefs == 8 as ::core::ffi::c_int {
                            x264_coeff_flag_offset_chroma_422_dc[i_0 as usize] as ::core::ffi::c_int
                        } else {
                            i_0
                        };
                    let mut cost_sig0: uint64_t = (x264_cabac_size_decision_noup2(
                        &mut *cabac_state_sig.offset(sigindex as isize),
                        0 as ::core::ffi::c_long,
                    ) as uint64_t)
                        .wrapping_mul(lambda2 as uint64_t)
                        >> CABAC_SIZE_BITS - LAMBDA_BITS;
                    let ref mut fresh0 =
                        (*nodes_cur.offset(0 as ::core::ffi::c_int as isize)).score;
                    *fresh0 = (*fresh0).wrapping_sub(cost_sig0);
                }
                let mut j_0: ::core::ffi::c_int = 1 as ::core::ffi::c_int;
                while j_0
                    < (if 0 as ::core::ffi::c_int != 0 {
                        8 as ::core::ffi::c_int
                    } else {
                        4 as ::core::ffi::c_int
                    })
                {
                    if ::core::mem::size_of::<trellis_level_t>() as usize
                        == ::core::mem::size_of::<uint32_t>() as usize
                    {
                        (*(&mut *level_tree.as_mut_ptr().offset(levels_used as isize)
                            as *mut trellis_level_t
                            as *mut x264_union32_t))
                            .i = pack16to32(
                            (*nodes_cur.offset(j_0 as isize)).level_idx as uint32_t,
                            0 as uint32_t,
                        );
                    } else {
                        level_tree[levels_used as usize] = {
                            let mut init = trellis_level_t {
                                next: (*nodes_cur.offset(j_0 as isize)).level_idx as uint16_t,
                                abs_level: 0 as uint16_t,
                            };
                            init
                        };
                    }
                    (*nodes_cur.offset(j_0 as isize)).level_idx = levels_used;
                    levels_used += 1;
                    j_0 += 1;
                }
            } else {
                let mut sign_coef: ::core::ffi::c_int =
                    orig_coefs[*zigzag.offset(i_0 as isize) as usize];
                let mut abs_coef: ::core::ffi::c_int = abs(sign_coef);
                let mut q: ::core::ffi::c_int = abs(quant_coefs[i_0 as usize]);
                let mut cost_siglast: [::core::ffi::c_int; 3] = [0; 3];
                let mut t: *mut trellis_node_t = nodes_cur;
                nodes_cur = nodes_prev;
                nodes_prev = t;
                let mut j_1: ::core::ffi::c_int = 0 as ::core::ffi::c_int;
                while j_1 < 8 as ::core::ffi::c_int {
                    (*nodes_cur.offset(j_1 as isize)).score = TRELLIS_SCORE_MAX as uint64_t;
                    j_1 += 1;
                }
                if i_0 < num_coefs - 1 as ::core::ffi::c_int || 0 as ::core::ffi::c_int != 0 {
                    let mut sigindex_0: ::core::ffi::c_int =
                        if dc == 0 && num_coefs == 64 as ::core::ffi::c_int {
                            x264_significant_coeff_flag_offset_8x8[b_interlaced as usize]
                                [i_0 as usize] as ::core::ffi::c_int
                        } else if b_chroma != 0 && dc != 0 && num_coefs == 8 as ::core::ffi::c_int {
                            x264_coeff_flag_offset_chroma_422_dc[i_0 as usize] as ::core::ffi::c_int
                        } else {
                            i_0
                        };
                    let mut lastindex: ::core::ffi::c_int =
                        if dc == 0 && num_coefs == 64 as ::core::ffi::c_int {
                            x264_last_coeff_flag_offset_8x8[i_0 as usize] as ::core::ffi::c_int
                        } else if b_chroma != 0 && dc != 0 && num_coefs == 8 as ::core::ffi::c_int {
                            x264_coeff_flag_offset_chroma_422_dc[i_0 as usize] as ::core::ffi::c_int
                        } else {
                            i_0
                        };
                    cost_siglast[0 as ::core::ffi::c_int as usize] = x264_cabac_size_decision_noup2(
                        &mut *cabac_state_sig.offset(sigindex_0 as isize),
                        0 as ::core::ffi::c_long,
                    );
                    let mut cost_sig1: ::core::ffi::c_int = x264_cabac_size_decision_noup2(
                        &mut *cabac_state_sig.offset(sigindex_0 as isize),
                        1 as ::core::ffi::c_long,
                    );
                    cost_siglast[1 as ::core::ffi::c_int as usize] = x264_cabac_size_decision_noup2(
                        &mut *cabac_state_last.offset(lastindex as isize),
                        0 as ::core::ffi::c_long,
                    ) + cost_sig1;
                    if 0 as ::core::ffi::c_int == 0 {
                        cost_siglast[2 as ::core::ffi::c_int as usize] =
                            x264_cabac_size_decision_noup2(
                                &mut *cabac_state_last.offset(lastindex as isize),
                                1 as ::core::ffi::c_long,
                            ) + cost_sig1;
                    }
                } else {
                    cost_siglast[2 as ::core::ffi::c_int as usize] = 0 as ::core::ffi::c_int;
                    cost_siglast[1 as ::core::ffi::c_int as usize] =
                        cost_siglast[2 as ::core::ffi::c_int as usize];
                    cost_siglast[0 as ::core::ffi::c_int as usize] =
                        cost_siglast[1 as ::core::ffi::c_int as usize];
                }
                let mut ssd0: [uint64_t; 2] = [0; 2];
                let mut ssd1: [uint64_t; 2] = [0; 2];
                let mut k: ::core::ffi::c_int = 0 as ::core::ffi::c_int;
                while k < 2 as ::core::ffi::c_int {
                    let mut abs_level: ::core::ffi::c_int = q - 1 as ::core::ffi::c_int + k;
                    let mut unquant_abs_level: ::core::ffi::c_int = (if dc != 0 {
                        *unquant_mf.offset(0 as ::core::ffi::c_int as isize)
                            << 1 as ::core::ffi::c_int
                    } else {
                        *unquant_mf.offset(*zigzag.offset(i_0 as isize) as isize)
                    }) * abs_level
                        + 128 as ::core::ffi::c_int
                        >> 8 as ::core::ffi::c_int;
                    let mut d: ::core::ffi::c_int = abs_coef - unquant_abs_level;
                    if (*h).mb.i_psy_trellis != 0 && i_0 != 0 && dc == 0 && b_chroma == 0 {
                        let mut orig_coef: ::core::ffi::c_int =
                            if num_coefs == 64 as ::core::ffi::c_int {
                                (*h).mb.pic.fenc_dct8[idx as usize]
                                    [*zigzag.offset(i_0 as isize) as usize]
                            } else {
                                (*h).mb.pic.fenc_dct4[idx as usize]
                                    [*zigzag.offset(i_0 as isize) as usize]
                            };
                        let mut predicted_coef: ::core::ffi::c_int = orig_coef - sign_coef;
                        let mut psy_value: ::core::ffi::c_int = abs(unquant_abs_level
                            + ((predicted_coef ^ sign_coef >> 31 as ::core::ffi::c_int)
                                - (sign_coef >> 31 as ::core::ffi::c_int)));
                        let mut psy_weight: ::core::ffi::c_int = (*coef_weight1
                            .offset(*zigzag.offset(i_0 as isize) as isize))
                        .wrapping_mul((*h).mb.i_psy_trellis as uint32_t)
                            as ::core::ffi::c_int;
                        let mut tmp: int64_t = d as int64_t
                            * d as int64_t
                            * *coef_weight2.offset(*zigzag.offset(i_0 as isize) as isize)
                                as int64_t
                            - psy_weight as int64_t * psy_value as int64_t;
                        ssd1[k as usize] = tmp as uint64_t;
                    } else {
                        ssd1[k as usize] = (d as int64_t
                            * d as int64_t
                            * (if dc != 0 {
                                256 as uint32_t
                            } else {
                                *coef_weight2.offset(*zigzag.offset(i_0 as isize) as isize)
                            }) as int64_t) as uint64_t;
                    }
                    ssd0[k as usize] = ssd1[k as usize];
                    if i_0 == 0 && dc == 0 && 0 as ::core::ffi::c_int == 0 {
                        d = sign_coef
                            - ((unquant_abs_level ^ sign_coef >> 31 as ::core::ffi::c_int)
                                - (sign_coef >> 31 as ::core::ffi::c_int)
                                + 8 as ::core::ffi::c_int
                                & !(15 as ::core::ffi::c_int));
                        ssd0[k as usize] = (d as int64_t
                            * d as int64_t
                            * *coef_weight2.offset(*zigzag.offset(i_0 as isize) as isize)
                                as int64_t) as uint64_t;
                    }
                    k += 1;
                }
                match q {
                    1 => {
                        ssd1[0 as ::core::ffi::c_int as usize] =
                            ssd1[0 as ::core::ffi::c_int as usize].wrapping_add(
                                (cost_siglast[0 as ::core::ffi::c_int as usize] as uint64_t)
                                    .wrapping_mul(lambda2 as uint64_t)
                                    >> CABAC_SIZE_BITS - LAMBDA_BITS,
                            );
                        levels_used = trellis_coef0_0(
                            ssd0[0 as ::core::ffi::c_int as usize]
                                .wrapping_sub(ssd1[0 as ::core::ffi::c_int as usize]),
                            nodes_cur,
                            nodes_prev,
                            level_tree.as_mut_ptr(),
                            levels_used,
                        );
                        levels_used = trellis_coef1_0(
                            ssd0[1 as ::core::ffi::c_int as usize]
                                .wrapping_sub(ssd1[0 as ::core::ffi::c_int as usize]),
                            ssd1[1 as ::core::ffi::c_int as usize]
                                .wrapping_sub(ssd1[0 as ::core::ffi::c_int as usize]),
                            cost_siglast.as_mut_ptr(),
                            nodes_cur,
                            nodes_prev,
                            level_tree.as_mut_ptr(),
                            levels_used,
                            lambda2,
                            level_state.as_mut_ptr(),
                        );
                    }
                    2 => {
                        levels_used = trellis_coef1_0(
                            ssd0[0 as ::core::ffi::c_int as usize],
                            ssd1[0 as ::core::ffi::c_int as usize],
                            cost_siglast.as_mut_ptr(),
                            nodes_cur,
                            nodes_prev,
                            level_tree.as_mut_ptr(),
                            levels_used,
                            lambda2,
                            level_state.as_mut_ptr(),
                        );
                        levels_used = trellis_coefn_0(
                            q,
                            ssd0[1 as ::core::ffi::c_int as usize],
                            ssd1[1 as ::core::ffi::c_int as usize],
                            cost_siglast.as_mut_ptr(),
                            nodes_cur,
                            nodes_prev,
                            level_tree.as_mut_ptr(),
                            levels_used,
                            lambda2,
                            level_state.as_mut_ptr(),
                            levelgt1_ctx,
                        );
                        current_block = 15622658527355336244;
                        break;
                    }
                    _ => {
                        levels_used = trellis_coefn_0(
                            q - 1 as ::core::ffi::c_int,
                            ssd0[0 as ::core::ffi::c_int as usize],
                            ssd1[0 as ::core::ffi::c_int as usize],
                            cost_siglast.as_mut_ptr(),
                            nodes_cur,
                            nodes_prev,
                            level_tree.as_mut_ptr(),
                            levels_used,
                            lambda2,
                            level_state.as_mut_ptr(),
                            levelgt1_ctx,
                        );
                        levels_used = trellis_coefn_0(
                            q,
                            ssd0[1 as ::core::ffi::c_int as usize],
                            ssd1[1 as ::core::ffi::c_int as usize],
                            cost_siglast.as_mut_ptr(),
                            nodes_cur,
                            nodes_prev,
                            level_tree.as_mut_ptr(),
                            levels_used,
                            lambda2,
                            level_state.as_mut_ptr(),
                            levelgt1_ctx,
                        );
                        current_block = 15622658527355336244;
                        break;
                    }
                }
            }
            i_0 -= 1;
        }
        match current_block {
            15622658527355336244 => {
                loop {
                    i_0 -= 1;
                    if !(i_0 >= b_ac) {
                        break;
                    }
                    if quant_coefs[i_0 as usize] == 0 {
                        if 1 as ::core::ffi::c_int == 0 {
                            let mut sigindex_1: ::core::ffi::c_int =
                                if dc == 0 && num_coefs == 64 as ::core::ffi::c_int {
                                    x264_significant_coeff_flag_offset_8x8[b_interlaced as usize]
                                        [i_0 as usize]
                                        as ::core::ffi::c_int
                                } else if b_chroma != 0
                                    && dc != 0
                                    && num_coefs == 8 as ::core::ffi::c_int
                                {
                                    x264_coeff_flag_offset_chroma_422_dc[i_0 as usize]
                                        as ::core::ffi::c_int
                                } else {
                                    i_0
                                };
                            let mut cost_sig0_0: uint64_t = (x264_cabac_size_decision_noup2(
                                &mut *cabac_state_sig.offset(sigindex_1 as isize),
                                0 as ::core::ffi::c_long,
                            )
                                as uint64_t)
                                .wrapping_mul(lambda2 as uint64_t)
                                >> CABAC_SIZE_BITS - LAMBDA_BITS;
                            let ref mut fresh1 =
                                (*nodes_cur.offset(0 as ::core::ffi::c_int as isize)).score;
                            *fresh1 = (*fresh1).wrapping_sub(cost_sig0_0);
                        }
                        let mut j_3: ::core::ffi::c_int = 1 as ::core::ffi::c_int;
                        while j_3
                            < (if 1 as ::core::ffi::c_int != 0 {
                                8 as ::core::ffi::c_int
                            } else {
                                4 as ::core::ffi::c_int
                            })
                        {
                            if ::core::mem::size_of::<trellis_level_t>() as usize
                                == ::core::mem::size_of::<uint32_t>() as usize
                            {
                                (*(&mut *level_tree.as_mut_ptr().offset(levels_used as isize)
                                    as *mut trellis_level_t
                                    as *mut x264_union32_t))
                                    .i = pack16to32(
                                    (*nodes_cur.offset(j_3 as isize)).level_idx as uint32_t,
                                    0 as uint32_t,
                                );
                            } else {
                                level_tree[levels_used as usize] = {
                                    let mut init = trellis_level_t {
                                        next: (*nodes_cur.offset(j_3 as isize)).level_idx
                                            as uint16_t,
                                        abs_level: 0 as uint16_t,
                                    };
                                    init
                                };
                            }
                            (*nodes_cur.offset(j_3 as isize)).level_idx = levels_used;
                            levels_used += 1;
                            j_3 += 1;
                        }
                    } else {
                        let mut sign_coef_0: ::core::ffi::c_int =
                            orig_coefs[*zigzag.offset(i_0 as isize) as usize];
                        let mut abs_coef_0: ::core::ffi::c_int = abs(sign_coef_0);
                        let mut q_0: ::core::ffi::c_int = abs(quant_coefs[i_0 as usize]);
                        let mut cost_siglast_0: [::core::ffi::c_int; 3] = [0; 3];
                        let mut t_0: *mut trellis_node_t = nodes_cur;
                        nodes_cur = nodes_prev;
                        nodes_prev = t_0;
                        let mut j_4: ::core::ffi::c_int = 1 as ::core::ffi::c_int;
                        while j_4 < 8 as ::core::ffi::c_int {
                            (*nodes_cur.offset(j_4 as isize)).score = TRELLIS_SCORE_MAX as uint64_t;
                            j_4 += 1;
                        }
                        if i_0 < num_coefs - 1 as ::core::ffi::c_int || 1 as ::core::ffi::c_int != 0
                        {
                            let mut sigindex_2: ::core::ffi::c_int =
                                if dc == 0 && num_coefs == 64 as ::core::ffi::c_int {
                                    x264_significant_coeff_flag_offset_8x8[b_interlaced as usize]
                                        [i_0 as usize]
                                        as ::core::ffi::c_int
                                } else if b_chroma != 0
                                    && dc != 0
                                    && num_coefs == 8 as ::core::ffi::c_int
                                {
                                    x264_coeff_flag_offset_chroma_422_dc[i_0 as usize]
                                        as ::core::ffi::c_int
                                } else {
                                    i_0
                                };
                            let mut lastindex_0: ::core::ffi::c_int = if dc == 0
                                && num_coefs == 64 as ::core::ffi::c_int
                            {
                                x264_last_coeff_flag_offset_8x8[i_0 as usize] as ::core::ffi::c_int
                            } else if b_chroma != 0
                                && dc != 0
                                && num_coefs == 8 as ::core::ffi::c_int
                            {
                                x264_coeff_flag_offset_chroma_422_dc[i_0 as usize]
                                    as ::core::ffi::c_int
                            } else {
                                i_0
                            };
                            cost_siglast_0[0 as ::core::ffi::c_int as usize] =
                                x264_cabac_size_decision_noup2(
                                    &mut *cabac_state_sig.offset(sigindex_2 as isize),
                                    0 as ::core::ffi::c_long,
                                );
                            let mut cost_sig1_0: ::core::ffi::c_int =
                                x264_cabac_size_decision_noup2(
                                    &mut *cabac_state_sig.offset(sigindex_2 as isize),
                                    1 as ::core::ffi::c_long,
                                );
                            cost_siglast_0[1 as ::core::ffi::c_int as usize] =
                                x264_cabac_size_decision_noup2(
                                    &mut *cabac_state_last.offset(lastindex_0 as isize),
                                    0 as ::core::ffi::c_long,
                                ) + cost_sig1_0;
                            if 1 as ::core::ffi::c_int == 0 {
                                cost_siglast_0[2 as ::core::ffi::c_int as usize] =
                                    x264_cabac_size_decision_noup2(
                                        &mut *cabac_state_last.offset(lastindex_0 as isize),
                                        1 as ::core::ffi::c_long,
                                    ) + cost_sig1_0;
                            }
                        } else {
                            cost_siglast_0[2 as ::core::ffi::c_int as usize] =
                                0 as ::core::ffi::c_int;
                            cost_siglast_0[1 as ::core::ffi::c_int as usize] =
                                cost_siglast_0[2 as ::core::ffi::c_int as usize];
                            cost_siglast_0[0 as ::core::ffi::c_int as usize] =
                                cost_siglast_0[1 as ::core::ffi::c_int as usize];
                        }
                        let mut ssd0_0: [uint64_t; 2] = [0; 2];
                        let mut ssd1_0: [uint64_t; 2] = [0; 2];
                        let mut k_0: ::core::ffi::c_int = 0 as ::core::ffi::c_int;
                        while k_0 < 2 as ::core::ffi::c_int {
                            let mut abs_level_0: ::core::ffi::c_int =
                                q_0 - 1 as ::core::ffi::c_int + k_0;
                            let mut unquant_abs_level_0: ::core::ffi::c_int = (if dc != 0 {
                                *unquant_mf.offset(0 as ::core::ffi::c_int as isize)
                                    << 1 as ::core::ffi::c_int
                            } else {
                                *unquant_mf.offset(*zigzag.offset(i_0 as isize) as isize)
                            }) * abs_level_0
                                + 128 as ::core::ffi::c_int
                                >> 8 as ::core::ffi::c_int;
                            let mut d_0: ::core::ffi::c_int = abs_coef_0 - unquant_abs_level_0;
                            if (*h).mb.i_psy_trellis != 0 && i_0 != 0 && dc == 0 && b_chroma == 0 {
                                let mut orig_coef_0: ::core::ffi::c_int =
                                    if num_coefs == 64 as ::core::ffi::c_int {
                                        (*h).mb.pic.fenc_dct8[idx as usize]
                                            [*zigzag.offset(i_0 as isize) as usize]
                                    } else {
                                        (*h).mb.pic.fenc_dct4[idx as usize]
                                            [*zigzag.offset(i_0 as isize) as usize]
                                    };
                                let mut predicted_coef_0: ::core::ffi::c_int =
                                    orig_coef_0 - sign_coef_0;
                                let mut psy_value_0: ::core::ffi::c_int = abs(unquant_abs_level_0
                                    + ((predicted_coef_0
                                        ^ sign_coef_0 >> 31 as ::core::ffi::c_int)
                                        - (sign_coef_0 >> 31 as ::core::ffi::c_int)));
                                let mut psy_weight_0: ::core::ffi::c_int = (*coef_weight1
                                    .offset(*zigzag.offset(i_0 as isize) as isize))
                                .wrapping_mul((*h).mb.i_psy_trellis as uint32_t)
                                    as ::core::ffi::c_int;
                                let mut tmp_0: int64_t = d_0 as int64_t
                                    * d_0 as int64_t
                                    * *coef_weight2.offset(*zigzag.offset(i_0 as isize) as isize)
                                        as int64_t
                                    - psy_weight_0 as int64_t * psy_value_0 as int64_t;
                                ssd1_0[k_0 as usize] = tmp_0 as uint64_t;
                            } else {
                                ssd1_0[k_0 as usize] = (d_0 as int64_t
                                    * d_0 as int64_t
                                    * (if dc != 0 {
                                        256 as uint32_t
                                    } else {
                                        *coef_weight2.offset(*zigzag.offset(i_0 as isize) as isize)
                                    }) as int64_t)
                                    as uint64_t;
                            }
                            ssd0_0[k_0 as usize] = ssd1_0[k_0 as usize];
                            if i_0 == 0 && dc == 0 && 1 as ::core::ffi::c_int == 0 {
                                d_0 = sign_coef_0
                                    - ((unquant_abs_level_0
                                        ^ sign_coef_0 >> 31 as ::core::ffi::c_int)
                                        - (sign_coef_0 >> 31 as ::core::ffi::c_int)
                                        + 8 as ::core::ffi::c_int
                                        & !(15 as ::core::ffi::c_int));
                                ssd0_0[k_0 as usize] = (d_0 as int64_t
                                    * d_0 as int64_t
                                    * *coef_weight2.offset(*zigzag.offset(i_0 as isize) as isize)
                                        as int64_t)
                                    as uint64_t;
                            }
                            k_0 += 1;
                        }
                        match q_0 {
                            1 => {
                                ssd1_0[0 as ::core::ffi::c_int as usize] =
                                    ssd1_0[0 as ::core::ffi::c_int as usize].wrapping_add(
                                        (cost_siglast_0[0 as ::core::ffi::c_int as usize]
                                            as uint64_t)
                                            .wrapping_mul(lambda2 as uint64_t)
                                            >> CABAC_SIZE_BITS - LAMBDA_BITS,
                                    );
                                levels_used = trellis_coef0_1(
                                    ssd0_0[0 as ::core::ffi::c_int as usize]
                                        .wrapping_sub(ssd1_0[0 as ::core::ffi::c_int as usize]),
                                    nodes_cur,
                                    nodes_prev,
                                    level_tree.as_mut_ptr(),
                                    levels_used,
                                );
                                levels_used = trellis_coef1_1(
                                    ssd0_0[1 as ::core::ffi::c_int as usize]
                                        .wrapping_sub(ssd1_0[0 as ::core::ffi::c_int as usize]),
                                    ssd1_0[1 as ::core::ffi::c_int as usize]
                                        .wrapping_sub(ssd1_0[0 as ::core::ffi::c_int as usize]),
                                    cost_siglast_0.as_mut_ptr(),
                                    nodes_cur,
                                    nodes_prev,
                                    level_tree.as_mut_ptr(),
                                    levels_used,
                                    lambda2,
                                    level_state.as_mut_ptr(),
                                );
                            }
                            2 => {
                                levels_used = trellis_coef1_1(
                                    ssd0_0[0 as ::core::ffi::c_int as usize],
                                    ssd1_0[0 as ::core::ffi::c_int as usize],
                                    cost_siglast_0.as_mut_ptr(),
                                    nodes_cur,
                                    nodes_prev,
                                    level_tree.as_mut_ptr(),
                                    levels_used,
                                    lambda2,
                                    level_state.as_mut_ptr(),
                                );
                                levels_used = trellis_coefn_1(
                                    q_0,
                                    ssd0_0[1 as ::core::ffi::c_int as usize],
                                    ssd1_0[1 as ::core::ffi::c_int as usize],
                                    cost_siglast_0.as_mut_ptr(),
                                    nodes_cur,
                                    nodes_prev,
                                    level_tree.as_mut_ptr(),
                                    levels_used,
                                    lambda2,
                                    level_state.as_mut_ptr(),
                                    levelgt1_ctx,
                                );
                            }
                            _ => {
                                levels_used = trellis_coefn_1(
                                    q_0 - 1 as ::core::ffi::c_int,
                                    ssd0_0[0 as ::core::ffi::c_int as usize],
                                    ssd1_0[0 as ::core::ffi::c_int as usize],
                                    cost_siglast_0.as_mut_ptr(),
                                    nodes_cur,
                                    nodes_prev,
                                    level_tree.as_mut_ptr(),
                                    levels_used,
                                    lambda2,
                                    level_state.as_mut_ptr(),
                                    levelgt1_ctx,
                                );
                                levels_used = trellis_coefn_1(
                                    q_0,
                                    ssd0_0[1 as ::core::ffi::c_int as usize],
                                    ssd1_0[1 as ::core::ffi::c_int as usize],
                                    cost_siglast_0.as_mut_ptr(),
                                    nodes_cur,
                                    nodes_prev,
                                    level_tree.as_mut_ptr(),
                                    levels_used,
                                    lambda2,
                                    level_state.as_mut_ptr(),
                                    levelgt1_ctx,
                                );
                            }
                        }
                    }
                }
                bnode =
                    &mut *nodes_cur.offset(1 as ::core::ffi::c_int as isize) as *mut trellis_node_t;
                let mut j_5: ::core::ffi::c_int = 1 as ::core::ffi::c_int + 1 as ::core::ffi::c_int;
                while j_5
                    < (if 1 as ::core::ffi::c_int != 0 {
                        8 as ::core::ffi::c_int
                    } else {
                        4 as ::core::ffi::c_int
                    })
                {
                    if (*nodes_cur.offset(j_5 as isize)).score < (*bnode).score {
                        bnode = &mut *nodes_cur.offset(j_5 as isize) as *mut trellis_node_t;
                    }
                    j_5 += 1;
                }
            }
            _ => {
                bnode =
                    &mut *nodes_cur.offset(0 as ::core::ffi::c_int as isize) as *mut trellis_node_t;
                let mut j_2: ::core::ffi::c_int = 0 as ::core::ffi::c_int + 1 as ::core::ffi::c_int;
                while j_2
                    < (if 0 as ::core::ffi::c_int != 0 {
                        8 as ::core::ffi::c_int
                    } else {
                        4 as ::core::ffi::c_int
                    })
                {
                    if (*nodes_cur.offset(j_2 as isize)).score < (*bnode).score {
                        bnode = &mut *nodes_cur.offset(j_2 as isize) as *mut trellis_node_t;
                    }
                    j_2 += 1;
                }
                if bnode
                    == &mut *nodes_cur.offset(0 as ::core::ffi::c_int as isize)
                        as *mut trellis_node_t
                {
                    if num_coefs == 16 as ::core::ffi::c_int && dc == 0 {
                        memset(
                            dct as *mut ::core::ffi::c_void,
                            0 as ::core::ffi::c_int,
                            (16 as size_t)
                                .wrapping_mul(::core::mem::size_of::<dctcoef>() as size_t),
                        );
                    }
                    return 0 as ::core::ffi::c_int;
                }
            }
        }
        let mut level: ::core::ffi::c_int = (*bnode).level_idx;
        i_0 = b_ac;
        while i_0 <= last_nnz {
            *dct.offset(*zigzag.offset(i_0 as isize) as isize) = (level_tree[level as usize]
                .abs_level
                as dctcoef
                ^ *dct.offset(*zigzag.offset(i_0 as isize) as isize) >> 31 as ::core::ffi::c_int)
                - (*dct.offset(*zigzag.offset(i_0 as isize) as isize) >> 31 as ::core::ffi::c_int);
            level = level_tree[level as usize].next as ::core::ffi::c_int;
            i_0 += 1;
        }
        return 1 as ::core::ffi::c_int;
    }
    #[inline(always)]
    #[c2rust::src_loc = "920:1"]
    pub unsafe extern "C" fn quant_trellis_cavlc(
        mut h: *mut x264_t,
        mut dct: *mut dctcoef,
        mut quant_mf: *const udctcoef,
        mut unquant_mf: *const ::core::ffi::c_int,
        mut zigzag: *const uint8_t,
        mut ctx_block_cat: ::core::ffi::c_int,
        mut lambda2: ::core::ffi::c_int,
        mut b_ac: ::core::ffi::c_int,
        mut b_chroma: ::core::ffi::c_int,
        mut dc: ::core::ffi::c_int,
        mut num_coefs: ::core::ffi::c_int,
        mut idx: ::core::ffi::c_int,
        mut b_8x8: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int {
        let mut last_nnz: ::core::ffi::c_int = 0;
        let mut coef_mask: ::core::ffi::c_int = 0;
        let mut round_mask: ::core::ffi::c_int = 0;
        let mut quant_coefs: [[dctcoef; 16]; 2] = [[0; 16]; 2];
        let mut coefs: [dctcoef; 16] = [0; 16];
        let mut coef_weight1: *const uint32_t = if b_8x8 != 0 {
            x264_dct8_weight_tab.as_ptr()
        } else {
            x264_dct4_weight_tab.as_ptr()
        };
        let mut coef_weight2: *const uint32_t = if b_8x8 != 0 {
            x264_dct8_weight2_tab.as_ptr()
        } else {
            x264_dct4_weight2_tab.as_ptr()
        };
        let mut delta_distortion: [int64_t; 16] = [0; 16];
        let mut score: int64_t =
            ((1 as ::core::ffi::c_ulonglong) << 62 as ::core::ffi::c_int) as int64_t;
        let mut i: ::core::ffi::c_int = 0;
        let mut j: ::core::ffi::c_int = 0;
        let f: ::core::ffi::c_int = (1 as ::core::ffi::c_int) << 15 as ::core::ffi::c_int;
        let mut nC: ::core::ffi::c_int = if b_chroma != 0 && dc != 0 {
            3 as ::core::ffi::c_int + (num_coefs >> 2 as ::core::ffi::c_int)
        } else {
            ct_index[x264_mb_predict_non_zero_code(
                h,
                if b_chroma == 0 && dc != 0 {
                    (idx - LUMA_DC) * 16 as ::core::ffi::c_int
                } else {
                    idx
                },
            ) as usize] as ::core::ffi::c_int
        };
        i = 0 as ::core::ffi::c_int;
        while i < 16 as ::core::ffi::c_int {
            (*(&mut *coefs.as_mut_ptr().offset(i as isize) as *mut dctcoef
                as *mut x264_union128_sse_t))
                .i = M128_ZERO;
            i = (i as ::core::ffi::c_ulong).wrapping_add(
                (16 as usize).wrapping_div(::core::mem::size_of::<dctcoef>() as usize)
                    as ::core::ffi::c_ulong,
            ) as ::core::ffi::c_int as ::core::ffi::c_int;
        }
        let mut step: ::core::ffi::c_int = 1 as ::core::ffi::c_int;
        let mut start: ::core::ffi::c_int = b_ac;
        let mut end: ::core::ffi::c_int = num_coefs - 1 as ::core::ffi::c_int;
        if b_8x8 != 0 {
            start = idx & 3 as ::core::ffi::c_int;
            end = 60 as ::core::ffi::c_int + start;
            step = 4 as ::core::ffi::c_int;
        }
        idx &= 15 as ::core::ffi::c_int;
        lambda2 <<= LAMBDA_BITS;
        i = end;
        while i >= start {
            if (abs(*dct.offset(*zigzag.offset(i as isize) as isize)) as udctcoef).wrapping_mul(
                (if dc != 0 {
                    *quant_mf.offset(0 as ::core::ffi::c_int as isize) >> 1 as ::core::ffi::c_int
                } else {
                    *quant_mf.offset(*zigzag.offset(i as isize) as isize)
                }),
            ) >= f as udctcoef
            {
                break;
            }
            i -= step;
        }
        if !(i < start) {
            last_nnz = if b_8x8 != 0 {
                i >> 2 as ::core::ffi::c_int
            } else {
                i
            };
            coef_mask = 0 as ::core::ffi::c_int;
            round_mask = 0 as ::core::ffi::c_int;
            i = b_ac;
            j = start;
            while i <= last_nnz {
                let mut coef: ::core::ffi::c_int = *dct.offset(*zigzag.offset(j as isize) as isize);
                let mut abs_coef: ::core::ffi::c_int = abs(coef);
                let mut sign: ::core::ffi::c_int = if coef < 0 as ::core::ffi::c_int {
                    -(1 as ::core::ffi::c_int)
                } else {
                    1 as ::core::ffi::c_int
                };
                let mut nearest_quant: ::core::ffi::c_int =
                    ((f as udctcoef).wrapping_add((abs_coef as udctcoef).wrapping_mul(
                        (if dc != 0 {
                            *quant_mf.offset(0 as ::core::ffi::c_int as isize)
                                >> 1 as ::core::ffi::c_int
                        } else {
                            *quant_mf.offset(*zigzag.offset(j as isize) as isize)
                        }),
                    )) >> 16 as ::core::ffi::c_int) as ::core::ffi::c_int;
                quant_coefs[0 as ::core::ffi::c_int as usize][i as usize] =
                    (sign * nearest_quant) as dctcoef;
                quant_coefs[1 as ::core::ffi::c_int as usize][i as usize] =
                    quant_coefs[0 as ::core::ffi::c_int as usize][i as usize];
                coefs[i as usize] = quant_coefs[1 as ::core::ffi::c_int as usize][i as usize];
                if nearest_quant != 0 {
                    let mut deadzone_quant: ::core::ffi::c_int = (((f / 2 as ::core::ffi::c_int)
                        as udctcoef)
                        .wrapping_add((abs_coef as udctcoef).wrapping_mul(
                            (if dc != 0 {
                                *quant_mf.offset(0 as ::core::ffi::c_int as isize)
                                    >> 1 as ::core::ffi::c_int
                            } else {
                                *quant_mf.offset(*zigzag.offset(j as isize) as isize)
                            }),
                        ))
                        >> 16 as ::core::ffi::c_int)
                        as ::core::ffi::c_int;
                    let mut unquant1: ::core::ffi::c_int = (if dc != 0 {
                        *unquant_mf.offset(0 as ::core::ffi::c_int as isize)
                            << 1 as ::core::ffi::c_int
                    } else {
                        *unquant_mf.offset(*zigzag.offset(j as isize) as isize)
                    }) * (nearest_quant
                        - 0 as ::core::ffi::c_int)
                        + 128 as ::core::ffi::c_int
                        >> 8 as ::core::ffi::c_int;
                    let mut unquant0: ::core::ffi::c_int = (if dc != 0 {
                        *unquant_mf.offset(0 as ::core::ffi::c_int as isize)
                            << 1 as ::core::ffi::c_int
                    } else {
                        *unquant_mf.offset(*zigzag.offset(j as isize) as isize)
                    }) * (nearest_quant
                        - 1 as ::core::ffi::c_int)
                        + 128 as ::core::ffi::c_int
                        >> 8 as ::core::ffi::c_int;
                    let mut d1: ::core::ffi::c_int = abs_coef - unquant1;
                    let mut d0: ::core::ffi::c_int = abs_coef - unquant0;
                    delta_distortion[i as usize] = (d0 * d0 - d1 * d1) as int64_t
                        * (if dc != 0 {
                            256 as uint32_t
                        } else {
                            *coef_weight2.offset(*zigzag.offset(j as isize) as isize)
                        }) as int64_t;
                    if (*h).mb.i_psy_trellis != 0 && j != 0 && dc == 0 && b_chroma == 0 {
                        let mut orig_coef: ::core::ffi::c_int = if b_8x8 != 0 {
                            (*h).mb.pic.fenc_dct8[(idx >> 2 as ::core::ffi::c_int) as usize]
                                [*zigzag.offset(j as isize) as usize]
                        } else {
                            (*h).mb.pic.fenc_dct4[idx as usize][*zigzag.offset(j as isize) as usize]
                        };
                        let mut predicted_coef: ::core::ffi::c_int = orig_coef - coef;
                        let mut psy_weight: ::core::ffi::c_int = *coef_weight1
                            .offset(*zigzag.offset(j as isize) as isize)
                            as ::core::ffi::c_int;
                        let mut psy_value0: ::core::ffi::c_int =
                            (*h).mb.i_psy_trellis * abs(predicted_coef + unquant0 * sign);
                        let mut psy_value1: ::core::ffi::c_int =
                            (*h).mb.i_psy_trellis * abs(predicted_coef + unquant1 * sign);
                        delta_distortion[i as usize] +=
                            ((psy_value0 - psy_value1) * psy_weight) as int64_t;
                    }
                    quant_coefs[0 as ::core::ffi::c_int as usize][i as usize] =
                        (sign * (nearest_quant - 1 as ::core::ffi::c_int)) as dctcoef;
                    if deadzone_quant != nearest_quant {
                        coefs[i as usize] =
                            quant_coefs[0 as ::core::ffi::c_int as usize][i as usize];
                    } else {
                        round_mask |= (1 as ::core::ffi::c_int) << i;
                    }
                } else {
                    delta_distortion[i as usize] = 0 as int64_t;
                }
                coef_mask |= ((coefs[i as usize] != 0) as ::core::ffi::c_int) << i;
                i += 1;
                j += step;
            }
            (*h).out.bs.i_bits_encoded = 0 as ::core::ffi::c_int;
            if coef_mask == 0 {
                (*h).out.bs.i_bits_encoded +=
                    x264_coeff0_token[nC as usize].i_size as ::core::ffi::c_int;
            } else {
                cavlc_block_residual_internal(
                    h,
                    ctx_block_cat,
                    coefs.as_mut_ptr().offset(b_ac as isize),
                    nC,
                );
            }
            score = (*h).out.bs.i_bits_encoded as int64_t * lambda2 as int64_t;
            loop {
                let mut iter_score: int64_t = score;
                let mut iter_distortion_delta: int64_t = 0 as int64_t;
                let mut iter_coef: ::core::ffi::c_int = -(1 as ::core::ffi::c_int);
                let mut iter_mask: ::core::ffi::c_int = coef_mask;
                let mut iter_round: ::core::ffi::c_int = round_mask;
                i = b_ac;
                while i <= last_nnz {
                    if !(delta_distortion[i as usize] == 0) {
                        let mut cur_round: ::core::ffi::c_int =
                            round_mask ^ (1 as ::core::ffi::c_int) << i;
                        let mut round_change: ::core::ffi::c_int =
                            cur_round >> i & 1 as ::core::ffi::c_int;
                        let mut old_coef: ::core::ffi::c_int = coefs[i as usize];
                        let mut new_coef: ::core::ffi::c_int =
                            quant_coefs[round_change as usize][i as usize];
                        let mut cur_mask: ::core::ffi::c_int = coef_mask
                            & !((1 as ::core::ffi::c_int) << i)
                            | ((new_coef != 0) as ::core::ffi::c_int) << i;
                        let mut cur_distortion_delta: int64_t = delta_distortion[i as usize]
                            * (if round_change != 0 {
                                -(1 as ::core::ffi::c_int)
                            } else {
                                1 as ::core::ffi::c_int
                            }) as int64_t;
                        let mut cur_score: int64_t = cur_distortion_delta;
                        coefs[i as usize] = new_coef as dctcoef;
                        (*h).out.bs.i_bits_encoded = 0 as ::core::ffi::c_int;
                        if cur_mask == 0 {
                            (*h).out.bs.i_bits_encoded +=
                                x264_coeff0_token[nC as usize].i_size as ::core::ffi::c_int;
                        } else {
                            cavlc_block_residual_internal(
                                h,
                                ctx_block_cat,
                                coefs.as_mut_ptr().offset(b_ac as isize),
                                nC,
                            );
                        }
                        cur_score += (*h).out.bs.i_bits_encoded as int64_t * lambda2 as int64_t;
                        coefs[i as usize] = old_coef as dctcoef;
                        if cur_score < iter_score {
                            iter_score = cur_score;
                            iter_coef = i;
                            iter_mask = cur_mask;
                            iter_round = cur_round;
                            iter_distortion_delta = cur_distortion_delta;
                        }
                    }
                    i += 1;
                }
                if !(iter_coef >= 0 as ::core::ffi::c_int) {
                    break;
                }
                score = iter_score - iter_distortion_delta;
                coef_mask = iter_mask;
                round_mask = iter_round;
                coefs[iter_coef as usize] = quant_coefs
                    [(round_mask >> iter_coef & 1 as ::core::ffi::c_int) as usize]
                    [iter_coef as usize];
                delta_distortion[iter_coef as usize] = 0 as int64_t;
            }
            if coef_mask != 0 {
                i = b_ac;
                j = start;
                while i < num_coefs {
                    *dct.offset(*zigzag.offset(j as isize) as isize) = coefs[i as usize];
                    i += 1;
                    j += step;
                }
                return 1 as ::core::ffi::c_int;
            }
        }
        if dc == 0 {
            if b_8x8 != 0 {
                i = start;
                while i <= end {
                    *dct.offset(*zigzag.offset(i as isize) as isize) =
                        0 as ::core::ffi::c_int as dctcoef;
                    i += step;
                }
            } else {
                memset(
                    dct as *mut ::core::ffi::c_void,
                    0 as ::core::ffi::c_int,
                    (16 as size_t).wrapping_mul(::core::mem::size_of::<dctcoef>() as size_t),
                );
            }
        }
        return 0 as ::core::ffi::c_int;
    }
    #[no_mangle]
    #[c2rust::src_loc = "1098:1"]
    pub unsafe extern "C" fn x264_10_quant_luma_dc_trellis(
        mut h: *mut x264_t,
        mut dct: *mut dctcoef,
        mut i_quant_cat: ::core::ffi::c_int,
        mut i_qp: ::core::ffi::c_int,
        mut ctx_block_cat: ::core::ffi::c_int,
        mut b_intra: ::core::ffi::c_int,
        mut idx: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int {
        if (*h).param.b_cabac != 0 {
            return quant_trellis_cabac(
                h,
                dct,
                (*(*(*h).quant4_mf.as_mut_ptr().offset(i_quant_cat as isize))
                    .offset(i_qp as isize))
                .as_mut_ptr(),
                (*(*(*h).quant4_bias0.as_mut_ptr().offset(i_quant_cat as isize))
                    .offset(i_qp as isize))
                .as_mut_ptr(),
                (*(*(*h).unquant4_mf.as_mut_ptr().offset(i_quant_cat as isize))
                    .offset(i_qp as isize))
                .as_mut_ptr(),
                (*x264_zigzag_scan4
                    .as_ptr()
                    .offset((*h).mb.b_interlaced as isize))
                .as_ptr(),
                ctx_block_cat,
                (*h).mb.i_trellis_lambda2[0 as ::core::ffi::c_int as usize][b_intra as usize],
                0 as ::core::ffi::c_int,
                0 as ::core::ffi::c_int,
                1 as ::core::ffi::c_int,
                16 as ::core::ffi::c_int,
                idx,
            );
        }
        return quant_trellis_cavlc(
            h,
            dct,
            (*(*(*h).quant4_mf.as_mut_ptr().offset(i_quant_cat as isize)).offset(i_qp as isize))
                .as_mut_ptr(),
            (*(*(*h).unquant4_mf.as_mut_ptr().offset(i_quant_cat as isize)).offset(i_qp as isize))
                .as_mut_ptr(),
            (*x264_zigzag_scan4
                .as_ptr()
                .offset((*h).mb.b_interlaced as isize))
            .as_ptr(),
            DCT_LUMA_DC as ::core::ffi::c_int,
            (*h).mb.i_trellis_lambda2[0 as ::core::ffi::c_int as usize][b_intra as usize],
            0 as ::core::ffi::c_int,
            0 as ::core::ffi::c_int,
            1 as ::core::ffi::c_int,
            16 as ::core::ffi::c_int,
            idx,
            0 as ::core::ffi::c_int,
        );
    }
    #[c2rust::src_loc = "1111:22"]
    pub static mut zigzag_scan2x2: [uint8_t; 4] = [
        0 as ::core::ffi::c_int as uint8_t,
        1 as ::core::ffi::c_int as uint8_t,
        2 as ::core::ffi::c_int as uint8_t,
        3 as ::core::ffi::c_int as uint8_t,
    ];
    #[c2rust::src_loc = "1112:22"]
    pub static mut zigzag_scan2x4: [uint8_t; 8] = [
        0 as ::core::ffi::c_int as uint8_t,
        2 as ::core::ffi::c_int as uint8_t,
        1 as ::core::ffi::c_int as uint8_t,
        4 as ::core::ffi::c_int as uint8_t,
        6 as ::core::ffi::c_int as uint8_t,
        3 as ::core::ffi::c_int as uint8_t,
        5 as ::core::ffi::c_int as uint8_t,
        7 as ::core::ffi::c_int as uint8_t,
    ];
    #[no_mangle]
    #[c2rust::src_loc = "1114:1"]
    pub unsafe extern "C" fn x264_10_quant_chroma_dc_trellis(
        mut h: *mut x264_t,
        mut dct: *mut dctcoef,
        mut i_qp: ::core::ffi::c_int,
        mut b_intra: ::core::ffi::c_int,
        mut idx: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int {
        let mut zigzag: *const uint8_t = 0 as *const uint8_t;
        let mut num_coefs: ::core::ffi::c_int = 0;
        let mut quant_cat: ::core::ffi::c_int =
            CQM_4IC as ::core::ffi::c_int + 1 as ::core::ffi::c_int - b_intra;
        if (*(*h).sps.as_mut_ptr()).i_chroma_format_idc == CHROMA_422 as ::core::ffi::c_int {
            zigzag = zigzag_scan2x4.as_ptr();
            num_coefs = 8 as ::core::ffi::c_int;
        } else {
            zigzag = zigzag_scan2x2.as_ptr();
            num_coefs = 4 as ::core::ffi::c_int;
        }
        if (*h).param.b_cabac != 0 {
            return quant_trellis_cabac(
                h,
                dct,
                (*(*(*h).quant4_mf.as_mut_ptr().offset(quant_cat as isize)).offset(i_qp as isize))
                    .as_mut_ptr(),
                (*(*(*h).quant4_bias0.as_mut_ptr().offset(quant_cat as isize))
                    .offset(i_qp as isize))
                .as_mut_ptr(),
                (*(*(*h).unquant4_mf.as_mut_ptr().offset(quant_cat as isize))
                    .offset(i_qp as isize))
                .as_mut_ptr(),
                zigzag,
                DCT_CHROMA_DC as ::core::ffi::c_int,
                (*h).mb.i_trellis_lambda2[1 as ::core::ffi::c_int as usize][b_intra as usize],
                0 as ::core::ffi::c_int,
                1 as ::core::ffi::c_int,
                1 as ::core::ffi::c_int,
                num_coefs,
                idx,
            );
        }
        return quant_trellis_cavlc(
            h,
            dct,
            (*(*(*h).quant4_mf.as_mut_ptr().offset(quant_cat as isize)).offset(i_qp as isize))
                .as_mut_ptr(),
            (*(*(*h).unquant4_mf.as_mut_ptr().offset(quant_cat as isize)).offset(i_qp as isize))
                .as_mut_ptr(),
            zigzag,
            DCT_CHROMA_DC as ::core::ffi::c_int,
            (*h).mb.i_trellis_lambda2[1 as ::core::ffi::c_int as usize][b_intra as usize],
            0 as ::core::ffi::c_int,
            1 as ::core::ffi::c_int,
            1 as ::core::ffi::c_int,
            num_coefs,
            idx,
            0 as ::core::ffi::c_int,
        );
    }
    #[no_mangle]
    #[c2rust::src_loc = "1142:1"]
    pub unsafe extern "C" fn x264_10_quant_4x4_trellis(
        mut h: *mut x264_t,
        mut dct: *mut dctcoef,
        mut i_quant_cat: ::core::ffi::c_int,
        mut i_qp: ::core::ffi::c_int,
        mut ctx_block_cat: ::core::ffi::c_int,
        mut b_intra: ::core::ffi::c_int,
        mut b_chroma: ::core::ffi::c_int,
        mut idx: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int {
        pub static mut ctx_ac: [uint8_t; 14] = [
            0 as ::core::ffi::c_int as uint8_t,
            1 as ::core::ffi::c_int as uint8_t,
            0 as ::core::ffi::c_int as uint8_t,
            0 as ::core::ffi::c_int as uint8_t,
            1 as ::core::ffi::c_int as uint8_t,
            0 as ::core::ffi::c_int as uint8_t,
            0 as ::core::ffi::c_int as uint8_t,
            1 as ::core::ffi::c_int as uint8_t,
            0 as ::core::ffi::c_int as uint8_t,
            0 as ::core::ffi::c_int as uint8_t,
            0 as ::core::ffi::c_int as uint8_t,
            1 as ::core::ffi::c_int as uint8_t,
            0 as ::core::ffi::c_int as uint8_t,
            0 as ::core::ffi::c_int as uint8_t,
        ];
        let mut b_ac: ::core::ffi::c_int = ctx_ac[ctx_block_cat as usize] as ::core::ffi::c_int;
        if (*h).param.b_cabac != 0 {
            return quant_trellis_cabac(
                h,
                dct,
                (*(*(*h).quant4_mf.as_mut_ptr().offset(i_quant_cat as isize))
                    .offset(i_qp as isize))
                .as_mut_ptr(),
                (*(*(*h).quant4_bias0.as_mut_ptr().offset(i_quant_cat as isize))
                    .offset(i_qp as isize))
                .as_mut_ptr(),
                (*(*(*h).unquant4_mf.as_mut_ptr().offset(i_quant_cat as isize))
                    .offset(i_qp as isize))
                .as_mut_ptr(),
                (*x264_zigzag_scan4
                    .as_ptr()
                    .offset((*h).mb.b_interlaced as isize))
                .as_ptr(),
                ctx_block_cat,
                (*h).mb.i_trellis_lambda2[b_chroma as usize][b_intra as usize],
                b_ac,
                b_chroma,
                0 as ::core::ffi::c_int,
                16 as ::core::ffi::c_int,
                idx,
            );
        }
        return quant_trellis_cavlc(
            h,
            dct,
            (*(*(*h).quant4_mf.as_mut_ptr().offset(i_quant_cat as isize)).offset(i_qp as isize))
                .as_mut_ptr(),
            (*(*(*h).unquant4_mf.as_mut_ptr().offset(i_quant_cat as isize)).offset(i_qp as isize))
                .as_mut_ptr(),
            (*x264_zigzag_scan4
                .as_ptr()
                .offset((*h).mb.b_interlaced as isize))
            .as_ptr(),
            ctx_block_cat,
            (*h).mb.i_trellis_lambda2[b_chroma as usize][b_intra as usize],
            b_ac,
            b_chroma,
            0 as ::core::ffi::c_int,
            16 as ::core::ffi::c_int,
            idx,
            0 as ::core::ffi::c_int,
        );
    }
    #[no_mangle]
    #[c2rust::src_loc = "1159:1"]
    pub unsafe extern "C" fn x264_10_quant_8x8_trellis(
        mut h: *mut x264_t,
        mut dct: *mut dctcoef,
        mut i_quant_cat: ::core::ffi::c_int,
        mut i_qp: ::core::ffi::c_int,
        mut ctx_block_cat: ::core::ffi::c_int,
        mut b_intra: ::core::ffi::c_int,
        mut b_chroma: ::core::ffi::c_int,
        mut idx: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int {
        if (*h).param.b_cabac != 0 {
            return quant_trellis_cabac(
                h,
                dct,
                (*(*(*h).quant8_mf.as_mut_ptr().offset(i_quant_cat as isize))
                    .offset(i_qp as isize))
                .as_mut_ptr(),
                (*(*(*h).quant8_bias0.as_mut_ptr().offset(i_quant_cat as isize))
                    .offset(i_qp as isize))
                .as_mut_ptr(),
                (*(*(*h).unquant8_mf.as_mut_ptr().offset(i_quant_cat as isize))
                    .offset(i_qp as isize))
                .as_mut_ptr(),
                (*x264_zigzag_scan8
                    .as_ptr()
                    .offset((*h).mb.b_interlaced as isize))
                .as_ptr(),
                ctx_block_cat,
                (*h).mb.i_trellis_lambda2[b_chroma as usize][b_intra as usize],
                0 as ::core::ffi::c_int,
                b_chroma,
                0 as ::core::ffi::c_int,
                64 as ::core::ffi::c_int,
                idx,
            );
        }
        let mut nzaccum: ::core::ffi::c_int = 0 as ::core::ffi::c_int;
        let mut i: ::core::ffi::c_int = 0 as ::core::ffi::c_int;
        while i < 4 as ::core::ffi::c_int {
            let mut nz: ::core::ffi::c_int = quant_trellis_cavlc(
                h,
                dct,
                (*(*(*h).quant8_mf.as_mut_ptr().offset(i_quant_cat as isize))
                    .offset(i_qp as isize))
                .as_mut_ptr(),
                (*(*(*h).unquant8_mf.as_mut_ptr().offset(i_quant_cat as isize))
                    .offset(i_qp as isize))
                .as_mut_ptr(),
                (*x264_zigzag_scan8
                    .as_ptr()
                    .offset((*h).mb.b_interlaced as isize))
                .as_ptr(),
                DCT_LUMA_4x4 as ::core::ffi::c_int,
                (*h).mb.i_trellis_lambda2[b_chroma as usize][b_intra as usize],
                0 as ::core::ffi::c_int,
                b_chroma,
                0 as ::core::ffi::c_int,
                16 as ::core::ffi::c_int,
                idx * 4 as ::core::ffi::c_int + i,
                1 as ::core::ffi::c_int,
            );
            (*h).mb.cache.non_zero_count
                [x264_scan8[(idx * 4 as ::core::ffi::c_int + i) as usize] as usize] = nz as uint8_t;
            nzaccum |= nz;
            i += 1;
        }
        (*(&mut *(*h).mb.cache.non_zero_count.as_mut_ptr().offset(
            (*x264_scan8.as_ptr().offset(
                (0 as ::core::ffi::c_int * 16 as ::core::ffi::c_int + idx * 4 as ::core::ffi::c_int)
                    as isize,
            ) as ::core::ffi::c_int
                + 0 as ::core::ffi::c_int) as isize,
        ) as *mut uint8_t as *mut x264_union16_t))
            .i = (0 as ::core::ffi::c_int * 0x101 as ::core::ffi::c_int) as uint16_t;
        (*(&mut *(*h).mb.cache.non_zero_count.as_mut_ptr().offset(
            (*x264_scan8.as_ptr().offset(
                (0 as ::core::ffi::c_int * 16 as ::core::ffi::c_int + idx * 4 as ::core::ffi::c_int)
                    as isize,
            ) as ::core::ffi::c_int
                + 8 as ::core::ffi::c_int) as isize,
        ) as *mut uint8_t as *mut x264_union16_t))
            .i = (0 as ::core::ffi::c_int * 0x101 as ::core::ffi::c_int) as uint16_t;
        return nzaccum;
    }
    use super::__stddef_size_t_h::size_t;
    use super::base_h::{
        x264_scan8, x264_union16_t, x264_union32_t, CHROMA_422, CHROMA_444, LUMA_DC,
    };
    use super::bitstream_h::bs_size_ue_big;
    use super::cabac_c::{
        chroma_size_cabac, macroblock_size_cabac, partition_i4x4_size_cabac,
        partition_i8x8_size_cabac, partition_size_cabac, subpartition_size_cabac,
    };
    use super::cabac_h::{x264_cabac_size_decision2, x264_cabac_size_decision_noup2, x264_cabac_t};
    use super::cavlc_c::{
        cavlc_block_residual_internal, chroma_size_cavlc, ct_index, macroblock_size_cavlc,
        partition_i4x4_size_cavlc, partition_i8x8_size_cavlc, partition_size_cavlc,
        subpartition_size_cavlc,
    };
    use super::common_h::{dctcoef, pixel, udctcoef, x264_t, FDEC_STRIDE, FENC_STRIDE};
    use super::encoder_macroblock_h::{
        x264_10_macroblock_encode, x264_10_macroblock_encode_p4x4, x264_10_macroblock_encode_p8x8,
        x264_10_mb_encode_chroma, x264_mb_encode_i4x4, x264_mb_encode_i8x8,
    };
    use super::frame_h::x264_10_macroblock_deblock;
    use super::macroblock_h::{
        block_idx_x, block_idx_y, pack16to32, x264_mb_predict_non_zero_code, x264_zigzag_scan4,
        x264_zigzag_scan8, DCT_LUMA_4x4, B_SKIP, DCT_CHROMA_DC, DCT_LUMA_DC, P_SKIP,
    };
    use super::pixel_h::{
        PIXEL_16x16, PIXEL_16x8, PIXEL_4x4, PIXEL_4x8, PIXEL_8x16, PIXEL_8x4, PIXEL_8x8,
    };
    use super::set_h::CQM_4IC;
    use super::stdint_h::intptr_t;
    use super::stdint_intn_h::int64_t;
    use super::stdint_uintn_h::{uint16_t, uint32_t, uint64_t, uint8_t};
    use super::stdlib_h::abs;
    use super::string_h::{memcpy, memset};
    use super::tables_h::{
        x264_cabac_entropy, x264_cabac_transition, x264_coeff0_token,
        x264_coeff_abs_level_m1_offset, x264_coeff_flag_offset_chroma_422_dc,
        x264_dct4_weight2_tab, x264_dct4_weight_tab, x264_dct8_weight2_tab, x264_dct8_weight_tab,
        x264_last_coeff_flag_offset, x264_last_coeff_flag_offset_8x8,
        x264_significant_coeff_flag_offset, x264_significant_coeff_flag_offset_8x8, x264_zero,
    };
    use super::util_h::{x264_union128_sse_t, M128_ZERO};
    use super::xmmintrin_h::__m128;
    #[cfg(target_arch = "x86")]
    pub use ::core::arch::x86::_mm_setr_ps;
    #[cfg(target_arch = "x86_64")]
    pub use ::core::arch::x86_64::_mm_setr_ps;
}
#[c2rust::header_src = "/home/nwplayer123/Hacks/hex264/x264/encoder/me.h:28"]
pub mod me_h {
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "33:9"]
    pub struct x264_me_t {
        pub i_pixel: ::core::ffi::c_int,
        pub p_cost_mv: *mut uint16_t,
        pub i_ref_cost: ::core::ffi::c_int,
        pub i_ref: ::core::ffi::c_int,
        pub weight: *const x264_weight_t,
        pub p_fref: [*mut pixel; 12],
        pub p_fref_w: *mut pixel,
        pub p_fenc: [*mut pixel; 3],
        pub integral: *mut uint16_t,
        pub i_stride: [::core::ffi::c_int; 3],
        pub mvp: [int16_t; 2],
        pub cost_mv: ::core::ffi::c_int,
        pub cost: ::core::ffi::c_int,
        pub mv: [int16_t; 2],
    }
    #[c2rust::src_loc = "30:9"]
    pub const COST_MAX: ::core::ffi::c_int = (1 as ::core::ffi::c_int) << 28 as ::core::ffi::c_int;
    #[c2rust::src_loc = "31:9"]
    pub const COST_MAX64: ::core::ffi::c_ulonglong =
        (1 as ::core::ffi::c_ulonglong) << 60 as ::core::ffi::c_int;
    use super::common_h::{pixel, x264_t};
    use super::mc_h::x264_weight_t;
    use super::stdint_intn_h::int16_t;
    use super::stdint_uintn_h::uint16_t;
    extern "C" {
        #[c2rust::src_loc = "59:1"]
        pub fn x264_10_me_search_ref(
            h: *mut x264_t,
            m: *mut x264_me_t,
            mvc: *mut [int16_t; 2],
            i_mvc: ::core::ffi::c_int,
            p_fullpel_thresh: *mut ::core::ffi::c_int,
        );
        #[c2rust::src_loc = "64:1"]
        pub fn x264_10_me_refine_qpel(h: *mut x264_t, m: *mut x264_me_t);
        #[c2rust::src_loc = "66:1"]
        pub fn x264_10_me_refine_qpel_refdupe(
            h: *mut x264_t,
            m: *mut x264_me_t,
            p_halfpel_thresh: *mut ::core::ffi::c_int,
        );
        #[c2rust::src_loc = "68:1"]
        pub fn x264_10_me_refine_qpel_rd(
            h: *mut x264_t,
            m: *mut x264_me_t,
            i_lambda2: ::core::ffi::c_int,
            i4: ::core::ffi::c_int,
            i_list: ::core::ffi::c_int,
        );
        #[c2rust::src_loc = "70:1"]
        pub fn x264_10_me_refine_bidir_rd(
            h: *mut x264_t,
            m0: *mut x264_me_t,
            m1: *mut x264_me_t,
            i_weight: ::core::ffi::c_int,
            i8: ::core::ffi::c_int,
            i_lambda2: ::core::ffi::c_int,
        );
        #[c2rust::src_loc = "72:1"]
        pub fn x264_10_me_refine_bidir_satd(
            h: *mut x264_t,
            m0: *mut x264_me_t,
            m1: *mut x264_me_t,
            i_weight: ::core::ffi::c_int,
        );
    }
}
#[c2rust::header_src = "/home/nwplayer123/Hacks/hex264/x264/encoder/slicetype.c:28"]
pub mod slicetype_c {
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "799:9"]
    pub struct x264_slicetype_slice_t {
        pub h: *mut x264_t,
        pub a: *mut x264_mb_analysis_t,
        pub frames: *mut *mut x264_frame_t,
        pub p0: ::core::ffi::c_int,
        pub p1: ::core::ffi::c_int,
        pub b: ::core::ffi::c_int,
        pub dist_scale_factor: ::core::ffi::c_int,
        pub do_search: *mut ::core::ffi::c_int,
        pub w: *const x264_weight_t,
        pub output_inter: *mut ::core::ffi::c_int,
        pub output_intra: *mut ::core::ffi::c_int,
    }
    #[c2rust::src_loc = "33:22"]
    pub static mut delta_tfi_divisor: [uint8_t; 10] = [
        0 as ::core::ffi::c_int as uint8_t,
        2 as ::core::ffi::c_int as uint8_t,
        1 as ::core::ffi::c_int as uint8_t,
        1 as ::core::ffi::c_int as uint8_t,
        2 as ::core::ffi::c_int as uint8_t,
        2 as ::core::ffi::c_int as uint8_t,
        3 as ::core::ffi::c_int as uint8_t,
        3 as ::core::ffi::c_int as uint8_t,
        4 as ::core::ffi::c_int as uint8_t,
        6 as ::core::ffi::c_int as uint8_t,
    ];
    #[c2rust::src_loc = "45:1"]
    pub unsafe extern "C" fn lowres_context_init(
        mut h: *mut x264_t,
        mut a: *mut x264_mb_analysis_t,
    ) {
        (*a).i_qp = X264_LOOKAHEAD_QP;
        (*a).i_lambda = x264_lambda_tab[(*a).i_qp as usize] as ::core::ffi::c_int;
        mb_analyse_load_costs(h, a);
        if (*h).param.analyse.i_subpel_refine > 1 as ::core::ffi::c_int {
            (*h).mb.i_me_method = if (1 as ::core::ffi::c_int) < (*h).param.analyse.i_me_method {
                1 as ::core::ffi::c_int
            } else {
                (*h).param.analyse.i_me_method
            };
            (*h).mb.i_subpel_refine = 4 as ::core::ffi::c_int;
        } else {
            (*h).mb.i_me_method = X264_ME_DIA;
            (*h).mb.i_subpel_refine = 2 as ::core::ffi::c_int;
        }
        (*h).mb.b_chroma_me = 0 as ::core::ffi::c_int;
    }
    #[c2rust::src_loc = "64:1"]
    pub unsafe extern "C" fn weight_get_h264(
        mut weight_nonh264: ::core::ffi::c_int,
        mut offset: ::core::ffi::c_int,
        mut w: *mut x264_weight_t,
    ) {
        (*w).i_offset = offset as int32_t;
        (*w).i_denom = 7 as ::core::ffi::c_int as int32_t;
        (*w).i_scale = weight_nonh264 as int32_t;
        while (*w).i_denom > 0 as int32_t && (*w).i_scale > 127 as int32_t {
            (*w).i_denom -= 1;
            (*w).i_scale >>= 1 as ::core::ffi::c_int;
        }
        (*w).i_scale = if (*w).i_scale < 127 as int32_t {
            (*w).i_scale
        } else {
            127 as int32_t
        };
    }
    #[inline(never)]
    #[c2rust::src_loc = "77:1"]
    pub unsafe extern "C" fn weight_cost_init_luma(
        mut h: *mut x264_t,
        mut fenc: *mut x264_frame_t,
        mut ref_0: *mut x264_frame_t,
        mut dest: *mut pixel,
    ) -> *mut pixel {
        let mut ref0_distance: ::core::ffi::c_int =
            (*fenc).i_frame - (*ref_0).i_frame - 1 as ::core::ffi::c_int;
        if (*(*fenc).lowres_mvs[0 as ::core::ffi::c_int as usize][ref0_distance as usize]
            .offset(0 as ::core::ffi::c_int as isize))[0 as ::core::ffi::c_int as usize]
            as ::core::ffi::c_int
            != 0x7fff as ::core::ffi::c_int
        {
            let mut i_stride: ::core::ffi::c_int = (*fenc).i_stride_lowres;
            let mut i_lines: ::core::ffi::c_int = (*fenc).i_lines_lowres;
            let mut i_width: ::core::ffi::c_int = (*fenc).i_width_lowres;
            let mut i_mb_xy: ::core::ffi::c_int = 0 as ::core::ffi::c_int;
            let mut p: *mut pixel = dest;
            let mut y: ::core::ffi::c_int = 0 as ::core::ffi::c_int;
            while y < i_lines {
                let mut x: ::core::ffi::c_int = 0 as ::core::ffi::c_int;
                while x < i_width {
                    let mut mvx: ::core::ffi::c_int = (*(*fenc).lowres_mvs
                        [0 as ::core::ffi::c_int as usize][ref0_distance as usize]
                        .offset(i_mb_xy as isize))[0 as ::core::ffi::c_int as usize]
                        as ::core::ffi::c_int;
                    let mut mvy: ::core::ffi::c_int = (*(*fenc).lowres_mvs
                        [0 as ::core::ffi::c_int as usize][ref0_distance as usize]
                        .offset(i_mb_xy as isize))[1 as ::core::ffi::c_int as usize]
                        as ::core::ffi::c_int;
                    (*h).mc.mc_luma.expect("non-null function pointer")(
                        p.offset(x as isize),
                        i_stride as intptr_t,
                        (*ref_0).lowres.as_mut_ptr(),
                        i_stride as intptr_t,
                        mvx + (x << 2 as ::core::ffi::c_int),
                        mvy + (y << 2 as ::core::ffi::c_int),
                        8 as ::core::ffi::c_int,
                        8 as ::core::ffi::c_int,
                        x264_zero.as_mut_ptr() as *const x264_weight_t,
                    );
                    x += 8 as ::core::ffi::c_int;
                    i_mb_xy += 1;
                }
                y += 8 as ::core::ffi::c_int;
                p = p.offset((i_stride * 8 as ::core::ffi::c_int) as isize);
            }
            return dest;
        }
        return (*ref_0).lowres[0 as ::core::ffi::c_int as usize];
    }
    #[inline(never)]
    #[c2rust::src_loc = "111:1"]
    pub unsafe extern "C" fn weight_cost_init_chroma(
        mut h: *mut x264_t,
        mut fenc: *mut x264_frame_t,
        mut ref_0: *mut x264_frame_t,
        mut dstu: *mut pixel,
        mut dstv: *mut pixel,
    ) {
        let mut ref0_distance: ::core::ffi::c_int =
            (*fenc).i_frame - (*ref_0).i_frame - 1 as ::core::ffi::c_int;
        let mut i_stride: ::core::ffi::c_int = (*fenc).i_stride[1 as ::core::ffi::c_int as usize];
        let mut i_lines: ::core::ffi::c_int = (*fenc).i_lines[1 as ::core::ffi::c_int as usize];
        let mut i_width: ::core::ffi::c_int = (*fenc).i_width[1 as ::core::ffi::c_int as usize];
        let mut v_shift: ::core::ffi::c_int = (*h).mb.chroma_v_shift;
        let mut cw: ::core::ffi::c_int = 8 as ::core::ffi::c_int * (*h).mb.i_mb_width;
        let mut ch: ::core::ffi::c_int = 16 as ::core::ffi::c_int * (*h).mb.i_mb_height >> v_shift;
        let mut height: ::core::ffi::c_int = 16 as ::core::ffi::c_int >> v_shift;
        if (*(*fenc).lowres_mvs[0 as ::core::ffi::c_int as usize][ref0_distance as usize]
            .offset(0 as ::core::ffi::c_int as isize))[0 as ::core::ffi::c_int as usize]
            as ::core::ffi::c_int
            != 0x7fff as ::core::ffi::c_int
        {
            x264_10_frame_expand_border_chroma(h, ref_0, 1 as ::core::ffi::c_int);
            let mut y: ::core::ffi::c_int = 0 as ::core::ffi::c_int;
            let mut mb_xy: ::core::ffi::c_int = 0 as ::core::ffi::c_int;
            let mut pel_offset_y: ::core::ffi::c_int = 0 as ::core::ffi::c_int;
            while y < i_lines {
                let mut x: ::core::ffi::c_int = 0 as ::core::ffi::c_int;
                let mut pel_offset_x: ::core::ffi::c_int = 0 as ::core::ffi::c_int;
                while x < i_width {
                    let mut pixu: *mut pixel = dstu
                        .offset(pel_offset_y as isize)
                        .offset(pel_offset_x as isize);
                    let mut pixv: *mut pixel = dstv
                        .offset(pel_offset_y as isize)
                        .offset(pel_offset_x as isize);
                    let mut src1: *mut pixel = (*ref_0).plane[1 as ::core::ffi::c_int as usize]
                        .offset(pel_offset_y as isize)
                        .offset((pel_offset_x * 2 as ::core::ffi::c_int) as isize);
                    let mut mvx: ::core::ffi::c_int = (*(*fenc).lowres_mvs
                        [0 as ::core::ffi::c_int as usize][ref0_distance as usize]
                        .offset(mb_xy as isize))[0 as ::core::ffi::c_int as usize]
                        as ::core::ffi::c_int;
                    let mut mvy: ::core::ffi::c_int = (*(*fenc).lowres_mvs
                        [0 as ::core::ffi::c_int as usize][ref0_distance as usize]
                        .offset(mb_xy as isize))[1 as ::core::ffi::c_int as usize]
                        as ::core::ffi::c_int;
                    (*h).mc.mc_chroma.expect("non-null function pointer")(
                        pixu,
                        pixv,
                        i_stride as intptr_t,
                        src1,
                        i_stride as intptr_t,
                        mvx,
                        2 as ::core::ffi::c_int * mvy >> v_shift,
                        8 as ::core::ffi::c_int,
                        height,
                    );
                    x += 8 as ::core::ffi::c_int;
                    mb_xy += 1;
                    pel_offset_x += 8 as ::core::ffi::c_int;
                }
                y += height;
                pel_offset_y = y * i_stride;
            }
        } else {
            (*h).mc
                .plane_copy_deinterleave
                .expect("non-null function pointer")(
                dstu,
                i_stride as intptr_t,
                dstv,
                i_stride as intptr_t,
                (*ref_0).plane[1 as ::core::ffi::c_int as usize],
                i_stride as intptr_t,
                cw,
                ch,
            );
        }
        (*h).mc
            .plane_copy_deinterleave
            .expect("non-null function pointer")(
            dstu.offset(i_width as isize),
            i_stride as intptr_t,
            dstv.offset(i_width as isize),
            i_stride as intptr_t,
            (*fenc).plane[1 as ::core::ffi::c_int as usize],
            i_stride as intptr_t,
            cw,
            ch,
        );
    }
    #[inline(never)]
    #[c2rust::src_loc = "142:1"]
    pub unsafe extern "C" fn weight_cost_init_chroma444(
        mut h: *mut x264_t,
        mut fenc: *mut x264_frame_t,
        mut ref_0: *mut x264_frame_t,
        mut dst: *mut pixel,
        mut p: ::core::ffi::c_int,
    ) -> *mut pixel {
        let mut ref0_distance: ::core::ffi::c_int =
            (*fenc).i_frame - (*ref_0).i_frame - 1 as ::core::ffi::c_int;
        let mut i_stride: ::core::ffi::c_int = (*fenc).i_stride[p as usize];
        let mut i_lines: ::core::ffi::c_int = (*fenc).i_lines[p as usize];
        let mut i_width: ::core::ffi::c_int = (*fenc).i_width[p as usize];
        if (*(*fenc).lowres_mvs[0 as ::core::ffi::c_int as usize][ref0_distance as usize]
            .offset(0 as ::core::ffi::c_int as isize))[0 as ::core::ffi::c_int as usize]
            as ::core::ffi::c_int
            != 0x7fff as ::core::ffi::c_int
        {
            x264_10_frame_expand_border_chroma(h, ref_0, p);
            let mut y: ::core::ffi::c_int = 0 as ::core::ffi::c_int;
            let mut mb_xy: ::core::ffi::c_int = 0 as ::core::ffi::c_int;
            let mut pel_offset_y: ::core::ffi::c_int = 0 as ::core::ffi::c_int;
            while y < i_lines {
                let mut x: ::core::ffi::c_int = 0 as ::core::ffi::c_int;
                let mut pel_offset_x: ::core::ffi::c_int = 0 as ::core::ffi::c_int;
                while x < i_width {
                    let mut pix: *mut pixel = dst
                        .offset(pel_offset_y as isize)
                        .offset(pel_offset_x as isize);
                    let mut src: *mut pixel = (*ref_0).plane[p as usize]
                        .offset(pel_offset_y as isize)
                        .offset(pel_offset_x as isize);
                    let mut mvx: ::core::ffi::c_int = (*(*fenc).lowres_mvs
                        [0 as ::core::ffi::c_int as usize][ref0_distance as usize]
                        .offset(mb_xy as isize))[0 as ::core::ffi::c_int as usize]
                        as ::core::ffi::c_int
                        / 2 as ::core::ffi::c_int;
                    let mut mvy: ::core::ffi::c_int = (*(*fenc).lowres_mvs
                        [0 as ::core::ffi::c_int as usize][ref0_distance as usize]
                        .offset(mb_xy as isize))[1 as ::core::ffi::c_int as usize]
                        as ::core::ffi::c_int
                        / 2 as ::core::ffi::c_int;
                    (*h).mc
                        .copy_16x16_unaligned
                        .expect("non-null function pointer")(
                        pix,
                        i_stride as intptr_t,
                        src.offset(mvx as isize).offset((mvy * i_stride) as isize),
                        i_stride as intptr_t,
                        16 as ::core::ffi::c_int,
                    );
                    x += 16 as ::core::ffi::c_int;
                    mb_xy += 1;
                    pel_offset_x += 16 as ::core::ffi::c_int;
                }
                y += 16 as ::core::ffi::c_int;
                pel_offset_y = y * i_stride;
            }
            return dst;
        }
        return (*ref_0).plane[p as usize];
    }
    #[c2rust::src_loc = "170:1"]
    pub unsafe extern "C" fn weight_slice_header_cost(
        mut h: *mut x264_t,
        mut w: *mut x264_weight_t,
        mut b_chroma: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int {
        let mut lambda: ::core::ffi::c_int =
            x264_lambda_tab[X264_LOOKAHEAD_QP as usize] as ::core::ffi::c_int;
        if b_chroma != 0 {
            lambda *= 4 as ::core::ffi::c_int;
        }
        let mut numslices: ::core::ffi::c_int = 0;
        if (*h).param.i_slice_count != 0 {
            numslices = (*h).param.i_slice_count;
        } else if (*h).param.i_slice_max_mbs != 0 {
            numslices = ((*h).mb.i_mb_width * (*h).mb.i_mb_height + (*h).param.i_slice_max_mbs
                - 1 as ::core::ffi::c_int)
                / (*h).param.i_slice_max_mbs;
        } else {
            numslices = 1 as ::core::ffi::c_int;
        }
        let mut denom_cost: ::core::ffi::c_int = bs_size_ue(
            (*w.offset(0 as ::core::ffi::c_int as isize)).i_denom as ::core::ffi::c_uint,
        ) * (2 as ::core::ffi::c_int - b_chroma);
        return lambda
            * numslices
            * (10 as ::core::ffi::c_int
                + denom_cost
                + 2 as ::core::ffi::c_int
                    * (bs_size_se(
                        (*w.offset(0 as ::core::ffi::c_int as isize)).i_scale as ::core::ffi::c_int,
                    ) + bs_size_se(
                        (*w.offset(0 as ::core::ffi::c_int as isize)).i_offset
                            as ::core::ffi::c_int,
                    )));
    }
    #[inline(never)]
    #[c2rust::src_loc = "191:1"]
    pub unsafe extern "C" fn weight_cost_luma(
        mut h: *mut x264_t,
        mut fenc: *mut x264_frame_t,
        mut src: *mut pixel,
        mut w: *mut x264_weight_t,
    ) -> ::core::ffi::c_uint {
        let mut cost: ::core::ffi::c_uint = 0 as ::core::ffi::c_uint;
        let mut i_stride: ::core::ffi::c_int = (*fenc).i_stride_lowres;
        let mut i_lines: ::core::ffi::c_int = (*fenc).i_lines_lowres;
        let mut i_width: ::core::ffi::c_int = (*fenc).i_width_lowres;
        let mut fenc_plane: *mut pixel = (*fenc).lowres[0 as ::core::ffi::c_int as usize];
        let mut buf: [pixel; 64] = [0; 64];
        let mut pixoff: ::core::ffi::c_int = 0 as ::core::ffi::c_int;
        let mut i_mb: ::core::ffi::c_int = 0 as ::core::ffi::c_int;
        if !w.is_null() {
            let mut y: ::core::ffi::c_int = 0 as ::core::ffi::c_int;
            while y < i_lines {
                let mut x: ::core::ffi::c_int = 0 as ::core::ffi::c_int;
                while x < i_width {
                    (*(*w)
                        .weightfn
                        .offset((8 as ::core::ffi::c_int >> 2 as ::core::ffi::c_int) as isize))
                    .expect("non-null function pointer")(
                        buf.as_mut_ptr(),
                        8 as intptr_t,
                        &mut *src.offset(pixoff as isize),
                        i_stride as intptr_t,
                        w,
                        8 as ::core::ffi::c_int,
                    );
                    let mut cmp: ::core::ffi::c_int = (*h).pixf.mbcmp
                        [PIXEL_8x8 as ::core::ffi::c_int as usize]
                        .expect("non-null function pointer")(
                        buf.as_mut_ptr(),
                        8 as intptr_t,
                        &mut *fenc_plane.offset(pixoff as isize),
                        i_stride as intptr_t,
                    );
                    cost = cost.wrapping_add(
                        (if cmp < *(*fenc).i_intra_cost.offset(i_mb as isize) as ::core::ffi::c_int
                        {
                            cmp
                        } else {
                            *(*fenc).i_intra_cost.offset(i_mb as isize) as ::core::ffi::c_int
                        }) as ::core::ffi::c_uint,
                    );
                    x += 8 as ::core::ffi::c_int;
                    i_mb += 1;
                    pixoff += 8 as ::core::ffi::c_int;
                }
                y += 8 as ::core::ffi::c_int;
                pixoff = y * i_stride;
            }
            cost = cost.wrapping_add(
                weight_slice_header_cost(h, w, 0 as ::core::ffi::c_int) as ::core::ffi::c_uint
            );
        } else {
            let mut y_0: ::core::ffi::c_int = 0 as ::core::ffi::c_int;
            while y_0 < i_lines {
                let mut x_0: ::core::ffi::c_int = 0 as ::core::ffi::c_int;
                while x_0 < i_width {
                    let mut cmp_0: ::core::ffi::c_int = (*h).pixf.mbcmp
                        [PIXEL_8x8 as ::core::ffi::c_int as usize]
                        .expect("non-null function pointer")(
                        &mut *src.offset(pixoff as isize),
                        i_stride as intptr_t,
                        &mut *fenc_plane.offset(pixoff as isize),
                        i_stride as intptr_t,
                    );
                    cost = cost.wrapping_add(
                        (if cmp_0
                            < *(*fenc).i_intra_cost.offset(i_mb as isize) as ::core::ffi::c_int
                        {
                            cmp_0
                        } else {
                            *(*fenc).i_intra_cost.offset(i_mb as isize) as ::core::ffi::c_int
                        }) as ::core::ffi::c_uint,
                    );
                    x_0 += 8 as ::core::ffi::c_int;
                    i_mb += 1;
                    pixoff += 8 as ::core::ffi::c_int;
                }
                y_0 += 8 as ::core::ffi::c_int;
                pixoff = y_0 * i_stride;
            }
        }
        return cost;
    }
    #[inline(never)]
    #[c2rust::src_loc = "224:1"]
    pub unsafe extern "C" fn weight_cost_chroma(
        mut h: *mut x264_t,
        mut fenc: *mut x264_frame_t,
        mut ref_0: *mut pixel,
        mut w: *mut x264_weight_t,
    ) -> ::core::ffi::c_uint {
        let mut cost: ::core::ffi::c_uint = 0 as ::core::ffi::c_uint;
        let mut i_stride: ::core::ffi::c_int = (*fenc).i_stride[1 as ::core::ffi::c_int as usize];
        let mut i_lines: ::core::ffi::c_int = (*fenc).i_lines[1 as ::core::ffi::c_int as usize];
        let mut i_width: ::core::ffi::c_int = (*fenc).i_width[1 as ::core::ffi::c_int as usize];
        let mut src: *mut pixel = ref_0.offset(i_width as isize);
        let mut buf: [pixel; 128] = [0; 128];
        let mut pixoff: ::core::ffi::c_int = 0 as ::core::ffi::c_int;
        let mut height: ::core::ffi::c_int = 16 as ::core::ffi::c_int >> (*h).mb.chroma_v_shift;
        if !w.is_null() {
            let mut y: ::core::ffi::c_int = 0 as ::core::ffi::c_int;
            while y < i_lines {
                let mut x: ::core::ffi::c_int = 0 as ::core::ffi::c_int;
                while x < i_width {
                    (*(*w)
                        .weightfn
                        .offset((8 as ::core::ffi::c_int >> 2 as ::core::ffi::c_int) as isize))
                    .expect("non-null function pointer")(
                        buf.as_mut_ptr(),
                        8 as intptr_t,
                        &mut *ref_0.offset(pixoff as isize),
                        i_stride as intptr_t,
                        w,
                        height,
                    );
                    cost = cost.wrapping_add((*h).pixf.asd8.expect("non-null function pointer")(
                        buf.as_mut_ptr(),
                        8 as intptr_t,
                        &mut *src.offset(pixoff as isize),
                        i_stride as intptr_t,
                        height,
                    ) as ::core::ffi::c_uint);
                    x += 8 as ::core::ffi::c_int;
                    pixoff += 8 as ::core::ffi::c_int;
                }
                y += height;
                pixoff = y * i_stride;
            }
            cost = cost.wrapping_add(
                weight_slice_header_cost(h, w, 1 as ::core::ffi::c_int) as ::core::ffi::c_uint
            );
        } else {
            let mut y_0: ::core::ffi::c_int = 0 as ::core::ffi::c_int;
            while y_0 < i_lines {
                let mut x_0: ::core::ffi::c_int = 0 as ::core::ffi::c_int;
                while x_0 < i_width {
                    cost = cost.wrapping_add((*h).pixf.asd8.expect("non-null function pointer")(
                        &mut *ref_0.offset(pixoff as isize),
                        i_stride as intptr_t,
                        &mut *src.offset(pixoff as isize),
                        i_stride as intptr_t,
                        height,
                    ) as ::core::ffi::c_uint);
                    x_0 += 8 as ::core::ffi::c_int;
                    pixoff += 8 as ::core::ffi::c_int;
                }
                y_0 += height;
                pixoff = y_0 * i_stride;
            }
        }
        return cost;
    }
    #[inline(never)]
    #[c2rust::src_loc = "257:1"]
    pub unsafe extern "C" fn weight_cost_chroma444(
        mut h: *mut x264_t,
        mut fenc: *mut x264_frame_t,
        mut ref_0: *mut pixel,
        mut w: *mut x264_weight_t,
        mut p: ::core::ffi::c_int,
    ) -> ::core::ffi::c_uint {
        let mut cost: ::core::ffi::c_uint = 0 as ::core::ffi::c_uint;
        let mut i_stride: ::core::ffi::c_int = (*fenc).i_stride[p as usize];
        let mut i_lines: ::core::ffi::c_int = (*fenc).i_lines[p as usize];
        let mut i_width: ::core::ffi::c_int = (*fenc).i_width[p as usize];
        let mut src: *mut pixel = (*fenc).plane[p as usize];
        let mut buf: [pixel; 256] = [0; 256];
        let mut pixoff: ::core::ffi::c_int = 0 as ::core::ffi::c_int;
        if !w.is_null() {
            let mut y: ::core::ffi::c_int = 0 as ::core::ffi::c_int;
            while y < i_lines {
                let mut x: ::core::ffi::c_int = 0 as ::core::ffi::c_int;
                while x < i_width {
                    (*(*w)
                        .weightfn
                        .offset((16 as ::core::ffi::c_int >> 2 as ::core::ffi::c_int) as isize))
                    .expect("non-null function pointer")(
                        buf.as_mut_ptr(),
                        16 as intptr_t,
                        &mut *ref_0.offset(pixoff as isize),
                        i_stride as intptr_t,
                        w,
                        16 as ::core::ffi::c_int,
                    );
                    cost = cost.wrapping_add((*h).pixf.mbcmp
                        [PIXEL_16x16 as ::core::ffi::c_int as usize]
                        .expect("non-null function pointer")(
                        buf.as_mut_ptr(),
                        16 as intptr_t,
                        &mut *src.offset(pixoff as isize),
                        i_stride as intptr_t,
                    ) as ::core::ffi::c_uint);
                    x += 16 as ::core::ffi::c_int;
                    pixoff += 16 as ::core::ffi::c_int;
                }
                y += 16 as ::core::ffi::c_int;
                pixoff = y * i_stride;
            }
            cost = cost.wrapping_add(
                weight_slice_header_cost(h, w, 1 as ::core::ffi::c_int) as ::core::ffi::c_uint
            );
        } else {
            let mut y_0: ::core::ffi::c_int = 0 as ::core::ffi::c_int;
            while y_0 < i_lines {
                let mut x_0: ::core::ffi::c_int = 0 as ::core::ffi::c_int;
                while x_0 < i_width {
                    cost = cost.wrapping_add((*h).pixf.mbcmp
                        [PIXEL_16x16 as ::core::ffi::c_int as usize]
                        .expect("non-null function pointer")(
                        &mut *ref_0.offset(pixoff as isize),
                        i_stride as intptr_t,
                        &mut *src.offset(pixoff as isize),
                        i_stride as intptr_t,
                    ) as ::core::ffi::c_uint);
                    x_0 += 16 as ::core::ffi::c_int;
                    pixoff += 16 as ::core::ffi::c_int;
                }
                y_0 += 16 as ::core::ffi::c_int;
                pixoff = y_0 * i_stride;
            }
        }
        return cost;
    }
    #[no_mangle]
    #[c2rust::src_loc = "284:1"]
    pub unsafe extern "C" fn x264_10_weights_analyse(
        mut h: *mut x264_t,
        mut fenc: *mut x264_frame_t,
        mut ref_0: *mut x264_frame_t,
        mut b_lookahead: ::core::ffi::c_int,
    ) {
        let mut i_delta_index: ::core::ffi::c_int =
            (*fenc).i_frame - (*ref_0).i_frame - 1 as ::core::ffi::c_int;
        let epsilon: ::core::ffi::c_float = 1.0f32 / 128.0f32;
        let mut weights: *mut x264_weight_t = (*(*fenc)
            .weight
            .as_mut_ptr()
            .offset(0 as ::core::ffi::c_int as isize))
        .as_mut_ptr();
        (*weights.offset(0 as ::core::ffi::c_int as isize)).i_scale =
            1 as ::core::ffi::c_int as int32_t;
        (*weights.offset(0 as ::core::ffi::c_int as isize)).i_denom =
            0 as ::core::ffi::c_int as int32_t;
        (*weights.offset(0 as ::core::ffi::c_int as isize)).i_offset =
            0 as ::core::ffi::c_int as int32_t;
        let ref mut fresh8 = (*weights.offset(0 as ::core::ffi::c_int as isize)).weightfn;
        *fresh8 = 0 as *mut weight_fn_t;
        (*weights.offset(1 as ::core::ffi::c_int as isize)).i_scale =
            1 as ::core::ffi::c_int as int32_t;
        (*weights.offset(1 as ::core::ffi::c_int as isize)).i_denom =
            0 as ::core::ffi::c_int as int32_t;
        (*weights.offset(1 as ::core::ffi::c_int as isize)).i_offset =
            0 as ::core::ffi::c_int as int32_t;
        let ref mut fresh9 = (*weights.offset(1 as ::core::ffi::c_int as isize)).weightfn;
        *fresh9 = 0 as *mut weight_fn_t;
        (*weights.offset(2 as ::core::ffi::c_int as isize)).i_scale =
            1 as ::core::ffi::c_int as int32_t;
        (*weights.offset(2 as ::core::ffi::c_int as isize)).i_denom =
            0 as ::core::ffi::c_int as int32_t;
        (*weights.offset(2 as ::core::ffi::c_int as isize)).i_offset =
            0 as ::core::ffi::c_int as int32_t;
        let ref mut fresh10 = (*weights.offset(2 as ::core::ffi::c_int as isize)).weightfn;
        *fresh10 = 0 as *mut weight_fn_t;
        let mut chroma_initted: ::core::ffi::c_int = 0 as ::core::ffi::c_int;
        let mut guess_scale: [::core::ffi::c_float; 3] = [0.; 3];
        let mut fenc_mean: [::core::ffi::c_float; 3] = [0.; 3];
        let mut ref_mean: [::core::ffi::c_float; 3] = [0.; 3];
        let mut plane: ::core::ffi::c_int = 0 as ::core::ffi::c_int;
        while plane <= 2 as ::core::ffi::c_int * (b_lookahead == 0) as ::core::ffi::c_int {
            if plane == 0 || (*(*h).sps.as_mut_ptr()).i_chroma_format_idc != 0 {
                let mut zero_bias: ::core::ffi::c_int =
                    ((*ref_0).i_pixel_ssd[plane as usize] == 0) as ::core::ffi::c_int;
                let mut fenc_var: ::core::ffi::c_float = (*fenc).i_pixel_ssd[plane as usize]
                    .wrapping_add(zero_bias as uint64_t)
                    as ::core::ffi::c_float;
                let mut ref_var: ::core::ffi::c_float = (*ref_0).i_pixel_ssd[plane as usize]
                    .wrapping_add(zero_bias as uint64_t)
                    as ::core::ffi::c_float;
                guess_scale[plane as usize] = sqrtf(fenc_var / ref_var);
                fenc_mean[plane as usize] = (*fenc).i_pixel_sum[plane as usize]
                    .wrapping_add(zero_bias as uint32_t)
                    as ::core::ffi::c_float
                    / ((*fenc).i_lines[(plane != 0) as ::core::ffi::c_int as usize]
                        * (*fenc).i_width[(plane != 0) as ::core::ffi::c_int as usize])
                        as ::core::ffi::c_float
                    / ((1 as ::core::ffi::c_int) << BIT_DEPTH - 8 as ::core::ffi::c_int)
                        as ::core::ffi::c_float;
                ref_mean[plane as usize] = (*ref_0).i_pixel_sum[plane as usize]
                    .wrapping_add(zero_bias as uint32_t)
                    as ::core::ffi::c_float
                    / ((*fenc).i_lines[(plane != 0) as ::core::ffi::c_int as usize]
                        * (*fenc).i_width[(plane != 0) as ::core::ffi::c_int as usize])
                        as ::core::ffi::c_float
                    / ((1 as ::core::ffi::c_int) << BIT_DEPTH - 8 as ::core::ffi::c_int)
                        as ::core::ffi::c_float;
            } else {
                guess_scale[plane as usize] = 1 as ::core::ffi::c_int as ::core::ffi::c_float;
                fenc_mean[plane as usize] = 0 as ::core::ffi::c_int as ::core::ffi::c_float;
                ref_mean[plane as usize] = 0 as ::core::ffi::c_int as ::core::ffi::c_float;
            }
            plane += 1;
        }
        let mut chroma_denom: ::core::ffi::c_int = 7 as ::core::ffi::c_int;
        if b_lookahead == 0 {
            while chroma_denom > 0 as ::core::ffi::c_int {
                let mut thresh: ::core::ffi::c_float =
                    127.0f32 / ((1 as ::core::ffi::c_int) << chroma_denom) as ::core::ffi::c_float;
                if guess_scale[1 as ::core::ffi::c_int as usize] < thresh
                    && guess_scale[2 as ::core::ffi::c_int as usize] < thresh
                {
                    break;
                }
                chroma_denom -= 1;
            }
        }
        let mut plane_0: ::core::ffi::c_int = 0 as ::core::ffi::c_int;
        while plane_0
            < (if (*(*h).sps.as_mut_ptr()).i_chroma_format_idc != 0 {
                3 as ::core::ffi::c_int
            } else {
                1 as ::core::ffi::c_int
            })
            && !(plane_0 != 0
                && ((*weights.offset(0 as ::core::ffi::c_int as isize))
                    .weightfn
                    .is_null()
                    || b_lookahead != 0))
        {
            let mut minoff: ::core::ffi::c_int = 0;
            let mut minscale: ::core::ffi::c_int = 0;
            let mut mindenom: ::core::ffi::c_int = 0;
            let mut minscore: ::core::ffi::c_uint = 0;
            let mut origscore: ::core::ffi::c_uint = 0;
            let mut found: ::core::ffi::c_int = 0;
            if fabsf(ref_mean[plane_0 as usize] - fenc_mean[plane_0 as usize]) < 0.5f32
                && fabsf(1.0f32 - guess_scale[plane_0 as usize]) < epsilon
            {
                (*weights.offset(plane_0 as isize)).i_scale = 1 as ::core::ffi::c_int as int32_t;
                (*weights.offset(plane_0 as isize)).i_denom = 0 as ::core::ffi::c_int as int32_t;
                (*weights.offset(plane_0 as isize)).i_offset = 0 as ::core::ffi::c_int as int32_t;
                let ref mut fresh11 = (*weights.offset(plane_0 as isize)).weightfn;
                *fresh11 = 0 as *mut weight_fn_t;
            } else {
                if plane_0 != 0 {
                    (*weights.offset(plane_0 as isize)).i_denom = chroma_denom as int32_t;
                    (*weights.offset(plane_0 as isize)).i_scale = x264_clip3(
                        round(
                            (guess_scale[plane_0 as usize]
                                * ((1 as ::core::ffi::c_int) << chroma_denom)
                                    as ::core::ffi::c_float)
                                as ::core::ffi::c_double,
                        ) as ::core::ffi::c_int,
                        0 as ::core::ffi::c_int,
                        255 as ::core::ffi::c_int,
                    ) as int32_t;
                    if (*weights.offset(plane_0 as isize)).i_scale > 127 as int32_t {
                        let ref mut fresh12 =
                            (*weights.offset(2 as ::core::ffi::c_int as isize)).weightfn;
                        *fresh12 = 0 as *mut weight_fn_t;
                        let ref mut fresh13 =
                            (*weights.offset(1 as ::core::ffi::c_int as isize)).weightfn;
                        *fresh13 = *fresh12;
                        break;
                    }
                } else {
                    weight_get_h264(
                        round(
                            (guess_scale[plane_0 as usize]
                                * 128 as ::core::ffi::c_int as ::core::ffi::c_float)
                                as ::core::ffi::c_double,
                        ) as ::core::ffi::c_int,
                        0 as ::core::ffi::c_int,
                        &mut *weights.offset(plane_0 as isize),
                    );
                }
                found = 0 as ::core::ffi::c_int;
                mindenom = (*weights.offset(plane_0 as isize)).i_denom as ::core::ffi::c_int;
                minscale = (*weights.offset(plane_0 as isize)).i_scale as ::core::ffi::c_int;
                minoff = 0 as ::core::ffi::c_int;
                let mut mcbuf: *mut pixel = 0 as *mut pixel;
                if plane_0 == 0 {
                    if (*fenc).b_intra_calculated == 0 {
                        let mut a: x264_mb_analysis_t = x264_mb_analysis_t {
                            i_lambda: 0,
                            i_lambda2: 0,
                            i_qp: 0,
                            p_cost_mv: 0 as *mut uint16_t,
                            p_cost_ref: [0 as *mut uint16_t; 2],
                            i_mbrd: 0,
                            b_fast_intra: 0,
                            b_force_intra: 0,
                            b_avoid_topright: 0,
                            b_try_skip: 0,
                            i_satd_i16x16: 0,
                            i_satd_i16x16_dir: [0; 7],
                            i_predict16x16: 0,
                            i_satd_i8x8: 0,
                            i_cbp_i8x8_luma: 0,
                            i_satd_i8x8_dir: [[0; 16]; 4],
                            i_predict8x8: [0; 4],
                            i_satd_i4x4: 0,
                            i_predict4x4: [0; 16],
                            i_satd_pcm: 0,
                            i_satd_chroma: 0,
                            i_satd_chroma_dir: [0; 7],
                            i_predict8x8chroma: 0,
                            l0: x264_mb_analysis_list_t {
                                me16x16: x264_me_t {
                                    i_pixel: 0,
                                    p_cost_mv: 0 as *mut uint16_t,
                                    i_ref_cost: 0,
                                    i_ref: 0,
                                    weight: 0 as *const x264_weight_t,
                                    p_fref: [0 as *mut pixel; 12],
                                    p_fref_w: 0 as *mut pixel,
                                    p_fenc: [0 as *mut pixel; 3],
                                    integral: 0 as *mut uint16_t,
                                    i_stride: [0; 3],
                                    mvp: [0; 2],
                                    cost_mv: 0,
                                    cost: 0,
                                    mv: [0; 2],
                                },
                                bi16x16: x264_me_t {
                                    i_pixel: 0,
                                    p_cost_mv: 0 as *mut uint16_t,
                                    i_ref_cost: 0,
                                    i_ref: 0,
                                    weight: 0 as *const x264_weight_t,
                                    p_fref: [0 as *mut pixel; 12],
                                    p_fref_w: 0 as *mut pixel,
                                    p_fenc: [0 as *mut pixel; 3],
                                    integral: 0 as *mut uint16_t,
                                    i_stride: [0; 3],
                                    mvp: [0; 2],
                                    cost_mv: 0,
                                    cost: 0,
                                    mv: [0; 2],
                                },
                                me8x8: [x264_me_t {
                                    i_pixel: 0,
                                    p_cost_mv: 0 as *mut uint16_t,
                                    i_ref_cost: 0,
                                    i_ref: 0,
                                    weight: 0 as *const x264_weight_t,
                                    p_fref: [0 as *mut pixel; 12],
                                    p_fref_w: 0 as *mut pixel,
                                    p_fenc: [0 as *mut pixel; 3],
                                    integral: 0 as *mut uint16_t,
                                    i_stride: [0; 3],
                                    mvp: [0; 2],
                                    cost_mv: 0,
                                    cost: 0,
                                    mv: [0; 2],
                                }; 4],
                                me4x4: [[x264_me_t {
                                    i_pixel: 0,
                                    p_cost_mv: 0 as *mut uint16_t,
                                    i_ref_cost: 0,
                                    i_ref: 0,
                                    weight: 0 as *const x264_weight_t,
                                    p_fref: [0 as *mut pixel; 12],
                                    p_fref_w: 0 as *mut pixel,
                                    p_fenc: [0 as *mut pixel; 3],
                                    integral: 0 as *mut uint16_t,
                                    i_stride: [0; 3],
                                    mvp: [0; 2],
                                    cost_mv: 0,
                                    cost: 0,
                                    mv: [0; 2],
                                }; 4]; 4],
                                me8x4: [[x264_me_t {
                                    i_pixel: 0,
                                    p_cost_mv: 0 as *mut uint16_t,
                                    i_ref_cost: 0,
                                    i_ref: 0,
                                    weight: 0 as *const x264_weight_t,
                                    p_fref: [0 as *mut pixel; 12],
                                    p_fref_w: 0 as *mut pixel,
                                    p_fenc: [0 as *mut pixel; 3],
                                    integral: 0 as *mut uint16_t,
                                    i_stride: [0; 3],
                                    mvp: [0; 2],
                                    cost_mv: 0,
                                    cost: 0,
                                    mv: [0; 2],
                                }; 2]; 4],
                                me4x8: [[x264_me_t {
                                    i_pixel: 0,
                                    p_cost_mv: 0 as *mut uint16_t,
                                    i_ref_cost: 0,
                                    i_ref: 0,
                                    weight: 0 as *const x264_weight_t,
                                    p_fref: [0 as *mut pixel; 12],
                                    p_fref_w: 0 as *mut pixel,
                                    p_fenc: [0 as *mut pixel; 3],
                                    integral: 0 as *mut uint16_t,
                                    i_stride: [0; 3],
                                    mvp: [0; 2],
                                    cost_mv: 0,
                                    cost: 0,
                                    mv: [0; 2],
                                }; 2]; 4],
                                me16x8: [x264_me_t {
                                    i_pixel: 0,
                                    p_cost_mv: 0 as *mut uint16_t,
                                    i_ref_cost: 0,
                                    i_ref: 0,
                                    weight: 0 as *const x264_weight_t,
                                    p_fref: [0 as *mut pixel; 12],
                                    p_fref_w: 0 as *mut pixel,
                                    p_fenc: [0 as *mut pixel; 3],
                                    integral: 0 as *mut uint16_t,
                                    i_stride: [0; 3],
                                    mvp: [0; 2],
                                    cost_mv: 0,
                                    cost: 0,
                                    mv: [0; 2],
                                }; 2],
                                me8x16: [x264_me_t {
                                    i_pixel: 0,
                                    p_cost_mv: 0 as *mut uint16_t,
                                    i_ref_cost: 0,
                                    i_ref: 0,
                                    weight: 0 as *const x264_weight_t,
                                    p_fref: [0 as *mut pixel; 12],
                                    p_fref_w: 0 as *mut pixel,
                                    p_fenc: [0 as *mut pixel; 3],
                                    integral: 0 as *mut uint16_t,
                                    i_stride: [0; 3],
                                    mvp: [0; 2],
                                    cost_mv: 0,
                                    cost: 0,
                                    mv: [0; 2],
                                }; 2],
                                i_rd16x16: 0,
                                i_cost8x8: 0,
                                i_cost4x4: [0; 4],
                                i_cost8x4: [0; 4],
                                i_cost4x8: [0; 4],
                                i_cost16x8: 0,
                                i_cost8x16: 0,
                                mvc: [[[0; 2]; 6]; 32],
                            },
                            l1: x264_mb_analysis_list_t {
                                me16x16: x264_me_t {
                                    i_pixel: 0,
                                    p_cost_mv: 0 as *mut uint16_t,
                                    i_ref_cost: 0,
                                    i_ref: 0,
                                    weight: 0 as *const x264_weight_t,
                                    p_fref: [0 as *mut pixel; 12],
                                    p_fref_w: 0 as *mut pixel,
                                    p_fenc: [0 as *mut pixel; 3],
                                    integral: 0 as *mut uint16_t,
                                    i_stride: [0; 3],
                                    mvp: [0; 2],
                                    cost_mv: 0,
                                    cost: 0,
                                    mv: [0; 2],
                                },
                                bi16x16: x264_me_t {
                                    i_pixel: 0,
                                    p_cost_mv: 0 as *mut uint16_t,
                                    i_ref_cost: 0,
                                    i_ref: 0,
                                    weight: 0 as *const x264_weight_t,
                                    p_fref: [0 as *mut pixel; 12],
                                    p_fref_w: 0 as *mut pixel,
                                    p_fenc: [0 as *mut pixel; 3],
                                    integral: 0 as *mut uint16_t,
                                    i_stride: [0; 3],
                                    mvp: [0; 2],
                                    cost_mv: 0,
                                    cost: 0,
                                    mv: [0; 2],
                                },
                                me8x8: [x264_me_t {
                                    i_pixel: 0,
                                    p_cost_mv: 0 as *mut uint16_t,
                                    i_ref_cost: 0,
                                    i_ref: 0,
                                    weight: 0 as *const x264_weight_t,
                                    p_fref: [0 as *mut pixel; 12],
                                    p_fref_w: 0 as *mut pixel,
                                    p_fenc: [0 as *mut pixel; 3],
                                    integral: 0 as *mut uint16_t,
                                    i_stride: [0; 3],
                                    mvp: [0; 2],
                                    cost_mv: 0,
                                    cost: 0,
                                    mv: [0; 2],
                                }; 4],
                                me4x4: [[x264_me_t {
                                    i_pixel: 0,
                                    p_cost_mv: 0 as *mut uint16_t,
                                    i_ref_cost: 0,
                                    i_ref: 0,
                                    weight: 0 as *const x264_weight_t,
                                    p_fref: [0 as *mut pixel; 12],
                                    p_fref_w: 0 as *mut pixel,
                                    p_fenc: [0 as *mut pixel; 3],
                                    integral: 0 as *mut uint16_t,
                                    i_stride: [0; 3],
                                    mvp: [0; 2],
                                    cost_mv: 0,
                                    cost: 0,
                                    mv: [0; 2],
                                }; 4]; 4],
                                me8x4: [[x264_me_t {
                                    i_pixel: 0,
                                    p_cost_mv: 0 as *mut uint16_t,
                                    i_ref_cost: 0,
                                    i_ref: 0,
                                    weight: 0 as *const x264_weight_t,
                                    p_fref: [0 as *mut pixel; 12],
                                    p_fref_w: 0 as *mut pixel,
                                    p_fenc: [0 as *mut pixel; 3],
                                    integral: 0 as *mut uint16_t,
                                    i_stride: [0; 3],
                                    mvp: [0; 2],
                                    cost_mv: 0,
                                    cost: 0,
                                    mv: [0; 2],
                                }; 2]; 4],
                                me4x8: [[x264_me_t {
                                    i_pixel: 0,
                                    p_cost_mv: 0 as *mut uint16_t,
                                    i_ref_cost: 0,
                                    i_ref: 0,
                                    weight: 0 as *const x264_weight_t,
                                    p_fref: [0 as *mut pixel; 12],
                                    p_fref_w: 0 as *mut pixel,
                                    p_fenc: [0 as *mut pixel; 3],
                                    integral: 0 as *mut uint16_t,
                                    i_stride: [0; 3],
                                    mvp: [0; 2],
                                    cost_mv: 0,
                                    cost: 0,
                                    mv: [0; 2],
                                }; 2]; 4],
                                me16x8: [x264_me_t {
                                    i_pixel: 0,
                                    p_cost_mv: 0 as *mut uint16_t,
                                    i_ref_cost: 0,
                                    i_ref: 0,
                                    weight: 0 as *const x264_weight_t,
                                    p_fref: [0 as *mut pixel; 12],
                                    p_fref_w: 0 as *mut pixel,
                                    p_fenc: [0 as *mut pixel; 3],
                                    integral: 0 as *mut uint16_t,
                                    i_stride: [0; 3],
                                    mvp: [0; 2],
                                    cost_mv: 0,
                                    cost: 0,
                                    mv: [0; 2],
                                }; 2],
                                me8x16: [x264_me_t {
                                    i_pixel: 0,
                                    p_cost_mv: 0 as *mut uint16_t,
                                    i_ref_cost: 0,
                                    i_ref: 0,
                                    weight: 0 as *const x264_weight_t,
                                    p_fref: [0 as *mut pixel; 12],
                                    p_fref_w: 0 as *mut pixel,
                                    p_fenc: [0 as *mut pixel; 3],
                                    integral: 0 as *mut uint16_t,
                                    i_stride: [0; 3],
                                    mvp: [0; 2],
                                    cost_mv: 0,
                                    cost: 0,
                                    mv: [0; 2],
                                }; 2],
                                i_rd16x16: 0,
                                i_cost8x8: 0,
                                i_cost4x4: [0; 4],
                                i_cost8x4: [0; 4],
                                i_cost4x8: [0; 4],
                                i_cost16x8: 0,
                                i_cost8x16: 0,
                                mvc: [[[0; 2]; 6]; 32],
                            },
                            i_cost16x16bi: 0,
                            i_cost16x16direct: 0,
                            i_cost8x8bi: 0,
                            i_cost8x8direct: [0; 4],
                            i_satd8x8: [[0; 4]; 3],
                            i_cost_est16x8: [0; 2],
                            i_cost_est8x16: [0; 2],
                            i_cost16x8bi: 0,
                            i_cost8x16bi: 0,
                            i_rd16x16bi: 0,
                            i_rd16x16direct: 0,
                            i_rd16x8bi: 0,
                            i_rd8x16bi: 0,
                            i_rd8x8bi: 0,
                            i_mb_partition16x8: [0; 2],
                            i_mb_partition8x16: [0; 2],
                            i_mb_type16x8: 0,
                            i_mb_type8x16: 0,
                            b_direct_available: 0,
                            b_early_terminate: 0,
                        };
                        lowres_context_init(h, &mut a);
                        slicetype_frame_cost(
                            h,
                            &mut a,
                            &mut fenc,
                            0 as ::core::ffi::c_int,
                            0 as ::core::ffi::c_int,
                            0 as ::core::ffi::c_int,
                        );
                    }
                    mcbuf = weight_cost_init_luma(
                        h,
                        fenc,
                        ref_0,
                        (*h).mb.p_weight_buf[0 as ::core::ffi::c_int as usize],
                    );
                    minscore = weight_cost_luma(h, fenc, mcbuf, 0 as *mut x264_weight_t);
                    origscore = minscore;
                } else if (*(*h).sps.as_mut_ptr()).i_chroma_format_idc
                    == CHROMA_444 as ::core::ffi::c_int
                {
                    mcbuf = weight_cost_init_chroma444(
                        h,
                        fenc,
                        ref_0,
                        (*h).mb.p_weight_buf[0 as ::core::ffi::c_int as usize],
                        plane_0,
                    );
                    minscore =
                        weight_cost_chroma444(h, fenc, mcbuf, 0 as *mut x264_weight_t, plane_0);
                    origscore = minscore;
                } else {
                    let mut dstu: *mut pixel =
                        (*h).mb.p_weight_buf[0 as ::core::ffi::c_int as usize];
                    let mut dstv: *mut pixel =
                        (*h).mb.p_weight_buf[0 as ::core::ffi::c_int as usize].offset(
                            ((*fenc).i_stride[1 as ::core::ffi::c_int as usize]
                                * (*fenc).i_lines[1 as ::core::ffi::c_int as usize])
                                as isize,
                        );
                    let fresh14 = chroma_initted;
                    chroma_initted = chroma_initted + 1;
                    if fresh14 == 0 {
                        weight_cost_init_chroma(h, fenc, ref_0, dstu, dstv);
                    }
                    mcbuf = if plane_0 == 1 as ::core::ffi::c_int {
                        dstu
                    } else {
                        dstv
                    };
                    minscore = weight_cost_chroma(h, fenc, mcbuf, 0 as *mut x264_weight_t);
                    origscore = minscore;
                }
                if !(minscore == 0) {
                    pub static mut weight_check_distance: [[uint8_t; 2]; 12] = [
                        [
                            0 as ::core::ffi::c_int as uint8_t,
                            0 as ::core::ffi::c_int as uint8_t,
                        ],
                        [
                            0 as ::core::ffi::c_int as uint8_t,
                            0 as ::core::ffi::c_int as uint8_t,
                        ],
                        [
                            0 as ::core::ffi::c_int as uint8_t,
                            1 as ::core::ffi::c_int as uint8_t,
                        ],
                        [
                            0 as ::core::ffi::c_int as uint8_t,
                            1 as ::core::ffi::c_int as uint8_t,
                        ],
                        [
                            0 as ::core::ffi::c_int as uint8_t,
                            1 as ::core::ffi::c_int as uint8_t,
                        ],
                        [
                            0 as ::core::ffi::c_int as uint8_t,
                            1 as ::core::ffi::c_int as uint8_t,
                        ],
                        [
                            0 as ::core::ffi::c_int as uint8_t,
                            1 as ::core::ffi::c_int as uint8_t,
                        ],
                        [
                            1 as ::core::ffi::c_int as uint8_t,
                            1 as ::core::ffi::c_int as uint8_t,
                        ],
                        [
                            1 as ::core::ffi::c_int as uint8_t,
                            1 as ::core::ffi::c_int as uint8_t,
                        ],
                        [
                            2 as ::core::ffi::c_int as uint8_t,
                            1 as ::core::ffi::c_int as uint8_t,
                        ],
                        [
                            2 as ::core::ffi::c_int as uint8_t,
                            1 as ::core::ffi::c_int as uint8_t,
                        ],
                        [
                            4 as ::core::ffi::c_int as uint8_t,
                            2 as ::core::ffi::c_int as uint8_t,
                        ],
                    ];
                    let mut scale_dist: ::core::ffi::c_int = if b_lookahead != 0 {
                        0 as ::core::ffi::c_int
                    } else {
                        weight_check_distance[(*h).param.analyse.i_subpel_refine as usize]
                            [0 as ::core::ffi::c_int as usize]
                            as ::core::ffi::c_int
                    };
                    let mut offset_dist: ::core::ffi::c_int = if b_lookahead != 0 {
                        0 as ::core::ffi::c_int
                    } else {
                        weight_check_distance[(*h).param.analyse.i_subpel_refine as usize]
                            [1 as ::core::ffi::c_int as usize]
                            as ::core::ffi::c_int
                    };
                    let mut start_scale: ::core::ffi::c_int = x264_clip3(
                        minscale - scale_dist,
                        0 as ::core::ffi::c_int,
                        127 as ::core::ffi::c_int,
                    );
                    let mut end_scale: ::core::ffi::c_int = x264_clip3(
                        minscale + scale_dist,
                        0 as ::core::ffi::c_int,
                        127 as ::core::ffi::c_int,
                    );
                    let mut i_scale: ::core::ffi::c_int = start_scale;
                    while i_scale <= end_scale {
                        let mut cur_scale: ::core::ffi::c_int = i_scale;
                        let mut cur_offset: ::core::ffi::c_int = (fenc_mean[plane_0 as usize]
                            - ref_mean[plane_0 as usize] * cur_scale as ::core::ffi::c_float
                                / ((1 as ::core::ffi::c_int) << mindenom) as ::core::ffi::c_float
                            + 0.5f32 * b_lookahead as ::core::ffi::c_float)
                            as ::core::ffi::c_int;
                        if cur_offset < -(128 as ::core::ffi::c_int)
                            || cur_offset > 127 as ::core::ffi::c_int
                        {
                            cur_offset = x264_clip3(
                                cur_offset,
                                -(128 as ::core::ffi::c_int),
                                127 as ::core::ffi::c_int,
                            );
                            cur_scale = x264_clip3f(
                                (((1 as ::core::ffi::c_int) << mindenom) as ::core::ffi::c_float
                                    * (fenc_mean[plane_0 as usize]
                                        - cur_offset as ::core::ffi::c_float)
                                    / ref_mean[plane_0 as usize]
                                    + 0.5f32)
                                    as ::core::ffi::c_double,
                                0 as ::core::ffi::c_int as ::core::ffi::c_double,
                                127 as ::core::ffi::c_int as ::core::ffi::c_double,
                            ) as ::core::ffi::c_int;
                        }
                        let mut start_offset: ::core::ffi::c_int = x264_clip3(
                            cur_offset - offset_dist,
                            -(128 as ::core::ffi::c_int),
                            127 as ::core::ffi::c_int,
                        );
                        let mut end_offset: ::core::ffi::c_int = x264_clip3(
                            cur_offset + offset_dist,
                            -(128 as ::core::ffi::c_int),
                            127 as ::core::ffi::c_int,
                        );
                        let mut i_off: ::core::ffi::c_int = start_offset;
                        while i_off <= end_offset {
                            (*weights.offset(plane_0 as isize)).i_scale = cur_scale as int32_t;
                            (*weights.offset(plane_0 as isize)).i_denom = mindenom as int32_t;
                            (*weights.offset(plane_0 as isize)).i_offset = i_off as int32_t;
                            (*h).mc.weight_cache.expect("non-null function pointer")(
                                h,
                                &mut *weights.offset(plane_0 as isize),
                            );
                            let mut s: ::core::ffi::c_uint = 0;
                            if plane_0 != 0 {
                                if (*(*h).sps.as_mut_ptr()).i_chroma_format_idc
                                    == CHROMA_444 as ::core::ffi::c_int
                                {
                                    s = weight_cost_chroma444(
                                        h,
                                        fenc,
                                        mcbuf,
                                        &mut *weights.offset(plane_0 as isize),
                                        plane_0,
                                    );
                                } else {
                                    s = weight_cost_chroma(
                                        h,
                                        fenc,
                                        mcbuf,
                                        &mut *weights.offset(plane_0 as isize),
                                    );
                                }
                            } else {
                                s = weight_cost_luma(
                                    h,
                                    fenc,
                                    mcbuf,
                                    &mut *weights.offset(plane_0 as isize),
                                );
                            }
                            if s < minscore {
                                minscore = s;
                                minscale = cur_scale;
                                minoff = i_off;
                                found = 1 as ::core::ffi::c_int;
                            }
                            if minoff == start_offset && i_off != start_offset {
                                break;
                            }
                            i_off += 1;
                        }
                        i_scale += 1;
                    }
                    if plane_0 == 0 {
                        while mindenom > 0 as ::core::ffi::c_int
                            && minscale & 1 as ::core::ffi::c_int == 0
                        {
                            mindenom -= 1;
                            minscale >>= 1 as ::core::ffi::c_int;
                        }
                    }
                    if found == 0
                        || minscale == (1 as ::core::ffi::c_int) << mindenom
                            && minoff == 0 as ::core::ffi::c_int
                        || minscore as ::core::ffi::c_float / origscore as ::core::ffi::c_float
                            > 0.998f32
                    {
                        (*weights.offset(plane_0 as isize)).i_scale =
                            1 as ::core::ffi::c_int as int32_t;
                        (*weights.offset(plane_0 as isize)).i_denom =
                            0 as ::core::ffi::c_int as int32_t;
                        (*weights.offset(plane_0 as isize)).i_offset =
                            0 as ::core::ffi::c_int as int32_t;
                        let ref mut fresh16 = (*weights.offset(plane_0 as isize)).weightfn;
                        *fresh16 = 0 as *mut weight_fn_t;
                    } else {
                        (*weights.offset(plane_0 as isize)).i_scale = minscale as int32_t;
                        (*weights.offset(plane_0 as isize)).i_denom = mindenom as int32_t;
                        (*weights.offset(plane_0 as isize)).i_offset = minoff as int32_t;
                        (*h).mc.weight_cache.expect("non-null function pointer")(
                            h,
                            &mut *weights.offset(plane_0 as isize),
                        );
                        if (*h).param.analyse.i_weighted_pred == X264_WEIGHTP_FAKE
                            && !(*weights.offset(0 as ::core::ffi::c_int as isize))
                                .weightfn
                                .is_null()
                            && plane_0 == 0
                        {
                            (*fenc).f_weighted_cost_delta[i_delta_index as usize] = minscore
                                as ::core::ffi::c_float
                                / origscore as ::core::ffi::c_float;
                        }
                    }
                }
            }
            plane_0 += 1;
        }
        if !(*weights.offset(1 as ::core::ffi::c_int as isize))
            .weightfn
            .is_null()
            || !(*weights.offset(2 as ::core::ffi::c_int as isize))
                .weightfn
                .is_null()
        {
            let mut denom: ::core::ffi::c_int = if !(*weights
                .offset(1 as ::core::ffi::c_int as isize))
            .weightfn
            .is_null()
            {
                (*weights.offset(1 as ::core::ffi::c_int as isize)).i_denom as ::core::ffi::c_int
            } else {
                (*weights.offset(2 as ::core::ffi::c_int as isize)).i_denom as ::core::ffi::c_int
            };
            let mut both_weighted: ::core::ffi::c_int =
                (!(*weights.offset(1 as ::core::ffi::c_int as isize))
                    .weightfn
                    .is_null()
                    && !(*weights.offset(2 as ::core::ffi::c_int as isize))
                        .weightfn
                        .is_null()) as ::core::ffi::c_int;
            while both_weighted == 0 && denom == 7 as ::core::ffi::c_int
                || denom > 0 as ::core::ffi::c_int
                    && !(!(*weights.offset(1 as ::core::ffi::c_int as isize))
                        .weightfn
                        .is_null()
                        && (*weights.offset(1 as ::core::ffi::c_int as isize)).i_scale
                            & 1 as int32_t
                            != 0)
                    && !(!(*weights.offset(2 as ::core::ffi::c_int as isize))
                        .weightfn
                        .is_null()
                        && (*weights.offset(2 as ::core::ffi::c_int as isize)).i_scale
                            & 1 as int32_t
                            != 0)
            {
                denom -= 1;
                let mut i: ::core::ffi::c_int = 1 as ::core::ffi::c_int;
                while i <= 2 as ::core::ffi::c_int {
                    if !(*weights.offset(i as isize)).weightfn.is_null() {
                        (*weights.offset(i as isize)).i_scale >>= 1 as ::core::ffi::c_int;
                        (*weights.offset(i as isize)).i_denom = denom as int32_t;
                    }
                    i += 1;
                }
            }
        }
        let mut i_0: ::core::ffi::c_int = 1 as ::core::ffi::c_int;
        while i_0 <= 2 as ::core::ffi::c_int {
            if !(*weights.offset(i_0 as isize)).weightfn.is_null() {
                (*h).mc.weight_cache.expect("non-null function pointer")(
                    h,
                    &mut *weights.offset(i_0 as isize),
                );
            }
            i_0 += 1;
        }
        if !(*weights.offset(0 as ::core::ffi::c_int as isize))
            .weightfn
            .is_null()
            && b_lookahead != 0
        {
            let mut src: *mut pixel = (*ref_0).buffer_lowres;
            let mut dst: *mut pixel = (*h).mb.p_weight_buf[0 as ::core::ffi::c_int as usize];
            let mut width: ::core::ffi::c_int = (*ref_0).i_width_lowres
                + ((if 32 as ::core::ffi::c_int
                    > 64 as ::core::ffi::c_int
                        / ::core::mem::size_of::<pixel>() as ::core::ffi::c_int
                {
                    32 as ::core::ffi::c_int
                } else {
                    64 as ::core::ffi::c_int / ::core::mem::size_of::<pixel>() as ::core::ffi::c_int
                }) + PADH);
            let mut height: ::core::ffi::c_int =
                (*ref_0).i_lines_lowres + PADV * 2 as ::core::ffi::c_int;
            x264_10_weight_scale_plane(
                h,
                dst,
                (*ref_0).i_stride_lowres as intptr_t,
                src,
                (*ref_0).i_stride_lowres as intptr_t,
                width,
                height,
                &mut *weights.offset(0 as ::core::ffi::c_int as isize),
            );
            (*fenc).weighted[0 as ::core::ffi::c_int as usize] = (*h).mb.p_weight_buf
                [0 as ::core::ffi::c_int as usize]
                .offset(
                    (if 32 as ::core::ffi::c_int
                        > 64 as ::core::ffi::c_int
                            / ::core::mem::size_of::<pixel>() as ::core::ffi::c_int
                    {
                        32 as ::core::ffi::c_int
                    } else {
                        64 as ::core::ffi::c_int
                            / ::core::mem::size_of::<pixel>() as ::core::ffi::c_int
                    }) as isize,
                )
                .offset(((*ref_0).i_stride_lowres * PADV) as isize);
        }
    }
    #[c2rust::src_loc = "505:9"]
    pub const PAD_SIZE: ::core::ffi::c_int = 32 as ::core::ffi::c_int;
    #[c2rust::src_loc = "507:9"]
    pub const NUM_INTS: ::core::ffi::c_int = 4 as ::core::ffi::c_int;
    #[c2rust::src_loc = "508:9"]
    pub const COST_EST: ::core::ffi::c_int = 0 as ::core::ffi::c_int;
    #[c2rust::src_loc = "509:9"]
    pub const COST_EST_AQ: ::core::ffi::c_int = 1 as ::core::ffi::c_int;
    #[c2rust::src_loc = "510:9"]
    pub const INTRA_MBS: ::core::ffi::c_int = 2 as ::core::ffi::c_int;
    #[c2rust::src_loc = "511:9"]
    pub const NUM_ROWS: ::core::ffi::c_int = 3 as ::core::ffi::c_int;
    #[c2rust::src_loc = "514:1"]
    pub unsafe extern "C" fn slicetype_mb_cost(
        mut h: *mut x264_t,
        mut a: *mut x264_mb_analysis_t,
        mut frames: *mut *mut x264_frame_t,
        mut p0: ::core::ffi::c_int,
        mut p1: ::core::ffi::c_int,
        mut b: ::core::ffi::c_int,
        mut dist_scale_factor: ::core::ffi::c_int,
        mut do_search: *mut ::core::ffi::c_int,
        mut w: *const x264_weight_t,
        mut output_inter: *mut ::core::ffi::c_int,
        mut output_intra: *mut ::core::ffi::c_int,
    ) {
        let mut mv_range: ::core::ffi::c_int = 0;
        let mut fref0: *mut x264_frame_t = *frames.offset(p0 as isize);
        let mut fref1: *mut x264_frame_t = *frames.offset(p1 as isize);
        let mut fenc: *mut x264_frame_t = *frames.offset(b as isize);
        let b_bidir: ::core::ffi::c_int = (b < p1) as ::core::ffi::c_int;
        let i_mb_x: ::core::ffi::c_int = (*h).mb.i_mb_x;
        let i_mb_y: ::core::ffi::c_int = (*h).mb.i_mb_y;
        let i_mb_stride: ::core::ffi::c_int = (*h).mb.i_mb_width;
        let i_mb_xy: ::core::ffi::c_int = i_mb_x + i_mb_y * i_mb_stride;
        let i_stride: ::core::ffi::c_int = (*fenc).i_stride_lowres;
        let i_pel_offset: ::core::ffi::c_int =
            8 as ::core::ffi::c_int * (i_mb_x + i_mb_y * i_stride);
        let i_bipred_weight: ::core::ffi::c_int = if (*h).param.analyse.b_weighted_bipred != 0 {
            64 as ::core::ffi::c_int - (dist_scale_factor >> 2 as ::core::ffi::c_int)
        } else {
            32 as ::core::ffi::c_int
        };
        let mut fenc_mvs: [*mut [int16_t; 2]; 2] = [
            if b != p0 {
                &mut *(*(*(*fenc)
                    .lowres_mvs
                    .as_mut_ptr()
                    .offset(0 as ::core::ffi::c_int as isize))
                .as_mut_ptr()
                .offset((b - p0 - 1 as ::core::ffi::c_int) as isize))
                .offset(i_mb_xy as isize) as *mut [int16_t; 2]
            } else {
                0 as *mut [int16_t; 2]
            },
            if b != p1 {
                &mut *(*(*(*fenc)
                    .lowres_mvs
                    .as_mut_ptr()
                    .offset(1 as ::core::ffi::c_int as isize))
                .as_mut_ptr()
                .offset((p1 - b - 1 as ::core::ffi::c_int) as isize))
                .offset(i_mb_xy as isize) as *mut [int16_t; 2]
            } else {
                0 as *mut [int16_t; 2]
            },
        ];
        let mut fenc_costs: [*mut ::core::ffi::c_int; 2] = [
            if b != p0 {
                &mut *(*(*(*fenc)
                    .lowres_mv_costs
                    .as_mut_ptr()
                    .offset(0 as ::core::ffi::c_int as isize))
                .as_mut_ptr()
                .offset((b - p0 - 1 as ::core::ffi::c_int) as isize))
                .offset(i_mb_xy as isize) as *mut ::core::ffi::c_int
            } else {
                0 as *mut ::core::ffi::c_int
            },
            if b != p1 {
                &mut *(*(*(*fenc)
                    .lowres_mv_costs
                    .as_mut_ptr()
                    .offset(1 as ::core::ffi::c_int as isize))
                .as_mut_ptr()
                .offset((p1 - b - 1 as ::core::ffi::c_int) as isize))
                .offset(i_mb_xy as isize) as *mut ::core::ffi::c_int
            } else {
                0 as *mut ::core::ffi::c_int
            },
        ];
        let mut b_frame_score_mb: ::core::ffi::c_int = (i_mb_x > 0 as ::core::ffi::c_int
            && i_mb_x < (*h).mb.i_mb_width - 1 as ::core::ffi::c_int
            && i_mb_y > 0 as ::core::ffi::c_int
            && i_mb_y < (*h).mb.i_mb_height - 1 as ::core::ffi::c_int
            || (*h).mb.i_mb_width <= 2 as ::core::ffi::c_int
            || (*h).mb.i_mb_height <= 2 as ::core::ffi::c_int)
            as ::core::ffi::c_int;
        let mut pix1: [pixel; 288] = [0; 288];
        let mut pix2: *mut pixel = pix1.as_mut_ptr().offset(8 as ::core::ffi::c_int as isize);
        let mut m: [x264_me_t; 2] = [x264_me_t {
            i_pixel: 0,
            p_cost_mv: 0 as *mut uint16_t,
            i_ref_cost: 0,
            i_ref: 0,
            weight: 0 as *const x264_weight_t,
            p_fref: [0 as *mut pixel; 12],
            p_fref_w: 0 as *mut pixel,
            p_fenc: [0 as *mut pixel; 3],
            integral: 0 as *mut uint16_t,
            i_stride: [0; 3],
            mvp: [0; 2],
            cost_mv: 0,
            cost: 0,
            mv: [0; 2],
        }; 2];
        let mut i_bcost: ::core::ffi::c_int = COST_MAX;
        let mut list_used: ::core::ffi::c_int = 0 as ::core::ffi::c_int;
        let mut lowres_penalty: ::core::ffi::c_int = 4 as ::core::ffi::c_int;
        (*h).mb.pic.p_fenc[0 as ::core::ffi::c_int as usize] = (*h).mb.pic.fenc_buf.as_mut_ptr();
        (*h).mc.copy[PIXEL_8x8 as ::core::ffi::c_int as usize].expect("non-null function pointer")(
            (*h).mb.pic.p_fenc[0 as ::core::ffi::c_int as usize],
            FENC_STRIDE as intptr_t,
            &mut *(*(*fenc)
                .lowres
                .as_mut_ptr()
                .offset(0 as ::core::ffi::c_int as isize))
            .offset(i_pel_offset as isize),
            i_stride as intptr_t,
            8 as ::core::ffi::c_int,
        );
        if !(p0 == p1) {
            mv_range = 2 as ::core::ffi::c_int * (*h).param.analyse.i_mv_range;
            (*h).mb.mv_min_spel[0 as ::core::ffi::c_int as usize] = if 4 as ::core::ffi::c_int
                * (-(8 as ::core::ffi::c_int) * (*h).mb.i_mb_x - 12 as ::core::ffi::c_int)
                > -mv_range
            {
                4 as ::core::ffi::c_int
                    * (-(8 as ::core::ffi::c_int) * (*h).mb.i_mb_x - 12 as ::core::ffi::c_int)
            } else {
                -mv_range
            };
            (*h).mb.mv_max_spel[0 as ::core::ffi::c_int as usize] = if 4 as ::core::ffi::c_int
                * (8 as ::core::ffi::c_int
                    * ((*h).mb.i_mb_width - (*h).mb.i_mb_x - 1 as ::core::ffi::c_int)
                    + 12 as ::core::ffi::c_int)
                < mv_range - 1 as ::core::ffi::c_int
            {
                4 as ::core::ffi::c_int
                    * (8 as ::core::ffi::c_int
                        * ((*h).mb.i_mb_width - (*h).mb.i_mb_x - 1 as ::core::ffi::c_int)
                        + 12 as ::core::ffi::c_int)
            } else {
                mv_range - 1 as ::core::ffi::c_int
            };
            (*h).mb.mv_limit_fpel[0 as ::core::ffi::c_int as usize]
                [0 as ::core::ffi::c_int as usize] =
                ((*h).mb.mv_min_spel[0 as ::core::ffi::c_int as usize] >> 2 as ::core::ffi::c_int)
                    as int16_t;
            (*h).mb.mv_limit_fpel[1 as ::core::ffi::c_int as usize]
                [0 as ::core::ffi::c_int as usize] =
                ((*h).mb.mv_max_spel[0 as ::core::ffi::c_int as usize] >> 2 as ::core::ffi::c_int)
                    as int16_t;
            if (*h).mb.i_mb_x >= (*h).mb.i_mb_width - 2 as ::core::ffi::c_int {
                (*h).mb.mv_min_spel[1 as ::core::ffi::c_int as usize] = if 4 as ::core::ffi::c_int
                    * (-(8 as ::core::ffi::c_int) * (*h).mb.i_mb_y - 12 as ::core::ffi::c_int)
                    > -mv_range
                {
                    4 as ::core::ffi::c_int
                        * (-(8 as ::core::ffi::c_int) * (*h).mb.i_mb_y - 12 as ::core::ffi::c_int)
                } else {
                    -mv_range
                };
                (*h).mb.mv_max_spel[1 as ::core::ffi::c_int as usize] = if 4 as ::core::ffi::c_int
                    * (8 as ::core::ffi::c_int
                        * ((*h).mb.i_mb_height - (*h).mb.i_mb_y - 1 as ::core::ffi::c_int)
                        + 12 as ::core::ffi::c_int)
                    < mv_range - 1 as ::core::ffi::c_int
                {
                    4 as ::core::ffi::c_int
                        * (8 as ::core::ffi::c_int
                            * ((*h).mb.i_mb_height - (*h).mb.i_mb_y - 1 as ::core::ffi::c_int)
                            + 12 as ::core::ffi::c_int)
                } else {
                    mv_range - 1 as ::core::ffi::c_int
                };
                (*h).mb.mv_limit_fpel[0 as ::core::ffi::c_int as usize]
                    [1 as ::core::ffi::c_int as usize] =
                    ((*h).mb.mv_min_spel[1 as ::core::ffi::c_int as usize]
                        >> 2 as ::core::ffi::c_int) as int16_t;
                (*h).mb.mv_limit_fpel[1 as ::core::ffi::c_int as usize]
                    [1 as ::core::ffi::c_int as usize] =
                    ((*h).mb.mv_max_spel[1 as ::core::ffi::c_int as usize]
                        >> 2 as ::core::ffi::c_int) as int16_t;
            }
            m[0 as ::core::ffi::c_int as usize].i_pixel = PIXEL_8x8 as ::core::ffi::c_int;
            m[0 as ::core::ffi::c_int as usize].p_cost_mv = (*a).p_cost_mv;
            m[0 as ::core::ffi::c_int as usize].i_stride[0 as ::core::ffi::c_int as usize] =
                i_stride;
            m[0 as ::core::ffi::c_int as usize].p_fenc[0 as ::core::ffi::c_int as usize] =
                (*h).mb.pic.p_fenc[0 as ::core::ffi::c_int as usize];
            m[0 as ::core::ffi::c_int as usize].weight = w;
            m[0 as ::core::ffi::c_int as usize].i_ref = 0 as ::core::ffi::c_int;
            m[0 as ::core::ffi::c_int as usize].p_fref[0 as ::core::ffi::c_int as usize] =
                &mut *(*(*fref0)
                    .lowres
                    .as_mut_ptr()
                    .offset(0 as ::core::ffi::c_int as isize))
                .offset(i_pel_offset as isize) as *mut pixel;
            m[0 as ::core::ffi::c_int as usize].p_fref[1 as ::core::ffi::c_int as usize] =
                &mut *(*(*fref0)
                    .lowres
                    .as_mut_ptr()
                    .offset(1 as ::core::ffi::c_int as isize))
                .offset(i_pel_offset as isize) as *mut pixel;
            m[0 as ::core::ffi::c_int as usize].p_fref[2 as ::core::ffi::c_int as usize] =
                &mut *(*(*fref0)
                    .lowres
                    .as_mut_ptr()
                    .offset(2 as ::core::ffi::c_int as isize))
                .offset(i_pel_offset as isize) as *mut pixel;
            m[0 as ::core::ffi::c_int as usize].p_fref[3 as ::core::ffi::c_int as usize] =
                &mut *(*(*fref0)
                    .lowres
                    .as_mut_ptr()
                    .offset(3 as ::core::ffi::c_int as isize))
                .offset(i_pel_offset as isize) as *mut pixel;
            m[0 as ::core::ffi::c_int as usize].p_fref_w =
                m[0 as ::core::ffi::c_int as usize].p_fref[0 as ::core::ffi::c_int as usize];
            if !(*w.offset(0 as ::core::ffi::c_int as isize))
                .weightfn
                .is_null()
            {
                m[0 as ::core::ffi::c_int as usize].p_fref_w = &mut *(*(*fenc)
                    .weighted
                    .as_mut_ptr()
                    .offset(0 as ::core::ffi::c_int as isize))
                .offset(i_pel_offset as isize)
                    as *mut pixel;
            }
            if b_bidir != 0 {
                let mut dmv: [[int16_t; 2]; 2] = [[0; 2]; 2];
                m[1 as ::core::ffi::c_int as usize].i_pixel = PIXEL_8x8 as ::core::ffi::c_int;
                m[1 as ::core::ffi::c_int as usize].p_cost_mv = (*a).p_cost_mv;
                m[1 as ::core::ffi::c_int as usize].i_stride[0 as ::core::ffi::c_int as usize] =
                    i_stride;
                m[1 as ::core::ffi::c_int as usize].p_fenc[0 as ::core::ffi::c_int as usize] =
                    (*h).mb.pic.p_fenc[0 as ::core::ffi::c_int as usize];
                m[1 as ::core::ffi::c_int as usize].i_ref = 0 as ::core::ffi::c_int;
                m[1 as ::core::ffi::c_int as usize].weight =
                    x264_zero.as_mut_ptr() as *const x264_weight_t;
                m[1 as ::core::ffi::c_int as usize].p_fref[0 as ::core::ffi::c_int as usize] =
                    &mut *(*(*fref1)
                        .lowres
                        .as_mut_ptr()
                        .offset(0 as ::core::ffi::c_int as isize))
                    .offset(i_pel_offset as isize) as *mut pixel;
                m[1 as ::core::ffi::c_int as usize].p_fref[1 as ::core::ffi::c_int as usize] =
                    &mut *(*(*fref1)
                        .lowres
                        .as_mut_ptr()
                        .offset(1 as ::core::ffi::c_int as isize))
                    .offset(i_pel_offset as isize) as *mut pixel;
                m[1 as ::core::ffi::c_int as usize].p_fref[2 as ::core::ffi::c_int as usize] =
                    &mut *(*(*fref1)
                        .lowres
                        .as_mut_ptr()
                        .offset(2 as ::core::ffi::c_int as isize))
                    .offset(i_pel_offset as isize) as *mut pixel;
                m[1 as ::core::ffi::c_int as usize].p_fref[3 as ::core::ffi::c_int as usize] =
                    &mut *(*(*fref1)
                        .lowres
                        .as_mut_ptr()
                        .offset(3 as ::core::ffi::c_int as isize))
                    .offset(i_pel_offset as isize) as *mut pixel;
                m[1 as ::core::ffi::c_int as usize].p_fref_w =
                    m[1 as ::core::ffi::c_int as usize].p_fref[0 as ::core::ffi::c_int as usize];
                if (*(*fref1).lowres_mvs[0 as ::core::ffi::c_int as usize]
                    [(p1 - p0 - 1 as ::core::ffi::c_int) as usize]
                    .offset(0 as ::core::ffi::c_int as isize))
                    [0 as ::core::ffi::c_int as usize] as ::core::ffi::c_int
                    != 0x7fff as ::core::ffi::c_int
                {
                    let mut mvr: *mut int16_t = (*(*(*(*fref1)
                        .lowres_mvs
                        .as_mut_ptr()
                        .offset(0 as ::core::ffi::c_int as isize))
                    .as_mut_ptr()
                    .offset((p1 - p0 - 1 as ::core::ffi::c_int) as isize))
                    .offset(i_mb_xy as isize))
                    .as_mut_ptr();
                    dmv[0 as ::core::ffi::c_int as usize][0 as ::core::ffi::c_int as usize] =
                        (*mvr.offset(0 as ::core::ffi::c_int as isize) as ::core::ffi::c_int
                            * dist_scale_factor
                            + 128 as ::core::ffi::c_int
                            >> 8 as ::core::ffi::c_int) as int16_t;
                    dmv[0 as ::core::ffi::c_int as usize][1 as ::core::ffi::c_int as usize] =
                        (*mvr.offset(1 as ::core::ffi::c_int as isize) as ::core::ffi::c_int
                            * dist_scale_factor
                            + 128 as ::core::ffi::c_int
                            >> 8 as ::core::ffi::c_int) as int16_t;
                    dmv[1 as ::core::ffi::c_int as usize][0 as ::core::ffi::c_int as usize] =
                        (dmv[0 as ::core::ffi::c_int as usize][0 as ::core::ffi::c_int as usize]
                            as ::core::ffi::c_int
                            - *mvr.offset(0 as ::core::ffi::c_int as isize) as ::core::ffi::c_int)
                            as int16_t;
                    dmv[1 as ::core::ffi::c_int as usize][1 as ::core::ffi::c_int as usize] =
                        (dmv[0 as ::core::ffi::c_int as usize][1 as ::core::ffi::c_int as usize]
                            as ::core::ffi::c_int
                            - *mvr.offset(1 as ::core::ffi::c_int as isize) as ::core::ffi::c_int)
                            as int16_t;
                    dmv[0 as ::core::ffi::c_int as usize][0 as ::core::ffi::c_int as usize] =
                        x264_clip3(
                            dmv[0 as ::core::ffi::c_int as usize][0 as ::core::ffi::c_int as usize]
                                as ::core::ffi::c_int,
                            (*h).mb.mv_min_spel[0 as ::core::ffi::c_int as usize],
                            (*h).mb.mv_max_spel[0 as ::core::ffi::c_int as usize],
                        ) as int16_t;
                    dmv[0 as ::core::ffi::c_int as usize][1 as ::core::ffi::c_int as usize] =
                        x264_clip3(
                            dmv[0 as ::core::ffi::c_int as usize][1 as ::core::ffi::c_int as usize]
                                as ::core::ffi::c_int,
                            (*h).mb.mv_min_spel[1 as ::core::ffi::c_int as usize],
                            (*h).mb.mv_max_spel[1 as ::core::ffi::c_int as usize],
                        ) as int16_t;
                    dmv[1 as ::core::ffi::c_int as usize][0 as ::core::ffi::c_int as usize] =
                        x264_clip3(
                            dmv[1 as ::core::ffi::c_int as usize][0 as ::core::ffi::c_int as usize]
                                as ::core::ffi::c_int,
                            (*h).mb.mv_min_spel[0 as ::core::ffi::c_int as usize],
                            (*h).mb.mv_max_spel[0 as ::core::ffi::c_int as usize],
                        ) as int16_t;
                    dmv[1 as ::core::ffi::c_int as usize][1 as ::core::ffi::c_int as usize] =
                        x264_clip3(
                            dmv[1 as ::core::ffi::c_int as usize][1 as ::core::ffi::c_int as usize]
                                as ::core::ffi::c_int,
                            (*h).mb.mv_min_spel[1 as ::core::ffi::c_int as usize],
                            (*h).mb.mv_max_spel[1 as ::core::ffi::c_int as usize],
                        ) as int16_t;
                    if (*h).param.analyse.i_subpel_refine <= 1 as ::core::ffi::c_int {
                        let ref mut fresh20 = (*(dmv.as_mut_ptr() as *mut x264_union64_t)).i;
                        *fresh20 = (*fresh20 as ::core::ffi::c_ulonglong
                            & !(0x1000100010001 as ::core::ffi::c_ulonglong))
                            as uint64_t;
                    }
                } else {
                    (*(dmv.as_mut_ptr() as *mut x264_union64_t)).i = 0 as uint64_t;
                }
                let mut i_cost: ::core::ffi::c_int = 0;
                if (*h).param.analyse.i_subpel_refine <= 1 as ::core::ffi::c_int {
                    let mut hpel_idx1: ::core::ffi::c_int = ((dmv[0 as ::core::ffi::c_int as usize]
                        [0 as ::core::ffi::c_int as usize]
                        as ::core::ffi::c_int
                        & 2 as ::core::ffi::c_int)
                        >> 1 as ::core::ffi::c_int)
                        + (dmv[0 as ::core::ffi::c_int as usize][1 as ::core::ffi::c_int as usize]
                            as ::core::ffi::c_int
                            & 2 as ::core::ffi::c_int);
                    let mut hpel_idx2: ::core::ffi::c_int = ((dmv[1 as ::core::ffi::c_int as usize]
                        [0 as ::core::ffi::c_int as usize]
                        as ::core::ffi::c_int
                        & 2 as ::core::ffi::c_int)
                        >> 1 as ::core::ffi::c_int)
                        + (dmv[1 as ::core::ffi::c_int as usize][1 as ::core::ffi::c_int as usize]
                            as ::core::ffi::c_int
                            & 2 as ::core::ffi::c_int);
                    let mut src1: *mut pixel = m[0 as ::core::ffi::c_int as usize].p_fref
                        [hpel_idx1 as usize]
                        .offset(
                            (dmv[0 as ::core::ffi::c_int as usize][0 as ::core::ffi::c_int as usize]
                                as ::core::ffi::c_int
                                >> 2 as ::core::ffi::c_int) as isize,
                        )
                        .offset(
                            ((dmv[0 as ::core::ffi::c_int as usize]
                                [1 as ::core::ffi::c_int as usize]
                                as ::core::ffi::c_int
                                >> 2 as ::core::ffi::c_int)
                                * m[0 as ::core::ffi::c_int as usize].i_stride
                                    [0 as ::core::ffi::c_int as usize])
                                as isize,
                        );
                    let mut src2: *mut pixel = m[1 as ::core::ffi::c_int as usize].p_fref
                        [hpel_idx2 as usize]
                        .offset(
                            (dmv[1 as ::core::ffi::c_int as usize][0 as ::core::ffi::c_int as usize]
                                as ::core::ffi::c_int
                                >> 2 as ::core::ffi::c_int) as isize,
                        )
                        .offset(
                            ((dmv[1 as ::core::ffi::c_int as usize]
                                [1 as ::core::ffi::c_int as usize]
                                as ::core::ffi::c_int
                                >> 2 as ::core::ffi::c_int)
                                * m[1 as ::core::ffi::c_int as usize].i_stride
                                    [0 as ::core::ffi::c_int as usize])
                                as isize,
                        );
                    (*h).mc.avg[PIXEL_8x8 as ::core::ffi::c_int as usize]
                        .expect("non-null function pointer")(
                        pix1.as_mut_ptr(),
                        16 as intptr_t,
                        src1,
                        m[0 as ::core::ffi::c_int as usize].i_stride
                            [0 as ::core::ffi::c_int as usize] as intptr_t,
                        src2,
                        m[1 as ::core::ffi::c_int as usize].i_stride
                            [0 as ::core::ffi::c_int as usize] as intptr_t,
                        i_bipred_weight,
                    );
                } else {
                    let mut stride1: intptr_t = 16 as intptr_t;
                    let mut stride2: intptr_t = 16 as intptr_t;
                    let mut src1_0: *mut pixel = 0 as *mut pixel;
                    let mut src2_0: *mut pixel = 0 as *mut pixel;
                    src1_0 = (*h).mc.get_ref.expect("non-null function pointer")(
                        pix1.as_mut_ptr(),
                        &mut stride1,
                        (*m.as_mut_ptr().offset(0 as ::core::ffi::c_int as isize))
                            .p_fref
                            .as_mut_ptr(),
                        m[0 as ::core::ffi::c_int as usize].i_stride
                            [0 as ::core::ffi::c_int as usize] as intptr_t,
                        dmv[0 as ::core::ffi::c_int as usize][0 as ::core::ffi::c_int as usize]
                            as ::core::ffi::c_int,
                        dmv[0 as ::core::ffi::c_int as usize][1 as ::core::ffi::c_int as usize]
                            as ::core::ffi::c_int,
                        8 as ::core::ffi::c_int,
                        8 as ::core::ffi::c_int,
                        w,
                    );
                    src2_0 = (*h).mc.get_ref.expect("non-null function pointer")(
                        pix2,
                        &mut stride2,
                        (*m.as_mut_ptr().offset(1 as ::core::ffi::c_int as isize))
                            .p_fref
                            .as_mut_ptr(),
                        m[1 as ::core::ffi::c_int as usize].i_stride
                            [0 as ::core::ffi::c_int as usize] as intptr_t,
                        dmv[1 as ::core::ffi::c_int as usize][0 as ::core::ffi::c_int as usize]
                            as ::core::ffi::c_int,
                        dmv[1 as ::core::ffi::c_int as usize][1 as ::core::ffi::c_int as usize]
                            as ::core::ffi::c_int,
                        8 as ::core::ffi::c_int,
                        8 as ::core::ffi::c_int,
                        w,
                    );
                    (*h).mc.avg[PIXEL_8x8 as ::core::ffi::c_int as usize]
                        .expect("non-null function pointer")(
                        pix1.as_mut_ptr(),
                        16 as intptr_t,
                        src1_0,
                        stride1,
                        src2_0,
                        stride2,
                        i_bipred_weight,
                    );
                }
                i_cost = 0 as ::core::ffi::c_int * (*a).i_lambda
                    + (*h).pixf.mbcmp[PIXEL_8x8 as ::core::ffi::c_int as usize]
                        .expect("non-null function pointer")(
                        m[0 as ::core::ffi::c_int as usize].p_fenc
                            [0 as ::core::ffi::c_int as usize],
                        FENC_STRIDE as intptr_t,
                        pix1.as_mut_ptr(),
                        16 as intptr_t,
                    );
                if i_cost < i_bcost {
                    i_bcost = i_cost;
                    list_used = 3 as ::core::ffi::c_int;
                }
                if (*(dmv.as_mut_ptr() as *mut x264_union64_t)).i != 0 {
                    let mut i_cost_0: ::core::ffi::c_int = 0;
                    (*h).mc.avg[PIXEL_8x8 as ::core::ffi::c_int as usize]
                        .expect("non-null function pointer")(
                        pix1.as_mut_ptr(),
                        16 as intptr_t,
                        m[0 as ::core::ffi::c_int as usize].p_fref
                            [0 as ::core::ffi::c_int as usize],
                        m[0 as ::core::ffi::c_int as usize].i_stride
                            [0 as ::core::ffi::c_int as usize] as intptr_t,
                        m[1 as ::core::ffi::c_int as usize].p_fref
                            [0 as ::core::ffi::c_int as usize],
                        m[1 as ::core::ffi::c_int as usize].i_stride
                            [0 as ::core::ffi::c_int as usize] as intptr_t,
                        i_bipred_weight,
                    );
                    i_cost_0 = (*h).pixf.mbcmp[PIXEL_8x8 as ::core::ffi::c_int as usize]
                        .expect("non-null function pointer")(
                        m[0 as ::core::ffi::c_int as usize].p_fenc
                            [0 as ::core::ffi::c_int as usize],
                        FENC_STRIDE as intptr_t,
                        pix1.as_mut_ptr(),
                        16 as intptr_t,
                    );
                    if i_cost_0 < i_bcost {
                        i_bcost = i_cost_0;
                        list_used = 3 as ::core::ffi::c_int;
                    }
                }
            }
            let mut l: ::core::ffi::c_int = 0 as ::core::ffi::c_int;
            while l < 1 as ::core::ffi::c_int + b_bidir {
                if *do_search.offset(l as isize) != 0 {
                    let mut current_block_117: u64;
                    let mut i_mvc: ::core::ffi::c_int = 0 as ::core::ffi::c_int;
                    let mut fenc_mv: *mut [int16_t; 2] = fenc_mvs[l as usize];
                    let mut mvc: [[int16_t; 2]; 4] = [[0; 2]; 4];
                    (*((*mvc.as_mut_ptr().offset(0 as ::core::ffi::c_int as isize)).as_mut_ptr()
                        as *mut x264_union32_t))
                        .i = 0 as uint32_t;
                    (*((*mvc.as_mut_ptr().offset(2 as ::core::ffi::c_int as isize)).as_mut_ptr()
                        as *mut x264_union32_t))
                        .i = 0 as uint32_t;
                    if i_mb_x < (*h).mb.i_mb_width - 1 as ::core::ffi::c_int {
                        (*((*mvc.as_mut_ptr().offset(i_mvc as isize)).as_mut_ptr()
                            as *mut x264_union32_t))
                            .i =
                            (*((*fenc_mv.offset(1 as ::core::ffi::c_int as isize)).as_mut_ptr()
                                as *mut x264_union32_t))
                                .i;
                        i_mvc += 1;
                    }
                    if i_mb_y < (*h).i_threadslice_end - 1 as ::core::ffi::c_int {
                        (*((*mvc.as_mut_ptr().offset(i_mvc as isize)).as_mut_ptr()
                            as *mut x264_union32_t))
                            .i = (*((*fenc_mv.offset(i_mb_stride as isize)).as_mut_ptr()
                            as *mut x264_union32_t))
                            .i;
                        i_mvc += 1;
                        if i_mb_x > 0 as ::core::ffi::c_int {
                            (*((*mvc.as_mut_ptr().offset(i_mvc as isize)).as_mut_ptr()
                                as *mut x264_union32_t))
                                .i = (*((*fenc_mv
                                .offset((i_mb_stride - 1 as ::core::ffi::c_int) as isize))
                            .as_mut_ptr()
                                as *mut x264_union32_t))
                                .i;
                            i_mvc += 1;
                        }
                        if i_mb_x < (*h).mb.i_mb_width - 1 as ::core::ffi::c_int {
                            (*((*mvc.as_mut_ptr().offset(i_mvc as isize)).as_mut_ptr()
                                as *mut x264_union32_t))
                                .i = (*((*fenc_mv
                                .offset((i_mb_stride + 1 as ::core::ffi::c_int) as isize))
                            .as_mut_ptr()
                                as *mut x264_union32_t))
                                .i;
                            i_mvc += 1;
                        }
                    }
                    if i_mvc <= 1 as ::core::ffi::c_int {
                        (*((*m.as_mut_ptr().offset(l as isize)).mvp.as_mut_ptr()
                            as *mut x264_union32_t))
                            .i = (*((*mvc.as_mut_ptr().offset(0 as ::core::ffi::c_int as isize))
                            .as_mut_ptr()
                            as *mut x264_union32_t))
                            .i;
                    } else {
                        x264_median_mv(
                            (*m.as_mut_ptr().offset(l as isize)).mvp.as_mut_ptr(),
                            (*mvc.as_mut_ptr().offset(0 as ::core::ffi::c_int as isize))
                                .as_mut_ptr(),
                            (*mvc.as_mut_ptr().offset(1 as ::core::ffi::c_int as isize))
                                .as_mut_ptr(),
                            (*mvc.as_mut_ptr().offset(2 as ::core::ffi::c_int as isize))
                                .as_mut_ptr(),
                        );
                    }
                    if (*((*m.as_mut_ptr().offset(l as isize)).mvp.as_mut_ptr()
                        as *mut x264_union32_t))
                        .i
                        == 0
                    {
                        m[l as usize].cost = (*h).pixf.mbcmp
                            [PIXEL_8x8 as ::core::ffi::c_int as usize]
                            .expect("non-null function pointer")(
                            m[l as usize].p_fenc[0 as ::core::ffi::c_int as usize],
                            FENC_STRIDE as intptr_t,
                            m[l as usize].p_fref[0 as ::core::ffi::c_int as usize],
                            m[l as usize].i_stride[0 as ::core::ffi::c_int as usize] as intptr_t,
                        );
                        if m[l as usize].cost < 64 as ::core::ffi::c_int {
                            (*((*m.as_mut_ptr().offset(l as isize)).mv.as_mut_ptr()
                                as *mut x264_union32_t))
                                .i = 0 as uint32_t;
                            current_block_117 = 8572148166097892831;
                        } else {
                            current_block_117 = 17958840340921835115;
                        }
                    } else {
                        current_block_117 = 17958840340921835115;
                    }
                    match current_block_117 {
                        17958840340921835115 => {
                            x264_10_me_search_ref(
                                h,
                                &mut *m.as_mut_ptr().offset(l as isize),
                                mvc.as_mut_ptr() as *mut [int16_t; 2],
                                i_mvc,
                                0 as *mut ::core::ffi::c_int,
                            );
                            m[l as usize].cost -=
                                *(*a).p_cost_mv.offset(0 as ::core::ffi::c_int as isize)
                                    as ::core::ffi::c_int;
                            if (*((*m.as_mut_ptr().offset(l as isize)).mv.as_mut_ptr()
                                as *mut x264_union32_t))
                                .i
                                != 0
                            {
                                m[l as usize].cost += 5 as ::core::ffi::c_int * (*a).i_lambda;
                            }
                        }
                        _ => {}
                    }
                    (*(fenc_mvs[l as usize] as *mut x264_union32_t)).i =
                        (*((*m.as_mut_ptr().offset(l as isize)).mv.as_mut_ptr()
                            as *mut x264_union32_t))
                            .i;
                    *fenc_costs[l as usize] = m[l as usize].cost as ::core::ffi::c_int;
                } else {
                    (*((*m.as_mut_ptr().offset(l as isize)).mv.as_mut_ptr()
                        as *mut x264_union32_t))
                        .i = (*(fenc_mvs[l as usize] as *mut x264_union32_t)).i;
                    m[l as usize].cost = *fenc_costs[l as usize] as ::core::ffi::c_int;
                }
                if m[l as usize].cost < i_bcost {
                    i_bcost = m[l as usize].cost;
                    list_used = l + 1 as ::core::ffi::c_int;
                }
                l += 1;
            }
            if b_bidir != 0
                && ((*((*m.as_mut_ptr().offset(0 as ::core::ffi::c_int as isize))
                    .mv
                    .as_mut_ptr() as *mut x264_union32_t))
                    .i
                    != 0
                    || (*((*m.as_mut_ptr().offset(1 as ::core::ffi::c_int as isize))
                        .mv
                        .as_mut_ptr() as *mut x264_union32_t))
                        .i
                        != 0)
            {
                let mut i_cost_1: ::core::ffi::c_int = 0;
                if (*h).param.analyse.i_subpel_refine <= 1 as ::core::ffi::c_int {
                    let mut hpel_idx1_0: ::core::ffi::c_int = ((m[0 as ::core::ffi::c_int as usize]
                        .mv[0 as ::core::ffi::c_int as usize]
                        as ::core::ffi::c_int
                        & 2 as ::core::ffi::c_int)
                        >> 1 as ::core::ffi::c_int)
                        + (m[0 as ::core::ffi::c_int as usize].mv[1 as ::core::ffi::c_int as usize]
                            as ::core::ffi::c_int
                            & 2 as ::core::ffi::c_int);
                    let mut hpel_idx2_0: ::core::ffi::c_int = ((m[1 as ::core::ffi::c_int as usize]
                        .mv[0 as ::core::ffi::c_int as usize]
                        as ::core::ffi::c_int
                        & 2 as ::core::ffi::c_int)
                        >> 1 as ::core::ffi::c_int)
                        + (m[1 as ::core::ffi::c_int as usize].mv[1 as ::core::ffi::c_int as usize]
                            as ::core::ffi::c_int
                            & 2 as ::core::ffi::c_int);
                    let mut src1_1: *mut pixel = m[0 as ::core::ffi::c_int as usize].p_fref
                        [hpel_idx1_0 as usize]
                        .offset(
                            (m[0 as ::core::ffi::c_int as usize].mv
                                [0 as ::core::ffi::c_int as usize]
                                as ::core::ffi::c_int
                                >> 2 as ::core::ffi::c_int) as isize,
                        )
                        .offset(
                            ((m[0 as ::core::ffi::c_int as usize].mv
                                [1 as ::core::ffi::c_int as usize]
                                as ::core::ffi::c_int
                                >> 2 as ::core::ffi::c_int)
                                * m[0 as ::core::ffi::c_int as usize].i_stride
                                    [0 as ::core::ffi::c_int as usize])
                                as isize,
                        );
                    let mut src2_1: *mut pixel = m[1 as ::core::ffi::c_int as usize].p_fref
                        [hpel_idx2_0 as usize]
                        .offset(
                            (m[1 as ::core::ffi::c_int as usize].mv
                                [0 as ::core::ffi::c_int as usize]
                                as ::core::ffi::c_int
                                >> 2 as ::core::ffi::c_int) as isize,
                        )
                        .offset(
                            ((m[1 as ::core::ffi::c_int as usize].mv
                                [1 as ::core::ffi::c_int as usize]
                                as ::core::ffi::c_int
                                >> 2 as ::core::ffi::c_int)
                                * m[1 as ::core::ffi::c_int as usize].i_stride
                                    [0 as ::core::ffi::c_int as usize])
                                as isize,
                        );
                    (*h).mc.avg[PIXEL_8x8 as ::core::ffi::c_int as usize]
                        .expect("non-null function pointer")(
                        pix1.as_mut_ptr(),
                        16 as intptr_t,
                        src1_1,
                        m[0 as ::core::ffi::c_int as usize].i_stride
                            [0 as ::core::ffi::c_int as usize] as intptr_t,
                        src2_1,
                        m[1 as ::core::ffi::c_int as usize].i_stride
                            [0 as ::core::ffi::c_int as usize] as intptr_t,
                        i_bipred_weight,
                    );
                } else {
                    let mut stride1_0: intptr_t = 16 as intptr_t;
                    let mut stride2_0: intptr_t = 16 as intptr_t;
                    let mut src1_2: *mut pixel = 0 as *mut pixel;
                    let mut src2_2: *mut pixel = 0 as *mut pixel;
                    src1_2 = (*h).mc.get_ref.expect("non-null function pointer")(
                        pix1.as_mut_ptr(),
                        &mut stride1_0,
                        (*m.as_mut_ptr().offset(0 as ::core::ffi::c_int as isize))
                            .p_fref
                            .as_mut_ptr(),
                        m[0 as ::core::ffi::c_int as usize].i_stride
                            [0 as ::core::ffi::c_int as usize] as intptr_t,
                        m[0 as ::core::ffi::c_int as usize].mv[0 as ::core::ffi::c_int as usize]
                            as ::core::ffi::c_int,
                        m[0 as ::core::ffi::c_int as usize].mv[1 as ::core::ffi::c_int as usize]
                            as ::core::ffi::c_int,
                        8 as ::core::ffi::c_int,
                        8 as ::core::ffi::c_int,
                        w,
                    );
                    src2_2 = (*h).mc.get_ref.expect("non-null function pointer")(
                        pix2,
                        &mut stride2_0,
                        (*m.as_mut_ptr().offset(1 as ::core::ffi::c_int as isize))
                            .p_fref
                            .as_mut_ptr(),
                        m[1 as ::core::ffi::c_int as usize].i_stride
                            [0 as ::core::ffi::c_int as usize] as intptr_t,
                        m[1 as ::core::ffi::c_int as usize].mv[0 as ::core::ffi::c_int as usize]
                            as ::core::ffi::c_int,
                        m[1 as ::core::ffi::c_int as usize].mv[1 as ::core::ffi::c_int as usize]
                            as ::core::ffi::c_int,
                        8 as ::core::ffi::c_int,
                        8 as ::core::ffi::c_int,
                        w,
                    );
                    (*h).mc.avg[PIXEL_8x8 as ::core::ffi::c_int as usize]
                        .expect("non-null function pointer")(
                        pix1.as_mut_ptr(),
                        16 as intptr_t,
                        src1_2,
                        stride1_0,
                        src2_2,
                        stride2_0,
                        i_bipred_weight,
                    );
                }
                i_cost_1 = 5 as ::core::ffi::c_int * (*a).i_lambda
                    + (*h).pixf.mbcmp[PIXEL_8x8 as ::core::ffi::c_int as usize]
                        .expect("non-null function pointer")(
                        m[0 as ::core::ffi::c_int as usize].p_fenc
                            [0 as ::core::ffi::c_int as usize],
                        FENC_STRIDE as intptr_t,
                        pix1.as_mut_ptr(),
                        16 as intptr_t,
                    );
                if i_cost_1 < i_bcost {
                    i_bcost = i_cost_1;
                    list_used = 3 as ::core::ffi::c_int;
                }
            }
        }
        if (*fenc).b_intra_calculated == 0 {
            let mut edge: [pixel; 36] = [0; 36];
            let mut pix: *mut pixel = &mut *pix1
                .as_mut_ptr()
                .offset((8 as ::core::ffi::c_int + FDEC_STRIDE) as isize)
                as *mut pixel;
            let mut src: *mut pixel = &mut *(*(*fenc)
                .lowres
                .as_mut_ptr()
                .offset(0 as ::core::ffi::c_int as isize))
            .offset(i_pel_offset as isize) as *mut pixel;
            let intra_penalty: ::core::ffi::c_int = 5 as ::core::ffi::c_int * (*a).i_lambda;
            let mut satds: [::core::ffi::c_int; 3] = [0; 3];
            let mut pixoff: ::core::ffi::c_int = 4 as ::core::ffi::c_int / SIZEOF_PIXEL;
            memcpy(
                pix.offset(-(FDEC_STRIDE as isize)) as *mut ::core::ffi::c_void,
                src.offset(-(i_stride as isize)) as *const ::core::ffi::c_void,
                (16 as ::core::ffi::c_int * SIZEOF_PIXEL) as size_t,
            );
            let mut i: ::core::ffi::c_int = -(1 as ::core::ffi::c_int);
            while i < 8 as ::core::ffi::c_int {
                (*(&mut *pix.offset((i * 32 as ::core::ffi::c_int - pixoff) as isize)
                    as *mut pixel as *mut x264_union32_t))
                    .i = (*(&mut *src.offset((i * i_stride - pixoff) as isize)
                    as *mut pixel as *mut x264_union32_t))
                    .i;
                i += 1;
            }
            (*h).pixf
                .intra_mbcmp_x3_8x8c
                .expect("non-null function pointer")(
                (*h).mb.pic.p_fenc[0 as ::core::ffi::c_int as usize],
                pix,
                satds.as_mut_ptr(),
            );
            let mut i_icost: ::core::ffi::c_int = if satds[0 as ::core::ffi::c_int as usize]
                < (if satds[1 as ::core::ffi::c_int as usize]
                    < satds[2 as ::core::ffi::c_int as usize]
                {
                    satds[1 as ::core::ffi::c_int as usize]
                } else {
                    satds[2 as ::core::ffi::c_int as usize]
                }) {
                satds[0 as ::core::ffi::c_int as usize]
            } else if satds[1 as ::core::ffi::c_int as usize]
                < satds[2 as ::core::ffi::c_int as usize]
            {
                satds[1 as ::core::ffi::c_int as usize]
            } else {
                satds[2 as ::core::ffi::c_int as usize]
            };
            if (*h).param.analyse.i_subpel_refine > 1 as ::core::ffi::c_int {
                (*h).predict_8x8c[I_PRED_CHROMA_P as ::core::ffi::c_int as usize]
                    .expect("non-null function pointer")(pix);
                let mut satd: ::core::ffi::c_int = (*h).pixf.mbcmp
                    [PIXEL_8x8 as ::core::ffi::c_int as usize]
                    .expect("non-null function pointer")(
                    (*h).mb.pic.p_fenc[0 as ::core::ffi::c_int as usize],
                    FENC_STRIDE as intptr_t,
                    pix,
                    FDEC_STRIDE as intptr_t,
                );
                i_icost = if i_icost < satd { i_icost } else { satd };
                (*h).predict_8x8_filter.expect("non-null function pointer")(
                    pix,
                    edge.as_mut_ptr(),
                    ALL_NEIGHBORS as ::core::ffi::c_int,
                    ALL_NEIGHBORS as ::core::ffi::c_int,
                );
                let mut i_0: ::core::ffi::c_int = 3 as ::core::ffi::c_int;
                while i_0 < 9 as ::core::ffi::c_int {
                    (*h).predict_8x8[i_0 as usize].expect("non-null function pointer")(
                        pix,
                        edge.as_mut_ptr(),
                    );
                    satd = (*h).pixf.mbcmp[PIXEL_8x8 as ::core::ffi::c_int as usize]
                        .expect("non-null function pointer")(
                        (*h).mb.pic.p_fenc[0 as ::core::ffi::c_int as usize],
                        FENC_STRIDE as intptr_t,
                        pix,
                        FDEC_STRIDE as intptr_t,
                    );
                    i_icost = if i_icost < satd { i_icost } else { satd };
                    i_0 += 1;
                }
            }
            i_icost =
                (i_icost + intra_penalty >> BIT_DEPTH - 8 as ::core::ffi::c_int) + lowres_penalty;
            *(*fenc).i_intra_cost.offset(i_mb_xy as isize) = i_icost as uint16_t;
            let mut i_icost_aq: ::core::ffi::c_int = i_icost;
            if (*h).param.rc.i_aq_mode != 0 {
                i_icost_aq = i_icost_aq
                    * *(*fenc).i_inv_qscale_factor.offset(i_mb_xy as isize) as ::core::ffi::c_int
                    + 128 as ::core::ffi::c_int
                    >> 8 as ::core::ffi::c_int;
            }
            *output_intra
                .offset((NUM_INTS + ((*h).mb.i_mb_y - (*h).i_threadslice_start)) as isize) +=
                i_icost_aq;
            if b_frame_score_mb != 0 {
                *output_intra.offset(COST_EST as isize) += i_icost;
                *output_intra.offset(COST_EST_AQ as isize) += i_icost_aq;
            }
        }
        i_bcost = (i_bcost >> BIT_DEPTH - 8 as ::core::ffi::c_int) + lowres_penalty;
        if b_bidir == 0 {
            let mut i_icost_0: ::core::ffi::c_int =
                *(*fenc).i_intra_cost.offset(i_mb_xy as isize) as ::core::ffi::c_int;
            let mut b_intra: ::core::ffi::c_int = (i_icost_0 < i_bcost) as ::core::ffi::c_int;
            if b_intra != 0 {
                i_bcost = i_icost_0;
                list_used = 0 as ::core::ffi::c_int;
            }
            if b_frame_score_mb != 0 {
                *output_inter.offset(INTRA_MBS as isize) += b_intra;
            }
        }
        if p0 != p1 {
            let mut i_bcost_aq: ::core::ffi::c_int = i_bcost;
            if (*h).param.rc.i_aq_mode != 0 {
                i_bcost_aq = i_bcost_aq
                    * *(*fenc).i_inv_qscale_factor.offset(i_mb_xy as isize) as ::core::ffi::c_int
                    + 128 as ::core::ffi::c_int
                    >> 8 as ::core::ffi::c_int;
            }
            *output_inter
                .offset((NUM_INTS + ((*h).mb.i_mb_y - (*h).i_threadslice_start)) as isize) +=
                i_bcost_aq;
            if b_frame_score_mb != 0 {
                *output_inter.offset(COST_EST as isize) += i_bcost;
                *output_inter.offset(COST_EST_AQ as isize) += i_bcost_aq;
            }
        }
        *(*fenc).lowres_costs[(b - p0) as usize][(p1 - b) as usize].offset(i_mb_xy as isize) =
            ((if i_bcost
                < ((1 as ::core::ffi::c_int) << 14 as ::core::ffi::c_int) - 1 as ::core::ffi::c_int
            {
                i_bcost
            } else {
                ((1 as ::core::ffi::c_int) << 14 as ::core::ffi::c_int) - 1 as ::core::ffi::c_int
            }) + (list_used << LOWRES_COST_SHIFT)) as uint16_t;
    }
    #[c2rust::src_loc = "814:1"]
    pub unsafe extern "C" fn slicetype_slice_cost(mut s: *mut x264_slicetype_slice_t) {
        let mut h: *mut x264_t = (*s).h;
        let mut do_edges: ::core::ffi::c_int = ((*h).param.rc.b_mb_tree != 0
            || (*h).param.rc.i_vbv_buffer_size != 0
            || (*h).mb.i_mb_width <= 2 as ::core::ffi::c_int
            || (*h).mb.i_mb_height <= 2 as ::core::ffi::c_int)
            as ::core::ffi::c_int;
        let mut start_y: ::core::ffi::c_int = if ((*h).i_threadslice_end - 1 as ::core::ffi::c_int)
            < (*h).mb.i_mb_height - 2 as ::core::ffi::c_int + do_edges
        {
            (*h).i_threadslice_end - 1 as ::core::ffi::c_int
        } else {
            (*h).mb.i_mb_height - 2 as ::core::ffi::c_int + do_edges
        };
        let mut end_y: ::core::ffi::c_int =
            if (*h).i_threadslice_start > 1 as ::core::ffi::c_int - do_edges {
                (*h).i_threadslice_start
            } else {
                1 as ::core::ffi::c_int - do_edges
            };
        let mut start_x: ::core::ffi::c_int =
            (*h).mb.i_mb_width - 2 as ::core::ffi::c_int + do_edges;
        let mut end_x: ::core::ffi::c_int = 1 as ::core::ffi::c_int - do_edges;
        (*h).mb.i_mb_y = start_y;
        while (*h).mb.i_mb_y >= end_y {
            (*h).mb.i_mb_x = start_x;
            while (*h).mb.i_mb_x >= end_x {
                slicetype_mb_cost(
                    h,
                    (*s).a,
                    (*s).frames,
                    (*s).p0,
                    (*s).p1,
                    (*s).b,
                    (*s).dist_scale_factor,
                    (*s).do_search as *mut ::core::ffi::c_int,
                    (*s).w,
                    (*s).output_inter,
                    (*s).output_intra,
                );
                (*h).mb.i_mb_x -= 1;
            }
            (*h).mb.i_mb_y -= 1;
        }
    }
    #[c2rust::src_loc = "836:1"]
    pub unsafe extern "C" fn slicetype_frame_cost(
        mut h: *mut x264_t,
        mut a: *mut x264_mb_analysis_t,
        mut frames: *mut *mut x264_frame_t,
        mut p0: ::core::ffi::c_int,
        mut p1: ::core::ffi::c_int,
        mut b: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int {
        let mut i_score: ::core::ffi::c_int = 0 as ::core::ffi::c_int;
        let mut do_search: [::core::ffi::c_int; 2] = [0; 2];
        let mut w: *const x264_weight_t = x264_zero.as_mut_ptr() as *const x264_weight_t;
        let mut fenc: *mut x264_frame_t = *frames.offset(b as isize);
        if (*fenc).i_cost_est[(b - p0) as usize][(p1 - b) as usize] >= 0 as ::core::ffi::c_int
            && ((*h).param.rc.i_vbv_buffer_size == 0
                || *(*fenc).i_row_satds[(b - p0) as usize][(p1 - b) as usize]
                    .offset(0 as ::core::ffi::c_int as isize)
                    != -(1 as ::core::ffi::c_int))
        {
            i_score = (*fenc).i_cost_est[(b - p0) as usize][(p1 - b) as usize];
        } else {
            let mut dist_scale_factor: ::core::ffi::c_int = 128 as ::core::ffi::c_int;
            do_search[0 as ::core::ffi::c_int as usize] = (b != p0
                && (*(*fenc).lowres_mvs[0 as ::core::ffi::c_int as usize]
                    [(b - p0 - 1 as ::core::ffi::c_int) as usize]
                    .offset(0 as ::core::ffi::c_int as isize))
                    [0 as ::core::ffi::c_int as usize] as ::core::ffi::c_int
                    == 0x7fff as ::core::ffi::c_int)
                as ::core::ffi::c_int;
            do_search[1 as ::core::ffi::c_int as usize] = (b != p1
                && (*(*fenc).lowres_mvs[1 as ::core::ffi::c_int as usize]
                    [(p1 - b - 1 as ::core::ffi::c_int) as usize]
                    .offset(0 as ::core::ffi::c_int as isize))
                    [0 as ::core::ffi::c_int as usize] as ::core::ffi::c_int
                    == 0x7fff as ::core::ffi::c_int)
                as ::core::ffi::c_int;
            if do_search[0 as ::core::ffi::c_int as usize] != 0 {
                if (*h).param.analyse.i_weighted_pred != 0 && b == p1 {
                    x264_10_weights_analyse(
                        h,
                        fenc,
                        *frames.offset(p0 as isize),
                        1 as ::core::ffi::c_int,
                    );
                    w = (*(*fenc)
                        .weight
                        .as_mut_ptr()
                        .offset(0 as ::core::ffi::c_int as isize))
                    .as_mut_ptr();
                }
                (*(*fenc).lowres_mvs[0 as ::core::ffi::c_int as usize]
                    [(b - p0 - 1 as ::core::ffi::c_int) as usize]
                    .offset(0 as ::core::ffi::c_int as isize))
                    [0 as ::core::ffi::c_int as usize] = 0 as int16_t;
            }
            if do_search[1 as ::core::ffi::c_int as usize] != 0 {
                (*(*fenc).lowres_mvs[1 as ::core::ffi::c_int as usize]
                    [(p1 - b - 1 as ::core::ffi::c_int) as usize]
                    .offset(0 as ::core::ffi::c_int as isize))
                    [0 as ::core::ffi::c_int as usize] = 0 as int16_t;
            }
            if p1 != p0 {
                dist_scale_factor = ((b - p0 << 8 as ::core::ffi::c_int)
                    + (p1 - p0 >> 1 as ::core::ffi::c_int))
                    / (p1 - p0);
            }
            let mut output_buf_size: ::core::ffi::c_int =
                (*h).mb.i_mb_height + (NUM_INTS + PAD_SIZE) * (*h).param.i_lookahead_threads;
            let mut output_inter: [*mut ::core::ffi::c_int; 17] =
                [0 as *mut ::core::ffi::c_int; 17];
            let mut output_intra: [*mut ::core::ffi::c_int; 17] =
                [0 as *mut ::core::ffi::c_int; 17];
            output_inter[0 as ::core::ffi::c_int as usize] =
                (*h).scratch_buffer2 as *mut ::core::ffi::c_int;
            output_intra[0 as ::core::ffi::c_int as usize] =
                output_inter[0 as ::core::ffi::c_int as usize].offset(output_buf_size as isize);
            if (*h).param.i_lookahead_threads > 1 as ::core::ffi::c_int {
                let mut s: [x264_slicetype_slice_t; 16] = [x264_slicetype_slice_t {
                    h: 0 as *mut x264_t,
                    a: 0 as *mut x264_mb_analysis_t,
                    frames: 0 as *mut *mut x264_frame_t,
                    p0: 0,
                    p1: 0,
                    b: 0,
                    dist_scale_factor: 0,
                    do_search: 0 as *mut ::core::ffi::c_int,
                    w: 0 as *const x264_weight_t,
                    output_inter: 0 as *mut ::core::ffi::c_int,
                    output_intra: 0 as *mut ::core::ffi::c_int,
                }; 16];
                let mut i: ::core::ffi::c_int = 0 as ::core::ffi::c_int;
                while i < (*h).param.i_lookahead_threads {
                    let mut t: *mut x264_t = (*h).lookahead_thread[i as usize];
                    (*t).mb.i_me_method = (*h).mb.i_me_method;
                    (*t).mb.i_subpel_refine = (*h).mb.i_subpel_refine;
                    (*t).mb.b_chroma_me = (*h).mb.b_chroma_me;
                    s[i as usize] = {
                        let mut init = x264_slicetype_slice_t {
                            h: t,
                            a: a,
                            frames: frames,
                            p0: p0,
                            p1: p1,
                            b: b,
                            dist_scale_factor: dist_scale_factor,
                            do_search: do_search.as_mut_ptr(),
                            w: w,
                            output_inter: output_inter[i as usize],
                            output_intra: output_intra[i as usize],
                        };
                        init
                    };
                    (*t).i_threadslice_start = ((*h).mb.i_mb_height * i
                        + (*h).param.i_lookahead_threads / 2 as ::core::ffi::c_int)
                        / (*h).param.i_lookahead_threads;
                    (*t).i_threadslice_end = ((*h).mb.i_mb_height * (i + 1 as ::core::ffi::c_int)
                        + (*h).param.i_lookahead_threads / 2 as ::core::ffi::c_int)
                        / (*h).param.i_lookahead_threads;
                    let mut thread_height: ::core::ffi::c_int =
                        (*t).i_threadslice_end - (*t).i_threadslice_start;
                    let mut thread_output_size: ::core::ffi::c_int = thread_height + NUM_INTS;
                    memset(
                        output_inter[i as usize] as *mut ::core::ffi::c_void,
                        0 as ::core::ffi::c_int,
                        (thread_output_size as size_t)
                            .wrapping_mul(::core::mem::size_of::<::core::ffi::c_int>() as size_t),
                    );
                    memset(
                        output_intra[i as usize] as *mut ::core::ffi::c_void,
                        0 as ::core::ffi::c_int,
                        (thread_output_size as size_t)
                            .wrapping_mul(::core::mem::size_of::<::core::ffi::c_int>() as size_t),
                    );
                    let ref mut fresh18 = *output_intra[i as usize].offset(NUM_ROWS as isize);
                    *fresh18 = thread_height;
                    *output_inter[i as usize].offset(NUM_ROWS as isize) = *fresh18;
                    output_inter[(i + 1 as ::core::ffi::c_int) as usize] = output_inter[i as usize]
                        .offset(thread_output_size as isize)
                        .offset(PAD_SIZE as isize);
                    output_intra[(i + 1 as ::core::ffi::c_int) as usize] = output_intra[i as usize]
                        .offset(thread_output_size as isize)
                        .offset(PAD_SIZE as isize);
                    x264_10_threadpool_run(
                        (*h).lookaheadpool,
                        ::core::mem::transmute::<
                            *mut ::core::ffi::c_void,
                            Option<
                                unsafe extern "C" fn(
                                    *mut ::core::ffi::c_void,
                                )
                                    -> *mut ::core::ffi::c_void,
                            >,
                        >(::core::mem::transmute::<
                            Option<unsafe extern "C" fn(*mut x264_slicetype_slice_t) -> ()>,
                            *mut ::core::ffi::c_void,
                        >(Some(
                            slicetype_slice_cost
                                as unsafe extern "C" fn(*mut x264_slicetype_slice_t) -> (),
                        ))),
                        &mut *s.as_mut_ptr().offset(i as isize) as *mut x264_slicetype_slice_t
                            as *mut ::core::ffi::c_void,
                    );
                    i += 1;
                }
                let mut i_0: ::core::ffi::c_int = 0 as ::core::ffi::c_int;
                while i_0 < (*h).param.i_lookahead_threads {
                    x264_10_threadpool_wait(
                        (*h).lookaheadpool,
                        &mut *s.as_mut_ptr().offset(i_0 as isize) as *mut x264_slicetype_slice_t
                            as *mut ::core::ffi::c_void,
                    );
                    i_0 += 1;
                }
            } else {
                (*h).i_threadslice_start = 0 as ::core::ffi::c_int;
                (*h).i_threadslice_end = (*h).mb.i_mb_height;
                memset(
                    output_inter[0 as ::core::ffi::c_int as usize] as *mut ::core::ffi::c_void,
                    0 as ::core::ffi::c_int,
                    ((output_buf_size - PAD_SIZE) as size_t)
                        .wrapping_mul(::core::mem::size_of::<::core::ffi::c_int>() as size_t),
                );
                memset(
                    output_intra[0 as ::core::ffi::c_int as usize] as *mut ::core::ffi::c_void,
                    0 as ::core::ffi::c_int,
                    ((output_buf_size - PAD_SIZE) as size_t)
                        .wrapping_mul(::core::mem::size_of::<::core::ffi::c_int>() as size_t),
                );
                let ref mut fresh19 =
                    *output_intra[0 as ::core::ffi::c_int as usize].offset(NUM_ROWS as isize);
                *fresh19 = (*h).mb.i_mb_height;
                *output_inter[0 as ::core::ffi::c_int as usize].offset(NUM_ROWS as isize) =
                    *fresh19;
                let mut s_0: x264_slicetype_slice_t = {
                    let mut init = x264_slicetype_slice_t {
                        h: h,
                        a: a,
                        frames: frames,
                        p0: p0,
                        p1: p1,
                        b: b,
                        dist_scale_factor: dist_scale_factor,
                        do_search: do_search.as_mut_ptr(),
                        w: w,
                        output_inter: output_inter[0 as ::core::ffi::c_int as usize],
                        output_intra: output_intra[0 as ::core::ffi::c_int as usize],
                    };
                    init
                };
                slicetype_slice_cost(&mut s_0);
            }
            if b == p1 {
                (*fenc).i_intra_mbs[(b - p0) as usize] = 0 as ::core::ffi::c_int;
            }
            if (*fenc).b_intra_calculated == 0 {
                (*fenc).i_cost_est[0 as ::core::ffi::c_int as usize]
                    [0 as ::core::ffi::c_int as usize] = 0 as ::core::ffi::c_int;
                (*fenc).i_cost_est_aq[0 as ::core::ffi::c_int as usize]
                    [0 as ::core::ffi::c_int as usize] = 0 as ::core::ffi::c_int;
            }
            (*fenc).i_cost_est[(b - p0) as usize][(p1 - b) as usize] = 0 as ::core::ffi::c_int;
            (*fenc).i_cost_est_aq[(b - p0) as usize][(p1 - b) as usize] = 0 as ::core::ffi::c_int;
            let mut row_satd_inter: *mut ::core::ffi::c_int =
                (*fenc).i_row_satds[(b - p0) as usize][(p1 - b) as usize];
            let mut row_satd_intra: *mut ::core::ffi::c_int = (*fenc).i_row_satds
                [0 as ::core::ffi::c_int as usize][0 as ::core::ffi::c_int as usize];
            let mut i_1: ::core::ffi::c_int = 0 as ::core::ffi::c_int;
            while i_1 < (*h).param.i_lookahead_threads {
                if b == p1 {
                    (*fenc).i_intra_mbs[(b - p0) as usize] +=
                        *output_inter[i_1 as usize].offset(INTRA_MBS as isize);
                }
                if (*fenc).b_intra_calculated == 0 {
                    (*fenc).i_cost_est[0 as ::core::ffi::c_int as usize]
                        [0 as ::core::ffi::c_int as usize] +=
                        *output_intra[i_1 as usize].offset(COST_EST as isize);
                    (*fenc).i_cost_est_aq[0 as ::core::ffi::c_int as usize]
                        [0 as ::core::ffi::c_int as usize] +=
                        *output_intra[i_1 as usize].offset(COST_EST_AQ as isize);
                }
                (*fenc).i_cost_est[(b - p0) as usize][(p1 - b) as usize] +=
                    *output_inter[i_1 as usize].offset(COST_EST as isize);
                (*fenc).i_cost_est_aq[(b - p0) as usize][(p1 - b) as usize] +=
                    *output_inter[i_1 as usize].offset(COST_EST_AQ as isize);
                if (*h).param.rc.i_vbv_buffer_size != 0 {
                    let mut row_count: ::core::ffi::c_int =
                        *output_inter[i_1 as usize].offset(NUM_ROWS as isize);
                    memcpy(
                        row_satd_inter as *mut ::core::ffi::c_void,
                        output_inter[i_1 as usize].offset(NUM_INTS as isize)
                            as *const ::core::ffi::c_void,
                        (row_count as size_t)
                            .wrapping_mul(::core::mem::size_of::<::core::ffi::c_int>() as size_t),
                    );
                    if (*fenc).b_intra_calculated == 0 {
                        memcpy(
                            row_satd_intra as *mut ::core::ffi::c_void,
                            output_intra[i_1 as usize].offset(NUM_INTS as isize)
                                as *const ::core::ffi::c_void,
                            (row_count as size_t)
                                .wrapping_mul(
                                    ::core::mem::size_of::<::core::ffi::c_int>() as size_t
                                ),
                        );
                    }
                    row_satd_inter = row_satd_inter.offset(row_count as isize);
                    row_satd_intra = row_satd_intra.offset(row_count as isize);
                }
                i_1 += 1;
            }
            i_score = (*fenc).i_cost_est[(b - p0) as usize][(p1 - b) as usize];
            if b != p1 {
                i_score = (i_score as uint64_t)
                    .wrapping_mul(100 as uint64_t)
                    .wrapping_div(
                        (120 as ::core::ffi::c_int + (*h).param.i_bframe_bias) as uint64_t,
                    ) as ::core::ffi::c_int;
            } else {
                (*fenc).b_intra_calculated = 1 as ::core::ffi::c_int;
            }
            (*fenc).i_cost_est[(b - p0) as usize][(p1 - b) as usize] = i_score;
        }
        return i_score;
    }
    #[c2rust::src_loc = "999:1"]
    pub unsafe extern "C" fn slicetype_frame_cost_recalculate(
        mut h: *mut x264_t,
        mut frames: *mut *mut x264_frame_t,
        mut p0: ::core::ffi::c_int,
        mut p1: ::core::ffi::c_int,
        mut b: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int {
        let mut i_score: ::core::ffi::c_int = 0 as ::core::ffi::c_int;
        let mut row_satd: *mut ::core::ffi::c_int =
            (**frames.offset(b as isize)).i_row_satds[(b - p0) as usize][(p1 - b) as usize];
        let mut qp_offset: *mut ::core::ffi::c_float = if (**frames.offset(b as isize)).i_type
            == X264_TYPE_B
            || (**frames.offset(b as isize)).i_type == X264_TYPE_BREF
        {
            (**frames.offset(b as isize)).f_qp_offset_aq
        } else {
            (**frames.offset(b as isize)).f_qp_offset
        };
        (*h).mb.i_mb_y = (*h).mb.i_mb_height - 1 as ::core::ffi::c_int;
        while (*h).mb.i_mb_y >= 0 as ::core::ffi::c_int {
            *row_satd.offset((*h).mb.i_mb_y as isize) = 0 as ::core::ffi::c_int;
            (*h).mb.i_mb_x = (*h).mb.i_mb_width - 1 as ::core::ffi::c_int;
            while (*h).mb.i_mb_x >= 0 as ::core::ffi::c_int {
                let mut i_mb_xy: ::core::ffi::c_int =
                    (*h).mb.i_mb_x + (*h).mb.i_mb_y * (*h).mb.i_mb_stride;
                let mut i_mb_cost: ::core::ffi::c_int = *(**frames.offset(b as isize)).lowres_costs
                    [(b - p0) as usize][(p1 - b) as usize]
                    .offset(i_mb_xy as isize)
                    as ::core::ffi::c_int
                    & LOWRES_COST_MASK;
                let mut qp_adj: ::core::ffi::c_float = *qp_offset.offset(i_mb_xy as isize);
                i_mb_cost = i_mb_cost * x264_exp2fix8(qp_adj) + 128 as ::core::ffi::c_int
                    >> 8 as ::core::ffi::c_int;
                *row_satd.offset((*h).mb.i_mb_y as isize) += i_mb_cost;
                if (*h).mb.i_mb_y > 0 as ::core::ffi::c_int
                    && (*h).mb.i_mb_y < (*h).mb.i_mb_height - 1 as ::core::ffi::c_int
                    && (*h).mb.i_mb_x > 0 as ::core::ffi::c_int
                    && (*h).mb.i_mb_x < (*h).mb.i_mb_width - 1 as ::core::ffi::c_int
                    || (*h).mb.i_mb_width <= 2 as ::core::ffi::c_int
                    || (*h).mb.i_mb_height <= 2 as ::core::ffi::c_int
                {
                    i_score += i_mb_cost;
                }
                (*h).mb.i_mb_x -= 1;
            }
            (*h).mb.i_mb_y -= 1;
        }
        return i_score;
    }
    #[c2rust::src_loc = "1027:9"]
    pub const MBTREE_PRECISION: ::core::ffi::c_float = 0.5f32;
    #[c2rust::src_loc = "1029:1"]
    pub unsafe extern "C" fn macroblock_tree_finish(
        mut h: *mut x264_t,
        mut frame: *mut x264_frame_t,
        mut average_duration: ::core::ffi::c_float,
        mut ref0_distance: ::core::ffi::c_int,
    ) {
        let mut fps_factor: ::core::ffi::c_int = round(
            x264_clip3f(
                average_duration as ::core::ffi::c_double,
                (0.01f32
                    / (((*h).param.i_frame_packing == 5 as ::core::ffi::c_int)
                        as ::core::ffi::c_int
                        + 1 as ::core::ffi::c_int) as ::core::ffi::c_float)
                    as ::core::ffi::c_double,
                (1.00f32
                    / (((*h).param.i_frame_packing == 5 as ::core::ffi::c_int)
                        as ::core::ffi::c_int
                        + 1 as ::core::ffi::c_int) as ::core::ffi::c_float)
                    as ::core::ffi::c_double,
            ) / x264_clip3f(
                (*frame).f_duration as ::core::ffi::c_double,
                (0.01f32
                    / (((*h).param.i_frame_packing == 5 as ::core::ffi::c_int)
                        as ::core::ffi::c_int
                        + 1 as ::core::ffi::c_int) as ::core::ffi::c_float)
                    as ::core::ffi::c_double,
                (1.00f32
                    / (((*h).param.i_frame_packing == 5 as ::core::ffi::c_int)
                        as ::core::ffi::c_int
                        + 1 as ::core::ffi::c_int) as ::core::ffi::c_float)
                    as ::core::ffi::c_double,
            ) * 256 as ::core::ffi::c_int as ::core::ffi::c_double
                / MBTREE_PRECISION as ::core::ffi::c_double,
        ) as ::core::ffi::c_int;
        let mut weightdelta: ::core::ffi::c_float = 0.0f32;
        if ref0_distance != 0
            && (*frame).f_weighted_cost_delta[(ref0_distance - 1 as ::core::ffi::c_int) as usize]
                > 0 as ::core::ffi::c_int as ::core::ffi::c_float
        {
            weightdelta = (1.0f64
                - (*frame).f_weighted_cost_delta[(ref0_distance - 1 as ::core::ffi::c_int) as usize]
                    as ::core::ffi::c_double) as ::core::ffi::c_float;
        }
        let mut strength: ::core::ffi::c_float = 5.0f32 * (1.0f32 - (*h).param.rc.f_qcompress);
        let mut mb_index: ::core::ffi::c_int = 0 as ::core::ffi::c_int;
        while mb_index < (*h).mb.i_mb_count {
            let mut intra_cost: ::core::ffi::c_int =
                *(*frame).i_intra_cost.offset(mb_index as isize) as ::core::ffi::c_int
                    * *(*frame).i_inv_qscale_factor.offset(mb_index as isize) as ::core::ffi::c_int
                    + 128 as ::core::ffi::c_int
                    >> 8 as ::core::ffi::c_int;
            if intra_cost != 0 {
                let mut propagate_cost: ::core::ffi::c_int =
                    *(*frame).i_propagate_cost.offset(mb_index as isize) as ::core::ffi::c_int
                        * fps_factor
                        + 128 as ::core::ffi::c_int
                        >> 8 as ::core::ffi::c_int;
                let mut log2_ratio: ::core::ffi::c_float =
                    x264_log2((intra_cost + propagate_cost) as uint32_t)
                        - x264_log2(intra_cost as uint32_t)
                        + weightdelta;
                *(*frame).f_qp_offset.offset(mb_index as isize) =
                    *(*frame).f_qp_offset_aq.offset(mb_index as isize) - strength * log2_ratio;
            }
            mb_index += 1;
        }
    }
    #[c2rust::src_loc = "1051:1"]
    pub unsafe extern "C" fn macroblock_tree_propagate(
        mut h: *mut x264_t,
        mut frames: *mut *mut x264_frame_t,
        mut average_duration: ::core::ffi::c_float,
        mut p0: ::core::ffi::c_int,
        mut p1: ::core::ffi::c_int,
        mut b: ::core::ffi::c_int,
        mut referenced: ::core::ffi::c_int,
    ) {
        let mut ref_costs: [*mut uint16_t; 2] = [
            (**frames.offset(p0 as isize)).i_propagate_cost,
            (**frames.offset(p1 as isize)).i_propagate_cost,
        ];
        let mut dist_scale_factor: ::core::ffi::c_int = ((b - p0 << 8 as ::core::ffi::c_int)
            + (p1 - p0 >> 1 as ::core::ffi::c_int))
            / (p1 - p0);
        let mut i_bipred_weight: ::core::ffi::c_int = if (*h).param.analyse.b_weighted_bipred != 0 {
            64 as ::core::ffi::c_int - (dist_scale_factor >> 2 as ::core::ffi::c_int)
        } else {
            32 as ::core::ffi::c_int
        };
        let mut mvs: [*mut [int16_t; 2]; 2] = [
            if b != p0 {
                (**frames.offset(b as isize)).lowres_mvs[0 as ::core::ffi::c_int as usize]
                    [(b - p0 - 1 as ::core::ffi::c_int) as usize]
            } else {
                0 as *mut [int16_t; 2]
            },
            if b != p1 {
                (**frames.offset(b as isize)).lowres_mvs[1 as ::core::ffi::c_int as usize]
                    [(p1 - b - 1 as ::core::ffi::c_int) as usize]
            } else {
                0 as *mut [int16_t; 2]
            },
        ];
        let mut bipred_weights: [::core::ffi::c_int; 2] =
            [i_bipred_weight, 64 as ::core::ffi::c_int - i_bipred_weight];
        let mut buf: *mut int16_t = (*h).scratch_buffer as *mut int16_t;
        let mut propagate_cost: *mut uint16_t = (**frames.offset(b as isize)).i_propagate_cost;
        let mut lowres_costs: *mut uint16_t =
            (**frames.offset(b as isize)).lowres_costs[(b - p0) as usize][(p1 - b) as usize];
        let mut fps_factor: ::core::ffi::c_float = (x264_clip3f(
            (**frames.offset(b as isize)).f_duration as ::core::ffi::c_double,
            (0.01f32
                / (((*h).param.i_frame_packing == 5 as ::core::ffi::c_int) as ::core::ffi::c_int
                    + 1 as ::core::ffi::c_int) as ::core::ffi::c_float)
                as ::core::ffi::c_double,
            (1.00f32
                / (((*h).param.i_frame_packing == 5 as ::core::ffi::c_int) as ::core::ffi::c_int
                    + 1 as ::core::ffi::c_int) as ::core::ffi::c_float)
                as ::core::ffi::c_double,
        ) / (x264_clip3f(
            average_duration as ::core::ffi::c_double,
            (0.01f32
                / (((*h).param.i_frame_packing == 5 as ::core::ffi::c_int) as ::core::ffi::c_int
                    + 1 as ::core::ffi::c_int) as ::core::ffi::c_float)
                as ::core::ffi::c_double,
            (1.00f32
                / (((*h).param.i_frame_packing == 5 as ::core::ffi::c_int) as ::core::ffi::c_int
                    + 1 as ::core::ffi::c_int) as ::core::ffi::c_float)
                as ::core::ffi::c_double,
        ) * 256.0f64)
            * MBTREE_PRECISION as ::core::ffi::c_double)
            as ::core::ffi::c_float;
        if referenced == 0 {
            memset(
                (**frames.offset(b as isize)).i_propagate_cost as *mut ::core::ffi::c_void,
                0 as ::core::ffi::c_int,
                ((*h).mb.i_mb_width as size_t)
                    .wrapping_mul(::core::mem::size_of::<uint16_t>() as size_t),
            );
        }
        (*h).mb.i_mb_y = 0 as ::core::ffi::c_int;
        while (*h).mb.i_mb_y < (*h).mb.i_mb_height {
            let mut mb_index: ::core::ffi::c_int = (*h).mb.i_mb_y * (*h).mb.i_mb_stride;
            (*h).mc
                .mbtree_propagate_cost
                .expect("non-null function pointer")(
                buf,
                propagate_cost,
                (**frames.offset(b as isize))
                    .i_intra_cost
                    .offset(mb_index as isize),
                lowres_costs.offset(mb_index as isize),
                (**frames.offset(b as isize))
                    .i_inv_qscale_factor
                    .offset(mb_index as isize),
                &mut fps_factor,
                (*h).mb.i_mb_width,
            );
            if referenced != 0 {
                propagate_cost = propagate_cost.offset((*h).mb.i_mb_width as isize);
            }
            (*h).mc
                .mbtree_propagate_list
                .expect("non-null function pointer")(
                h,
                ref_costs[0 as ::core::ffi::c_int as usize],
                &mut *(*mvs.as_mut_ptr().offset(0 as ::core::ffi::c_int as isize))
                    .offset(mb_index as isize),
                buf,
                &mut *lowres_costs.offset(mb_index as isize),
                bipred_weights[0 as ::core::ffi::c_int as usize],
                (*h).mb.i_mb_y,
                (*h).mb.i_mb_width,
                0 as ::core::ffi::c_int,
            );
            if b != p1 {
                (*h).mc
                    .mbtree_propagate_list
                    .expect("non-null function pointer")(
                    h,
                    ref_costs[1 as ::core::ffi::c_int as usize],
                    &mut *(*mvs.as_mut_ptr().offset(1 as ::core::ffi::c_int as isize))
                        .offset(mb_index as isize),
                    buf,
                    &mut *lowres_costs.offset(mb_index as isize),
                    bipred_weights[1 as ::core::ffi::c_int as usize],
                    (*h).mb.i_mb_y,
                    (*h).mb.i_mb_width,
                    1 as ::core::ffi::c_int,
                );
            }
            (*h).mb.i_mb_y += 1;
        }
        if (*h).param.rc.i_vbv_buffer_size != 0 && (*h).param.rc.i_lookahead != 0 && referenced != 0
        {
            macroblock_tree_finish(
                h,
                *frames.offset(b as isize),
                average_duration,
                if b == p1 {
                    b - p0
                } else {
                    0 as ::core::ffi::c_int
                },
            );
        }
    }
    #[c2rust::src_loc = "1091:1"]
    pub unsafe extern "C" fn macroblock_tree(
        mut h: *mut x264_t,
        mut a: *mut x264_mb_analysis_t,
        mut frames: *mut *mut x264_frame_t,
        mut num_frames: ::core::ffi::c_int,
        mut b_intra: ::core::ffi::c_int,
    ) {
        let mut idx: ::core::ffi::c_int = (b_intra == 0) as ::core::ffi::c_int;
        let mut last_nonb: ::core::ffi::c_int = 0;
        let mut cur_nonb: ::core::ffi::c_int = 1 as ::core::ffi::c_int;
        let mut bframes: ::core::ffi::c_int = 0 as ::core::ffi::c_int;
        let mut total_duration: ::core::ffi::c_float = 0.0f32;
        let mut j: ::core::ffi::c_int = 0 as ::core::ffi::c_int;
        while j <= num_frames {
            total_duration += (**frames.offset(j as isize)).f_duration;
            j += 1;
        }
        let mut average_duration: ::core::ffi::c_float =
            total_duration / (num_frames + 1 as ::core::ffi::c_int) as ::core::ffi::c_float;
        let mut i: ::core::ffi::c_int = num_frames;
        if b_intra != 0 {
            slicetype_frame_cost(
                h,
                a,
                frames,
                0 as ::core::ffi::c_int,
                0 as ::core::ffi::c_int,
                0 as ::core::ffi::c_int,
            );
        }
        while i > 0 as ::core::ffi::c_int
            && ((**frames.offset(i as isize)).i_type == X264_TYPE_B
                || (**frames.offset(i as isize)).i_type == X264_TYPE_BREF)
        {
            i -= 1;
        }
        last_nonb = i;
        if (*h).param.rc.i_lookahead == 0 {
            if b_intra != 0 {
                memset(
                    (**frames.offset(0 as ::core::ffi::c_int as isize)).i_propagate_cost
                        as *mut ::core::ffi::c_void,
                    0 as ::core::ffi::c_int,
                    ((*h).mb.i_mb_count as size_t)
                        .wrapping_mul(::core::mem::size_of::<uint16_t>() as size_t),
                );
                memcpy(
                    (**frames.offset(0 as ::core::ffi::c_int as isize)).f_qp_offset
                        as *mut ::core::ffi::c_void,
                    (**frames.offset(0 as ::core::ffi::c_int as isize)).f_qp_offset_aq
                        as *const ::core::ffi::c_void,
                    ((*h).mb.i_mb_count as size_t)
                        .wrapping_mul(::core::mem::size_of::<::core::ffi::c_float>() as size_t),
                );
                return;
            }
            let mut t: *mut uint16_t = (**frames.offset(last_nonb as isize)).i_propagate_cost;
            let ref mut fresh21 = (**frames.offset(last_nonb as isize)).i_propagate_cost;
            *fresh21 = (**frames.offset(0 as ::core::ffi::c_int as isize)).i_propagate_cost;
            let ref mut fresh22 =
                (**frames.offset(0 as ::core::ffi::c_int as isize)).i_propagate_cost;
            *fresh22 = t;
            memset(
                (**frames.offset(0 as ::core::ffi::c_int as isize)).i_propagate_cost
                    as *mut ::core::ffi::c_void,
                0 as ::core::ffi::c_int,
                ((*h).mb.i_mb_count as size_t)
                    .wrapping_mul(::core::mem::size_of::<uint16_t>() as size_t),
            );
        } else {
            if last_nonb < idx {
                return;
            }
            memset(
                (**frames.offset(last_nonb as isize)).i_propagate_cost as *mut ::core::ffi::c_void,
                0 as ::core::ffi::c_int,
                ((*h).mb.i_mb_count as size_t)
                    .wrapping_mul(::core::mem::size_of::<uint16_t>() as size_t),
            );
        }
        loop {
            let fresh23 = i;
            i = i - 1;
            if !(fresh23 > idx) {
                break;
            }
            cur_nonb = i;
            while ((**frames.offset(cur_nonb as isize)).i_type == X264_TYPE_B
                || (**frames.offset(cur_nonb as isize)).i_type == X264_TYPE_BREF)
                && cur_nonb > 0 as ::core::ffi::c_int
            {
                cur_nonb -= 1;
            }
            if cur_nonb < idx {
                break;
            }
            slicetype_frame_cost(h, a, frames, cur_nonb, last_nonb, last_nonb);
            memset(
                (**frames.offset(cur_nonb as isize)).i_propagate_cost as *mut ::core::ffi::c_void,
                0 as ::core::ffi::c_int,
                ((*h).mb.i_mb_count as size_t)
                    .wrapping_mul(::core::mem::size_of::<uint16_t>() as size_t),
            );
            bframes = last_nonb - cur_nonb - 1 as ::core::ffi::c_int;
            if (*h).param.i_bframe_pyramid != 0 && bframes > 1 as ::core::ffi::c_int {
                let mut middle: ::core::ffi::c_int =
                    (bframes + 1 as ::core::ffi::c_int) / 2 as ::core::ffi::c_int + cur_nonb;
                slicetype_frame_cost(h, a, frames, cur_nonb, last_nonb, middle);
                memset(
                    (**frames.offset(middle as isize)).i_propagate_cost as *mut ::core::ffi::c_void,
                    0 as ::core::ffi::c_int,
                    ((*h).mb.i_mb_count as size_t)
                        .wrapping_mul(::core::mem::size_of::<uint16_t>() as size_t),
                );
                while i > cur_nonb {
                    let mut p0: ::core::ffi::c_int = if i > middle { middle } else { cur_nonb };
                    let mut p1: ::core::ffi::c_int = if i < middle { middle } else { last_nonb };
                    if i != middle {
                        slicetype_frame_cost(h, a, frames, p0, p1, i);
                        macroblock_tree_propagate(
                            h,
                            frames,
                            average_duration,
                            p0,
                            p1,
                            i,
                            0 as ::core::ffi::c_int,
                        );
                    }
                    i -= 1;
                }
                macroblock_tree_propagate(
                    h,
                    frames,
                    average_duration,
                    cur_nonb,
                    last_nonb,
                    middle,
                    1 as ::core::ffi::c_int,
                );
            } else {
                while i > cur_nonb {
                    slicetype_frame_cost(h, a, frames, cur_nonb, last_nonb, i);
                    macroblock_tree_propagate(
                        h,
                        frames,
                        average_duration,
                        cur_nonb,
                        last_nonb,
                        i,
                        0 as ::core::ffi::c_int,
                    );
                    i -= 1;
                }
            }
            macroblock_tree_propagate(
                h,
                frames,
                average_duration,
                cur_nonb,
                last_nonb,
                last_nonb,
                1 as ::core::ffi::c_int,
            );
            last_nonb = cur_nonb;
        }
        if (*h).param.rc.i_lookahead == 0 {
            slicetype_frame_cost(h, a, frames, 0 as ::core::ffi::c_int, last_nonb, last_nonb);
            macroblock_tree_propagate(
                h,
                frames,
                average_duration,
                0 as ::core::ffi::c_int,
                last_nonb,
                last_nonb,
                1 as ::core::ffi::c_int,
            );
            let mut t_0: *mut uint16_t = (**frames.offset(last_nonb as isize)).i_propagate_cost;
            let ref mut fresh24 = (**frames.offset(last_nonb as isize)).i_propagate_cost;
            *fresh24 = (**frames.offset(0 as ::core::ffi::c_int as isize)).i_propagate_cost;
            let ref mut fresh25 =
                (**frames.offset(0 as ::core::ffi::c_int as isize)).i_propagate_cost;
            *fresh25 = t_0;
        }
        macroblock_tree_finish(
            h,
            *frames.offset(last_nonb as isize),
            average_duration,
            last_nonb,
        );
        if (*h).param.i_bframe_pyramid != 0
            && bframes > 1 as ::core::ffi::c_int
            && (*h).param.rc.i_vbv_buffer_size == 0
        {
            macroblock_tree_finish(
                h,
                *frames.offset(
                    (last_nonb + (bframes + 1 as ::core::ffi::c_int) / 2 as ::core::ffi::c_int)
                        as isize,
                ),
                average_duration,
                0 as ::core::ffi::c_int,
            );
        }
    }
    #[c2rust::src_loc = "1186:1"]
    pub unsafe extern "C" fn vbv_frame_cost(
        mut h: *mut x264_t,
        mut a: *mut x264_mb_analysis_t,
        mut frames: *mut *mut x264_frame_t,
        mut p0: ::core::ffi::c_int,
        mut p1: ::core::ffi::c_int,
        mut b: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int {
        let mut cost: ::core::ffi::c_int = slicetype_frame_cost(h, a, frames, p0, p1, b);
        if (*h).param.rc.i_aq_mode != 0 {
            if (*h).param.rc.b_mb_tree != 0 {
                return slicetype_frame_cost_recalculate(h, frames, p0, p1, b);
            } else {
                return (**frames.offset(b as isize)).i_cost_est_aq[(b - p0) as usize]
                    [(p1 - b) as usize];
            }
        }
        return cost;
    }
    #[c2rust::src_loc = "1199:1"]
    pub unsafe extern "C" fn calculate_durations(
        mut h: *mut x264_t,
        mut cur_frame: *mut x264_frame_t,
        mut prev_frame: *mut x264_frame_t,
        mut i_cpb_delay: *mut int64_t,
        mut i_coded_fields: *mut int64_t,
    ) {
        (*cur_frame).i_cpb_delay = *i_cpb_delay;
        (*cur_frame).i_dpb_output_delay = (*cur_frame).i_field_cnt - *i_coded_fields;
        (*cur_frame).i_dpb_output_delay += ((*(*h).sps.as_mut_ptr()).vui.i_num_reorder_frames
            * 2 as ::core::ffi::c_int) as int64_t;
        if (*cur_frame).i_dpb_output_delay < 0 as int64_t {
            (*cur_frame).i_cpb_delay += (*cur_frame).i_dpb_output_delay;
            (*cur_frame).i_dpb_output_delay = 0 as int64_t;
            if !prev_frame.is_null() {
                (*prev_frame).i_cpb_duration += (*cur_frame).i_dpb_output_delay;
            }
        }
        if (*cur_frame).b_keyframe != 0 && (*h).param.b_intra_refresh == 0 {
            *i_cpb_delay = 0 as int64_t;
        }
        *i_cpb_delay += (*cur_frame).i_duration;
        *i_coded_fields += (*cur_frame).i_duration;
        (*cur_frame).i_cpb_duration = (*cur_frame).i_duration;
    }
    #[c2rust::src_loc = "1225:1"]
    pub unsafe extern "C" fn vbv_lookahead(
        mut h: *mut x264_t,
        mut a: *mut x264_mb_analysis_t,
        mut frames: *mut *mut x264_frame_t,
        mut num_frames: ::core::ffi::c_int,
        mut keyframe: ::core::ffi::c_int,
    ) {
        let mut last_nonb: ::core::ffi::c_int = 0 as ::core::ffi::c_int;
        let mut cur_nonb: ::core::ffi::c_int = 1 as ::core::ffi::c_int;
        let mut idx: ::core::ffi::c_int = 0 as ::core::ffi::c_int;
        let mut prev_frame: *mut x264_frame_t = 0 as *mut x264_frame_t;
        let mut prev_frame_idx: ::core::ffi::c_int = 0 as ::core::ffi::c_int;
        while cur_nonb < num_frames
            && ((**frames.offset(cur_nonb as isize)).i_type == X264_TYPE_B
                || (**frames.offset(cur_nonb as isize)).i_type == X264_TYPE_BREF)
        {
            cur_nonb += 1;
        }
        let mut next_nonb: ::core::ffi::c_int = if keyframe != 0 { last_nonb } else { cur_nonb };
        if (**frames.offset(cur_nonb as isize)).i_coded_fields_lookahead >= 0 as int64_t {
            (*h).i_coded_fields_lookahead =
                (**frames.offset(cur_nonb as isize)).i_coded_fields_lookahead;
            (*h).i_cpb_delay_lookahead = (**frames.offset(cur_nonb as isize)).i_cpb_delay_lookahead;
        }
        while cur_nonb < num_frames {
            if next_nonb != cur_nonb {
                let mut p0: ::core::ffi::c_int = if (**frames.offset(cur_nonb as isize)).i_type
                    == X264_TYPE_I
                    || (**frames.offset(cur_nonb as isize)).i_type == X264_TYPE_IDR
                    || (**frames.offset(cur_nonb as isize)).i_type == X264_TYPE_KEYFRAME
                {
                    cur_nonb
                } else {
                    last_nonb
                };
                (**frames.offset(next_nonb as isize)).i_planned_satd[idx as usize] =
                    vbv_frame_cost(h, a, frames, p0, cur_nonb, cur_nonb);
                (**frames.offset(next_nonb as isize)).i_planned_type[idx as usize] =
                    (**frames.offset(cur_nonb as isize)).i_type as uint8_t;
                (**frames.offset(cur_nonb as isize)).i_coded_fields_lookahead =
                    (*h).i_coded_fields_lookahead;
                (**frames.offset(cur_nonb as isize)).i_cpb_delay_lookahead =
                    (*h).i_cpb_delay_lookahead;
                calculate_durations(
                    h,
                    *frames.offset(cur_nonb as isize),
                    prev_frame,
                    &mut (*h).i_cpb_delay_lookahead,
                    &mut (*h).i_coded_fields_lookahead,
                );
                if !prev_frame.is_null() {
                    (**frames.offset(next_nonb as isize)).f_planned_cpb_duration
                        [prev_frame_idx as usize] = (*prev_frame).i_cpb_duration
                        as ::core::ffi::c_double
                        * (*(*h).sps.as_mut_ptr()).vui.i_num_units_in_tick as ::core::ffi::c_double
                        / (*(*h).sps.as_mut_ptr()).vui.i_time_scale as ::core::ffi::c_double;
                }
                (**frames.offset(next_nonb as isize)).f_planned_cpb_duration[idx as usize] =
                    (**frames.offset(cur_nonb as isize)).i_cpb_duration as ::core::ffi::c_double
                        * (*(*h).sps.as_mut_ptr()).vui.i_num_units_in_tick as ::core::ffi::c_double
                        / (*(*h).sps.as_mut_ptr()).vui.i_time_scale as ::core::ffi::c_double;
                prev_frame = *frames.offset(cur_nonb as isize);
                prev_frame_idx = idx;
                idx += 1;
            }
            let mut i: ::core::ffi::c_int = last_nonb + 1 as ::core::ffi::c_int;
            while i < cur_nonb {
                (**frames.offset(next_nonb as isize)).i_planned_satd[idx as usize] =
                    vbv_frame_cost(h, a, frames, last_nonb, cur_nonb, i);
                (**frames.offset(next_nonb as isize)).i_planned_type[idx as usize] =
                    X264_TYPE_B as uint8_t;
                (**frames.offset(i as isize)).i_coded_fields_lookahead =
                    (*h).i_coded_fields_lookahead;
                (**frames.offset(i as isize)).i_cpb_delay_lookahead = (*h).i_cpb_delay_lookahead;
                calculate_durations(
                    h,
                    *frames.offset(i as isize),
                    prev_frame,
                    &mut (*h).i_cpb_delay_lookahead,
                    &mut (*h).i_coded_fields_lookahead,
                );
                if !prev_frame.is_null() {
                    (**frames.offset(next_nonb as isize)).f_planned_cpb_duration
                        [prev_frame_idx as usize] = (*prev_frame).i_cpb_duration
                        as ::core::ffi::c_double
                        * (*(*h).sps.as_mut_ptr()).vui.i_num_units_in_tick as ::core::ffi::c_double
                        / (*(*h).sps.as_mut_ptr()).vui.i_time_scale as ::core::ffi::c_double;
                }
                (**frames.offset(next_nonb as isize)).f_planned_cpb_duration[idx as usize] =
                    (**frames.offset(i as isize)).i_cpb_duration as ::core::ffi::c_double
                        * (*(*h).sps.as_mut_ptr()).vui.i_num_units_in_tick as ::core::ffi::c_double
                        / (*(*h).sps.as_mut_ptr()).vui.i_time_scale as ::core::ffi::c_double;
                prev_frame = *frames.offset(i as isize);
                prev_frame_idx = idx;
                i += 1;
                idx += 1;
            }
            last_nonb = cur_nonb;
            cur_nonb += 1;
            while cur_nonb <= num_frames
                && ((**frames.offset(cur_nonb as isize)).i_type == X264_TYPE_B
                    || (**frames.offset(cur_nonb as isize)).i_type == X264_TYPE_BREF)
            {
                cur_nonb += 1;
            }
        }
        (**frames.offset(next_nonb as isize)).i_planned_type[idx as usize] =
            X264_TYPE_AUTO as uint8_t;
    }
    #[c2rust::src_loc = "1288:1"]
    pub unsafe extern "C" fn slicetype_path_cost(
        mut h: *mut x264_t,
        mut a: *mut x264_mb_analysis_t,
        mut frames: *mut *mut x264_frame_t,
        mut path: *mut ::core::ffi::c_char,
        mut threshold: uint64_t,
    ) -> uint64_t {
        let mut cost: uint64_t = 0 as uint64_t;
        let mut loc: ::core::ffi::c_int = 1 as ::core::ffi::c_int;
        let mut cur_nonb: ::core::ffi::c_int = 0 as ::core::ffi::c_int;
        path = path.offset(-1);
        while *path.offset(loc as isize) != 0 {
            let mut next_nonb: ::core::ffi::c_int = loc;
            while *path.offset(next_nonb as isize) as ::core::ffi::c_int == 'B' as i32 {
                next_nonb += 1;
            }
            if *path.offset(next_nonb as isize) as ::core::ffi::c_int == 'P' as i32 {
                cost = cost.wrapping_add(slicetype_frame_cost(
                    h, a, frames, cur_nonb, next_nonb, next_nonb,
                ) as uint64_t);
            } else {
                cost = cost.wrapping_add(slicetype_frame_cost(
                    h, a, frames, next_nonb, next_nonb, next_nonb,
                ) as uint64_t);
            }
            if cost > threshold {
                break;
            }
            if (*h).param.i_bframe_pyramid != 0 && next_nonb - cur_nonb > 2 as ::core::ffi::c_int {
                let mut middle: ::core::ffi::c_int =
                    cur_nonb + (next_nonb - cur_nonb) / 2 as ::core::ffi::c_int;
                cost = cost.wrapping_add(slicetype_frame_cost(
                    h, a, frames, cur_nonb, next_nonb, middle,
                ) as uint64_t);
                let mut next_b: ::core::ffi::c_int = loc;
                while next_b < middle && cost < threshold {
                    cost = cost
                        .wrapping_add(slicetype_frame_cost(h, a, frames, cur_nonb, middle, next_b)
                            as uint64_t);
                    next_b += 1;
                }
                let mut next_b_0: ::core::ffi::c_int = middle + 1 as ::core::ffi::c_int;
                while next_b_0 < next_nonb && cost < threshold {
                    cost = cost.wrapping_add(slicetype_frame_cost(
                        h, a, frames, middle, next_nonb, next_b_0,
                    ) as uint64_t);
                    next_b_0 += 1;
                }
            } else {
                let mut next_b_1: ::core::ffi::c_int = loc;
                while next_b_1 < next_nonb && cost < threshold {
                    cost = cost.wrapping_add(slicetype_frame_cost(
                        h, a, frames, cur_nonb, next_nonb, next_b_1,
                    ) as uint64_t);
                    next_b_1 += 1;
                }
            }
            loc = next_nonb + 1 as ::core::ffi::c_int;
            cur_nonb = next_nonb;
        }
        return cost;
    }
    #[c2rust::src_loc = "1333:1"]
    pub unsafe extern "C" fn slicetype_path(
        mut h: *mut x264_t,
        mut a: *mut x264_mb_analysis_t,
        mut frames: *mut *mut x264_frame_t,
        mut length: ::core::ffi::c_int,
        mut best_paths: *mut [::core::ffi::c_char; 251],
    ) {
        let mut paths: [[::core::ffi::c_char; 251]; 2] = [[0; 251]; 2];
        let mut num_paths: ::core::ffi::c_int =
            if ((*h).param.i_bframe + 1 as ::core::ffi::c_int) < length {
                (*h).param.i_bframe + 1 as ::core::ffi::c_int
            } else {
                length
            };
        let mut best_cost: uint64_t = COST_MAX64 as uint64_t;
        let mut best_possible: ::core::ffi::c_int = 0 as ::core::ffi::c_int;
        let mut idx: ::core::ffi::c_int = 0 as ::core::ffi::c_int;
        let mut path: ::core::ffi::c_int = 0 as ::core::ffi::c_int;
        while path < num_paths {
            let mut len: ::core::ffi::c_int = length - (path + 1 as ::core::ffi::c_int);
            memcpy(
                (*paths.as_mut_ptr().offset(idx as isize)).as_mut_ptr() as *mut ::core::ffi::c_void,
                (*best_paths.offset((len % (X264_BFRAME_MAX + 1 as ::core::ffi::c_int)) as isize))
                    .as_mut_ptr() as *const ::core::ffi::c_void,
                len as size_t,
            );
            memset(
                (*paths.as_mut_ptr().offset(idx as isize))
                    .as_mut_ptr()
                    .offset(len as isize) as *mut ::core::ffi::c_void,
                'B' as i32,
                path as size_t,
            );
            strcpy(
                (*paths.as_mut_ptr().offset(idx as isize))
                    .as_mut_ptr()
                    .offset(len as isize)
                    .offset(path as isize),
                b"P\0" as *const u8 as *const ::core::ffi::c_char,
            );
            let mut possible: ::core::ffi::c_int = 1 as ::core::ffi::c_int;
            let mut i: ::core::ffi::c_int = 1 as ::core::ffi::c_int;
            while i <= length {
                let mut i_type: ::core::ffi::c_int = (**frames.offset(i as isize)).i_type;
                if !(i_type == X264_TYPE_AUTO) {
                    if i_type == X264_TYPE_B || i_type == X264_TYPE_BREF {
                        possible = (possible != 0
                            && (i < len
                                || i == length
                                || paths[idx as usize][(i - 1 as ::core::ffi::c_int) as usize]
                                    as ::core::ffi::c_int
                                    == 'B' as i32))
                            as ::core::ffi::c_int;
                    } else {
                        possible = (possible != 0
                            && (i < len
                                || paths[idx as usize][(i - 1 as ::core::ffi::c_int) as usize]
                                    as ::core::ffi::c_int
                                    != 'B' as i32))
                            as ::core::ffi::c_int;
                        paths[idx as usize][(i - 1 as ::core::ffi::c_int) as usize] =
                            (if i_type == X264_TYPE_I
                                || i_type == X264_TYPE_IDR
                                || i_type == X264_TYPE_KEYFRAME
                            {
                                'I' as i32
                            } else {
                                'P' as i32
                            }) as ::core::ffi::c_char;
                    }
                }
                i += 1;
            }
            if possible != 0 || best_possible == 0 {
                if possible != 0 && best_possible == 0 {
                    best_cost = COST_MAX64 as uint64_t;
                }
                let mut cost: uint64_t = slicetype_path_cost(
                    h,
                    a,
                    frames,
                    (*paths.as_mut_ptr().offset(idx as isize)).as_mut_ptr(),
                    best_cost,
                );
                if cost < best_cost {
                    best_cost = cost;
                    best_possible = possible;
                    idx ^= 1 as ::core::ffi::c_int;
                }
            }
            path += 1;
        }
        memcpy(
            (*best_paths.offset((length % (X264_BFRAME_MAX + 1 as ::core::ffi::c_int)) as isize))
                .as_mut_ptr() as *mut ::core::ffi::c_void,
            (*paths
                .as_mut_ptr()
                .offset((idx ^ 1 as ::core::ffi::c_int) as isize))
            .as_mut_ptr() as *const ::core::ffi::c_void,
            length as size_t,
        );
    }
    #[c2rust::src_loc = "1384:1"]
    pub unsafe extern "C" fn scenecut_internal(
        mut h: *mut x264_t,
        mut a: *mut x264_mb_analysis_t,
        mut frames: *mut *mut x264_frame_t,
        mut p0: ::core::ffi::c_int,
        mut p1: ::core::ffi::c_int,
        mut real_scenecut: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int {
        let mut frame: *mut x264_frame_t = *frames.offset(p1 as isize);
        if real_scenecut != 0
            && (*h).param.i_frame_packing == 5 as ::core::ffi::c_int
            && (*frame).i_frame & 1 as ::core::ffi::c_int != 0
        {
            return 0 as ::core::ffi::c_int;
        }
        slicetype_frame_cost(h, a, frames, p0, p1, p1);
        let mut icost: ::core::ffi::c_int =
            (*frame).i_cost_est[0 as ::core::ffi::c_int as usize][0 as ::core::ffi::c_int as usize];
        let mut pcost: ::core::ffi::c_int =
            (*frame).i_cost_est[(p1 - p0) as usize][0 as ::core::ffi::c_int as usize];
        let mut f_bias: ::core::ffi::c_float = 0.;
        let mut i_gop_size: ::core::ffi::c_int =
            (*frame).i_frame - (*(*h).lookahead).i_last_keyframe;
        let mut f_thresh_max: ::core::ffi::c_float =
            ((*h).param.i_scenecut_threshold as ::core::ffi::c_double / 100.0f64)
                as ::core::ffi::c_float;
        let mut f_thresh_min: ::core::ffi::c_float =
            (f_thresh_max as ::core::ffi::c_double * 0.25f64) as ::core::ffi::c_float;
        let mut res: ::core::ffi::c_int = 0;
        if (*h).param.i_keyint_min == (*h).param.i_keyint_max {
            f_thresh_min = f_thresh_max;
        }
        if i_gop_size <= (*h).param.i_keyint_min / 4 as ::core::ffi::c_int
            || (*h).param.b_intra_refresh != 0
        {
            f_bias = f_thresh_min / 4 as ::core::ffi::c_int as ::core::ffi::c_float;
        } else if i_gop_size <= (*h).param.i_keyint_min {
            f_bias = f_thresh_min * i_gop_size as ::core::ffi::c_float
                / (*h).param.i_keyint_min as ::core::ffi::c_float;
        } else {
            f_bias = f_thresh_min
                + (f_thresh_max - f_thresh_min)
                    * (i_gop_size - (*h).param.i_keyint_min) as ::core::ffi::c_float
                    / ((*h).param.i_keyint_max - (*h).param.i_keyint_min) as ::core::ffi::c_float;
        }
        res = (pcost as ::core::ffi::c_double
            >= (1.0f64 - f_bias as ::core::ffi::c_double) * icost as ::core::ffi::c_double)
            as ::core::ffi::c_int;
        if res != 0 && real_scenecut != 0 {
            let mut imb: ::core::ffi::c_int = (*frame).i_intra_mbs[(p1 - p0) as usize];
            let mut pmb: ::core::ffi::c_int = (if (*h).mb.i_mb_width > 2 as ::core::ffi::c_int
                && (*h).mb.i_mb_height > 2 as ::core::ffi::c_int
            {
                ((*h).mb.i_mb_width - 2 as ::core::ffi::c_int)
                    * ((*h).mb.i_mb_height - 2 as ::core::ffi::c_int)
            } else {
                (*h).mb.i_mb_width * (*h).mb.i_mb_height
            }) - imb;
            x264_10_log(
                h,
                X264_LOG_DEBUG,
                b"scene cut at %d Icost:%d Pcost:%d ratio:%.4f bias:%.4f gop:%d (imb:%d pmb:%d)\n\0"
                    as *const u8 as *const ::core::ffi::c_char,
                (*frame).i_frame,
                icost,
                pcost,
                1.0f64 - pcost as ::core::ffi::c_double / icost as ::core::ffi::c_double,
                f_bias as ::core::ffi::c_double,
                i_gop_size,
                imb,
                pmb,
            );
        }
        return res;
    }
    #[c2rust::src_loc = "1430:1"]
    pub unsafe extern "C" fn scenecut(
        mut h: *mut x264_t,
        mut a: *mut x264_mb_analysis_t,
        mut frames: *mut *mut x264_frame_t,
        mut p0: ::core::ffi::c_int,
        mut p1: ::core::ffi::c_int,
        mut real_scenecut: ::core::ffi::c_int,
        mut num_frames: ::core::ffi::c_int,
        mut i_max_search: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int {
        if real_scenecut != 0 && (*h).param.i_bframe != 0 {
            let mut origmaxp1: ::core::ffi::c_int = p0 + 1 as ::core::ffi::c_int;
            if (*h).param.i_bframe_adaptive == X264_B_ADAPT_TRELLIS {
                origmaxp1 += (*h).param.i_bframe;
            } else {
                origmaxp1 += 1;
            }
            let mut maxp1: ::core::ffi::c_int = if origmaxp1 < num_frames {
                origmaxp1
            } else {
                num_frames
            };
            let mut curp1: ::core::ffi::c_int = p1;
            while curp1 <= maxp1 {
                if scenecut_internal(h, a, frames, p0, curp1, 0 as ::core::ffi::c_int) == 0 {
                    let mut i: ::core::ffi::c_int = curp1;
                    while i > p0 {
                        (**frames.offset(i as isize)).b_scenecut = 0 as ::core::ffi::c_int;
                        i -= 1;
                    }
                }
                curp1 += 1;
            }
            let mut curp0: ::core::ffi::c_int = p0;
            while curp0 <= maxp1 {
                if origmaxp1 > i_max_search
                    || curp0 < maxp1
                        && scenecut_internal(h, a, frames, curp0, maxp1, 0 as ::core::ffi::c_int)
                            != 0
                {
                    (**frames.offset(curp0 as isize)).b_scenecut = 0 as ::core::ffi::c_int;
                }
                curp0 += 1;
            }
        }
        if (**frames.offset(p1 as isize)).b_scenecut == 0 {
            return 0 as ::core::ffi::c_int;
        }
        return scenecut_internal(h, a, frames, p0, p1, real_scenecut);
    }
    #[no_mangle]
    #[c2rust::src_loc = "1473:1"]
    pub unsafe extern "C" fn x264_10_slicetype_analyse(
        mut h: *mut x264_t,
        mut intra_minigop: ::core::ffi::c_int,
    ) {
        let mut a: x264_mb_analysis_t = x264_mb_analysis_t {
            i_lambda: 0,
            i_lambda2: 0,
            i_qp: 0,
            p_cost_mv: 0 as *mut uint16_t,
            p_cost_ref: [0 as *mut uint16_t; 2],
            i_mbrd: 0,
            b_fast_intra: 0,
            b_force_intra: 0,
            b_avoid_topright: 0,
            b_try_skip: 0,
            i_satd_i16x16: 0,
            i_satd_i16x16_dir: [0; 7],
            i_predict16x16: 0,
            i_satd_i8x8: 0,
            i_cbp_i8x8_luma: 0,
            i_satd_i8x8_dir: [[0; 16]; 4],
            i_predict8x8: [0; 4],
            i_satd_i4x4: 0,
            i_predict4x4: [0; 16],
            i_satd_pcm: 0,
            i_satd_chroma: 0,
            i_satd_chroma_dir: [0; 7],
            i_predict8x8chroma: 0,
            l0: x264_mb_analysis_list_t {
                me16x16: x264_me_t {
                    i_pixel: 0,
                    p_cost_mv: 0 as *mut uint16_t,
                    i_ref_cost: 0,
                    i_ref: 0,
                    weight: 0 as *const x264_weight_t,
                    p_fref: [0 as *mut pixel; 12],
                    p_fref_w: 0 as *mut pixel,
                    p_fenc: [0 as *mut pixel; 3],
                    integral: 0 as *mut uint16_t,
                    i_stride: [0; 3],
                    mvp: [0; 2],
                    cost_mv: 0,
                    cost: 0,
                    mv: [0; 2],
                },
                bi16x16: x264_me_t {
                    i_pixel: 0,
                    p_cost_mv: 0 as *mut uint16_t,
                    i_ref_cost: 0,
                    i_ref: 0,
                    weight: 0 as *const x264_weight_t,
                    p_fref: [0 as *mut pixel; 12],
                    p_fref_w: 0 as *mut pixel,
                    p_fenc: [0 as *mut pixel; 3],
                    integral: 0 as *mut uint16_t,
                    i_stride: [0; 3],
                    mvp: [0; 2],
                    cost_mv: 0,
                    cost: 0,
                    mv: [0; 2],
                },
                me8x8: [x264_me_t {
                    i_pixel: 0,
                    p_cost_mv: 0 as *mut uint16_t,
                    i_ref_cost: 0,
                    i_ref: 0,
                    weight: 0 as *const x264_weight_t,
                    p_fref: [0 as *mut pixel; 12],
                    p_fref_w: 0 as *mut pixel,
                    p_fenc: [0 as *mut pixel; 3],
                    integral: 0 as *mut uint16_t,
                    i_stride: [0; 3],
                    mvp: [0; 2],
                    cost_mv: 0,
                    cost: 0,
                    mv: [0; 2],
                }; 4],
                me4x4: [[x264_me_t {
                    i_pixel: 0,
                    p_cost_mv: 0 as *mut uint16_t,
                    i_ref_cost: 0,
                    i_ref: 0,
                    weight: 0 as *const x264_weight_t,
                    p_fref: [0 as *mut pixel; 12],
                    p_fref_w: 0 as *mut pixel,
                    p_fenc: [0 as *mut pixel; 3],
                    integral: 0 as *mut uint16_t,
                    i_stride: [0; 3],
                    mvp: [0; 2],
                    cost_mv: 0,
                    cost: 0,
                    mv: [0; 2],
                }; 4]; 4],
                me8x4: [[x264_me_t {
                    i_pixel: 0,
                    p_cost_mv: 0 as *mut uint16_t,
                    i_ref_cost: 0,
                    i_ref: 0,
                    weight: 0 as *const x264_weight_t,
                    p_fref: [0 as *mut pixel; 12],
                    p_fref_w: 0 as *mut pixel,
                    p_fenc: [0 as *mut pixel; 3],
                    integral: 0 as *mut uint16_t,
                    i_stride: [0; 3],
                    mvp: [0; 2],
                    cost_mv: 0,
                    cost: 0,
                    mv: [0; 2],
                }; 2]; 4],
                me4x8: [[x264_me_t {
                    i_pixel: 0,
                    p_cost_mv: 0 as *mut uint16_t,
                    i_ref_cost: 0,
                    i_ref: 0,
                    weight: 0 as *const x264_weight_t,
                    p_fref: [0 as *mut pixel; 12],
                    p_fref_w: 0 as *mut pixel,
                    p_fenc: [0 as *mut pixel; 3],
                    integral: 0 as *mut uint16_t,
                    i_stride: [0; 3],
                    mvp: [0; 2],
                    cost_mv: 0,
                    cost: 0,
                    mv: [0; 2],
                }; 2]; 4],
                me16x8: [x264_me_t {
                    i_pixel: 0,
                    p_cost_mv: 0 as *mut uint16_t,
                    i_ref_cost: 0,
                    i_ref: 0,
                    weight: 0 as *const x264_weight_t,
                    p_fref: [0 as *mut pixel; 12],
                    p_fref_w: 0 as *mut pixel,
                    p_fenc: [0 as *mut pixel; 3],
                    integral: 0 as *mut uint16_t,
                    i_stride: [0; 3],
                    mvp: [0; 2],
                    cost_mv: 0,
                    cost: 0,
                    mv: [0; 2],
                }; 2],
                me8x16: [x264_me_t {
                    i_pixel: 0,
                    p_cost_mv: 0 as *mut uint16_t,
                    i_ref_cost: 0,
                    i_ref: 0,
                    weight: 0 as *const x264_weight_t,
                    p_fref: [0 as *mut pixel; 12],
                    p_fref_w: 0 as *mut pixel,
                    p_fenc: [0 as *mut pixel; 3],
                    integral: 0 as *mut uint16_t,
                    i_stride: [0; 3],
                    mvp: [0; 2],
                    cost_mv: 0,
                    cost: 0,
                    mv: [0; 2],
                }; 2],
                i_rd16x16: 0,
                i_cost8x8: 0,
                i_cost4x4: [0; 4],
                i_cost8x4: [0; 4],
                i_cost4x8: [0; 4],
                i_cost16x8: 0,
                i_cost8x16: 0,
                mvc: [[[0; 2]; 6]; 32],
            },
            l1: x264_mb_analysis_list_t {
                me16x16: x264_me_t {
                    i_pixel: 0,
                    p_cost_mv: 0 as *mut uint16_t,
                    i_ref_cost: 0,
                    i_ref: 0,
                    weight: 0 as *const x264_weight_t,
                    p_fref: [0 as *mut pixel; 12],
                    p_fref_w: 0 as *mut pixel,
                    p_fenc: [0 as *mut pixel; 3],
                    integral: 0 as *mut uint16_t,
                    i_stride: [0; 3],
                    mvp: [0; 2],
                    cost_mv: 0,
                    cost: 0,
                    mv: [0; 2],
                },
                bi16x16: x264_me_t {
                    i_pixel: 0,
                    p_cost_mv: 0 as *mut uint16_t,
                    i_ref_cost: 0,
                    i_ref: 0,
                    weight: 0 as *const x264_weight_t,
                    p_fref: [0 as *mut pixel; 12],
                    p_fref_w: 0 as *mut pixel,
                    p_fenc: [0 as *mut pixel; 3],
                    integral: 0 as *mut uint16_t,
                    i_stride: [0; 3],
                    mvp: [0; 2],
                    cost_mv: 0,
                    cost: 0,
                    mv: [0; 2],
                },
                me8x8: [x264_me_t {
                    i_pixel: 0,
                    p_cost_mv: 0 as *mut uint16_t,
                    i_ref_cost: 0,
                    i_ref: 0,
                    weight: 0 as *const x264_weight_t,
                    p_fref: [0 as *mut pixel; 12],
                    p_fref_w: 0 as *mut pixel,
                    p_fenc: [0 as *mut pixel; 3],
                    integral: 0 as *mut uint16_t,
                    i_stride: [0; 3],
                    mvp: [0; 2],
                    cost_mv: 0,
                    cost: 0,
                    mv: [0; 2],
                }; 4],
                me4x4: [[x264_me_t {
                    i_pixel: 0,
                    p_cost_mv: 0 as *mut uint16_t,
                    i_ref_cost: 0,
                    i_ref: 0,
                    weight: 0 as *const x264_weight_t,
                    p_fref: [0 as *mut pixel; 12],
                    p_fref_w: 0 as *mut pixel,
                    p_fenc: [0 as *mut pixel; 3],
                    integral: 0 as *mut uint16_t,
                    i_stride: [0; 3],
                    mvp: [0; 2],
                    cost_mv: 0,
                    cost: 0,
                    mv: [0; 2],
                }; 4]; 4],
                me8x4: [[x264_me_t {
                    i_pixel: 0,
                    p_cost_mv: 0 as *mut uint16_t,
                    i_ref_cost: 0,
                    i_ref: 0,
                    weight: 0 as *const x264_weight_t,
                    p_fref: [0 as *mut pixel; 12],
                    p_fref_w: 0 as *mut pixel,
                    p_fenc: [0 as *mut pixel; 3],
                    integral: 0 as *mut uint16_t,
                    i_stride: [0; 3],
                    mvp: [0; 2],
                    cost_mv: 0,
                    cost: 0,
                    mv: [0; 2],
                }; 2]; 4],
                me4x8: [[x264_me_t {
                    i_pixel: 0,
                    p_cost_mv: 0 as *mut uint16_t,
                    i_ref_cost: 0,
                    i_ref: 0,
                    weight: 0 as *const x264_weight_t,
                    p_fref: [0 as *mut pixel; 12],
                    p_fref_w: 0 as *mut pixel,
                    p_fenc: [0 as *mut pixel; 3],
                    integral: 0 as *mut uint16_t,
                    i_stride: [0; 3],
                    mvp: [0; 2],
                    cost_mv: 0,
                    cost: 0,
                    mv: [0; 2],
                }; 2]; 4],
                me16x8: [x264_me_t {
                    i_pixel: 0,
                    p_cost_mv: 0 as *mut uint16_t,
                    i_ref_cost: 0,
                    i_ref: 0,
                    weight: 0 as *const x264_weight_t,
                    p_fref: [0 as *mut pixel; 12],
                    p_fref_w: 0 as *mut pixel,
                    p_fenc: [0 as *mut pixel; 3],
                    integral: 0 as *mut uint16_t,
                    i_stride: [0; 3],
                    mvp: [0; 2],
                    cost_mv: 0,
                    cost: 0,
                    mv: [0; 2],
                }; 2],
                me8x16: [x264_me_t {
                    i_pixel: 0,
                    p_cost_mv: 0 as *mut uint16_t,
                    i_ref_cost: 0,
                    i_ref: 0,
                    weight: 0 as *const x264_weight_t,
                    p_fref: [0 as *mut pixel; 12],
                    p_fref_w: 0 as *mut pixel,
                    p_fenc: [0 as *mut pixel; 3],
                    integral: 0 as *mut uint16_t,
                    i_stride: [0; 3],
                    mvp: [0; 2],
                    cost_mv: 0,
                    cost: 0,
                    mv: [0; 2],
                }; 2],
                i_rd16x16: 0,
                i_cost8x8: 0,
                i_cost4x4: [0; 4],
                i_cost8x4: [0; 4],
                i_cost4x8: [0; 4],
                i_cost16x8: 0,
                i_cost8x16: 0,
                mvc: [[[0; 2]; 6]; 32],
            },
            i_cost16x16bi: 0,
            i_cost16x16direct: 0,
            i_cost8x8bi: 0,
            i_cost8x8direct: [0; 4],
            i_satd8x8: [[0; 4]; 3],
            i_cost_est16x8: [0; 2],
            i_cost_est8x16: [0; 2],
            i_cost16x8bi: 0,
            i_cost8x16bi: 0,
            i_rd16x16bi: 0,
            i_rd16x16direct: 0,
            i_rd16x8bi: 0,
            i_rd8x16bi: 0,
            i_rd8x8bi: 0,
            i_mb_partition16x8: [0; 2],
            i_mb_partition8x16: [0; 2],
            i_mb_type16x8: 0,
            i_mb_type8x16: 0,
            b_direct_available: 0,
            b_early_terminate: 0,
        };
        let mut frames: [*mut x264_frame_t; 253] = [
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
        ];
        let mut num_frames: ::core::ffi::c_int = 0;
        let mut orig_num_frames: ::core::ffi::c_int = 0;
        let mut keyint_limit: ::core::ffi::c_int = 0;
        let mut framecnt: ::core::ffi::c_int = 0;
        let mut i_max_search: ::core::ffi::c_int =
            if (*(*h).lookahead).next.i_size < 250 as ::core::ffi::c_int {
                (*(*h).lookahead).next.i_size
            } else {
                250 as ::core::ffi::c_int
            };
        let mut b_vbv_lookahead: ::core::ffi::c_int = ((*h).param.rc.i_vbv_buffer_size != 0
            && (*h).param.rc.i_lookahead != 0)
            as ::core::ffi::c_int;
        if (*h).param.b_deterministic != 0 {
            i_max_search = if i_max_search
                < (*(*h).lookahead).i_slicetype_length + 1 as ::core::ffi::c_int - intra_minigop
            {
                i_max_search
            } else {
                (*(*h).lookahead).i_slicetype_length + 1 as ::core::ffi::c_int - intra_minigop
            };
        }
        let mut keyframe: ::core::ffi::c_int = (intra_minigop != 0) as ::core::ffi::c_int;
        if (*h).frames.b_have_lowres != 0 {
        } else {
            __assert_fail(
                b"h->frames.b_have_lowres\0" as *const u8 as *const ::core::ffi::c_char,
                b"encoder/slicetype.c\0" as *const u8 as *const ::core::ffi::c_char,
                1488 as ::core::ffi::c_uint,
                ::core::mem::transmute::<[u8; 46], [::core::ffi::c_char; 46]>(
                    *b"void x264_10_slicetype_analyse(x264_t *, int)\0",
                )
                .as_ptr(),
            );
        }
        'c_125261: {
            if (*h).frames.b_have_lowres != 0 {
            } else {
                __assert_fail(
                    b"h->frames.b_have_lowres\0" as *const u8 as *const ::core::ffi::c_char,
                    b"encoder/slicetype.c\0" as *const u8 as *const ::core::ffi::c_char,
                    1488 as ::core::ffi::c_uint,
                    ::core::mem::transmute::<[u8; 46], [::core::ffi::c_char; 46]>(
                        *b"void x264_10_slicetype_analyse(x264_t *, int)\0",
                    )
                    .as_ptr(),
                );
            }
        };
        if (*(*h).lookahead).last_nonb.is_null() {
            return;
        }
        frames[0 as ::core::ffi::c_int as usize] = (*(*h).lookahead).last_nonb;
        framecnt = 0 as ::core::ffi::c_int;
        while framecnt < i_max_search {
            frames[(framecnt + 1 as ::core::ffi::c_int) as usize] =
                *(*(*h).lookahead).next.list.offset(framecnt as isize);
            framecnt += 1;
        }
        lowres_context_init(h, &mut a);
        if framecnt == 0 {
            if (*h).param.rc.b_mb_tree != 0 {
                macroblock_tree(
                    h,
                    &mut a,
                    frames.as_mut_ptr(),
                    0 as ::core::ffi::c_int,
                    keyframe,
                );
            }
            return;
        }
        keyint_limit = (*h).param.i_keyint_max
            - (*frames[0 as ::core::ffi::c_int as usize]).i_frame
            + (*(*h).lookahead).i_last_keyframe
            - 1 as ::core::ffi::c_int;
        num_frames = if (*h).param.b_intra_refresh != 0 {
            framecnt
        } else if framecnt < keyint_limit {
            framecnt
        } else {
            keyint_limit
        };
        orig_num_frames = num_frames;
        if (*h).param.analyse.b_psy != 0 && (*h).param.rc.b_mb_tree != 0 || b_vbv_lookahead != 0 {
            num_frames = framecnt;
        } else if (*h).param.b_open_gop != 0 && num_frames < framecnt {
            num_frames += 1;
        } else if num_frames == 0 as ::core::ffi::c_int {
            (*frames[1 as ::core::ffi::c_int as usize]).i_type = X264_TYPE_I;
            return;
        }
        if ((*frames[1 as ::core::ffi::c_int as usize]).i_type == X264_TYPE_AUTO
            || ((*frames[1 as ::core::ffi::c_int as usize]).i_type == X264_TYPE_I
                || (*frames[1 as ::core::ffi::c_int as usize]).i_type == X264_TYPE_IDR
                || (*frames[1 as ::core::ffi::c_int as usize]).i_type == X264_TYPE_KEYFRAME))
            && (*h).param.i_scenecut_threshold != 0
            && scenecut(
                h,
                &mut a,
                frames.as_mut_ptr(),
                0 as ::core::ffi::c_int,
                1 as ::core::ffi::c_int,
                1 as ::core::ffi::c_int,
                orig_num_frames,
                i_max_search,
            ) != 0
        {
            if (*frames[1 as ::core::ffi::c_int as usize]).i_type == X264_TYPE_AUTO {
                (*frames[1 as ::core::ffi::c_int as usize]).i_type = X264_TYPE_I;
            }
            return;
        }
        let mut j: ::core::ffi::c_int = 1 as ::core::ffi::c_int;
        while j <= num_frames {
            if (*frames[j as usize]).i_type == X264_TYPE_KEYFRAME {
                (*frames[j as usize]).i_type = if (*h).param.b_open_gop != 0 {
                    X264_TYPE_I
                } else {
                    X264_TYPE_IDR
                };
            }
            j += 1;
        }
        let mut j_0: ::core::ffi::c_int = 2 as ::core::ffi::c_int;
        while j_0 <= num_frames {
            if (*frames[j_0 as usize]).i_type == X264_TYPE_IDR
                && ((*frames[(j_0 - 1 as ::core::ffi::c_int) as usize]).i_type == X264_TYPE_AUTO
                    || ((*frames[(j_0 - 1 as ::core::ffi::c_int) as usize]).i_type == X264_TYPE_B
                        || (*frames[(j_0 - 1 as ::core::ffi::c_int) as usize]).i_type
                            == X264_TYPE_BREF))
            {
                (*frames[(j_0 - 1 as ::core::ffi::c_int) as usize]).i_type = X264_TYPE_P;
            }
            j_0 += 1;
        }
        let mut num_analysed_frames: ::core::ffi::c_int = num_frames;
        let mut reset_start: ::core::ffi::c_int = 0;
        if (*h).param.i_bframe != 0 {
            if (*h).param.i_bframe_adaptive == X264_B_ADAPT_TRELLIS {
                if num_frames > 1 as ::core::ffi::c_int {
                    let mut best_paths: [[::core::ffi::c_char; 251]; 17] = [
                        ::core::mem::transmute::<
                            [u8; 251],
                            [::core::ffi::c_char; 251],
                        >(
                            *b"\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0",
                        ),
                        ::core::mem::transmute::<
                            [u8; 251],
                            [::core::ffi::c_char; 251],
                        >(
                            *b"P\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0",
                        ),
                        [0; 251],
                        [0; 251],
                        [0; 251],
                        [0; 251],
                        [0; 251],
                        [0; 251],
                        [0; 251],
                        [0; 251],
                        [0; 251],
                        [0; 251],
                        [0; 251],
                        [0; 251],
                        [0; 251],
                        [0; 251],
                        [0; 251],
                    ];
                    let mut best_path_index: ::core::ffi::c_int =
                        num_frames % (X264_BFRAME_MAX + 1 as ::core::ffi::c_int);
                    let mut j_1: ::core::ffi::c_int = 2 as ::core::ffi::c_int;
                    while j_1 <= num_frames {
                        slicetype_path(
                            h,
                            &mut a,
                            frames.as_mut_ptr(),
                            j_1,
                            best_paths.as_mut_ptr() as *mut [::core::ffi::c_char; 251],
                        );
                        j_1 += 1;
                    }
                    let mut j_2: ::core::ffi::c_int = 1 as ::core::ffi::c_int;
                    while j_2 < num_frames {
                        if best_paths[best_path_index as usize]
                            [(j_2 - 1 as ::core::ffi::c_int) as usize]
                            as ::core::ffi::c_int
                            != 'B' as i32
                        {
                            if (*frames[j_2 as usize]).i_type == X264_TYPE_AUTO
                                || ((*frames[j_2 as usize]).i_type == X264_TYPE_B
                                    || (*frames[j_2 as usize]).i_type == X264_TYPE_BREF)
                            {
                                (*frames[j_2 as usize]).i_type = X264_TYPE_P;
                            }
                        } else if (*frames[j_2 as usize]).i_type == X264_TYPE_AUTO {
                            (*frames[j_2 as usize]).i_type = X264_TYPE_B;
                        }
                        j_2 += 1;
                    }
                }
            } else if (*h).param.i_bframe_adaptive == X264_B_ADAPT_FAST {
                let mut last_nonb: ::core::ffi::c_int = 0 as ::core::ffi::c_int;
                let mut num_bframes: ::core::ffi::c_int = (*h).param.i_bframe;
                let mut path: [::core::ffi::c_char; 251] = [0; 251];
                let mut j_3: ::core::ffi::c_int = 1 as ::core::ffi::c_int;
                while j_3 < num_frames {
                    if j_3 - 1 as ::core::ffi::c_int > 0 as ::core::ffi::c_int
                        && ((*frames[(j_3 - 1 as ::core::ffi::c_int) as usize]).i_type
                            == X264_TYPE_B
                            || (*frames[(j_3 - 1 as ::core::ffi::c_int) as usize]).i_type
                                == X264_TYPE_BREF)
                    {
                        num_bframes -= 1;
                    } else {
                        last_nonb = j_3 - 1 as ::core::ffi::c_int;
                        num_bframes = (*h).param.i_bframe;
                    }
                    if num_bframes == 0 {
                        if (*frames[j_3 as usize]).i_type == X264_TYPE_AUTO
                            || ((*frames[j_3 as usize]).i_type == X264_TYPE_B
                                || (*frames[j_3 as usize]).i_type == X264_TYPE_BREF)
                        {
                            (*frames[j_3 as usize]).i_type = X264_TYPE_P;
                        }
                    } else if !((*frames[j_3 as usize]).i_type != X264_TYPE_AUTO) {
                        if (*frames[(j_3 + 1 as ::core::ffi::c_int) as usize]).i_type == X264_TYPE_B
                            || (*frames[(j_3 + 1 as ::core::ffi::c_int) as usize]).i_type
                                == X264_TYPE_BREF
                        {
                            (*frames[j_3 as usize]).i_type = X264_TYPE_P;
                        } else {
                            let mut bframes: ::core::ffi::c_int =
                                j_3 - last_nonb - 1 as ::core::ffi::c_int;
                            memset(
                                path.as_mut_ptr() as *mut ::core::ffi::c_void,
                                'B' as i32,
                                bframes as size_t,
                            );
                            strcpy(
                                path.as_mut_ptr().offset(bframes as isize),
                                b"PP\0" as *const u8 as *const ::core::ffi::c_char,
                            );
                            let mut cost_p: uint64_t = slicetype_path_cost(
                                h,
                                &mut a,
                                frames.as_mut_ptr().offset(last_nonb as isize),
                                path.as_mut_ptr(),
                                COST_MAX64 as uint64_t,
                            );
                            strcpy(
                                path.as_mut_ptr().offset(bframes as isize),
                                b"BP\0" as *const u8 as *const ::core::ffi::c_char,
                            );
                            let mut cost_b: uint64_t = slicetype_path_cost(
                                h,
                                &mut a,
                                frames.as_mut_ptr().offset(last_nonb as isize),
                                path.as_mut_ptr(),
                                cost_p,
                            );
                            if cost_b < cost_p {
                                (*frames[j_3 as usize]).i_type = X264_TYPE_B;
                            } else {
                                (*frames[j_3 as usize]).i_type = X264_TYPE_P;
                            }
                        }
                    }
                    j_3 += 1;
                }
            } else {
                let mut num_bframes_0: ::core::ffi::c_int = (*h).param.i_bframe;
                let mut j_4: ::core::ffi::c_int = 1 as ::core::ffi::c_int;
                while j_4 < num_frames {
                    if num_bframes_0 == 0 {
                        if (*frames[j_4 as usize]).i_type == X264_TYPE_AUTO
                            || ((*frames[j_4 as usize]).i_type == X264_TYPE_B
                                || (*frames[j_4 as usize]).i_type == X264_TYPE_BREF)
                        {
                            (*frames[j_4 as usize]).i_type = X264_TYPE_P;
                        }
                    } else if (*frames[j_4 as usize]).i_type == X264_TYPE_AUTO {
                        if (*frames[(j_4 + 1 as ::core::ffi::c_int) as usize]).i_type == X264_TYPE_B
                            || (*frames[(j_4 + 1 as ::core::ffi::c_int) as usize]).i_type
                                == X264_TYPE_BREF
                        {
                            (*frames[j_4 as usize]).i_type = X264_TYPE_P;
                        } else {
                            (*frames[j_4 as usize]).i_type = X264_TYPE_B;
                        }
                    }
                    if (*frames[j_4 as usize]).i_type == X264_TYPE_B
                        || (*frames[j_4 as usize]).i_type == X264_TYPE_BREF
                    {
                        num_bframes_0 -= 1;
                    } else {
                        num_bframes_0 = (*h).param.i_bframe;
                    }
                    j_4 += 1;
                }
            }
            if (*frames[num_frames as usize]).i_type == X264_TYPE_AUTO
                || ((*frames[num_frames as usize]).i_type == X264_TYPE_B
                    || (*frames[num_frames as usize]).i_type == X264_TYPE_BREF)
            {
                (*frames[num_frames as usize]).i_type = X264_TYPE_P;
            }
            let mut num_bframes_1: ::core::ffi::c_int = 0 as ::core::ffi::c_int;
            while num_bframes_1 < num_frames
                && ((*frames[(num_bframes_1 + 1 as ::core::ffi::c_int) as usize]).i_type
                    == X264_TYPE_B
                    || (*frames[(num_bframes_1 + 1 as ::core::ffi::c_int) as usize]).i_type
                        == X264_TYPE_BREF)
            {
                num_bframes_1 += 1;
            }
            let mut j_5: ::core::ffi::c_int = 1 as ::core::ffi::c_int;
            while j_5 < num_bframes_1 + 1 as ::core::ffi::c_int {
                if (*frames[j_5 as usize]).i_forced_type == X264_TYPE_AUTO
                    && ((*frames[(j_5 + 1 as ::core::ffi::c_int) as usize]).i_forced_type
                        == X264_TYPE_AUTO
                        || ((*frames[(j_5 + 1 as ::core::ffi::c_int) as usize]).i_forced_type
                            == X264_TYPE_I
                            || (*frames[(j_5 + 1 as ::core::ffi::c_int) as usize]).i_forced_type
                                == X264_TYPE_IDR
                            || (*frames[(j_5 + 1 as ::core::ffi::c_int) as usize]).i_forced_type
                                == X264_TYPE_KEYFRAME))
                    && (*h).param.i_scenecut_threshold != 0
                    && scenecut(
                        h,
                        &mut a,
                        frames.as_mut_ptr(),
                        j_5,
                        j_5 + 1 as ::core::ffi::c_int,
                        0 as ::core::ffi::c_int,
                        orig_num_frames,
                        i_max_search,
                    ) != 0
                {
                    (*frames[j_5 as usize]).i_type = X264_TYPE_P;
                    num_analysed_frames = j_5;
                    break;
                } else {
                    j_5 += 1;
                }
            }
            reset_start = if keyframe != 0 {
                1 as ::core::ffi::c_int
            } else if (num_bframes_1 + 2 as ::core::ffi::c_int)
                < num_analysed_frames + 1 as ::core::ffi::c_int
            {
                num_bframes_1 + 2 as ::core::ffi::c_int
            } else {
                num_analysed_frames + 1 as ::core::ffi::c_int
            };
        } else {
            let mut j_6: ::core::ffi::c_int = 1 as ::core::ffi::c_int;
            while j_6 <= num_frames {
                if (*frames[j_6 as usize]).i_type == X264_TYPE_AUTO
                    || ((*frames[j_6 as usize]).i_type == X264_TYPE_B
                        || (*frames[j_6 as usize]).i_type == X264_TYPE_BREF)
                {
                    (*frames[j_6 as usize]).i_type = X264_TYPE_P;
                }
                j_6 += 1;
            }
            reset_start = (keyframe == 0) as ::core::ffi::c_int + 1 as ::core::ffi::c_int;
        }
        if (*h).param.rc.b_mb_tree != 0 {
            macroblock_tree(
                h,
                &mut a,
                frames.as_mut_ptr(),
                if num_frames < (*h).param.i_keyint_max {
                    num_frames
                } else {
                    (*h).param.i_keyint_max
                },
                keyframe,
            );
        }
        if (*h).param.b_intra_refresh == 0 {
            let mut last_keyframe: ::core::ffi::c_int = (*(*h).lookahead).i_last_keyframe;
            let mut last_possible: ::core::ffi::c_int = 0 as ::core::ffi::c_int;
            let mut j_7: ::core::ffi::c_int = 1 as ::core::ffi::c_int;
            while j_7 <= num_frames {
                let mut frm: *mut x264_frame_t = frames[j_7 as usize];
                let mut keyframe_dist: ::core::ffi::c_int = (*frm).i_frame - last_keyframe;
                if (*frm).i_forced_type == X264_TYPE_AUTO
                    || ((*frm).i_forced_type == X264_TYPE_I
                        || (*frm).i_forced_type == X264_TYPE_IDR
                        || (*frm).i_forced_type == X264_TYPE_KEYFRAME)
                {
                    if (*h).param.b_open_gop != 0
                        || !((*frames[(j_7 - 1 as ::core::ffi::c_int) as usize]).i_forced_type
                            == X264_TYPE_B
                            || (*frames[(j_7 - 1 as ::core::ffi::c_int) as usize]).i_forced_type
                                == X264_TYPE_BREF)
                    {
                        last_possible = j_7;
                    }
                }
                if keyframe_dist >= (*h).param.i_keyint_max {
                    if last_possible != 0 as ::core::ffi::c_int && last_possible != j_7 {
                        j_7 = last_possible;
                        frm = frames[j_7 as usize];
                        keyframe_dist = (*frm).i_frame - last_keyframe;
                    }
                    last_possible = 0 as ::core::ffi::c_int;
                    if (*frm).i_type != X264_TYPE_IDR {
                        (*frm).i_type = if (*h).param.b_open_gop != 0 {
                            X264_TYPE_I
                        } else {
                            X264_TYPE_IDR
                        };
                    }
                }
                if (*frm).i_type == X264_TYPE_I && keyframe_dist >= (*h).param.i_keyint_min {
                    if (*h).param.b_open_gop != 0 {
                        last_keyframe = (*frm).i_frame;
                        if (*h).param.b_bluray_compat != 0 {
                            let mut bframes_0: ::core::ffi::c_int = 0 as ::core::ffi::c_int;
                            while bframes_0 < j_7 - 1 as ::core::ffi::c_int
                                && ((*frames[(j_7 - 1 as ::core::ffi::c_int - bframes_0) as usize])
                                    .i_type
                                    == X264_TYPE_B
                                    || (*frames
                                        [(j_7 - 1 as ::core::ffi::c_int - bframes_0) as usize])
                                        .i_type
                                        == X264_TYPE_BREF)
                            {
                                bframes_0 += 1;
                            }
                            last_keyframe -= bframes_0;
                        }
                    } else if (*frm).i_forced_type != X264_TYPE_I {
                        (*frm).i_type = X264_TYPE_IDR;
                    }
                }
                if (*frm).i_type == X264_TYPE_IDR {
                    last_keyframe = (*frm).i_frame;
                    if j_7 > 1 as ::core::ffi::c_int
                        && ((*frames[(j_7 - 1 as ::core::ffi::c_int) as usize]).i_type
                            == X264_TYPE_B
                            || (*frames[(j_7 - 1 as ::core::ffi::c_int) as usize]).i_type
                                == X264_TYPE_BREF)
                    {
                        (*frames[(j_7 - 1 as ::core::ffi::c_int) as usize]).i_type = X264_TYPE_P;
                    }
                }
                j_7 += 1;
            }
        }
        if b_vbv_lookahead != 0 {
            vbv_lookahead(h, &mut a, frames.as_mut_ptr(), num_frames, keyframe);
        }
        let mut j_8: ::core::ffi::c_int = reset_start;
        while j_8 <= num_frames {
            (*frames[j_8 as usize]).i_type = (*frames[j_8 as usize]).i_forced_type;
            j_8 += 1;
        }
    }
    use super::x264_mb_analysis_list_t;
    #[no_mangle]
    #[c2rust::src_loc = "1745:1"]
    pub unsafe extern "C" fn x264_10_slicetype_decide(mut h: *mut x264_t) {
        let mut frames: [*mut x264_frame_t; 18] = [0 as *mut x264_frame_t; 18];
        let mut frm: *mut x264_frame_t = 0 as *mut x264_frame_t;
        let mut bframes: ::core::ffi::c_int = 0;
        let mut brefs: ::core::ffi::c_int = 0;
        if (*(*h).lookahead).next.i_size == 0 {
            return;
        }
        let mut lookahead_size: ::core::ffi::c_int = (*(*h).lookahead).next.i_size;
        let mut i: ::core::ffi::c_int = 0 as ::core::ffi::c_int;
        while i < (*(*h).lookahead).next.i_size {
            if (*h).param.b_vfr_input != 0 {
                let fresh5 = lookahead_size;
                lookahead_size = lookahead_size - 1;
                if fresh5 > 1 as ::core::ffi::c_int {
                    (**(*(*h).lookahead).next.list.offset(i as isize)).i_duration = 2 as int64_t
                        * ((**(*(*h).lookahead)
                            .next
                            .list
                            .offset((i + 1 as ::core::ffi::c_int) as isize))
                        .i_pts
                            - (**(*(*h).lookahead).next.list.offset(i as isize)).i_pts);
                } else {
                    (**(*(*h).lookahead).next.list.offset(i as isize)).i_duration =
                        (*h).i_prev_duration;
                }
            } else {
                (**(*(*h).lookahead).next.list.offset(i as isize)).i_duration = delta_tfi_divisor
                    [(**(*(*h).lookahead).next.list.offset(i as isize)).i_pic_struct as usize]
                    as int64_t;
            }
            (*h).i_prev_duration = (**(*(*h).lookahead).next.list.offset(i as isize)).i_duration;
            (**(*(*h).lookahead).next.list.offset(i as isize)).f_duration =
                ((**(*(*h).lookahead).next.list.offset(i as isize)).i_duration
                    as ::core::ffi::c_double
                    * (*(*h).sps.as_mut_ptr()).vui.i_num_units_in_tick as ::core::ffi::c_double
                    / (*(*h).sps.as_mut_ptr()).vui.i_time_scale as ::core::ffi::c_double)
                    as ::core::ffi::c_float;
            if (**(*(*h).lookahead).next.list.offset(i as isize)).i_frame
                > (*h).i_disp_fields_last_frame
                && lookahead_size > 0 as ::core::ffi::c_int
            {
                (**(*(*h).lookahead).next.list.offset(i as isize)).i_field_cnt = (*h).i_disp_fields;
                (*h).i_disp_fields += (**(*(*h).lookahead).next.list.offset(i as isize)).i_duration;
                (*h).i_disp_fields_last_frame =
                    (**(*(*h).lookahead).next.list.offset(i as isize)).i_frame;
            } else if lookahead_size == 0 as ::core::ffi::c_int {
                (**(*(*h).lookahead).next.list.offset(i as isize)).i_field_cnt = (*h).i_disp_fields;
                (**(*(*h).lookahead).next.list.offset(i as isize)).i_duration =
                    (*h).i_prev_duration;
            }
            i += 1;
        }
        if (*h).param.rc.b_stat_read != 0 {
            let mut i_0: ::core::ffi::c_int = 0 as ::core::ffi::c_int;
            while i_0 < (*(*h).lookahead).next.i_size {
                (**(*(*h).lookahead).next.list.offset(i_0 as isize)).i_type =
                    x264_10_ratecontrol_slice_type(
                        h,
                        (**(*(*h).lookahead).next.list.offset(i_0 as isize)).i_frame,
                    );
                i_0 += 1;
            }
        } else if (*h).param.i_bframe != 0 && (*h).param.i_bframe_adaptive != 0
            || (*h).param.i_scenecut_threshold != 0
            || (*h).param.rc.b_mb_tree != 0
            || (*h).param.rc.i_vbv_buffer_size != 0 && (*h).param.rc.i_lookahead != 0
        {
            x264_10_slicetype_analyse(h, 0 as ::core::ffi::c_int);
        }
        bframes = 0 as ::core::ffi::c_int;
        brefs = 0 as ::core::ffi::c_int;
        loop {
            frm = *(*(*h).lookahead).next.list.offset(bframes as isize);
            if (*frm).i_forced_type != X264_TYPE_AUTO
                && (*frm).i_type != (*frm).i_forced_type
                && !((*frm).i_forced_type == X264_TYPE_KEYFRAME
                    && ((*frm).i_type == X264_TYPE_I
                        || (*frm).i_type == X264_TYPE_IDR
                        || (*frm).i_type == X264_TYPE_KEYFRAME))
            {
                x264_10_log(
                    h,
                    X264_LOG_WARNING,
                    b"forced frame type (%d) at %d was changed to frame type (%d)\n\0" as *const u8
                        as *const ::core::ffi::c_char,
                    (*frm).i_forced_type,
                    (*frm).i_frame,
                    (*frm).i_type,
                );
            }
            if (*frm).i_type == X264_TYPE_BREF
                && (*h).param.i_bframe_pyramid < X264_B_PYRAMID_NORMAL
                && brefs == (*h).param.i_bframe_pyramid
            {
                (*frm).i_type = X264_TYPE_B;
                x264_10_log(
                    h,
                    X264_LOG_WARNING,
                    b"B-ref at frame %d incompatible with B-pyramid %s \n\0" as *const u8
                        as *const ::core::ffi::c_char,
                    (*frm).i_frame,
                    x264_b_pyramid_names[(*h).param.i_bframe_pyramid as usize],
                );
            } else if (*frm).i_type == X264_TYPE_BREF
                && (*h).param.i_bframe_pyramid == X264_B_PYRAMID_NORMAL
                && brefs != 0
                && (*h).param.i_frame_reference <= brefs + 3 as ::core::ffi::c_int
            {
                (*frm).i_type = X264_TYPE_B;
                x264_10_log(
                    h,
                    X264_LOG_WARNING,
                    b"B-ref at frame %d incompatible with B-pyramid %s and %d reference frames\n\0"
                        as *const u8 as *const ::core::ffi::c_char,
                    (*frm).i_frame,
                    x264_b_pyramid_names[(*h).param.i_bframe_pyramid as usize],
                    (*h).param.i_frame_reference,
                );
            }
            if (*frm).i_type == X264_TYPE_KEYFRAME {
                (*frm).i_type = if (*h).param.b_open_gop != 0 {
                    X264_TYPE_I
                } else {
                    X264_TYPE_IDR
                };
            }
            if ((*h).param.b_intra_refresh == 0 || (*frm).i_frame == 0 as ::core::ffi::c_int)
                && (*frm).i_frame - (*(*h).lookahead).i_last_keyframe >= (*h).param.i_keyint_max
            {
                if (*frm).i_type == X264_TYPE_AUTO || (*frm).i_type == X264_TYPE_I {
                    (*frm).i_type = if (*h).param.b_open_gop != 0
                        && (*(*h).lookahead).i_last_keyframe >= 0 as ::core::ffi::c_int
                    {
                        X264_TYPE_I
                    } else {
                        X264_TYPE_IDR
                    };
                }
                let mut warn: ::core::ffi::c_int =
                    ((*frm).i_type != X264_TYPE_IDR) as ::core::ffi::c_int;
                if warn != 0 && (*h).param.b_open_gop != 0 {
                    warn &= ((*frm).i_type != X264_TYPE_I) as ::core::ffi::c_int;
                }
                if warn != 0 {
                    x264_10_log(
                        h,
                        X264_LOG_WARNING,
                        b"specified frame type (%d) at %d is not compatible with keyframe interval\n\0"
                            as *const u8 as *const ::core::ffi::c_char,
                        (*frm).i_type,
                        (*frm).i_frame,
                    );
                    (*frm).i_type = if (*h).param.b_open_gop != 0
                        && (*(*h).lookahead).i_last_keyframe >= 0 as ::core::ffi::c_int
                    {
                        X264_TYPE_I
                    } else {
                        X264_TYPE_IDR
                    };
                }
            }
            if (*frm).i_type == X264_TYPE_I
                && (*frm).i_frame - (*(*h).lookahead).i_last_keyframe >= (*h).param.i_keyint_min
            {
                if (*h).param.b_open_gop != 0 {
                    (*(*h).lookahead).i_last_keyframe = (*frm).i_frame;
                    if (*h).param.b_bluray_compat != 0 {
                        (*(*h).lookahead).i_last_keyframe -= bframes;
                    }
                    (*frm).b_keyframe = 1 as ::core::ffi::c_int;
                } else {
                    (*frm).i_type = X264_TYPE_IDR;
                }
            }
            if (*frm).i_type == X264_TYPE_IDR {
                (*(*h).lookahead).i_last_keyframe = (*frm).i_frame;
                (*frm).b_keyframe = 1 as ::core::ffi::c_int;
                if bframes > 0 as ::core::ffi::c_int {
                    bframes -= 1;
                    (**(*(*h).lookahead).next.list.offset(bframes as isize)).i_type = X264_TYPE_P;
                }
            }
            if bframes == (*h).param.i_bframe
                || (*(*(*h).lookahead)
                    .next
                    .list
                    .offset((bframes + 1 as ::core::ffi::c_int) as isize))
                .is_null()
            {
                if (*frm).i_type == X264_TYPE_B || (*frm).i_type == X264_TYPE_BREF {
                    x264_10_log(
                        h,
                        X264_LOG_WARNING,
                        b"specified frame type is not compatible with max B-frames\n\0" as *const u8
                            as *const ::core::ffi::c_char,
                    );
                }
                if (*frm).i_type == X264_TYPE_AUTO
                    || ((*frm).i_type == X264_TYPE_B || (*frm).i_type == X264_TYPE_BREF)
                {
                    (*frm).i_type = X264_TYPE_P;
                }
            }
            if (*frm).i_type == X264_TYPE_BREF {
                brefs += 1;
            }
            if (*frm).i_type == X264_TYPE_AUTO {
                (*frm).i_type = X264_TYPE_B;
            } else if !((*frm).i_type == X264_TYPE_B || (*frm).i_type == X264_TYPE_BREF) {
                break;
            }
            bframes += 1;
        }
        if bframes != 0 {
            (**(*(*h).lookahead)
                .next
                .list
                .offset((bframes - 1 as ::core::ffi::c_int) as isize))
            .b_last_minigop_bframe = 1 as uint8_t;
        }
        (**(*(*h).lookahead).next.list.offset(bframes as isize)).i_bframes = bframes as uint8_t;
        if (*h).param.i_bframe_pyramid != 0 && bframes > 1 as ::core::ffi::c_int && brefs == 0 {
            (**(*(*h).lookahead).next.list.offset(
                ((bframes - 1 as ::core::ffi::c_int) / 2 as ::core::ffi::c_int) as isize,
            ))
            .i_type = X264_TYPE_BREF;
            brefs += 1;
        }
        if (*h).param.rc.i_rc_method != X264_RC_CQP {
            let mut a: x264_mb_analysis_t = x264_mb_analysis_t {
                i_lambda: 0,
                i_lambda2: 0,
                i_qp: 0,
                p_cost_mv: 0 as *mut uint16_t,
                p_cost_ref: [0 as *mut uint16_t; 2],
                i_mbrd: 0,
                b_fast_intra: 0,
                b_force_intra: 0,
                b_avoid_topright: 0,
                b_try_skip: 0,
                i_satd_i16x16: 0,
                i_satd_i16x16_dir: [0; 7],
                i_predict16x16: 0,
                i_satd_i8x8: 0,
                i_cbp_i8x8_luma: 0,
                i_satd_i8x8_dir: [[0; 16]; 4],
                i_predict8x8: [0; 4],
                i_satd_i4x4: 0,
                i_predict4x4: [0; 16],
                i_satd_pcm: 0,
                i_satd_chroma: 0,
                i_satd_chroma_dir: [0; 7],
                i_predict8x8chroma: 0,
                l0: x264_mb_analysis_list_t {
                    me16x16: x264_me_t {
                        i_pixel: 0,
                        p_cost_mv: 0 as *mut uint16_t,
                        i_ref_cost: 0,
                        i_ref: 0,
                        weight: 0 as *const x264_weight_t,
                        p_fref: [0 as *mut pixel; 12],
                        p_fref_w: 0 as *mut pixel,
                        p_fenc: [0 as *mut pixel; 3],
                        integral: 0 as *mut uint16_t,
                        i_stride: [0; 3],
                        mvp: [0; 2],
                        cost_mv: 0,
                        cost: 0,
                        mv: [0; 2],
                    },
                    bi16x16: x264_me_t {
                        i_pixel: 0,
                        p_cost_mv: 0 as *mut uint16_t,
                        i_ref_cost: 0,
                        i_ref: 0,
                        weight: 0 as *const x264_weight_t,
                        p_fref: [0 as *mut pixel; 12],
                        p_fref_w: 0 as *mut pixel,
                        p_fenc: [0 as *mut pixel; 3],
                        integral: 0 as *mut uint16_t,
                        i_stride: [0; 3],
                        mvp: [0; 2],
                        cost_mv: 0,
                        cost: 0,
                        mv: [0; 2],
                    },
                    me8x8: [x264_me_t {
                        i_pixel: 0,
                        p_cost_mv: 0 as *mut uint16_t,
                        i_ref_cost: 0,
                        i_ref: 0,
                        weight: 0 as *const x264_weight_t,
                        p_fref: [0 as *mut pixel; 12],
                        p_fref_w: 0 as *mut pixel,
                        p_fenc: [0 as *mut pixel; 3],
                        integral: 0 as *mut uint16_t,
                        i_stride: [0; 3],
                        mvp: [0; 2],
                        cost_mv: 0,
                        cost: 0,
                        mv: [0; 2],
                    }; 4],
                    me4x4: [[x264_me_t {
                        i_pixel: 0,
                        p_cost_mv: 0 as *mut uint16_t,
                        i_ref_cost: 0,
                        i_ref: 0,
                        weight: 0 as *const x264_weight_t,
                        p_fref: [0 as *mut pixel; 12],
                        p_fref_w: 0 as *mut pixel,
                        p_fenc: [0 as *mut pixel; 3],
                        integral: 0 as *mut uint16_t,
                        i_stride: [0; 3],
                        mvp: [0; 2],
                        cost_mv: 0,
                        cost: 0,
                        mv: [0; 2],
                    }; 4]; 4],
                    me8x4: [[x264_me_t {
                        i_pixel: 0,
                        p_cost_mv: 0 as *mut uint16_t,
                        i_ref_cost: 0,
                        i_ref: 0,
                        weight: 0 as *const x264_weight_t,
                        p_fref: [0 as *mut pixel; 12],
                        p_fref_w: 0 as *mut pixel,
                        p_fenc: [0 as *mut pixel; 3],
                        integral: 0 as *mut uint16_t,
                        i_stride: [0; 3],
                        mvp: [0; 2],
                        cost_mv: 0,
                        cost: 0,
                        mv: [0; 2],
                    }; 2]; 4],
                    me4x8: [[x264_me_t {
                        i_pixel: 0,
                        p_cost_mv: 0 as *mut uint16_t,
                        i_ref_cost: 0,
                        i_ref: 0,
                        weight: 0 as *const x264_weight_t,
                        p_fref: [0 as *mut pixel; 12],
                        p_fref_w: 0 as *mut pixel,
                        p_fenc: [0 as *mut pixel; 3],
                        integral: 0 as *mut uint16_t,
                        i_stride: [0; 3],
                        mvp: [0; 2],
                        cost_mv: 0,
                        cost: 0,
                        mv: [0; 2],
                    }; 2]; 4],
                    me16x8: [x264_me_t {
                        i_pixel: 0,
                        p_cost_mv: 0 as *mut uint16_t,
                        i_ref_cost: 0,
                        i_ref: 0,
                        weight: 0 as *const x264_weight_t,
                        p_fref: [0 as *mut pixel; 12],
                        p_fref_w: 0 as *mut pixel,
                        p_fenc: [0 as *mut pixel; 3],
                        integral: 0 as *mut uint16_t,
                        i_stride: [0; 3],
                        mvp: [0; 2],
                        cost_mv: 0,
                        cost: 0,
                        mv: [0; 2],
                    }; 2],
                    me8x16: [x264_me_t {
                        i_pixel: 0,
                        p_cost_mv: 0 as *mut uint16_t,
                        i_ref_cost: 0,
                        i_ref: 0,
                        weight: 0 as *const x264_weight_t,
                        p_fref: [0 as *mut pixel; 12],
                        p_fref_w: 0 as *mut pixel,
                        p_fenc: [0 as *mut pixel; 3],
                        integral: 0 as *mut uint16_t,
                        i_stride: [0; 3],
                        mvp: [0; 2],
                        cost_mv: 0,
                        cost: 0,
                        mv: [0; 2],
                    }; 2],
                    i_rd16x16: 0,
                    i_cost8x8: 0,
                    i_cost4x4: [0; 4],
                    i_cost8x4: [0; 4],
                    i_cost4x8: [0; 4],
                    i_cost16x8: 0,
                    i_cost8x16: 0,
                    mvc: [[[0; 2]; 6]; 32],
                },
                l1: x264_mb_analysis_list_t {
                    me16x16: x264_me_t {
                        i_pixel: 0,
                        p_cost_mv: 0 as *mut uint16_t,
                        i_ref_cost: 0,
                        i_ref: 0,
                        weight: 0 as *const x264_weight_t,
                        p_fref: [0 as *mut pixel; 12],
                        p_fref_w: 0 as *mut pixel,
                        p_fenc: [0 as *mut pixel; 3],
                        integral: 0 as *mut uint16_t,
                        i_stride: [0; 3],
                        mvp: [0; 2],
                        cost_mv: 0,
                        cost: 0,
                        mv: [0; 2],
                    },
                    bi16x16: x264_me_t {
                        i_pixel: 0,
                        p_cost_mv: 0 as *mut uint16_t,
                        i_ref_cost: 0,
                        i_ref: 0,
                        weight: 0 as *const x264_weight_t,
                        p_fref: [0 as *mut pixel; 12],
                        p_fref_w: 0 as *mut pixel,
                        p_fenc: [0 as *mut pixel; 3],
                        integral: 0 as *mut uint16_t,
                        i_stride: [0; 3],
                        mvp: [0; 2],
                        cost_mv: 0,
                        cost: 0,
                        mv: [0; 2],
                    },
                    me8x8: [x264_me_t {
                        i_pixel: 0,
                        p_cost_mv: 0 as *mut uint16_t,
                        i_ref_cost: 0,
                        i_ref: 0,
                        weight: 0 as *const x264_weight_t,
                        p_fref: [0 as *mut pixel; 12],
                        p_fref_w: 0 as *mut pixel,
                        p_fenc: [0 as *mut pixel; 3],
                        integral: 0 as *mut uint16_t,
                        i_stride: [0; 3],
                        mvp: [0; 2],
                        cost_mv: 0,
                        cost: 0,
                        mv: [0; 2],
                    }; 4],
                    me4x4: [[x264_me_t {
                        i_pixel: 0,
                        p_cost_mv: 0 as *mut uint16_t,
                        i_ref_cost: 0,
                        i_ref: 0,
                        weight: 0 as *const x264_weight_t,
                        p_fref: [0 as *mut pixel; 12],
                        p_fref_w: 0 as *mut pixel,
                        p_fenc: [0 as *mut pixel; 3],
                        integral: 0 as *mut uint16_t,
                        i_stride: [0; 3],
                        mvp: [0; 2],
                        cost_mv: 0,
                        cost: 0,
                        mv: [0; 2],
                    }; 4]; 4],
                    me8x4: [[x264_me_t {
                        i_pixel: 0,
                        p_cost_mv: 0 as *mut uint16_t,
                        i_ref_cost: 0,
                        i_ref: 0,
                        weight: 0 as *const x264_weight_t,
                        p_fref: [0 as *mut pixel; 12],
                        p_fref_w: 0 as *mut pixel,
                        p_fenc: [0 as *mut pixel; 3],
                        integral: 0 as *mut uint16_t,
                        i_stride: [0; 3],
                        mvp: [0; 2],
                        cost_mv: 0,
                        cost: 0,
                        mv: [0; 2],
                    }; 2]; 4],
                    me4x8: [[x264_me_t {
                        i_pixel: 0,
                        p_cost_mv: 0 as *mut uint16_t,
                        i_ref_cost: 0,
                        i_ref: 0,
                        weight: 0 as *const x264_weight_t,
                        p_fref: [0 as *mut pixel; 12],
                        p_fref_w: 0 as *mut pixel,
                        p_fenc: [0 as *mut pixel; 3],
                        integral: 0 as *mut uint16_t,
                        i_stride: [0; 3],
                        mvp: [0; 2],
                        cost_mv: 0,
                        cost: 0,
                        mv: [0; 2],
                    }; 2]; 4],
                    me16x8: [x264_me_t {
                        i_pixel: 0,
                        p_cost_mv: 0 as *mut uint16_t,
                        i_ref_cost: 0,
                        i_ref: 0,
                        weight: 0 as *const x264_weight_t,
                        p_fref: [0 as *mut pixel; 12],
                        p_fref_w: 0 as *mut pixel,
                        p_fenc: [0 as *mut pixel; 3],
                        integral: 0 as *mut uint16_t,
                        i_stride: [0; 3],
                        mvp: [0; 2],
                        cost_mv: 0,
                        cost: 0,
                        mv: [0; 2],
                    }; 2],
                    me8x16: [x264_me_t {
                        i_pixel: 0,
                        p_cost_mv: 0 as *mut uint16_t,
                        i_ref_cost: 0,
                        i_ref: 0,
                        weight: 0 as *const x264_weight_t,
                        p_fref: [0 as *mut pixel; 12],
                        p_fref_w: 0 as *mut pixel,
                        p_fenc: [0 as *mut pixel; 3],
                        integral: 0 as *mut uint16_t,
                        i_stride: [0; 3],
                        mvp: [0; 2],
                        cost_mv: 0,
                        cost: 0,
                        mv: [0; 2],
                    }; 2],
                    i_rd16x16: 0,
                    i_cost8x8: 0,
                    i_cost4x4: [0; 4],
                    i_cost8x4: [0; 4],
                    i_cost4x8: [0; 4],
                    i_cost16x8: 0,
                    i_cost8x16: 0,
                    mvc: [[[0; 2]; 6]; 32],
                },
                i_cost16x16bi: 0,
                i_cost16x16direct: 0,
                i_cost8x8bi: 0,
                i_cost8x8direct: [0; 4],
                i_satd8x8: [[0; 4]; 3],
                i_cost_est16x8: [0; 2],
                i_cost_est8x16: [0; 2],
                i_cost16x8bi: 0,
                i_cost8x16bi: 0,
                i_rd16x16bi: 0,
                i_rd16x16direct: 0,
                i_rd16x8bi: 0,
                i_rd8x16bi: 0,
                i_rd8x8bi: 0,
                i_mb_partition16x8: [0; 2],
                i_mb_partition8x16: [0; 2],
                i_mb_type16x8: 0,
                i_mb_type8x16: 0,
                b_direct_available: 0,
                b_early_terminate: 0,
            };
            let mut p0: ::core::ffi::c_int = 0;
            let mut p1: ::core::ffi::c_int = 0;
            let mut b: ::core::ffi::c_int = 0;
            b = bframes + 1 as ::core::ffi::c_int;
            p1 = b;
            lowres_context_init(h, &mut a);
            frames[0 as ::core::ffi::c_int as usize] = (*(*h).lookahead).last_nonb;
            memcpy(
                &mut *frames.as_mut_ptr().offset(1 as ::core::ffi::c_int as isize)
                    as *mut *mut x264_frame_t as *mut ::core::ffi::c_void,
                (*(*h).lookahead).next.list as *const ::core::ffi::c_void,
                ((bframes + 1 as ::core::ffi::c_int) as size_t)
                    .wrapping_mul(::core::mem::size_of::<*mut x264_frame_t>() as size_t),
            );
            if (**(*(*h).lookahead).next.list.offset(bframes as isize)).i_type == X264_TYPE_I
                || (**(*(*h).lookahead).next.list.offset(bframes as isize)).i_type == X264_TYPE_IDR
                || (**(*(*h).lookahead).next.list.offset(bframes as isize)).i_type
                    == X264_TYPE_KEYFRAME
            {
                p0 = bframes + 1 as ::core::ffi::c_int;
            } else {
                p0 = 0 as ::core::ffi::c_int;
            }
            slicetype_frame_cost(h, &mut a, frames.as_mut_ptr(), p0, p1, b);
            if (p0 != p1 || bframes != 0) && (*h).param.rc.i_vbv_buffer_size != 0 {
                slicetype_frame_cost(h, &mut a, frames.as_mut_ptr(), b, b, b);
                p0 = 0 as ::core::ffi::c_int;
                b = 1 as ::core::ffi::c_int;
                while b <= bframes {
                    if (*frames[b as usize]).i_type == X264_TYPE_B {
                        p1 = b;
                        while (*frames[p1 as usize]).i_type == X264_TYPE_B {
                            p1 += 1;
                        }
                    } else {
                        p1 = bframes + 1 as ::core::ffi::c_int;
                    }
                    slicetype_frame_cost(h, &mut a, frames.as_mut_ptr(), p0, p1, b);
                    if (*frames[b as usize]).i_type == X264_TYPE_BREF {
                        p0 = b;
                    }
                    b += 1;
                }
            }
        }
        if (*h).param.rc.b_stat_read == 0
            && (**(*(*h).lookahead).next.list.offset(bframes as isize)).i_type == X264_TYPE_P
            && (*h).param.analyse.i_weighted_pred >= X264_WEIGHTP_SIMPLE
        {
            x264_10_weights_analyse(
                h,
                *(*(*h).lookahead).next.list.offset(bframes as isize),
                (*(*h).lookahead).last_nonb,
                0 as ::core::ffi::c_int,
            );
        }
        let mut i_coded: ::core::ffi::c_int = (**(*(*h).lookahead)
            .next
            .list
            .offset(0 as ::core::ffi::c_int as isize))
        .i_frame;
        if bframes != 0 {
            let mut idx_list: [::core::ffi::c_int; 2] =
                [brefs + 1 as ::core::ffi::c_int, 1 as ::core::ffi::c_int];
            let mut i_1: ::core::ffi::c_int = 0 as ::core::ffi::c_int;
            while i_1 < bframes {
                let fresh6 = idx_list[((**(*(*h).lookahead).next.list.offset(i_1 as isize)).i_type
                    == X264_TYPE_BREF) as ::core::ffi::c_int
                    as usize];
                idx_list[((**(*(*h).lookahead).next.list.offset(i_1 as isize)).i_type
                    == X264_TYPE_BREF) as ::core::ffi::c_int as usize] =
                    idx_list[((**(*(*h).lookahead).next.list.offset(i_1 as isize)).i_type
                        == X264_TYPE_BREF) as ::core::ffi::c_int
                        as usize]
                        + 1;
                let mut idx: ::core::ffi::c_int = fresh6;
                frames[idx as usize] = *(*(*h).lookahead).next.list.offset(i_1 as isize);
                (*frames[idx as usize]).i_reordered_pts =
                    (**(*(*h).lookahead).next.list.offset(idx as isize)).i_pts;
                i_1 += 1;
            }
            frames[0 as ::core::ffi::c_int as usize] =
                *(*(*h).lookahead).next.list.offset(bframes as isize);
            (*frames[0 as ::core::ffi::c_int as usize]).i_reordered_pts = (**(*(*h).lookahead)
                .next
                .list
                .offset(0 as ::core::ffi::c_int as isize))
            .i_pts;
            memcpy(
                (*(*h).lookahead).next.list as *mut ::core::ffi::c_void,
                frames.as_mut_ptr() as *const ::core::ffi::c_void,
                ((bframes + 1 as ::core::ffi::c_int) as size_t)
                    .wrapping_mul(::core::mem::size_of::<*mut x264_frame_t>() as size_t),
            );
        }
        let mut i_2: ::core::ffi::c_int = 0 as ::core::ffi::c_int;
        while i_2 <= bframes {
            let fresh7 = i_coded;
            i_coded = i_coded + 1;
            (**(*(*h).lookahead).next.list.offset(i_2 as isize)).i_coded = fresh7;
            if i_2 != 0 {
                calculate_durations(
                    h,
                    *(*(*h).lookahead).next.list.offset(i_2 as isize),
                    *(*(*h).lookahead)
                        .next
                        .list
                        .offset((i_2 - 1 as ::core::ffi::c_int) as isize),
                    &mut (*h).i_cpb_delay,
                    &mut (*h).i_coded_fields,
                );
                (**(*(*h).lookahead)
                    .next
                    .list
                    .offset(0 as ::core::ffi::c_int as isize))
                .f_planned_cpb_duration[(i_2 - 1 as ::core::ffi::c_int) as usize] =
                    (**(*(*h).lookahead).next.list.offset(i_2 as isize)).i_cpb_duration
                        as ::core::ffi::c_double
                        * (*(*h).sps.as_mut_ptr()).vui.i_num_units_in_tick as ::core::ffi::c_double
                        / (*(*h).sps.as_mut_ptr()).vui.i_time_scale as ::core::ffi::c_double;
            } else {
                calculate_durations(
                    h,
                    *(*(*h).lookahead).next.list.offset(i_2 as isize),
                    0 as *mut x264_frame_t,
                    &mut (*h).i_cpb_delay,
                    &mut (*h).i_coded_fields,
                );
            }
            i_2 += 1;
        }
    }
    #[no_mangle]
    #[c2rust::src_loc = "1976:1"]
    pub unsafe extern "C" fn x264_10_rc_analyse_slice(mut h: *mut x264_t) -> ::core::ffi::c_int {
        let mut p0: ::core::ffi::c_int = 0 as ::core::ffi::c_int;
        let mut p1: ::core::ffi::c_int = 0;
        let mut b: ::core::ffi::c_int = 0;
        let mut cost: ::core::ffi::c_int = 0;
        if (*(*h).fenc).i_type == X264_TYPE_I
            || (*(*h).fenc).i_type == X264_TYPE_IDR
            || (*(*h).fenc).i_type == X264_TYPE_KEYFRAME
        {
            b = 0 as ::core::ffi::c_int;
            p1 = b;
        } else if (*(*h).fenc).i_type == X264_TYPE_P {
            b = (*(*h).fenc).i_bframes as ::core::ffi::c_int + 1 as ::core::ffi::c_int;
            p1 = b;
        } else {
            p1 = ((*(*h).fref_nearest[1 as ::core::ffi::c_int as usize]).i_poc
                - (*(*h).fref_nearest[0 as ::core::ffi::c_int as usize]).i_poc)
                / 2 as ::core::ffi::c_int;
            b = ((*(*h).fenc).i_poc - (*(*h).fref_nearest[0 as ::core::ffi::c_int as usize]).i_poc)
                / 2 as ::core::ffi::c_int;
        }
        let mut frames: *mut *mut x264_frame_t =
            (&mut (*h).fenc as *mut *mut x264_frame_t).offset(-(b as isize));
        cost = (**frames.offset(b as isize)).i_cost_est[(b - p0) as usize][(p1 - b) as usize];
        if cost >= 0 as ::core::ffi::c_int {
        } else {
            __assert_fail(
                b"cost >= 0\0" as *const u8 as *const ::core::ffi::c_char,
                b"encoder/slicetype.c\0" as *const u8 as *const ::core::ffi::c_char,
                1996 as ::core::ffi::c_uint,
                ::core::mem::transmute::<[u8; 39], [::core::ffi::c_char; 39]>(
                    *b"int x264_10_rc_analyse_slice(x264_t *)\0",
                )
                .as_ptr(),
            );
        }
        'c_55672: {
            if cost >= 0 as ::core::ffi::c_int {
            } else {
                __assert_fail(
                    b"cost >= 0\0" as *const u8 as *const ::core::ffi::c_char,
                    b"encoder/slicetype.c\0" as *const u8 as *const ::core::ffi::c_char,
                    1996 as ::core::ffi::c_uint,
                    ::core::mem::transmute::<[u8; 39], [::core::ffi::c_char; 39]>(
                        *b"int x264_10_rc_analyse_slice(x264_t *)\0",
                    )
                    .as_ptr(),
                );
            }
        };
        if (*h).param.rc.b_mb_tree != 0 && (*h).param.rc.b_stat_read == 0 {
            cost = slicetype_frame_cost_recalculate(h, frames, p0, p1, b);
            if b != 0 && (*h).param.rc.i_vbv_buffer_size != 0 {
                slicetype_frame_cost_recalculate(h, frames, b, b, b);
            }
        } else if (*h).param.rc.i_aq_mode != 0 {
            cost =
                (**frames.offset(b as isize)).i_cost_est_aq[(b - p0) as usize][(p1 - b) as usize];
        }
        (*(*h).fenc).i_row_satd = (*(*h).fenc).i_row_satds[(b - p0) as usize][(p1 - b) as usize];
        (*(*h).fdec).i_row_satd = (*(*h).fdec).i_row_satds[(b - p0) as usize][(p1 - b) as usize];
        (*(*h).fdec).i_satd = cost;
        memcpy(
            (*(*h).fdec).i_row_satd as *mut ::core::ffi::c_void,
            (*(*h).fenc).i_row_satd as *const ::core::ffi::c_void,
            ((*h).mb.i_mb_height as size_t)
                .wrapping_mul(::core::mem::size_of::<::core::ffi::c_int>() as size_t),
        );
        if !((*(*h).fenc).i_type == X264_TYPE_I
            || (*(*h).fenc).i_type == X264_TYPE_IDR
            || (*(*h).fenc).i_type == X264_TYPE_KEYFRAME)
        {
            memcpy(
                (*(*h).fdec).i_row_satds[0 as ::core::ffi::c_int as usize]
                    [0 as ::core::ffi::c_int as usize] as *mut ::core::ffi::c_void,
                (*(*h).fenc).i_row_satds[0 as ::core::ffi::c_int as usize]
                    [0 as ::core::ffi::c_int as usize]
                    as *const ::core::ffi::c_void,
                ((*h).mb.i_mb_height as size_t)
                    .wrapping_mul(::core::mem::size_of::<::core::ffi::c_int>() as size_t),
            );
        }
        if (*h).param.b_intra_refresh != 0
            && (*h).param.rc.i_vbv_buffer_size != 0
            && (*(*h).fenc).i_type == X264_TYPE_P
        {
            let mut ip_factor: ::core::ffi::c_int =
                (256 as ::core::ffi::c_int as ::core::ffi::c_float * (*h).param.rc.f_ip_factor)
                    as ::core::ffi::c_int;
            let mut y: ::core::ffi::c_int = 0 as ::core::ffi::c_int;
            while y < (*h).mb.i_mb_height {
                let mut mb_xy: ::core::ffi::c_int =
                    y * (*h).mb.i_mb_stride + (*(*h).fdec).i_pir_start_col;
                let mut x: ::core::ffi::c_int = (*(*h).fdec).i_pir_start_col;
                while x <= (*(*h).fdec).i_pir_end_col {
                    let mut intra_cost: ::core::ffi::c_int =
                        *(*(*h).fenc).i_intra_cost.offset(mb_xy as isize) as ::core::ffi::c_int
                            * ip_factor
                            + 128 as ::core::ffi::c_int
                            >> 8 as ::core::ffi::c_int;
                    let mut inter_cost: ::core::ffi::c_int =
                        *(*(*h).fenc).lowres_costs[(b - p0) as usize][(p1 - b) as usize]
                            .offset(mb_xy as isize) as ::core::ffi::c_int
                            & LOWRES_COST_MASK;
                    let mut diff: ::core::ffi::c_int = intra_cost - inter_cost;
                    if (*h).param.rc.i_aq_mode != 0 {
                        *(*(*h).fdec).i_row_satd.offset(y as isize) += diff
                            * *(**frames.offset(b as isize))
                                .i_inv_qscale_factor
                                .offset(mb_xy as isize)
                                as ::core::ffi::c_int
                            + 128 as ::core::ffi::c_int
                            >> 8 as ::core::ffi::c_int;
                    } else {
                        *(*(*h).fdec).i_row_satd.offset(y as isize) += diff;
                    }
                    cost += diff;
                    x += 1;
                    mb_xy += 1;
                }
                y += 1;
            }
        }
        return cost;
    }
    use super::__stddef_null_h::NULL;
    use super::__stddef_size_t_h::size_t;
    use super::assert_h::__assert_fail;
    use super::base_h::{
        x264_clip3, x264_clip3f, x264_exp2fix8, x264_log2, x264_median_mv, x264_union32_t,
        x264_union64_t, CHROMA_444, X264_BFRAME_MAX, X264_WEIGHTP_FAKE,
    };
    use super::bitstream_h::{bs_size_se, bs_size_ue};
    use super::common_h::{
        pixel, x264_10_log, x264_t, FDEC_STRIDE, FENC_STRIDE, SIZEOF_PIXEL, X264_LOOKAHEAD_QP,
    };
    use super::frame_h::{
        x264_10_frame_expand_border_chroma, x264_10_weight_scale_plane, x264_frame_t,
        LOWRES_COST_MASK, LOWRES_COST_SHIFT, PADH, PADV,
    };
    use super::internal::BIT_DEPTH;
    use super::macroblock_h::ALL_NEIGHBORS;
    use super::mathcalls_h::{fabsf, round, sqrtf};
    use super::mc_h::{weight_fn_t, x264_weight_t};
    use super::me_h::{x264_10_me_search_ref, x264_me_t, COST_MAX, COST_MAX64};
    use super::pixel_h::{PIXEL_16x16, PIXEL_8x8};
    use super::predict_h::I_PRED_CHROMA_P;
    use super::ratecontrol_h::x264_10_ratecontrol_slice_type;
    use super::stdint_h::intptr_t;
    use super::stdint_intn_h::{int16_t, int32_t, int64_t};
    use super::stdint_uintn_h::{uint16_t, uint32_t, uint64_t, uint8_t};
    use super::string_h::{memcpy, memset, strcpy};
    use super::tables_h::{x264_lambda_tab, x264_zero};
    use super::threadpool_h::{x264_10_threadpool_run, x264_10_threadpool_wait};
    use super::x264_h::{
        x264_b_pyramid_names, X264_B_ADAPT_FAST, X264_B_ADAPT_TRELLIS, X264_B_PYRAMID_NORMAL,
        X264_LOG_DEBUG, X264_LOG_WARNING, X264_ME_DIA, X264_RC_CQP, X264_TYPE_AUTO, X264_TYPE_B,
        X264_TYPE_BREF, X264_TYPE_I, X264_TYPE_IDR, X264_TYPE_KEYFRAME, X264_TYPE_P,
        X264_WEIGHTP_SIMPLE,
    };
    use super::{mb_analyse_load_costs, x264_mb_analysis_t};
}
#[c2rust::header_src = "/home/nwplayer123/Hacks/hex264/x264/common/osdep.h:28"]
pub mod osdep_h {
    #[c2rust::src_loc = "452:9"]
    pub const WORD_SIZE: uint64_t = ::core::mem::size_of::<*mut ::core::ffi::c_void>() as uint64_t;
    #[inline(always)]
    #[c2rust::src_loc = "503:1"]
    pub unsafe extern "C" fn x264_ctz_4bit(mut x: uint32_t) -> ::core::ffi::c_int {
        pub static mut lut: [uint8_t; 16] = [
            4 as ::core::ffi::c_int as uint8_t,
            0 as ::core::ffi::c_int as uint8_t,
            1 as ::core::ffi::c_int as uint8_t,
            0 as ::core::ffi::c_int as uint8_t,
            2 as ::core::ffi::c_int as uint8_t,
            0 as ::core::ffi::c_int as uint8_t,
            1 as ::core::ffi::c_int as uint8_t,
            0 as ::core::ffi::c_int as uint8_t,
            3 as ::core::ffi::c_int as uint8_t,
            0 as ::core::ffi::c_int as uint8_t,
            1 as ::core::ffi::c_int as uint8_t,
            0 as ::core::ffi::c_int as uint8_t,
            2 as ::core::ffi::c_int as uint8_t,
            0 as ::core::ffi::c_int as uint8_t,
            1 as ::core::ffi::c_int as uint8_t,
            0 as ::core::ffi::c_int as uint8_t,
        ];
        return lut[x as usize] as ::core::ffi::c_int;
    }
    use super::stdint_uintn_h::{uint32_t, uint64_t, uint8_t};
}
#[c2rust::header_src = "/usr/include/string.h:28"]
pub mod string_h {
    use super::__stddef_size_t_h::size_t;
    extern "C" {
        #[c2rust::src_loc = "43:1"]
        pub fn memcpy(
            __dest: *mut ::core::ffi::c_void,
            __src: *const ::core::ffi::c_void,
            __n: size_t,
        ) -> *mut ::core::ffi::c_void;
        #[c2rust::src_loc = "61:1"]
        pub fn memset(
            __s: *mut ::core::ffi::c_void,
            __c: ::core::ffi::c_int,
            __n: size_t,
        ) -> *mut ::core::ffi::c_void;
        #[c2rust::src_loc = "141:1"]
        pub fn strcpy(
            __dest: *mut ::core::ffi::c_char,
            __src: *const ::core::ffi::c_char,
        ) -> *mut ::core::ffi::c_char;
    }
}
#[c2rust::header_src = "/home/nwplayer123/Hacks/hex264/x264/common/rectangle.h:28"]
pub mod rectangle_h {
    #[inline(always)]
    #[c2rust::src_loc = "28:1"]
    pub unsafe extern "C" fn x264_macroblock_cache_rect(
        mut dst: *mut ::core::ffi::c_void,
        mut w: ::core::ffi::c_int,
        mut h: ::core::ffi::c_int,
        mut s: ::core::ffi::c_int,
        mut v: uint32_t,
    ) {
        let mut d: *mut uint8_t = dst as *mut uint8_t;
        let mut v2: uint16_t = (if s >= 2 as ::core::ffi::c_int {
            v
        } else {
            v.wrapping_mul(0x101 as uint32_t)
        }) as uint16_t;
        let mut v4: uint32_t = if s >= 4 as ::core::ffi::c_int {
            v
        } else if s >= 2 as ::core::ffi::c_int {
            v.wrapping_mul(0x10001 as uint32_t)
        } else {
            v.wrapping_mul(0x1010101 as uint32_t)
        };
        let mut v8: uint64_t =
            (v4 as uint64_t).wrapping_add((v4 as uint64_t) << 32 as ::core::ffi::c_int);
        s *= 8 as ::core::ffi::c_int;
        if w == 2 as ::core::ffi::c_int {
            (*(d.offset((s * 0 as ::core::ffi::c_int) as isize) as *mut x264_union16_t)).i = v2;
            if h == 1 as ::core::ffi::c_int {
                return;
            }
            (*(d.offset((s * 1 as ::core::ffi::c_int) as isize) as *mut x264_union16_t)).i = v2;
            if h == 2 as ::core::ffi::c_int {
                return;
            }
            (*(d.offset((s * 2 as ::core::ffi::c_int) as isize) as *mut x264_union16_t)).i = v2;
            (*(d.offset((s * 3 as ::core::ffi::c_int) as isize) as *mut x264_union16_t)).i = v2;
        } else if w == 4 as ::core::ffi::c_int {
            (*(d.offset((s * 0 as ::core::ffi::c_int) as isize) as *mut x264_union32_t)).i = v4;
            if h == 1 as ::core::ffi::c_int {
                return;
            }
            (*(d.offset((s * 1 as ::core::ffi::c_int) as isize) as *mut x264_union32_t)).i = v4;
            if h == 2 as ::core::ffi::c_int {
                return;
            }
            (*(d.offset((s * 2 as ::core::ffi::c_int) as isize) as *mut x264_union32_t)).i = v4;
            (*(d.offset((s * 3 as ::core::ffi::c_int) as isize) as *mut x264_union32_t)).i = v4;
        } else if w == 8 as ::core::ffi::c_int {
            if WORD_SIZE == 8 as uint64_t {
                (*(d.offset((s * 0 as ::core::ffi::c_int) as isize) as *mut x264_union64_t)).i = v8;
                if h == 1 as ::core::ffi::c_int {
                    return;
                }
                (*(d.offset((s * 1 as ::core::ffi::c_int) as isize) as *mut x264_union64_t)).i = v8;
                if h == 2 as ::core::ffi::c_int {
                    return;
                }
                (*(d.offset((s * 2 as ::core::ffi::c_int) as isize) as *mut x264_union64_t)).i = v8;
                (*(d.offset((s * 3 as ::core::ffi::c_int) as isize) as *mut x264_union64_t)).i = v8;
            } else {
                (*(d.offset((s * 0 as ::core::ffi::c_int) as isize)
                    .offset(0 as ::core::ffi::c_int as isize)
                    as *mut x264_union32_t))
                    .i = v4;
                (*(d.offset((s * 0 as ::core::ffi::c_int) as isize)
                    .offset(4 as ::core::ffi::c_int as isize)
                    as *mut x264_union32_t))
                    .i = v4;
                if h == 1 as ::core::ffi::c_int {
                    return;
                }
                (*(d.offset((s * 1 as ::core::ffi::c_int) as isize)
                    .offset(0 as ::core::ffi::c_int as isize)
                    as *mut x264_union32_t))
                    .i = v4;
                (*(d.offset((s * 1 as ::core::ffi::c_int) as isize)
                    .offset(4 as ::core::ffi::c_int as isize)
                    as *mut x264_union32_t))
                    .i = v4;
                if h == 2 as ::core::ffi::c_int {
                    return;
                }
                (*(d.offset((s * 2 as ::core::ffi::c_int) as isize)
                    .offset(0 as ::core::ffi::c_int as isize)
                    as *mut x264_union32_t))
                    .i = v4;
                (*(d.offset((s * 2 as ::core::ffi::c_int) as isize)
                    .offset(4 as ::core::ffi::c_int as isize)
                    as *mut x264_union32_t))
                    .i = v4;
                (*(d.offset((s * 3 as ::core::ffi::c_int) as isize)
                    .offset(0 as ::core::ffi::c_int as isize)
                    as *mut x264_union32_t))
                    .i = v4;
                (*(d.offset((s * 3 as ::core::ffi::c_int) as isize)
                    .offset(4 as ::core::ffi::c_int as isize)
                    as *mut x264_union32_t))
                    .i = v4;
            }
        } else if w == 16 as ::core::ffi::c_int {
            if h != 1 as ::core::ffi::c_int {
            } else {
                __assert_fail(
                    b"h != 1\0" as *const u8 as *const ::core::ffi::c_char,
                    b"./common/rectangle.h\0" as *const u8 as *const ::core::ffi::c_char,
                    82 as ::core::ffi::c_uint,
                    ::core::mem::transmute::<[u8; 65], [::core::ffi::c_char; 65]>(
                        *b"void x264_macroblock_cache_rect(void *, int, int, int, uint32_t)\0",
                    )
                    .as_ptr(),
                );
            }
            'c_27249: {
                if h != 1 as ::core::ffi::c_int {
                } else {
                    __assert_fail(
                        b"h != 1\0" as *const u8 as *const ::core::ffi::c_char,
                        b"./common/rectangle.h\0" as *const u8 as *const ::core::ffi::c_char,
                        82 as ::core::ffi::c_uint,
                        ::core::mem::transmute::<[u8; 65], [::core::ffi::c_char; 65]>(
                            *b"void x264_macroblock_cache_rect(void *, int, int, int, uint32_t)\0",
                        )
                        .as_ptr(),
                    );
                }
            };
            if WORD_SIZE == 8 as uint64_t {
                loop {
                    (*(d.offset((s * 0 as ::core::ffi::c_int) as isize)
                        .offset(0 as ::core::ffi::c_int as isize)
                        as *mut x264_union64_t))
                        .i = v8;
                    (*(d.offset((s * 0 as ::core::ffi::c_int) as isize)
                        .offset(8 as ::core::ffi::c_int as isize)
                        as *mut x264_union64_t))
                        .i = v8;
                    (*(d.offset((s * 1 as ::core::ffi::c_int) as isize)
                        .offset(0 as ::core::ffi::c_int as isize)
                        as *mut x264_union64_t))
                        .i = v8;
                    (*(d.offset((s * 1 as ::core::ffi::c_int) as isize)
                        .offset(8 as ::core::ffi::c_int as isize)
                        as *mut x264_union64_t))
                        .i = v8;
                    h -= 2 as ::core::ffi::c_int;
                    d = d.offset((s * 2 as ::core::ffi::c_int) as isize);
                    if !(h != 0) {
                        break;
                    }
                }
            } else {
                loop {
                    (*(d.offset(0 as ::core::ffi::c_int as isize) as *mut x264_union32_t)).i = v4;
                    (*(d.offset(4 as ::core::ffi::c_int as isize) as *mut x264_union32_t)).i = v4;
                    (*(d.offset(8 as ::core::ffi::c_int as isize) as *mut x264_union32_t)).i = v4;
                    (*(d.offset(12 as ::core::ffi::c_int as isize) as *mut x264_union32_t)).i = v4;
                    d = d.offset(s as isize);
                    h -= 1;
                    if !(h != 0) {
                        break;
                    }
                }
            }
        } else {
            __assert_fail(
                b"0\0" as *const u8 as *const ::core::ffi::c_char,
                b"./common/rectangle.h\0" as *const u8 as *const ::core::ffi::c_char,
                108 as ::core::ffi::c_uint,
                ::core::mem::transmute::<[u8; 65], [::core::ffi::c_char; 65]>(
                    *b"void x264_macroblock_cache_rect(void *, int, int, int, uint32_t)\0",
                )
                .as_ptr(),
            );
            'c_27015: {
                __assert_fail(
                    b"0\0" as *const u8 as *const ::core::ffi::c_char,
                    b"./common/rectangle.h\0" as *const u8 as *const ::core::ffi::c_char,
                    108 as ::core::ffi::c_uint,
                    ::core::mem::transmute::<[u8; 65], [::core::ffi::c_char; 65]>(
                        *b"void x264_macroblock_cache_rect(void *, int, int, int, uint32_t)\0",
                    )
                    .as_ptr(),
                );
            };
        };
    }
    #[inline(always)]
    #[c2rust::src_loc = "119:1"]
    pub unsafe extern "C" fn x264_macroblock_cache_mv(
        mut h: *mut x264_t,
        mut x: ::core::ffi::c_int,
        mut y: ::core::ffi::c_int,
        mut width: ::core::ffi::c_int,
        mut height: ::core::ffi::c_int,
        mut i_list: ::core::ffi::c_int,
        mut mv: uint32_t,
    ) {
        let mut mv_cache: *mut ::core::ffi::c_void =
            &mut *(*(*h).mb.cache.mv.as_mut_ptr().offset(i_list as isize))
                .as_mut_ptr()
                .offset((X264_SCAN8_0 + x + 8 as ::core::ffi::c_int * y) as isize)
                as *mut [int16_t; 2] as *mut ::core::ffi::c_void;
        if 0 == 0 || 0 == 0 {
            x264_10_cache_mv_func_table
                [(width + (height << 1 as ::core::ffi::c_int) - 3 as ::core::ffi::c_int) as usize]
                .expect("non-null function pointer")(mv_cache, mv);
        } else {
            x264_macroblock_cache_rect(
                mv_cache,
                width * 4 as ::core::ffi::c_int,
                height,
                4 as ::core::ffi::c_int,
                mv,
            );
        };
    }
    #[inline(always)]
    #[c2rust::src_loc = "127:1"]
    pub unsafe extern "C" fn x264_macroblock_cache_mvd(
        mut h: *mut x264_t,
        mut x: ::core::ffi::c_int,
        mut y: ::core::ffi::c_int,
        mut width: ::core::ffi::c_int,
        mut height: ::core::ffi::c_int,
        mut i_list: ::core::ffi::c_int,
        mut mvd: uint16_t,
    ) {
        let mut mvd_cache: *mut ::core::ffi::c_void =
            &mut *(*(*h).mb.cache.mvd.as_mut_ptr().offset(i_list as isize))
                .as_mut_ptr()
                .offset((X264_SCAN8_0 + x + 8 as ::core::ffi::c_int * y) as isize)
                as *mut [uint8_t; 2] as *mut ::core::ffi::c_void;
        if 0 == 0 || 0 == 0 {
            x264_10_cache_mvd_func_table
                [(width + (height << 1 as ::core::ffi::c_int) - 3 as ::core::ffi::c_int) as usize]
                .expect("non-null function pointer")(mvd_cache, mvd as uint32_t);
        } else {
            x264_macroblock_cache_rect(
                mvd_cache,
                width * 2 as ::core::ffi::c_int,
                height,
                2 as ::core::ffi::c_int,
                mvd as uint32_t,
            );
        };
    }
    #[inline(always)]
    #[c2rust::src_loc = "135:1"]
    pub unsafe extern "C" fn x264_macroblock_cache_ref(
        mut h: *mut x264_t,
        mut x: ::core::ffi::c_int,
        mut y: ::core::ffi::c_int,
        mut width: ::core::ffi::c_int,
        mut height: ::core::ffi::c_int,
        mut i_list: ::core::ffi::c_int,
        mut ref_0: int8_t,
    ) {
        let mut ref_cache: *mut ::core::ffi::c_void =
            &mut *(*(*h).mb.cache.ref_0.as_mut_ptr().offset(i_list as isize))
                .as_mut_ptr()
                .offset((X264_SCAN8_0 + x + 8 as ::core::ffi::c_int * y) as isize)
                as *mut int8_t as *mut ::core::ffi::c_void;
        if 0 == 0 || 0 == 0 {
            x264_10_cache_ref_func_table
                [(width + (height << 1 as ::core::ffi::c_int) - 3 as ::core::ffi::c_int) as usize]
                .expect("non-null function pointer")(
                ref_cache, ref_0 as uint8_t as uint32_t
            );
        } else {
            x264_macroblock_cache_rect(
                ref_cache,
                width,
                height,
                1 as ::core::ffi::c_int,
                ref_0 as uint8_t as uint32_t,
            );
        };
    }
    #[inline(always)]
    #[c2rust::src_loc = "143:1"]
    pub unsafe extern "C" fn x264_macroblock_cache_skip(
        mut h: *mut x264_t,
        mut x: ::core::ffi::c_int,
        mut y: ::core::ffi::c_int,
        mut width: ::core::ffi::c_int,
        mut height: ::core::ffi::c_int,
        mut b_skip: ::core::ffi::c_int,
    ) {
        x264_macroblock_cache_rect(
            &mut *(*h)
                .mb
                .cache
                .skip
                .as_mut_ptr()
                .offset((X264_SCAN8_0 + x + 8 as ::core::ffi::c_int * y) as isize)
                as *mut int8_t as *mut ::core::ffi::c_void,
            width,
            height,
            1 as ::core::ffi::c_int,
            b_skip as uint32_t,
        );
    }
    #[inline(always)]
    #[c2rust::src_loc = "147:1"]
    pub unsafe extern "C" fn x264_macroblock_cache_intra8x8_pred(
        mut h: *mut x264_t,
        mut x: ::core::ffi::c_int,
        mut y: ::core::ffi::c_int,
        mut i_mode: ::core::ffi::c_int,
    ) {
        x264_macroblock_cache_rect(
            &mut *(*h)
                .mb
                .cache
                .intra4x4_pred_mode
                .as_mut_ptr()
                .offset((X264_SCAN8_0 + x + 8 as ::core::ffi::c_int * y) as isize)
                as *mut int8_t as *mut ::core::ffi::c_void,
            2 as ::core::ffi::c_int,
            2 as ::core::ffi::c_int,
            1 as ::core::ffi::c_int,
            i_mode as uint32_t,
        );
    }
    use super::assert_h::__assert_fail;
    use super::base_h::{x264_union16_t, x264_union32_t, x264_union64_t, X264_SCAN8_0};
    use super::common_h::x264_t;
    use super::osdep_h::WORD_SIZE;
    use super::stdint_intn_h::{int16_t, int8_t};
    use super::stdint_uintn_h::{uint16_t, uint32_t, uint64_t, uint8_t};
    extern "C" {
        #[c2rust::src_loc = "112:15"]
        pub static mut x264_10_cache_mv_func_table:
            [Option<unsafe extern "C" fn(*mut ::core::ffi::c_void, uint32_t) -> ()>; 10];
        #[c2rust::src_loc = "114:15"]
        pub static mut x264_10_cache_mvd_func_table:
            [Option<unsafe extern "C" fn(*mut ::core::ffi::c_void, uint32_t) -> ()>; 10];
        #[c2rust::src_loc = "116:15"]
        pub static mut x264_10_cache_ref_func_table:
            [Option<unsafe extern "C" fn(*mut ::core::ffi::c_void, uint32_t) -> ()>; 10];
    }
}
#[c2rust::header_src = "/home/nwplayer123/Hacks/hex264/x264/encoder/macroblock.h:28"]
pub mod encoder_macroblock_h {
    #[inline(always)]
    #[c2rust::src_loc = "90:1"]
    pub unsafe extern "C" fn x264_quant_4x4(
        mut h: *mut x264_t,
        mut dct: *mut dctcoef,
        mut i_qp: ::core::ffi::c_int,
        mut ctx_block_cat: ::core::ffi::c_int,
        mut b_intra: ::core::ffi::c_int,
        mut p: ::core::ffi::c_int,
        mut idx: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int {
        let mut i_quant_cat: ::core::ffi::c_int = if b_intra != 0 {
            if p != 0 {
                CQM_4IC as ::core::ffi::c_int
            } else {
                CQM_4IY as ::core::ffi::c_int
            }
        } else if p != 0 {
            CQM_4PC as ::core::ffi::c_int
        } else {
            CQM_4PY as ::core::ffi::c_int
        };
        if (*h).mb.b_noise_reduction != 0 {
            (*h).quantf.denoise_dct.expect("non-null function pointer")(
                dct as *mut dctcoef,
                (*(*h).nr_residual_sum.offset(
                    (0 as ::core::ffi::c_int
                        + (p != 0) as ::core::ffi::c_int * 2 as ::core::ffi::c_int)
                        as isize,
                ))
                .as_mut_ptr(),
                (*(*h).nr_offset.offset(
                    (0 as ::core::ffi::c_int
                        + (p != 0) as ::core::ffi::c_int * 2 as ::core::ffi::c_int)
                        as isize,
                ))
                .as_mut_ptr(),
                16 as ::core::ffi::c_int,
            );
        }
        if (*h).mb.b_trellis != 0 {
            return x264_10_quant_4x4_trellis(
                h,
                dct as *mut dctcoef,
                i_quant_cat,
                i_qp,
                ctx_block_cat,
                b_intra,
                (p != 0) as ::core::ffi::c_int,
                idx + p * 16 as ::core::ffi::c_int,
            );
        } else {
            return (*h).quantf.quant_4x4.expect("non-null function pointer")(
                dct,
                (*(*(*h).quant4_mf.as_mut_ptr().offset(i_quant_cat as isize))
                    .offset(i_qp as isize))
                .as_mut_ptr(),
                (*(*(*h).quant4_bias.as_mut_ptr().offset(i_quant_cat as isize))
                    .offset(i_qp as isize))
                .as_mut_ptr(),
            );
        };
    }
    #[inline(always)]
    #[c2rust::src_loc = "101:1"]
    pub unsafe extern "C" fn x264_quant_8x8(
        mut h: *mut x264_t,
        mut dct: *mut dctcoef,
        mut i_qp: ::core::ffi::c_int,
        mut ctx_block_cat: ::core::ffi::c_int,
        mut b_intra: ::core::ffi::c_int,
        mut p: ::core::ffi::c_int,
        mut idx: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int {
        let mut i_quant_cat: ::core::ffi::c_int = if b_intra != 0 {
            if p != 0 {
                CQM_8IC as ::core::ffi::c_int
            } else {
                CQM_8IY as ::core::ffi::c_int
            }
        } else if p != 0 {
            CQM_8PC as ::core::ffi::c_int
        } else {
            CQM_8PY as ::core::ffi::c_int
        };
        if (*h).mb.b_noise_reduction != 0 {
            (*h).quantf.denoise_dct.expect("non-null function pointer")(
                dct as *mut dctcoef,
                (*(*h).nr_residual_sum.offset(
                    (1 as ::core::ffi::c_int
                        + (p != 0) as ::core::ffi::c_int * 2 as ::core::ffi::c_int)
                        as isize,
                ))
                .as_mut_ptr(),
                (*(*h).nr_offset.offset(
                    (1 as ::core::ffi::c_int
                        + (p != 0) as ::core::ffi::c_int * 2 as ::core::ffi::c_int)
                        as isize,
                ))
                .as_mut_ptr(),
                64 as ::core::ffi::c_int,
            );
        }
        if (*h).mb.b_trellis != 0 {
            return x264_10_quant_8x8_trellis(
                h,
                dct as *mut dctcoef,
                i_quant_cat,
                i_qp,
                ctx_block_cat,
                b_intra,
                (p != 0) as ::core::ffi::c_int,
                idx + p * 4 as ::core::ffi::c_int,
            );
        } else {
            return (*h).quantf.quant_8x8.expect("non-null function pointer")(
                dct,
                (*(*(*h).quant8_mf.as_mut_ptr().offset(i_quant_cat as isize))
                    .offset(i_qp as isize))
                .as_mut_ptr(),
                (*(*(*h).quant8_bias.as_mut_ptr().offset(i_quant_cat as isize))
                    .offset(i_qp as isize))
                .as_mut_ptr(),
            );
        };
    }
    #[inline(always)]
    #[c2rust::src_loc = "132:1"]
    pub unsafe extern "C" fn x264_mb_encode_i4x4(
        mut h: *mut x264_t,
        mut p: ::core::ffi::c_int,
        mut idx: ::core::ffi::c_int,
        mut i_qp: ::core::ffi::c_int,
        mut i_mode: ::core::ffi::c_int,
        mut b_predict: ::core::ffi::c_int,
    ) {
        let mut nz: ::core::ffi::c_int = 0;
        let mut p_src: *mut pixel = &mut *(*(*h).mb.pic.p_fenc.as_mut_ptr().offset(p as isize))
            .offset(*block_idx_xy_fenc.as_ptr().offset(idx as isize) as isize)
            as *mut pixel;
        let mut p_dst: *mut pixel = &mut *(*(*h).mb.pic.p_fdec.as_mut_ptr().offset(p as isize))
            .offset(*block_idx_xy_fdec.as_ptr().offset(idx as isize) as isize)
            as *mut pixel;
        let mut dct4x4: [dctcoef; 16] = [0; 16];
        if b_predict != 0 {
            if (*h).mb.b_lossless != 0 {
                x264_10_predict_lossless_4x4(h, p_dst, p, idx, i_mode);
            } else {
                (*h).predict_4x4[i_mode as usize].expect("non-null function pointer")(p_dst);
            }
        }
        if (*h).mb.b_lossless != 0 {
            nz = (*h).zigzagf.sub_4x4.expect("non-null function pointer")(
                (*(*h)
                    .dct
                    .luma4x4
                    .as_mut_ptr()
                    .offset((p * 16 as ::core::ffi::c_int + idx) as isize))
                .as_mut_ptr(),
                p_src,
                p_dst,
            );
            (*h).mb.cache.non_zero_count
                [x264_scan8[(p * 16 as ::core::ffi::c_int + idx) as usize] as usize] =
                nz as uint8_t;
            (*h).mb.i_cbp_luma |= nz << (idx >> 2 as ::core::ffi::c_int);
            return;
        }
        (*h).dctf.sub4x4_dct.expect("non-null function pointer")(dct4x4.as_mut_ptr(), p_src, p_dst);
        nz = x264_quant_4x4(
            h,
            dct4x4.as_mut_ptr(),
            i_qp,
            ctx_cat_plane[DCT_LUMA_4x4 as ::core::ffi::c_int as usize][p as usize]
                as ::core::ffi::c_int,
            1 as ::core::ffi::c_int,
            p,
            idx,
        );
        (*h).mb.cache.non_zero_count
            [x264_scan8[(p * 16 as ::core::ffi::c_int + idx) as usize] as usize] = nz as uint8_t;
        if nz != 0 {
            (*h).mb.i_cbp_luma |= (1 as ::core::ffi::c_int) << (idx >> 2 as ::core::ffi::c_int);
            (*h).zigzagf.scan_4x4.expect("non-null function pointer")(
                (*(*h)
                    .dct
                    .luma4x4
                    .as_mut_ptr()
                    .offset((p * 16 as ::core::ffi::c_int + idx) as isize))
                .as_mut_ptr(),
                dct4x4.as_mut_ptr(),
            );
            (*h).quantf.dequant_4x4.expect("non-null function pointer")(
                dct4x4.as_mut_ptr(),
                (*h).dequant4_mf[(if p != 0 {
                    CQM_4IC as ::core::ffi::c_int
                } else {
                    CQM_4IY as ::core::ffi::c_int
                }) as usize],
                i_qp,
            );
            (*h).dctf.add4x4_idct.expect("non-null function pointer")(p_dst, dct4x4.as_mut_ptr());
        }
    }
    #[inline(always)]
    #[c2rust::src_loc = "168:1"]
    pub unsafe extern "C" fn x264_mb_encode_i8x8(
        mut h: *mut x264_t,
        mut p: ::core::ffi::c_int,
        mut idx: ::core::ffi::c_int,
        mut i_qp: ::core::ffi::c_int,
        mut i_mode: ::core::ffi::c_int,
        mut edge: *mut pixel,
        mut b_predict: ::core::ffi::c_int,
    ) {
        let mut x: ::core::ffi::c_int = idx & 1 as ::core::ffi::c_int;
        let mut y: ::core::ffi::c_int = idx >> 1 as ::core::ffi::c_int;
        let mut nz: ::core::ffi::c_int = 0;
        let mut p_src: *mut pixel = &mut *(*(*h).mb.pic.p_fenc.as_mut_ptr().offset(p as isize))
            .offset(
                (8 as ::core::ffi::c_int * x + 8 as ::core::ffi::c_int * y * FENC_STRIDE) as isize,
            ) as *mut pixel;
        let mut p_dst: *mut pixel = &mut *(*(*h).mb.pic.p_fdec.as_mut_ptr().offset(p as isize))
            .offset(
                (8 as ::core::ffi::c_int * x + 8 as ::core::ffi::c_int * y * FDEC_STRIDE) as isize,
            ) as *mut pixel;
        let mut dct8x8: [dctcoef; 64] = [0; 64];
        let mut edge_buf: [pixel; 36] = [0; 36];
        if b_predict != 0 {
            if edge.is_null() {
                (*h).predict_8x8_filter.expect("non-null function pointer")(
                    p_dst,
                    edge_buf.as_mut_ptr(),
                    (*h).mb.i_neighbour8[idx as usize] as ::core::ffi::c_int,
                    x264_pred_i4x4_neighbors[i_mode as usize] as ::core::ffi::c_int,
                );
                edge = edge_buf.as_mut_ptr();
            }
            if (*h).mb.b_lossless != 0 {
                x264_10_predict_lossless_8x8(h, p_dst, p, idx, i_mode, edge as *mut pixel);
            } else {
                (*h).predict_8x8[i_mode as usize].expect("non-null function pointer")(
                    p_dst,
                    edge as *mut pixel,
                );
            }
        }
        if (*h).mb.b_lossless != 0 {
            nz = (*h).zigzagf.sub_8x8.expect("non-null function pointer")(
                (*(*h)
                    .dct
                    .luma8x8
                    .as_mut_ptr()
                    .offset((p * 4 as ::core::ffi::c_int + idx) as isize))
                .as_mut_ptr(),
                p_src,
                p_dst,
            );
            (*(&mut *(*h).mb.cache.non_zero_count.as_mut_ptr().offset(
                (*x264_scan8
                    .as_ptr()
                    .offset((p * 16 as ::core::ffi::c_int + idx * 4 as ::core::ffi::c_int) as isize)
                    as ::core::ffi::c_int
                    + 0 as ::core::ffi::c_int) as isize,
            ) as *mut uint8_t as *mut x264_union16_t))
                .i = (nz * 0x101 as ::core::ffi::c_int) as uint16_t;
            (*(&mut *(*h).mb.cache.non_zero_count.as_mut_ptr().offset(
                (*x264_scan8
                    .as_ptr()
                    .offset((p * 16 as ::core::ffi::c_int + idx * 4 as ::core::ffi::c_int) as isize)
                    as ::core::ffi::c_int
                    + 8 as ::core::ffi::c_int) as isize,
            ) as *mut uint8_t as *mut x264_union16_t))
                .i = (nz * 0x101 as ::core::ffi::c_int) as uint16_t;
            (*h).mb.i_cbp_luma |= nz << idx;
            return;
        }
        (*h).dctf.sub8x8_dct8.expect("non-null function pointer")(
            dct8x8.as_mut_ptr(),
            p_src,
            p_dst,
        );
        nz = x264_quant_8x8(
            h,
            dct8x8.as_mut_ptr(),
            i_qp,
            ctx_cat_plane[DCT_LUMA_8x8 as ::core::ffi::c_int as usize][p as usize]
                as ::core::ffi::c_int,
            1 as ::core::ffi::c_int,
            p,
            idx,
        );
        if nz != 0 {
            (*h).mb.i_cbp_luma |= (1 as ::core::ffi::c_int) << idx;
            (*h).zigzagf.scan_8x8.expect("non-null function pointer")(
                (*(*h)
                    .dct
                    .luma8x8
                    .as_mut_ptr()
                    .offset((p * 4 as ::core::ffi::c_int + idx) as isize))
                .as_mut_ptr(),
                dct8x8.as_mut_ptr(),
            );
            (*h).quantf.dequant_8x8.expect("non-null function pointer")(
                dct8x8.as_mut_ptr(),
                (*h).dequant8_mf[(if p != 0 {
                    CQM_8IC as ::core::ffi::c_int
                } else {
                    CQM_8IY as ::core::ffi::c_int
                }) as usize],
                i_qp,
            );
            (*h).dctf.add8x8_idct8.expect("non-null function pointer")(p_dst, dct8x8.as_mut_ptr());
            (*(&mut *(*h).mb.cache.non_zero_count.as_mut_ptr().offset(
                (*x264_scan8
                    .as_ptr()
                    .offset((p * 16 as ::core::ffi::c_int + idx * 4 as ::core::ffi::c_int) as isize)
                    as ::core::ffi::c_int
                    + 0 as ::core::ffi::c_int) as isize,
            ) as *mut uint8_t as *mut x264_union16_t))
                .i = (1 as ::core::ffi::c_int * 0x101 as ::core::ffi::c_int) as uint16_t;
            (*(&mut *(*h).mb.cache.non_zero_count.as_mut_ptr().offset(
                (*x264_scan8
                    .as_ptr()
                    .offset((p * 16 as ::core::ffi::c_int + idx * 4 as ::core::ffi::c_int) as isize)
                    as ::core::ffi::c_int
                    + 8 as ::core::ffi::c_int) as isize,
            ) as *mut uint8_t as *mut x264_union16_t))
                .i = (1 as ::core::ffi::c_int * 0x101 as ::core::ffi::c_int) as uint16_t;
        } else {
            (*(&mut *(*h).mb.cache.non_zero_count.as_mut_ptr().offset(
                (*x264_scan8
                    .as_ptr()
                    .offset((p * 16 as ::core::ffi::c_int + idx * 4 as ::core::ffi::c_int) as isize)
                    as ::core::ffi::c_int
                    + 0 as ::core::ffi::c_int) as isize,
            ) as *mut uint8_t as *mut x264_union16_t))
                .i = (0 as ::core::ffi::c_int * 0x101 as ::core::ffi::c_int) as uint16_t;
            (*(&mut *(*h).mb.cache.non_zero_count.as_mut_ptr().offset(
                (*x264_scan8
                    .as_ptr()
                    .offset((p * 16 as ::core::ffi::c_int + idx * 4 as ::core::ffi::c_int) as isize)
                    as ::core::ffi::c_int
                    + 8 as ::core::ffi::c_int) as isize,
            ) as *mut uint8_t as *mut x264_union16_t))
                .i = (0 as ::core::ffi::c_int * 0x101 as ::core::ffi::c_int) as uint16_t;
        };
    }
    use super::base_h::{x264_scan8, x264_union16_t};
    use super::common_h::{dctcoef, pixel, x264_t, FDEC_STRIDE, FENC_STRIDE};
    use super::macroblock_h::{
        block_idx_xy_fdec, block_idx_xy_fenc, ctx_cat_plane, x264_pred_i4x4_neighbors,
        DCT_LUMA_4x4, DCT_LUMA_8x8,
    };
    use super::rdo_c::{x264_10_quant_4x4_trellis, x264_10_quant_8x8_trellis};
    use super::set_h::{CQM_4IC, CQM_4IY, CQM_4PC, CQM_4PY, CQM_8IC, CQM_8IY, CQM_8PC, CQM_8PY};
    use super::stdint_uintn_h::{uint16_t, uint8_t};
    extern "C" {
        #[c2rust::src_loc = "36:1"]
        pub fn x264_10_macroblock_probe_skip(
            h: *mut x264_t,
            b_bidir: ::core::ffi::c_int,
        ) -> ::core::ffi::c_int;
        #[c2rust::src_loc = "44:1"]
        pub fn x264_10_predict_lossless_4x4(
            h: *mut x264_t,
            p_dst: *mut pixel,
            p: ::core::ffi::c_int,
            idx: ::core::ffi::c_int,
            i_mode: ::core::ffi::c_int,
        );
        #[c2rust::src_loc = "46:1"]
        pub fn x264_10_predict_lossless_8x8(
            h: *mut x264_t,
            p_dst: *mut pixel,
            p: ::core::ffi::c_int,
            idx: ::core::ffi::c_int,
            i_mode: ::core::ffi::c_int,
            edge: *mut pixel,
        );
        #[c2rust::src_loc = "48:1"]
        pub fn x264_10_predict_lossless_16x16(
            h: *mut x264_t,
            p: ::core::ffi::c_int,
            i_mode: ::core::ffi::c_int,
        );
        #[c2rust::src_loc = "50:1"]
        pub fn x264_10_predict_lossless_chroma(h: *mut x264_t, i_mode: ::core::ffi::c_int);
        #[c2rust::src_loc = "53:1"]
        pub fn x264_10_macroblock_encode(h: *mut x264_t);
        #[c2rust::src_loc = "60:1"]
        pub fn x264_10_macroblock_encode_p8x8(h: *mut x264_t, i8: ::core::ffi::c_int);
        #[c2rust::src_loc = "62:1"]
        pub fn x264_10_macroblock_encode_p4x4(h: *mut x264_t, i4: ::core::ffi::c_int);
        #[c2rust::src_loc = "64:1"]
        pub fn x264_10_mb_encode_chroma(
            h: *mut x264_t,
            b_inter: ::core::ffi::c_int,
            i_qp: ::core::ffi::c_int,
        );
    }
}
#[c2rust::header_src = "/home/nwplayer123/Hacks/hex264/x264/encoder/cabac.c:28"]
pub mod cabac_c {
    #[inline]
    #[c2rust::src_loc = "35:1"]
    pub unsafe extern "C" fn cabac_mb_type_intra(
        mut h: *mut x264_t,
        mut cb: *mut x264_cabac_t,
        mut i_mb_type: ::core::ffi::c_int,
        mut ctx0: ::core::ffi::c_int,
        mut ctx1: ::core::ffi::c_int,
        mut ctx2: ::core::ffi::c_int,
        mut ctx3: ::core::ffi::c_int,
        mut ctx4: ::core::ffi::c_int,
        mut ctx5: ::core::ffi::c_int,
    ) {
        if i_mb_type == I_4x4 as ::core::ffi::c_int || i_mb_type == I_8x8 as ::core::ffi::c_int {
            x264_cabac_size_decision_noup(
                cb,
                ctx0 as ::core::ffi::c_long,
                0 as ::core::ffi::c_long,
            );
        } else {
            let mut i_pred: ::core::ffi::c_int = x264_mb_pred_mode16x16_fix
                [(*h).mb.i_intra16x16_pred_mode as usize]
                as ::core::ffi::c_int;
            x264_cabac_size_decision_noup(
                cb,
                ctx0 as ::core::ffi::c_long,
                1 as ::core::ffi::c_long,
            );
            (*cb).f8_bits_encoded += 7 as ::core::ffi::c_int;
            x264_cabac_size_decision_noup(
                cb,
                ctx1 as ::core::ffi::c_long,
                ((*h).mb.i_cbp_luma != 0) as ::core::ffi::c_int as ::core::ffi::c_long,
            );
            if (*h).mb.i_cbp_chroma == 0 as ::core::ffi::c_int {
                x264_cabac_size_decision_noup(
                    cb,
                    ctx2 as ::core::ffi::c_long,
                    0 as ::core::ffi::c_long,
                );
            } else {
                x264_cabac_size_decision(cb, ctx2 as ::core::ffi::c_long, 1 as ::core::ffi::c_long);
                x264_cabac_size_decision_noup(
                    cb,
                    ctx3 as ::core::ffi::c_long,
                    ((*h).mb.i_cbp_chroma >> 1 as ::core::ffi::c_int) as ::core::ffi::c_long,
                );
            }
            x264_cabac_size_decision(
                cb,
                ctx4 as ::core::ffi::c_long,
                (i_pred >> 1 as ::core::ffi::c_int) as ::core::ffi::c_long,
            );
            x264_cabac_size_decision_noup(
                cb,
                ctx5 as ::core::ffi::c_long,
                (i_pred & 1 as ::core::ffi::c_int) as ::core::ffi::c_long,
            );
        };
    }
    #[c2rust::src_loc = "83:1"]
    pub unsafe extern "C" fn cabac_intra4x4_pred_mode(
        mut cb: *mut x264_cabac_t,
        mut i_pred: ::core::ffi::c_int,
        mut i_mode: ::core::ffi::c_int,
    ) {
        if i_pred == i_mode {
            x264_cabac_size_decision(cb, 68 as ::core::ffi::c_long, 1 as ::core::ffi::c_long);
        } else {
            x264_cabac_size_decision(cb, 68 as ::core::ffi::c_long, 0 as ::core::ffi::c_long);
            if i_mode > i_pred {
                i_mode -= 1;
            }
            x264_cabac_size_decision(
                cb,
                69 as ::core::ffi::c_long,
                (i_mode & 0x1 as ::core::ffi::c_int) as ::core::ffi::c_long,
            );
            x264_cabac_size_decision(
                cb,
                69 as ::core::ffi::c_long,
                (i_mode >> 1 as ::core::ffi::c_int & 0x1 as ::core::ffi::c_int)
                    as ::core::ffi::c_long,
            );
            x264_cabac_size_decision(
                cb,
                69 as ::core::ffi::c_long,
                (i_mode >> 2 as ::core::ffi::c_int) as ::core::ffi::c_long,
            );
        };
    }
    #[c2rust::src_loc = "98:1"]
    pub unsafe extern "C" fn cabac_intra_chroma_pred_mode(
        mut h: *mut x264_t,
        mut cb: *mut x264_cabac_t,
    ) {
        let mut i_mode: ::core::ffi::c_int =
            x264_mb_chroma_pred_mode_fix[(*h).mb.i_chroma_pred_mode as usize] as ::core::ffi::c_int;
        let mut ctx: ::core::ffi::c_int = 0 as ::core::ffi::c_int;
        if (*h).mb.i_neighbour & MB_LEFT as ::core::ffi::c_int as ::core::ffi::c_uint != 0
            && *(*h)
                .mb
                .chroma_pred_mode
                .offset((*h).mb.i_mb_left_xy[0 as ::core::ffi::c_int as usize] as isize)
                as ::core::ffi::c_int
                != 0 as ::core::ffi::c_int
        {
            ctx += 1;
        }
        if (*h).mb.i_neighbour & MB_TOP as ::core::ffi::c_int as ::core::ffi::c_uint != 0
            && *(*h)
                .mb
                .chroma_pred_mode
                .offset((*h).mb.i_mb_top_xy as isize) as ::core::ffi::c_int
                != 0 as ::core::ffi::c_int
        {
            ctx += 1;
        }
        x264_cabac_size_decision_noup(
            cb,
            (64 as ::core::ffi::c_int + ctx) as ::core::ffi::c_long,
            (i_mode > 0 as ::core::ffi::c_int) as ::core::ffi::c_int as ::core::ffi::c_long,
        );
        if i_mode > 0 as ::core::ffi::c_int {
            x264_cabac_size_decision(
                cb,
                (64 as ::core::ffi::c_int + 3 as ::core::ffi::c_int) as ::core::ffi::c_long,
                (i_mode > 1 as ::core::ffi::c_int) as ::core::ffi::c_int as ::core::ffi::c_long,
            );
            if i_mode > 1 as ::core::ffi::c_int {
                x264_cabac_size_decision_noup(
                    cb,
                    (64 as ::core::ffi::c_int + 3 as ::core::ffi::c_int) as ::core::ffi::c_long,
                    (i_mode > 2 as ::core::ffi::c_int) as ::core::ffi::c_int as ::core::ffi::c_long,
                );
            }
        }
    }
    #[c2rust::src_loc = "118:1"]
    pub unsafe extern "C" fn cabac_cbp_luma(mut h: *mut x264_t, mut cb: *mut x264_cabac_t) {
        let mut cbp: ::core::ffi::c_int = (*h).mb.i_cbp_luma;
        let mut cbp_l: ::core::ffi::c_int = (*h).mb.cache.i_cbp_left;
        let mut cbp_t: ::core::ffi::c_int = (*h).mb.cache.i_cbp_top;
        x264_cabac_size_decision(
            cb,
            (76 as ::core::ffi::c_int
                - (cbp_l >> 1 as ::core::ffi::c_int & 1 as ::core::ffi::c_int)
                - (cbp_t >> 1 as ::core::ffi::c_int & 2 as ::core::ffi::c_int))
                as ::core::ffi::c_long,
            (cbp >> 0 as ::core::ffi::c_int & 1 as ::core::ffi::c_int) as ::core::ffi::c_long,
        );
        x264_cabac_size_decision(
            cb,
            (76 as ::core::ffi::c_int
                - (cbp >> 0 as ::core::ffi::c_int & 1 as ::core::ffi::c_int)
                - (cbp_t >> 2 as ::core::ffi::c_int & 2 as ::core::ffi::c_int))
                as ::core::ffi::c_long,
            (cbp >> 1 as ::core::ffi::c_int & 1 as ::core::ffi::c_int) as ::core::ffi::c_long,
        );
        x264_cabac_size_decision(
            cb,
            (76 as ::core::ffi::c_int
                - (cbp_l >> 3 as ::core::ffi::c_int & 1 as ::core::ffi::c_int)
                - (cbp << 1 as ::core::ffi::c_int & 2 as ::core::ffi::c_int))
                as ::core::ffi::c_long,
            (cbp >> 2 as ::core::ffi::c_int & 1 as ::core::ffi::c_int) as ::core::ffi::c_long,
        );
        x264_cabac_size_decision_noup(
            cb,
            (76 as ::core::ffi::c_int
                - (cbp >> 2 as ::core::ffi::c_int & 1 as ::core::ffi::c_int)
                - (cbp >> 0 as ::core::ffi::c_int & 2 as ::core::ffi::c_int))
                as ::core::ffi::c_long,
            (cbp >> 3 as ::core::ffi::c_int & 1 as ::core::ffi::c_int) as ::core::ffi::c_long,
        );
    }
    #[c2rust::src_loc = "129:1"]
    pub unsafe extern "C" fn cabac_cbp_chroma(mut h: *mut x264_t, mut cb: *mut x264_cabac_t) {
        let mut cbp_a: ::core::ffi::c_int = (*h).mb.cache.i_cbp_left & 0x30 as ::core::ffi::c_int;
        let mut cbp_b: ::core::ffi::c_int = (*h).mb.cache.i_cbp_top & 0x30 as ::core::ffi::c_int;
        let mut ctx: ::core::ffi::c_int = 0 as ::core::ffi::c_int;
        if cbp_a != 0 && (*h).mb.cache.i_cbp_left != -(1 as ::core::ffi::c_int) {
            ctx += 1;
        }
        if cbp_b != 0 && (*h).mb.cache.i_cbp_top != -(1 as ::core::ffi::c_int) {
            ctx += 2 as ::core::ffi::c_int;
        }
        if (*h).mb.i_cbp_chroma == 0 as ::core::ffi::c_int {
            x264_cabac_size_decision_noup(
                cb,
                (77 as ::core::ffi::c_int + ctx) as ::core::ffi::c_long,
                0 as ::core::ffi::c_long,
            );
        } else {
            x264_cabac_size_decision_noup(
                cb,
                (77 as ::core::ffi::c_int + ctx) as ::core::ffi::c_long,
                1 as ::core::ffi::c_long,
            );
            ctx = 4 as ::core::ffi::c_int;
            if cbp_a == 0x20 as ::core::ffi::c_int {
                ctx += 1;
            }
            if cbp_b == 0x20 as ::core::ffi::c_int {
                ctx += 2 as ::core::ffi::c_int;
            }
            x264_cabac_size_decision_noup(
                cb,
                (77 as ::core::ffi::c_int + ctx) as ::core::ffi::c_long,
                ((*h).mb.i_cbp_chroma >> 1 as ::core::ffi::c_int) as ::core::ffi::c_long,
            );
        };
    }
    #[c2rust::src_loc = "150:1"]
    pub unsafe extern "C" fn cabac_qp_delta(mut h: *mut x264_t, mut cb: *mut x264_cabac_t) {
        let mut i_dqp: ::core::ffi::c_int = (*h).mb.i_qp - (*h).mb.i_last_qp;
        let mut ctx: ::core::ffi::c_int = 0;
        if (*h).mb.i_type == I_16x16 as ::core::ffi::c_int
            && *(*h).mb.cbp.offset((*h).mb.i_mb_xy as isize) == 0
            && (*h).mb.i_qp > (*h).mb.i_last_qp
        {
            i_dqp = 0 as ::core::ffi::c_int;
        }
        ctx = ((*h).mb.i_last_dqp != 0
            && (*(*h).mb.type_0.offset((*h).mb.i_mb_prev_xy as isize) as ::core::ffi::c_int
                == I_16x16 as ::core::ffi::c_int
                || *(*h).mb.cbp.offset((*h).mb.i_mb_prev_xy as isize) as ::core::ffi::c_int
                    & 0x3f as ::core::ffi::c_int
                    != 0)) as ::core::ffi::c_int;
        if i_dqp != 0 as ::core::ffi::c_int {
            i_dqp *= 2 as ::core::ffi::c_int;
            let mut val: ::core::ffi::c_int = 1 as ::core::ffi::c_int - i_dqp;
            if val < 0 as ::core::ffi::c_int {
                val = i_dqp;
            }
            val -= 1;
            if val >= QP_MAX_SPEC && val != QP_MAX_SPEC + 1 as ::core::ffi::c_int {
                val = 2 as ::core::ffi::c_int * QP_MAX_SPEC + 1 as ::core::ffi::c_int - val;
            }
            loop {
                x264_cabac_size_decision(
                    cb,
                    (60 as ::core::ffi::c_int + ctx) as ::core::ffi::c_long,
                    1 as ::core::ffi::c_long,
                );
                ctx = 2 as ::core::ffi::c_int + (ctx >> 1 as ::core::ffi::c_int);
                val -= 1;
                if !(val != 0) {
                    break;
                }
            }
        }
        x264_cabac_size_decision_noup(
            cb,
            (60 as ::core::ffi::c_int + ctx) as ::core::ffi::c_long,
            0 as ::core::ffi::c_long,
        );
    }
    #[inline]
    #[c2rust::src_loc = "198:1"]
    pub unsafe extern "C" fn cabac_subpartition_p(
        mut cb: *mut x264_cabac_t,
        mut i_sub: ::core::ffi::c_int,
    ) {
        if i_sub == D_L0_8x8 as ::core::ffi::c_int {
            x264_cabac_size_decision(cb, 21 as ::core::ffi::c_long, 1 as ::core::ffi::c_long);
            return;
        }
        x264_cabac_size_decision(cb, 21 as ::core::ffi::c_long, 0 as ::core::ffi::c_long);
        if i_sub == D_L0_8x4 as ::core::ffi::c_int {
            x264_cabac_size_decision(cb, 22 as ::core::ffi::c_long, 0 as ::core::ffi::c_long);
        } else {
            x264_cabac_size_decision(cb, 22 as ::core::ffi::c_long, 1 as ::core::ffi::c_long);
            x264_cabac_size_decision(
                cb,
                23 as ::core::ffi::c_long,
                (i_sub == D_L0_4x8 as ::core::ffi::c_int) as ::core::ffi::c_int
                    as ::core::ffi::c_long,
            );
        };
    }
    #[inline(always)]
    #[c2rust::src_loc = "215:1"]
    pub unsafe extern "C" fn cabac_subpartition_b(
        mut cb: *mut x264_cabac_t,
        mut i_sub: ::core::ffi::c_int,
    ) {
        if i_sub == D_DIRECT_8x8 as ::core::ffi::c_int {
            x264_cabac_size_decision(cb, 36 as ::core::ffi::c_long, 0 as ::core::ffi::c_long);
            return;
        }
        x264_cabac_size_decision(cb, 36 as ::core::ffi::c_long, 1 as ::core::ffi::c_long);
        if i_sub == D_BI_8x8 as ::core::ffi::c_int {
            x264_cabac_size_decision(cb, 37 as ::core::ffi::c_long, 1 as ::core::ffi::c_long);
            x264_cabac_size_decision(cb, 38 as ::core::ffi::c_long, 0 as ::core::ffi::c_long);
            x264_cabac_size_decision(cb, 39 as ::core::ffi::c_long, 0 as ::core::ffi::c_long);
            x264_cabac_size_decision(cb, 39 as ::core::ffi::c_long, 0 as ::core::ffi::c_long);
            return;
        }
        x264_cabac_size_decision(cb, 37 as ::core::ffi::c_long, 0 as ::core::ffi::c_long);
        x264_cabac_size_decision(
            cb,
            39 as ::core::ffi::c_long,
            (i_sub == D_L1_8x8 as ::core::ffi::c_int) as ::core::ffi::c_int as ::core::ffi::c_long,
        );
    }
    #[inline(always)]
    #[c2rust::src_loc = "235:1"]
    pub unsafe extern "C" fn cabac_transform_size(mut h: *mut x264_t, mut cb: *mut x264_cabac_t) {
        let mut ctx: ::core::ffi::c_int =
            399 as ::core::ffi::c_int + (*h).mb.cache.i_neighbour_transform_size;
        x264_cabac_size_decision_noup(
            cb,
            ctx as ::core::ffi::c_long,
            (*h).mb.b_transform_8x8 as ::core::ffi::c_long,
        );
    }
    #[inline(always)]
    #[c2rust::src_loc = "241:1"]
    pub unsafe extern "C" fn cabac_ref_internal(
        mut h: *mut x264_t,
        mut cb: *mut x264_cabac_t,
        mut i_list: ::core::ffi::c_int,
        mut idx: ::core::ffi::c_int,
        mut bframe: ::core::ffi::c_int,
    ) {
        let i8: ::core::ffi::c_int = x264_scan8[idx as usize] as ::core::ffi::c_int;
        let i_refa: ::core::ffi::c_int = (*h).mb.cache.ref_0[i_list as usize]
            [(i8 - 1 as ::core::ffi::c_int) as usize]
            as ::core::ffi::c_int;
        let i_refb: ::core::ffi::c_int = (*h).mb.cache.ref_0[i_list as usize]
            [(i8 - 8 as ::core::ffi::c_int) as usize]
            as ::core::ffi::c_int;
        let mut ctx: ::core::ffi::c_int = 0 as ::core::ffi::c_int;
        if i_refa > 0 as ::core::ffi::c_int
            && (bframe == 0 || (*h).mb.cache.skip[(i8 - 1 as ::core::ffi::c_int) as usize] == 0)
        {
            ctx += 1;
        }
        if i_refb > 0 as ::core::ffi::c_int
            && (bframe == 0 || (*h).mb.cache.skip[(i8 - 8 as ::core::ffi::c_int) as usize] == 0)
        {
            ctx += 2 as ::core::ffi::c_int;
        }
        let mut i_ref: ::core::ffi::c_int =
            (*h).mb.cache.ref_0[i_list as usize][i8 as usize] as ::core::ffi::c_int;
        while i_ref > 0 as ::core::ffi::c_int {
            x264_cabac_size_decision(
                cb,
                (54 as ::core::ffi::c_int + ctx) as ::core::ffi::c_long,
                1 as ::core::ffi::c_long,
            );
            ctx = (ctx >> 2 as ::core::ffi::c_int) + 4 as ::core::ffi::c_int;
            i_ref -= 1;
        }
        x264_cabac_size_decision(
            cb,
            (54 as ::core::ffi::c_int + ctx) as ::core::ffi::c_long,
            0 as ::core::ffi::c_long,
        );
    }
    #[inline(never)]
    #[c2rust::src_loc = "261:1"]
    pub unsafe extern "C" fn cabac_ref_p(
        mut h: *mut x264_t,
        mut cb: *mut x264_cabac_t,
        mut idx: ::core::ffi::c_int,
    ) {
        cabac_ref_internal(h, cb, 0 as ::core::ffi::c_int, idx, 0 as ::core::ffi::c_int);
    }
    #[inline(never)]
    #[c2rust::src_loc = "265:1"]
    pub unsafe extern "C" fn cabac_ref_b(
        mut h: *mut x264_t,
        mut cb: *mut x264_cabac_t,
        mut i_list: ::core::ffi::c_int,
        mut idx: ::core::ffi::c_int,
    ) {
        cabac_ref_internal(h, cb, i_list, idx, 1 as ::core::ffi::c_int);
    }
    #[inline(always)]
    #[c2rust::src_loc = "270:1"]
    pub unsafe extern "C" fn cabac_mvd_cpn(
        mut h: *mut x264_t,
        mut cb: *mut x264_cabac_t,
        mut i_list: ::core::ffi::c_int,
        mut idx: ::core::ffi::c_int,
        mut l: ::core::ffi::c_int,
        mut mvd: ::core::ffi::c_int,
        mut ctx: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int {
        let mut ctxbase: ::core::ffi::c_int = if l != 0 {
            47 as ::core::ffi::c_int
        } else {
            40 as ::core::ffi::c_int
        };
        if mvd == 0 as ::core::ffi::c_int {
            x264_cabac_size_decision(
                cb,
                (ctxbase + ctx) as ::core::ffi::c_long,
                0 as ::core::ffi::c_long,
            );
            return 0 as ::core::ffi::c_int;
        }
        let mut i_abs: ::core::ffi::c_int = abs(mvd);
        x264_cabac_size_decision(
            cb,
            (ctxbase + ctx) as ::core::ffi::c_long,
            1 as ::core::ffi::c_long,
        );
        if i_abs <= 3 as ::core::ffi::c_int {
            let mut i: ::core::ffi::c_int = 1 as ::core::ffi::c_int;
            while i < i_abs {
                x264_cabac_size_decision(
                    cb,
                    (ctxbase + i + 2 as ::core::ffi::c_int) as ::core::ffi::c_long,
                    1 as ::core::ffi::c_long,
                );
                i += 1;
            }
            x264_cabac_size_decision(
                cb,
                (ctxbase + i_abs + 2 as ::core::ffi::c_int) as ::core::ffi::c_long,
                0 as ::core::ffi::c_long,
            );
            (*cb).f8_bits_encoded += 256 as ::core::ffi::c_int;
        } else {
            x264_cabac_size_decision(
                cb,
                (ctxbase + 3 as ::core::ffi::c_int) as ::core::ffi::c_long,
                1 as ::core::ffi::c_long,
            );
            x264_cabac_size_decision(
                cb,
                (ctxbase + 4 as ::core::ffi::c_int) as ::core::ffi::c_long,
                1 as ::core::ffi::c_long,
            );
            x264_cabac_size_decision(
                cb,
                (ctxbase + 5 as ::core::ffi::c_int) as ::core::ffi::c_long,
                1 as ::core::ffi::c_long,
            );
            if i_abs < 9 as ::core::ffi::c_int {
                (*cb).f8_bits_encoded += x264_10_cabac_size_unary
                    [(i_abs - 3 as ::core::ffi::c_int) as usize]
                    [(*cb).state[(ctxbase + 6 as ::core::ffi::c_int) as usize] as usize]
                    as ::core::ffi::c_int;
                (*cb).state[(ctxbase + 6 as ::core::ffi::c_int) as usize] =
                    x264_10_cabac_transition_unary[(i_abs - 3 as ::core::ffi::c_int) as usize]
                        [(*cb).state[(ctxbase + 6 as ::core::ffi::c_int) as usize] as usize];
            } else {
                (*cb).f8_bits_encoded += cabac_size_5ones
                    [(*cb).state[(ctxbase + 6 as ::core::ffi::c_int) as usize] as usize]
                    as ::core::ffi::c_int;
                (*cb).state[(ctxbase + 6 as ::core::ffi::c_int) as usize] = cabac_transition_5ones
                    [(*cb).state[(ctxbase + 6 as ::core::ffi::c_int) as usize] as usize];
                (*cb).f8_bits_encoded += (bs_size_ue_big(
                    (i_abs - 9 as ::core::ffi::c_int
                        + ((1 as ::core::ffi::c_int) << 3 as ::core::ffi::c_int)
                        - 1 as ::core::ffi::c_int) as ::core::ffi::c_uint,
                ) - 3 as ::core::ffi::c_int)
                    << 8 as ::core::ffi::c_int;
            }
        }
        return if i_abs < 66 as ::core::ffi::c_int {
            i_abs
        } else {
            66 as ::core::ffi::c_int
        };
    }
    #[inline(never)]
    #[c2rust::src_loc = "329:1"]
    pub unsafe extern "C" fn cabac_mvd(
        mut h: *mut x264_t,
        mut cb: *mut x264_cabac_t,
        mut i_list: ::core::ffi::c_int,
        mut idx: ::core::ffi::c_int,
        mut width: ::core::ffi::c_int,
    ) -> uint16_t {
        let mut mvp: [int16_t; 2] = [0; 2];
        let mut mdx: ::core::ffi::c_int = 0;
        let mut mdy: ::core::ffi::c_int = 0;
        x264_10_mb_predict_mv(h, i_list, idx, width, mvp.as_mut_ptr());
        mdx = (*h).mb.cache.mv[i_list as usize][x264_scan8[idx as usize] as usize]
            [0 as ::core::ffi::c_int as usize] as ::core::ffi::c_int
            - mvp[0 as ::core::ffi::c_int as usize] as ::core::ffi::c_int;
        mdy = (*h).mb.cache.mv[i_list as usize][x264_scan8[idx as usize] as usize]
            [1 as ::core::ffi::c_int as usize] as ::core::ffi::c_int
            - mvp[1 as ::core::ffi::c_int as usize] as ::core::ffi::c_int;
        let mut amvd: uint16_t = x264_cabac_mvd_sum(
            (*(*(*h).mb.cache.mvd.as_mut_ptr().offset(i_list as isize))
                .as_mut_ptr()
                .offset(
                    (*x264_scan8.as_ptr().offset(idx as isize) as ::core::ffi::c_int
                        - 1 as ::core::ffi::c_int) as isize,
                ))
            .as_mut_ptr(),
            (*(*(*h).mb.cache.mvd.as_mut_ptr().offset(i_list as isize))
                .as_mut_ptr()
                .offset(
                    (*x264_scan8.as_ptr().offset(idx as isize) as ::core::ffi::c_int
                        - 8 as ::core::ffi::c_int) as isize,
                ))
            .as_mut_ptr(),
        );
        mdx = cabac_mvd_cpn(
            h,
            cb,
            i_list,
            idx,
            0 as ::core::ffi::c_int,
            mdx,
            amvd as ::core::ffi::c_int & 0xff as ::core::ffi::c_int,
        );
        mdy = cabac_mvd_cpn(
            h,
            cb,
            i_list,
            idx,
            1 as ::core::ffi::c_int,
            mdy,
            amvd as ::core::ffi::c_int >> 8 as ::core::ffi::c_int,
        );
        return pack8to16(mdx as uint32_t, mdy as uint32_t) as uint16_t;
    }
    #[inline]
    #[c2rust::src_loc = "355:1"]
    pub unsafe extern "C" fn cabac_8x8_mvd(
        mut h: *mut x264_t,
        mut cb: *mut x264_cabac_t,
        mut i: ::core::ffi::c_int,
    ) {
        match (*h).mb.i_sub_partition[i as usize] as ::core::ffi::c_int {
            3 => {
                let mut mvd: uint16_t = cabac_mvd(
                    h,
                    cb,
                    0 as ::core::ffi::c_int,
                    4 as ::core::ffi::c_int * i,
                    2 as ::core::ffi::c_int,
                );
                x264_macroblock_cache_mvd(
                    h,
                    block_idx_x[(4 as ::core::ffi::c_int * i) as usize] as ::core::ffi::c_int,
                    block_idx_y[(4 as ::core::ffi::c_int * i) as usize] as ::core::ffi::c_int,
                    2 as ::core::ffi::c_int,
                    2 as ::core::ffi::c_int,
                    0 as ::core::ffi::c_int,
                    mvd,
                );
            }
            1 => {
                let mut mvd_0: uint16_t = cabac_mvd(
                    h,
                    cb,
                    0 as ::core::ffi::c_int,
                    4 as ::core::ffi::c_int * i + 0 as ::core::ffi::c_int,
                    2 as ::core::ffi::c_int,
                );
                x264_macroblock_cache_mvd(
                    h,
                    block_idx_x[(4 as ::core::ffi::c_int * i + 0 as ::core::ffi::c_int) as usize]
                        as ::core::ffi::c_int,
                    block_idx_y[(4 as ::core::ffi::c_int * i + 0 as ::core::ffi::c_int) as usize]
                        as ::core::ffi::c_int,
                    2 as ::core::ffi::c_int,
                    1 as ::core::ffi::c_int,
                    0 as ::core::ffi::c_int,
                    mvd_0,
                );
                let mut mvd_1: uint16_t = cabac_mvd(
                    h,
                    cb,
                    0 as ::core::ffi::c_int,
                    4 as ::core::ffi::c_int * i + 2 as ::core::ffi::c_int,
                    2 as ::core::ffi::c_int,
                );
                x264_macroblock_cache_mvd(
                    h,
                    block_idx_x[(4 as ::core::ffi::c_int * i + 2 as ::core::ffi::c_int) as usize]
                        as ::core::ffi::c_int,
                    block_idx_y[(4 as ::core::ffi::c_int * i + 2 as ::core::ffi::c_int) as usize]
                        as ::core::ffi::c_int,
                    2 as ::core::ffi::c_int,
                    1 as ::core::ffi::c_int,
                    0 as ::core::ffi::c_int,
                    mvd_1,
                );
            }
            2 => {
                let mut mvd_2: uint16_t = cabac_mvd(
                    h,
                    cb,
                    0 as ::core::ffi::c_int,
                    4 as ::core::ffi::c_int * i + 0 as ::core::ffi::c_int,
                    1 as ::core::ffi::c_int,
                );
                x264_macroblock_cache_mvd(
                    h,
                    block_idx_x[(4 as ::core::ffi::c_int * i + 0 as ::core::ffi::c_int) as usize]
                        as ::core::ffi::c_int,
                    block_idx_y[(4 as ::core::ffi::c_int * i + 0 as ::core::ffi::c_int) as usize]
                        as ::core::ffi::c_int,
                    1 as ::core::ffi::c_int,
                    2 as ::core::ffi::c_int,
                    0 as ::core::ffi::c_int,
                    mvd_2,
                );
                let mut mvd_3: uint16_t = cabac_mvd(
                    h,
                    cb,
                    0 as ::core::ffi::c_int,
                    4 as ::core::ffi::c_int * i + 1 as ::core::ffi::c_int,
                    1 as ::core::ffi::c_int,
                );
                x264_macroblock_cache_mvd(
                    h,
                    block_idx_x[(4 as ::core::ffi::c_int * i + 1 as ::core::ffi::c_int) as usize]
                        as ::core::ffi::c_int,
                    block_idx_y[(4 as ::core::ffi::c_int * i + 1 as ::core::ffi::c_int) as usize]
                        as ::core::ffi::c_int,
                    1 as ::core::ffi::c_int,
                    2 as ::core::ffi::c_int,
                    0 as ::core::ffi::c_int,
                    mvd_3,
                );
            }
            0 => {
                let mut mvd_4: uint16_t = cabac_mvd(
                    h,
                    cb,
                    0 as ::core::ffi::c_int,
                    4 as ::core::ffi::c_int * i + 0 as ::core::ffi::c_int,
                    1 as ::core::ffi::c_int,
                );
                x264_macroblock_cache_mvd(
                    h,
                    block_idx_x[(4 as ::core::ffi::c_int * i + 0 as ::core::ffi::c_int) as usize]
                        as ::core::ffi::c_int,
                    block_idx_y[(4 as ::core::ffi::c_int * i + 0 as ::core::ffi::c_int) as usize]
                        as ::core::ffi::c_int,
                    1 as ::core::ffi::c_int,
                    1 as ::core::ffi::c_int,
                    0 as ::core::ffi::c_int,
                    mvd_4,
                );
                let mut mvd_5: uint16_t = cabac_mvd(
                    h,
                    cb,
                    0 as ::core::ffi::c_int,
                    4 as ::core::ffi::c_int * i + 1 as ::core::ffi::c_int,
                    1 as ::core::ffi::c_int,
                );
                x264_macroblock_cache_mvd(
                    h,
                    block_idx_x[(4 as ::core::ffi::c_int * i + 1 as ::core::ffi::c_int) as usize]
                        as ::core::ffi::c_int,
                    block_idx_y[(4 as ::core::ffi::c_int * i + 1 as ::core::ffi::c_int) as usize]
                        as ::core::ffi::c_int,
                    1 as ::core::ffi::c_int,
                    1 as ::core::ffi::c_int,
                    0 as ::core::ffi::c_int,
                    mvd_5,
                );
                let mut mvd_6: uint16_t = cabac_mvd(
                    h,
                    cb,
                    0 as ::core::ffi::c_int,
                    4 as ::core::ffi::c_int * i + 2 as ::core::ffi::c_int,
                    1 as ::core::ffi::c_int,
                );
                x264_macroblock_cache_mvd(
                    h,
                    block_idx_x[(4 as ::core::ffi::c_int * i + 2 as ::core::ffi::c_int) as usize]
                        as ::core::ffi::c_int,
                    block_idx_y[(4 as ::core::ffi::c_int * i + 2 as ::core::ffi::c_int) as usize]
                        as ::core::ffi::c_int,
                    1 as ::core::ffi::c_int,
                    1 as ::core::ffi::c_int,
                    0 as ::core::ffi::c_int,
                    mvd_6,
                );
                let mut mvd_7: uint16_t = cabac_mvd(
                    h,
                    cb,
                    0 as ::core::ffi::c_int,
                    4 as ::core::ffi::c_int * i + 3 as ::core::ffi::c_int,
                    1 as ::core::ffi::c_int,
                );
                x264_macroblock_cache_mvd(
                    h,
                    block_idx_x[(4 as ::core::ffi::c_int * i + 3 as ::core::ffi::c_int) as usize]
                        as ::core::ffi::c_int,
                    block_idx_y[(4 as ::core::ffi::c_int * i + 3 as ::core::ffi::c_int) as usize]
                        as ::core::ffi::c_int,
                    1 as ::core::ffi::c_int,
                    1 as ::core::ffi::c_int,
                    0 as ::core::ffi::c_int,
                    mvd_7,
                );
            }
            _ => {
                __assert_fail(
                    b"0\0" as *const u8 as *const ::core::ffi::c_char,
                    b"encoder/cabac.c\0" as *const u8 as *const ::core::ffi::c_char,
                    377 as ::core::ffi::c_uint,
                    ::core::mem::transmute::<[u8; 50], [::core::ffi::c_char; 50]>(
                        *b"void cabac_8x8_mvd(x264_t *, x264_cabac_t *, int)\0",
                    )
                    .as_ptr(),
                );
                'c_42519: {
                    __assert_fail(
                        b"0\0" as *const u8 as *const ::core::ffi::c_char,
                        b"encoder/cabac.c\0" as *const u8 as *const ::core::ffi::c_char,
                        377 as ::core::ffi::c_uint,
                        ::core::mem::transmute::<[u8; 50], [::core::ffi::c_char; 50]>(
                            *b"void cabac_8x8_mvd(x264_t *, x264_cabac_t *, int)\0",
                        )
                        .as_ptr(),
                    );
                };
            }
        };
    }
    #[inline(always)]
    #[c2rust::src_loc = "381:1"]
    pub unsafe extern "C" fn cabac_mb_header_i(
        mut h: *mut x264_t,
        mut cb: *mut x264_cabac_t,
        mut i_mb_type: ::core::ffi::c_int,
        mut slice_type: ::core::ffi::c_int,
        mut chroma: ::core::ffi::c_int,
    ) {
        if slice_type == SLICE_TYPE_I as ::core::ffi::c_int {
            let mut ctx: ::core::ffi::c_int = 0 as ::core::ffi::c_int;
            if (*h).mb.i_neighbour & MB_LEFT as ::core::ffi::c_int as ::core::ffi::c_uint != 0
                && (*h).mb.i_mb_type_left[0 as ::core::ffi::c_int as usize]
                    != I_4x4 as ::core::ffi::c_int
            {
                ctx += 1;
            }
            if (*h).mb.i_neighbour & MB_TOP as ::core::ffi::c_int as ::core::ffi::c_uint != 0
                && (*h).mb.i_mb_type_top != I_4x4 as ::core::ffi::c_int
            {
                ctx += 1;
            }
            cabac_mb_type_intra(
                h,
                cb,
                i_mb_type,
                3 as ::core::ffi::c_int + ctx,
                3 as ::core::ffi::c_int + 3 as ::core::ffi::c_int,
                3 as ::core::ffi::c_int + 4 as ::core::ffi::c_int,
                3 as ::core::ffi::c_int + 5 as ::core::ffi::c_int,
                3 as ::core::ffi::c_int + 6 as ::core::ffi::c_int,
                3 as ::core::ffi::c_int + 7 as ::core::ffi::c_int,
            );
        } else if slice_type == SLICE_TYPE_P as ::core::ffi::c_int {
            x264_cabac_size_decision_noup(cb, 14 as ::core::ffi::c_long, 1 as ::core::ffi::c_long);
            cabac_mb_type_intra(
                h,
                cb,
                i_mb_type,
                17 as ::core::ffi::c_int + 0 as ::core::ffi::c_int,
                17 as ::core::ffi::c_int + 1 as ::core::ffi::c_int,
                17 as ::core::ffi::c_int + 2 as ::core::ffi::c_int,
                17 as ::core::ffi::c_int + 2 as ::core::ffi::c_int,
                17 as ::core::ffi::c_int + 3 as ::core::ffi::c_int,
                17 as ::core::ffi::c_int + 3 as ::core::ffi::c_int,
            );
        } else if slice_type == SLICE_TYPE_B as ::core::ffi::c_int {
            x264_cabac_size_decision_noup(
                cb,
                (27 as ::core::ffi::c_int + 3 as ::core::ffi::c_int) as ::core::ffi::c_long,
                1 as ::core::ffi::c_long,
            );
            x264_cabac_size_decision_noup(
                cb,
                (27 as ::core::ffi::c_int + 4 as ::core::ffi::c_int) as ::core::ffi::c_long,
                1 as ::core::ffi::c_long,
            );
            x264_cabac_size_decision(
                cb,
                (27 as ::core::ffi::c_int + 5 as ::core::ffi::c_int) as ::core::ffi::c_long,
                1 as ::core::ffi::c_long,
            );
            x264_cabac_size_decision(
                cb,
                (27 as ::core::ffi::c_int + 5 as ::core::ffi::c_int) as ::core::ffi::c_long,
                0 as ::core::ffi::c_long,
            );
            x264_cabac_size_decision(
                cb,
                (27 as ::core::ffi::c_int + 5 as ::core::ffi::c_int) as ::core::ffi::c_long,
                1 as ::core::ffi::c_long,
            );
            cabac_mb_type_intra(
                h,
                cb,
                i_mb_type,
                32 as ::core::ffi::c_int + 0 as ::core::ffi::c_int,
                32 as ::core::ffi::c_int + 1 as ::core::ffi::c_int,
                32 as ::core::ffi::c_int + 2 as ::core::ffi::c_int,
                32 as ::core::ffi::c_int + 2 as ::core::ffi::c_int,
                32 as ::core::ffi::c_int + 3 as ::core::ffi::c_int,
                32 as ::core::ffi::c_int + 3 as ::core::ffi::c_int,
            );
        }
        if i_mb_type == I_PCM as ::core::ffi::c_int {
            return;
        }
        if i_mb_type != I_16x16 as ::core::ffi::c_int {
            if (*(*h).pps.as_mut_ptr()).b_transform_8x8_mode != 0 {
                cabac_transform_size(h, cb);
            }
            let mut di: ::core::ffi::c_int = if (*h).mb.b_transform_8x8 != 0 {
                4 as ::core::ffi::c_int
            } else {
                1 as ::core::ffi::c_int
            };
            let mut i: ::core::ffi::c_int = 0 as ::core::ffi::c_int;
            while i < 16 as ::core::ffi::c_int {
                let i_pred: ::core::ffi::c_int =
                    x264_mb_predict_intra4x4_mode(h, i) as ::core::ffi::c_int;
                let i_mode: ::core::ffi::c_int =
                    x264_mb_pred_mode4x4_fix[((*h).mb.cache.intra4x4_pred_mode
                        [x264_scan8[i as usize] as usize]
                        as ::core::ffi::c_int
                        + 1 as ::core::ffi::c_int)
                        as usize] as ::core::ffi::c_int;
                cabac_intra4x4_pred_mode(cb, i_pred, i_mode);
                i += di;
            }
        }
        if chroma != 0 {
            cabac_intra_chroma_pred_mode(h, cb);
        }
    }
    #[inline(always)]
    #[c2rust::src_loc = "435:1"]
    pub unsafe extern "C" fn cabac_mb_header_p(
        mut h: *mut x264_t,
        mut cb: *mut x264_cabac_t,
        mut i_mb_type: ::core::ffi::c_int,
        mut chroma: ::core::ffi::c_int,
    ) {
        if i_mb_type == P_L0 as ::core::ffi::c_int {
            x264_cabac_size_decision_noup(cb, 14 as ::core::ffi::c_long, 0 as ::core::ffi::c_long);
            if (*h).mb.i_partition == D_16x16 as ::core::ffi::c_int {
                x264_cabac_size_decision_noup(
                    cb,
                    15 as ::core::ffi::c_long,
                    0 as ::core::ffi::c_long,
                );
                x264_cabac_size_decision_noup(
                    cb,
                    16 as ::core::ffi::c_long,
                    0 as ::core::ffi::c_long,
                );
                if (*h).mb.pic.i_fref[0 as ::core::ffi::c_int as usize] > 1 as ::core::ffi::c_int {
                    cabac_ref_p(h, cb, 0 as ::core::ffi::c_int);
                }
                let mut mvd: uint16_t = cabac_mvd(
                    h,
                    cb,
                    0 as ::core::ffi::c_int,
                    0 as ::core::ffi::c_int,
                    4 as ::core::ffi::c_int,
                );
                x264_macroblock_cache_mvd(
                    h,
                    block_idx_x[0 as ::core::ffi::c_int as usize] as ::core::ffi::c_int,
                    block_idx_y[0 as ::core::ffi::c_int as usize] as ::core::ffi::c_int,
                    4 as ::core::ffi::c_int,
                    4 as ::core::ffi::c_int,
                    0 as ::core::ffi::c_int,
                    mvd,
                );
            } else if (*h).mb.i_partition == D_16x8 as ::core::ffi::c_int {
                x264_cabac_size_decision_noup(
                    cb,
                    15 as ::core::ffi::c_long,
                    1 as ::core::ffi::c_long,
                );
                x264_cabac_size_decision_noup(
                    cb,
                    17 as ::core::ffi::c_long,
                    1 as ::core::ffi::c_long,
                );
                if (*h).mb.pic.i_fref[0 as ::core::ffi::c_int as usize] > 1 as ::core::ffi::c_int {
                    cabac_ref_p(h, cb, 0 as ::core::ffi::c_int);
                    cabac_ref_p(h, cb, 8 as ::core::ffi::c_int);
                }
                let mut mvd_0: uint16_t = cabac_mvd(
                    h,
                    cb,
                    0 as ::core::ffi::c_int,
                    0 as ::core::ffi::c_int,
                    4 as ::core::ffi::c_int,
                );
                x264_macroblock_cache_mvd(
                    h,
                    block_idx_x[0 as ::core::ffi::c_int as usize] as ::core::ffi::c_int,
                    block_idx_y[0 as ::core::ffi::c_int as usize] as ::core::ffi::c_int,
                    4 as ::core::ffi::c_int,
                    2 as ::core::ffi::c_int,
                    0 as ::core::ffi::c_int,
                    mvd_0,
                );
                let mut mvd_1: uint16_t = cabac_mvd(
                    h,
                    cb,
                    0 as ::core::ffi::c_int,
                    8 as ::core::ffi::c_int,
                    4 as ::core::ffi::c_int,
                );
                x264_macroblock_cache_mvd(
                    h,
                    block_idx_x[8 as ::core::ffi::c_int as usize] as ::core::ffi::c_int,
                    block_idx_y[8 as ::core::ffi::c_int as usize] as ::core::ffi::c_int,
                    4 as ::core::ffi::c_int,
                    2 as ::core::ffi::c_int,
                    0 as ::core::ffi::c_int,
                    mvd_1,
                );
            } else {
                x264_cabac_size_decision_noup(
                    cb,
                    15 as ::core::ffi::c_long,
                    1 as ::core::ffi::c_long,
                );
                x264_cabac_size_decision_noup(
                    cb,
                    17 as ::core::ffi::c_long,
                    0 as ::core::ffi::c_long,
                );
                if (*h).mb.pic.i_fref[0 as ::core::ffi::c_int as usize] > 1 as ::core::ffi::c_int {
                    cabac_ref_p(h, cb, 0 as ::core::ffi::c_int);
                    cabac_ref_p(h, cb, 4 as ::core::ffi::c_int);
                }
                let mut mvd_2: uint16_t = cabac_mvd(
                    h,
                    cb,
                    0 as ::core::ffi::c_int,
                    0 as ::core::ffi::c_int,
                    2 as ::core::ffi::c_int,
                );
                x264_macroblock_cache_mvd(
                    h,
                    block_idx_x[0 as ::core::ffi::c_int as usize] as ::core::ffi::c_int,
                    block_idx_y[0 as ::core::ffi::c_int as usize] as ::core::ffi::c_int,
                    2 as ::core::ffi::c_int,
                    4 as ::core::ffi::c_int,
                    0 as ::core::ffi::c_int,
                    mvd_2,
                );
                let mut mvd_3: uint16_t = cabac_mvd(
                    h,
                    cb,
                    0 as ::core::ffi::c_int,
                    4 as ::core::ffi::c_int,
                    2 as ::core::ffi::c_int,
                );
                x264_macroblock_cache_mvd(
                    h,
                    block_idx_x[4 as ::core::ffi::c_int as usize] as ::core::ffi::c_int,
                    block_idx_y[4 as ::core::ffi::c_int as usize] as ::core::ffi::c_int,
                    2 as ::core::ffi::c_int,
                    4 as ::core::ffi::c_int,
                    0 as ::core::ffi::c_int,
                    mvd_3,
                );
            }
        } else if i_mb_type == P_8x8 as ::core::ffi::c_int {
            x264_cabac_size_decision_noup(cb, 14 as ::core::ffi::c_long, 0 as ::core::ffi::c_long);
            x264_cabac_size_decision_noup(cb, 15 as ::core::ffi::c_long, 0 as ::core::ffi::c_long);
            x264_cabac_size_decision_noup(cb, 16 as ::core::ffi::c_long, 1 as ::core::ffi::c_long);
            let mut i: ::core::ffi::c_int = 0 as ::core::ffi::c_int;
            while i < 4 as ::core::ffi::c_int {
                cabac_subpartition_p(
                    cb,
                    (*h).mb.i_sub_partition[i as usize] as ::core::ffi::c_int,
                );
                i += 1;
            }
            if (*h).mb.pic.i_fref[0 as ::core::ffi::c_int as usize] > 1 as ::core::ffi::c_int {
                cabac_ref_p(h, cb, 0 as ::core::ffi::c_int);
                cabac_ref_p(h, cb, 4 as ::core::ffi::c_int);
                cabac_ref_p(h, cb, 8 as ::core::ffi::c_int);
                cabac_ref_p(h, cb, 12 as ::core::ffi::c_int);
            }
            let mut i_0: ::core::ffi::c_int = 0 as ::core::ffi::c_int;
            while i_0 < 4 as ::core::ffi::c_int {
                cabac_8x8_mvd(h, cb, i_0);
                i_0 += 1;
            }
        } else {
            cabac_mb_header_i(h, cb, i_mb_type, SLICE_TYPE_P as ::core::ffi::c_int, chroma);
        };
    }
    #[inline(always)]
    #[c2rust::src_loc = "499:1"]
    pub unsafe extern "C" fn cabac_mb_header_b(
        mut h: *mut x264_t,
        mut cb: *mut x264_cabac_t,
        mut i_mb_type: ::core::ffi::c_int,
        mut chroma: ::core::ffi::c_int,
    ) {
        let mut ctx: ::core::ffi::c_int = 0 as ::core::ffi::c_int;
        if (*h).mb.i_neighbour & MB_LEFT as ::core::ffi::c_int as ::core::ffi::c_uint != 0
            && (*h).mb.i_mb_type_left[0 as ::core::ffi::c_int as usize]
                != B_SKIP as ::core::ffi::c_int
            && (*h).mb.i_mb_type_left[0 as ::core::ffi::c_int as usize]
                != B_DIRECT as ::core::ffi::c_int
        {
            ctx += 1;
        }
        if (*h).mb.i_neighbour & MB_TOP as ::core::ffi::c_int as ::core::ffi::c_uint != 0
            && (*h).mb.i_mb_type_top != B_SKIP as ::core::ffi::c_int
            && (*h).mb.i_mb_type_top != B_DIRECT as ::core::ffi::c_int
        {
            ctx += 1;
        }
        if i_mb_type == B_DIRECT as ::core::ffi::c_int {
            x264_cabac_size_decision_noup(
                cb,
                (27 as ::core::ffi::c_int + ctx) as ::core::ffi::c_long,
                0 as ::core::ffi::c_long,
            );
            return;
        }
        x264_cabac_size_decision_noup(
            cb,
            (27 as ::core::ffi::c_int + ctx) as ::core::ffi::c_long,
            1 as ::core::ffi::c_long,
        );
        if i_mb_type == B_8x8 as ::core::ffi::c_int {
            x264_cabac_size_decision_noup(
                cb,
                (27 as ::core::ffi::c_int + 3 as ::core::ffi::c_int) as ::core::ffi::c_long,
                1 as ::core::ffi::c_long,
            );
            x264_cabac_size_decision_noup(
                cb,
                (27 as ::core::ffi::c_int + 4 as ::core::ffi::c_int) as ::core::ffi::c_long,
                1 as ::core::ffi::c_long,
            );
            x264_cabac_size_decision(
                cb,
                (27 as ::core::ffi::c_int + 5 as ::core::ffi::c_int) as ::core::ffi::c_long,
                1 as ::core::ffi::c_long,
            );
            x264_cabac_size_decision(
                cb,
                (27 as ::core::ffi::c_int + 5 as ::core::ffi::c_int) as ::core::ffi::c_long,
                1 as ::core::ffi::c_long,
            );
            x264_cabac_size_decision_noup(
                cb,
                (27 as ::core::ffi::c_int + 5 as ::core::ffi::c_int) as ::core::ffi::c_long,
                1 as ::core::ffi::c_long,
            );
            let mut i: ::core::ffi::c_int = 0 as ::core::ffi::c_int;
            while i < 4 as ::core::ffi::c_int {
                cabac_subpartition_b(
                    cb,
                    (*h).mb.i_sub_partition[i as usize] as ::core::ffi::c_int,
                );
                i += 1;
            }
            if (*h).mb.pic.i_fref[0 as ::core::ffi::c_int as usize] > 1 as ::core::ffi::c_int {
                let mut i_0: ::core::ffi::c_int = 0 as ::core::ffi::c_int;
                while i_0 < 4 as ::core::ffi::c_int {
                    if x264_mb_partition_listX_table[0 as ::core::ffi::c_int as usize]
                        [(*h).mb.i_sub_partition[i_0 as usize] as usize]
                        != 0
                    {
                        cabac_ref_b(
                            h,
                            cb,
                            0 as ::core::ffi::c_int,
                            4 as ::core::ffi::c_int * i_0,
                        );
                    }
                    i_0 += 1;
                }
            }
            if (*h).mb.pic.i_fref[1 as ::core::ffi::c_int as usize] > 1 as ::core::ffi::c_int {
                let mut i_1: ::core::ffi::c_int = 0 as ::core::ffi::c_int;
                while i_1 < 4 as ::core::ffi::c_int {
                    if x264_mb_partition_listX_table[1 as ::core::ffi::c_int as usize]
                        [(*h).mb.i_sub_partition[i_1 as usize] as usize]
                        != 0
                    {
                        cabac_ref_b(
                            h,
                            cb,
                            1 as ::core::ffi::c_int,
                            4 as ::core::ffi::c_int * i_1,
                        );
                    }
                    i_1 += 1;
                }
            }
            let mut i_2: ::core::ffi::c_int = 0 as ::core::ffi::c_int;
            while i_2 < 4 as ::core::ffi::c_int {
                if x264_mb_partition_listX_table[0 as ::core::ffi::c_int as usize]
                    [(*h).mb.i_sub_partition[i_2 as usize] as usize]
                    != 0
                {
                    let mut mvd: uint16_t = cabac_mvd(
                        h,
                        cb,
                        0 as ::core::ffi::c_int,
                        4 as ::core::ffi::c_int * i_2,
                        2 as ::core::ffi::c_int,
                    );
                    x264_macroblock_cache_mvd(
                        h,
                        block_idx_x[(4 as ::core::ffi::c_int * i_2) as usize] as ::core::ffi::c_int,
                        block_idx_y[(4 as ::core::ffi::c_int * i_2) as usize] as ::core::ffi::c_int,
                        2 as ::core::ffi::c_int,
                        2 as ::core::ffi::c_int,
                        0 as ::core::ffi::c_int,
                        mvd,
                    );
                }
                i_2 += 1;
            }
            let mut i_3: ::core::ffi::c_int = 0 as ::core::ffi::c_int;
            while i_3 < 4 as ::core::ffi::c_int {
                if x264_mb_partition_listX_table[1 as ::core::ffi::c_int as usize]
                    [(*h).mb.i_sub_partition[i_3 as usize] as usize]
                    != 0
                {
                    let mut mvd_0: uint16_t = cabac_mvd(
                        h,
                        cb,
                        1 as ::core::ffi::c_int,
                        4 as ::core::ffi::c_int * i_3,
                        2 as ::core::ffi::c_int,
                    );
                    x264_macroblock_cache_mvd(
                        h,
                        block_idx_x[(4 as ::core::ffi::c_int * i_3) as usize] as ::core::ffi::c_int,
                        block_idx_y[(4 as ::core::ffi::c_int * i_3) as usize] as ::core::ffi::c_int,
                        2 as ::core::ffi::c_int,
                        2 as ::core::ffi::c_int,
                        1 as ::core::ffi::c_int,
                        mvd_0,
                    );
                }
                i_3 += 1;
            }
        } else if i_mb_type >= B_L0_L0 as ::core::ffi::c_int
            && i_mb_type <= B_BI_BI as ::core::ffi::c_int
        {
            pub static mut i_mb_bits: [uint8_t; 27] = [
                0x31 as ::core::ffi::c_int as uint8_t,
                0x29 as ::core::ffi::c_int as uint8_t,
                0x4 as ::core::ffi::c_int as uint8_t,
                0x35 as ::core::ffi::c_int as uint8_t,
                0x2d as ::core::ffi::c_int as uint8_t,
                0 as ::core::ffi::c_int as uint8_t,
                0x43 as ::core::ffi::c_int as uint8_t,
                0x63 as ::core::ffi::c_int as uint8_t,
                0 as ::core::ffi::c_int as uint8_t,
                0x3d as ::core::ffi::c_int as uint8_t,
                0x2f as ::core::ffi::c_int as uint8_t,
                0 as ::core::ffi::c_int as uint8_t,
                0x39 as ::core::ffi::c_int as uint8_t,
                0x25 as ::core::ffi::c_int as uint8_t,
                0x6 as ::core::ffi::c_int as uint8_t,
                0x53 as ::core::ffi::c_int as uint8_t,
                0x73 as ::core::ffi::c_int as uint8_t,
                0 as ::core::ffi::c_int as uint8_t,
                0x4b as ::core::ffi::c_int as uint8_t,
                0x6b as ::core::ffi::c_int as uint8_t,
                0 as ::core::ffi::c_int as uint8_t,
                0x5b as ::core::ffi::c_int as uint8_t,
                0x7b as ::core::ffi::c_int as uint8_t,
                0 as ::core::ffi::c_int as uint8_t,
                0x47 as ::core::ffi::c_int as uint8_t,
                0x67 as ::core::ffi::c_int as uint8_t,
                0x21 as ::core::ffi::c_int as uint8_t,
            ];
            let idx: ::core::ffi::c_int = (i_mb_type
                - B_L0_L0 as ::core::ffi::c_int as ::core::ffi::c_int)
                * 3 as ::core::ffi::c_int
                + ((*h).mb.i_partition - D_16x8 as ::core::ffi::c_int as ::core::ffi::c_int);
            let mut bits: ::core::ffi::c_int = i_mb_bits[idx as usize] as ::core::ffi::c_int;
            x264_cabac_size_decision_noup(
                cb,
                (27 as ::core::ffi::c_int + 3 as ::core::ffi::c_int) as ::core::ffi::c_long,
                (bits & 1 as ::core::ffi::c_int) as ::core::ffi::c_long,
            );
            x264_cabac_size_decision(
                cb,
                (27 as ::core::ffi::c_int + 5 as ::core::ffi::c_int
                    - (bits & 1 as ::core::ffi::c_int)) as ::core::ffi::c_long,
                (bits >> 1 as ::core::ffi::c_int & 1 as ::core::ffi::c_int) as ::core::ffi::c_long,
            );
            bits >>= 2 as ::core::ffi::c_int;
            if bits != 1 as ::core::ffi::c_int {
                x264_cabac_size_decision(
                    cb,
                    (27 as ::core::ffi::c_int + 5 as ::core::ffi::c_int) as ::core::ffi::c_long,
                    (bits & 1 as ::core::ffi::c_int) as ::core::ffi::c_long,
                );
                bits >>= 1 as ::core::ffi::c_int;
                x264_cabac_size_decision(
                    cb,
                    (27 as ::core::ffi::c_int + 5 as ::core::ffi::c_int) as ::core::ffi::c_long,
                    (bits & 1 as ::core::ffi::c_int) as ::core::ffi::c_long,
                );
                bits >>= 1 as ::core::ffi::c_int;
                x264_cabac_size_decision(
                    cb,
                    (27 as ::core::ffi::c_int + 5 as ::core::ffi::c_int) as ::core::ffi::c_long,
                    (bits & 1 as ::core::ffi::c_int) as ::core::ffi::c_long,
                );
                bits >>= 1 as ::core::ffi::c_int;
                if bits != 1 as ::core::ffi::c_int {
                    x264_cabac_size_decision_noup(
                        cb,
                        (27 as ::core::ffi::c_int + 5 as ::core::ffi::c_int) as ::core::ffi::c_long,
                        (bits & 1 as ::core::ffi::c_int) as ::core::ffi::c_long,
                    );
                }
            }
            let mut b_list: *const [uint8_t; 2] =
                (*x264_mb_type_list_table.as_ptr().offset(i_mb_type as isize)).as_ptr()
                    as *const [uint8_t; 2];
            if (*h).mb.pic.i_fref[0 as ::core::ffi::c_int as usize] > 1 as ::core::ffi::c_int {
                if (*b_list.offset(0 as ::core::ffi::c_int as isize))
                    [0 as ::core::ffi::c_int as usize]
                    != 0
                {
                    cabac_ref_b(h, cb, 0 as ::core::ffi::c_int, 0 as ::core::ffi::c_int);
                }
                if (*b_list.offset(0 as ::core::ffi::c_int as isize))
                    [1 as ::core::ffi::c_int as usize] as ::core::ffi::c_int
                    != 0
                    && (*h).mb.i_partition != D_16x16 as ::core::ffi::c_int
                {
                    cabac_ref_b(
                        h,
                        cb,
                        0 as ::core::ffi::c_int,
                        8 as ::core::ffi::c_int
                            >> ((*h).mb.i_partition == D_8x16 as ::core::ffi::c_int)
                                as ::core::ffi::c_int,
                    );
                }
            }
            if (*h).mb.pic.i_fref[1 as ::core::ffi::c_int as usize] > 1 as ::core::ffi::c_int {
                if (*b_list.offset(1 as ::core::ffi::c_int as isize))
                    [0 as ::core::ffi::c_int as usize]
                    != 0
                {
                    cabac_ref_b(h, cb, 1 as ::core::ffi::c_int, 0 as ::core::ffi::c_int);
                }
                if (*b_list.offset(1 as ::core::ffi::c_int as isize))
                    [1 as ::core::ffi::c_int as usize] as ::core::ffi::c_int
                    != 0
                    && (*h).mb.i_partition != D_16x16 as ::core::ffi::c_int
                {
                    cabac_ref_b(
                        h,
                        cb,
                        1 as ::core::ffi::c_int,
                        8 as ::core::ffi::c_int
                            >> ((*h).mb.i_partition == D_8x16 as ::core::ffi::c_int)
                                as ::core::ffi::c_int,
                    );
                }
            }
            let mut i_list: ::core::ffi::c_int = 0 as ::core::ffi::c_int;
            while i_list < 2 as ::core::ffi::c_int {
                if (*h).mb.i_partition == D_16x16 as ::core::ffi::c_int {
                    if (*b_list.offset(i_list as isize))[0 as ::core::ffi::c_int as usize] != 0 {
                        let mut mvd_1: uint16_t = cabac_mvd(
                            h,
                            cb,
                            i_list,
                            0 as ::core::ffi::c_int,
                            4 as ::core::ffi::c_int,
                        );
                        x264_macroblock_cache_mvd(
                            h,
                            block_idx_x[0 as ::core::ffi::c_int as usize] as ::core::ffi::c_int,
                            block_idx_y[0 as ::core::ffi::c_int as usize] as ::core::ffi::c_int,
                            4 as ::core::ffi::c_int,
                            4 as ::core::ffi::c_int,
                            i_list,
                            mvd_1,
                        );
                    }
                } else if (*h).mb.i_partition == D_16x8 as ::core::ffi::c_int {
                    if (*b_list.offset(i_list as isize))[0 as ::core::ffi::c_int as usize] != 0 {
                        let mut mvd_2: uint16_t = cabac_mvd(
                            h,
                            cb,
                            i_list,
                            0 as ::core::ffi::c_int,
                            4 as ::core::ffi::c_int,
                        );
                        x264_macroblock_cache_mvd(
                            h,
                            block_idx_x[0 as ::core::ffi::c_int as usize] as ::core::ffi::c_int,
                            block_idx_y[0 as ::core::ffi::c_int as usize] as ::core::ffi::c_int,
                            4 as ::core::ffi::c_int,
                            2 as ::core::ffi::c_int,
                            i_list,
                            mvd_2,
                        );
                    }
                    if (*b_list.offset(i_list as isize))[1 as ::core::ffi::c_int as usize] != 0 {
                        let mut mvd_3: uint16_t = cabac_mvd(
                            h,
                            cb,
                            i_list,
                            8 as ::core::ffi::c_int,
                            4 as ::core::ffi::c_int,
                        );
                        x264_macroblock_cache_mvd(
                            h,
                            block_idx_x[8 as ::core::ffi::c_int as usize] as ::core::ffi::c_int,
                            block_idx_y[8 as ::core::ffi::c_int as usize] as ::core::ffi::c_int,
                            4 as ::core::ffi::c_int,
                            2 as ::core::ffi::c_int,
                            i_list,
                            mvd_3,
                        );
                    }
                } else {
                    if (*b_list.offset(i_list as isize))[0 as ::core::ffi::c_int as usize] != 0 {
                        let mut mvd_4: uint16_t = cabac_mvd(
                            h,
                            cb,
                            i_list,
                            0 as ::core::ffi::c_int,
                            2 as ::core::ffi::c_int,
                        );
                        x264_macroblock_cache_mvd(
                            h,
                            block_idx_x[0 as ::core::ffi::c_int as usize] as ::core::ffi::c_int,
                            block_idx_y[0 as ::core::ffi::c_int as usize] as ::core::ffi::c_int,
                            2 as ::core::ffi::c_int,
                            4 as ::core::ffi::c_int,
                            i_list,
                            mvd_4,
                        );
                    }
                    if (*b_list.offset(i_list as isize))[1 as ::core::ffi::c_int as usize] != 0 {
                        let mut mvd_5: uint16_t = cabac_mvd(
                            h,
                            cb,
                            i_list,
                            4 as ::core::ffi::c_int,
                            2 as ::core::ffi::c_int,
                        );
                        x264_macroblock_cache_mvd(
                            h,
                            block_idx_x[4 as ::core::ffi::c_int as usize] as ::core::ffi::c_int,
                            block_idx_y[4 as ::core::ffi::c_int as usize] as ::core::ffi::c_int,
                            2 as ::core::ffi::c_int,
                            4 as ::core::ffi::c_int,
                            i_list,
                            mvd_5,
                        );
                    }
                }
                i_list += 1;
            }
        } else {
            cabac_mb_header_i(h, cb, i_mb_type, SLICE_TYPE_B as ::core::ffi::c_int, chroma);
        };
    }
    #[inline(always)]
    #[c2rust::src_loc = "612:1"]
    pub unsafe extern "C" fn cabac_cbf_ctxidxinc(
        mut h: *mut x264_t,
        mut i_cat: ::core::ffi::c_int,
        mut i_idx: ::core::ffi::c_int,
        mut b_intra: ::core::ffi::c_int,
        mut b_dc: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int {
        pub static mut base_ctx: [uint16_t; 14] = [
            85 as ::core::ffi::c_int as uint16_t,
            89 as ::core::ffi::c_int as uint16_t,
            93 as ::core::ffi::c_int as uint16_t,
            97 as ::core::ffi::c_int as uint16_t,
            101 as ::core::ffi::c_int as uint16_t,
            1012 as ::core::ffi::c_int as uint16_t,
            460 as ::core::ffi::c_int as uint16_t,
            464 as ::core::ffi::c_int as uint16_t,
            468 as ::core::ffi::c_int as uint16_t,
            1016 as ::core::ffi::c_int as uint16_t,
            472 as ::core::ffi::c_int as uint16_t,
            476 as ::core::ffi::c_int as uint16_t,
            480 as ::core::ffi::c_int as uint16_t,
            1020 as ::core::ffi::c_int as uint16_t,
        ];
        if b_dc != 0 {
            i_idx -= LUMA_DC;
            if i_cat == DCT_CHROMA_DC as ::core::ffi::c_int {
                let mut i_nza: ::core::ffi::c_int =
                    if (*h).mb.cache.i_cbp_left != -(1 as ::core::ffi::c_int) {
                        (*h).mb.cache.i_cbp_left >> 8 as ::core::ffi::c_int + i_idx
                            & 1 as ::core::ffi::c_int
                    } else {
                        b_intra
                    };
                let mut i_nzb: ::core::ffi::c_int =
                    if (*h).mb.cache.i_cbp_top != -(1 as ::core::ffi::c_int) {
                        (*h).mb.cache.i_cbp_top >> 8 as ::core::ffi::c_int + i_idx
                            & 1 as ::core::ffi::c_int
                    } else {
                        b_intra
                    };
                return base_ctx[i_cat as usize] as ::core::ffi::c_int
                    + 2 as ::core::ffi::c_int * i_nzb
                    + i_nza;
            } else {
                let mut i_nza_0: ::core::ffi::c_int = (*h).mb.cache.i_cbp_left
                    >> 8 as ::core::ffi::c_int + i_idx
                    & 1 as ::core::ffi::c_int;
                let mut i_nzb_0: ::core::ffi::c_int = (*h).mb.cache.i_cbp_top
                    >> 8 as ::core::ffi::c_int + i_idx
                    & 1 as ::core::ffi::c_int;
                return base_ctx[i_cat as usize] as ::core::ffi::c_int
                    + 2 as ::core::ffi::c_int * i_nzb_0
                    + i_nza_0;
            }
        } else {
            let mut i_nza_1: ::core::ffi::c_int =
                (*h).mb.cache.non_zero_count[(x264_scan8[i_idx as usize] as ::core::ffi::c_int
                    - 1 as ::core::ffi::c_int)
                    as usize] as ::core::ffi::c_int;
            let mut i_nzb_1: ::core::ffi::c_int =
                (*h).mb.cache.non_zero_count[(x264_scan8[i_idx as usize] as ::core::ffi::c_int
                    - 8 as ::core::ffi::c_int)
                    as usize] as ::core::ffi::c_int;
            if 0 != 0 && b_intra == 0 {
                return base_ctx[i_cat as usize] as ::core::ffi::c_int
                    + (2 as ::core::ffi::c_int * i_nzb_1 + i_nza_1 & 0x7f as ::core::ffi::c_int);
            } else {
                i_nza_1 &= 0x7f as ::core::ffi::c_int + (b_intra << 7 as ::core::ffi::c_int);
                i_nzb_1 &= 0x7f as ::core::ffi::c_int + (b_intra << 7 as ::core::ffi::c_int);
                return base_ctx[i_cat as usize] as ::core::ffi::c_int
                    + 2 as ::core::ffi::c_int * (i_nzb_1 != 0) as ::core::ffi::c_int
                    + (i_nza_1 != 0) as ::core::ffi::c_int;
            }
        };
    }
    #[c2rust::src_loc = "650:22"]
    pub static mut coeff_abs_level1_ctx: [uint8_t; 8] = [
        1 as ::core::ffi::c_int as uint8_t,
        2 as ::core::ffi::c_int as uint8_t,
        3 as ::core::ffi::c_int as uint8_t,
        4 as ::core::ffi::c_int as uint8_t,
        0 as ::core::ffi::c_int as uint8_t,
        0 as ::core::ffi::c_int as uint8_t,
        0 as ::core::ffi::c_int as uint8_t,
        0 as ::core::ffi::c_int as uint8_t,
    ];
    #[c2rust::src_loc = "652:22"]
    pub static mut coeff_abs_levelgt1_ctx: [uint8_t; 8] = [
        5 as ::core::ffi::c_int as uint8_t,
        5 as ::core::ffi::c_int as uint8_t,
        5 as ::core::ffi::c_int as uint8_t,
        5 as ::core::ffi::c_int as uint8_t,
        6 as ::core::ffi::c_int as uint8_t,
        7 as ::core::ffi::c_int as uint8_t,
        8 as ::core::ffi::c_int as uint8_t,
        9 as ::core::ffi::c_int as uint8_t,
    ];
    #[c2rust::src_loc = "655:22"]
    pub static mut coeff_abs_levelgt1_ctx_chroma_dc: [uint8_t; 8] = [
        5 as ::core::ffi::c_int as uint8_t,
        5 as ::core::ffi::c_int as uint8_t,
        5 as ::core::ffi::c_int as uint8_t,
        5 as ::core::ffi::c_int as uint8_t,
        6 as ::core::ffi::c_int as uint8_t,
        7 as ::core::ffi::c_int as uint8_t,
        8 as ::core::ffi::c_int as uint8_t,
        8 as ::core::ffi::c_int as uint8_t,
    ];
    #[c2rust::src_loc = "657:22"]
    pub static mut coeff_abs_level_transition: [[uint8_t; 8]; 2] = [
        [
            1 as ::core::ffi::c_int as uint8_t,
            2 as ::core::ffi::c_int as uint8_t,
            3 as ::core::ffi::c_int as uint8_t,
            3 as ::core::ffi::c_int as uint8_t,
            4 as ::core::ffi::c_int as uint8_t,
            5 as ::core::ffi::c_int as uint8_t,
            6 as ::core::ffi::c_int as uint8_t,
            7 as ::core::ffi::c_int as uint8_t,
        ],
        [
            4 as ::core::ffi::c_int as uint8_t,
            4 as ::core::ffi::c_int as uint8_t,
            4 as ::core::ffi::c_int as uint8_t,
            4 as ::core::ffi::c_int as uint8_t,
            5 as ::core::ffi::c_int as uint8_t,
            6 as ::core::ffi::c_int as uint8_t,
            7 as ::core::ffi::c_int as uint8_t,
            7 as ::core::ffi::c_int as uint8_t,
        ],
    ];
    #[inline(always)]
    #[c2rust::src_loc = "775:1"]
    pub unsafe extern "C" fn cabac_block_residual_internal(
        mut h: *mut x264_t,
        mut cb: *mut x264_cabac_t,
        mut ctx_block_cat: ::core::ffi::c_int,
        mut l: *mut dctcoef,
        mut b_8x8: ::core::ffi::c_int,
        mut chroma422dc: ::core::ffi::c_int,
    ) {
        let mut sig_offset: *const uint8_t = (*x264_significant_coeff_flag_offset_8x8
            .as_ptr()
            .offset((*h).mb.b_interlaced as isize))
        .as_ptr();
        let mut ctx_sig: ::core::ffi::c_int = x264_significant_coeff_flag_offset
            [(*h).mb.b_interlaced as usize][ctx_block_cat as usize]
            as ::core::ffi::c_int;
        let mut ctx_last: ::core::ffi::c_int = x264_last_coeff_flag_offset
            [(*h).mb.b_interlaced as usize][ctx_block_cat as usize]
            as ::core::ffi::c_int;
        let mut ctx_level: ::core::ffi::c_int =
            x264_coeff_abs_level_m1_offset[ctx_block_cat as usize] as ::core::ffi::c_int;
        let mut last: ::core::ffi::c_int =
            (*h).quantf.coeff_last[ctx_block_cat as usize].expect("non-null function pointer")(l);
        let mut coeff_abs: ::core::ffi::c_int = abs(*l.offset(last as isize));
        let mut ctx: ::core::ffi::c_int = coeff_abs_level1_ctx[0 as ::core::ffi::c_int as usize]
            as ::core::ffi::c_int
            + ctx_level;
        let mut node_ctx: ::core::ffi::c_int = 0;
        let mut levelgt1_ctx: *const uint8_t = if chroma422dc != 0 {
            coeff_abs_levelgt1_ctx_chroma_dc.as_ptr()
        } else {
            coeff_abs_levelgt1_ctx.as_ptr()
        };
        if last
            != (if b_8x8 != 0 {
                63 as ::core::ffi::c_int
            } else {
                (if chroma422dc != 0 {
                    7 as ::core::ffi::c_int
                } else {
                    x264_count_cat_m1[ctx_block_cat as usize] as ::core::ffi::c_int
                })
            })
        {
            x264_cabac_size_decision(
                cb,
                (ctx_sig
                    + (if b_8x8 != 0 {
                        *sig_offset.offset(last as isize) as ::core::ffi::c_int
                    } else {
                        (if chroma422dc != 0 {
                            x264_coeff_flag_offset_chroma_422_dc[last as usize]
                                as ::core::ffi::c_int
                        } else {
                            last
                        })
                    })) as ::core::ffi::c_long,
                1 as ::core::ffi::c_long,
            );
            x264_cabac_size_decision(
                cb,
                (ctx_last
                    + (if b_8x8 != 0 {
                        x264_last_coeff_flag_offset_8x8[last as usize] as ::core::ffi::c_int
                    } else {
                        (if chroma422dc != 0 {
                            x264_coeff_flag_offset_chroma_422_dc[last as usize]
                                as ::core::ffi::c_int
                        } else {
                            last
                        })
                    })) as ::core::ffi::c_long,
                1 as ::core::ffi::c_long,
            );
        }
        if coeff_abs > 1 as ::core::ffi::c_int {
            x264_cabac_size_decision(cb, ctx as ::core::ffi::c_long, 1 as ::core::ffi::c_long);
            ctx = *levelgt1_ctx.offset(0 as ::core::ffi::c_int as isize) as ::core::ffi::c_int
                + ctx_level;
            if coeff_abs < 15 as ::core::ffi::c_int {
                (*cb).f8_bits_encoded += x264_10_cabac_size_unary
                    [(coeff_abs - 1 as ::core::ffi::c_int) as usize]
                    [(*cb).state[ctx as usize] as usize]
                    as ::core::ffi::c_int;
                (*cb).state[ctx as usize] = x264_10_cabac_transition_unary
                    [(coeff_abs - 1 as ::core::ffi::c_int) as usize]
                    [(*cb).state[ctx as usize] as usize];
            } else {
                (*cb).f8_bits_encoded += x264_10_cabac_size_unary[14 as ::core::ffi::c_int as usize]
                    [(*cb).state[ctx as usize] as usize]
                    as ::core::ffi::c_int;
                (*cb).state[ctx as usize] = x264_10_cabac_transition_unary
                    [14 as ::core::ffi::c_int as usize][(*cb).state[ctx as usize] as usize];
                (*cb).f8_bits_encoded += (bs_size_ue_big(
                    (coeff_abs - 15 as ::core::ffi::c_int
                        + ((1 as ::core::ffi::c_int) << 0 as ::core::ffi::c_int)
                        - 1 as ::core::ffi::c_int) as ::core::ffi::c_uint,
                ) - 0 as ::core::ffi::c_int)
                    << 8 as ::core::ffi::c_int;
            }
            node_ctx = coeff_abs_level_transition[1 as ::core::ffi::c_int as usize]
                [0 as ::core::ffi::c_int as usize] as ::core::ffi::c_int;
        } else {
            x264_cabac_size_decision(cb, ctx as ::core::ffi::c_long, 0 as ::core::ffi::c_long);
            node_ctx = coeff_abs_level_transition[0 as ::core::ffi::c_int as usize]
                [0 as ::core::ffi::c_int as usize] as ::core::ffi::c_int;
            (*cb).f8_bits_encoded += 256 as ::core::ffi::c_int;
        }
        let mut i: ::core::ffi::c_int = last - 1 as ::core::ffi::c_int;
        while i >= 0 as ::core::ffi::c_int {
            if *l.offset(i as isize) != 0 {
                coeff_abs = abs(*l.offset(i as isize));
                x264_cabac_size_decision(
                    cb,
                    (ctx_sig
                        + (if b_8x8 != 0 {
                            *sig_offset.offset(i as isize) as ::core::ffi::c_int
                        } else {
                            (if chroma422dc != 0 {
                                x264_coeff_flag_offset_chroma_422_dc[i as usize]
                                    as ::core::ffi::c_int
                            } else {
                                i
                            })
                        })) as ::core::ffi::c_long,
                    1 as ::core::ffi::c_long,
                );
                x264_cabac_size_decision(
                    cb,
                    (ctx_last
                        + (if b_8x8 != 0 {
                            x264_last_coeff_flag_offset_8x8[i as usize] as ::core::ffi::c_int
                        } else {
                            (if chroma422dc != 0 {
                                x264_coeff_flag_offset_chroma_422_dc[i as usize]
                                    as ::core::ffi::c_int
                            } else {
                                i
                            })
                        })) as ::core::ffi::c_long,
                    0 as ::core::ffi::c_long,
                );
                ctx = coeff_abs_level1_ctx[node_ctx as usize] as ::core::ffi::c_int + ctx_level;
                if coeff_abs > 1 as ::core::ffi::c_int {
                    x264_cabac_size_decision(
                        cb,
                        ctx as ::core::ffi::c_long,
                        1 as ::core::ffi::c_long,
                    );
                    ctx = *levelgt1_ctx.offset(node_ctx as isize) as ::core::ffi::c_int + ctx_level;
                    if coeff_abs < 15 as ::core::ffi::c_int {
                        (*cb).f8_bits_encoded += x264_10_cabac_size_unary
                            [(coeff_abs - 1 as ::core::ffi::c_int) as usize]
                            [(*cb).state[ctx as usize] as usize]
                            as ::core::ffi::c_int;
                        (*cb).state[ctx as usize] = x264_10_cabac_transition_unary
                            [(coeff_abs - 1 as ::core::ffi::c_int) as usize]
                            [(*cb).state[ctx as usize] as usize];
                    } else {
                        (*cb).f8_bits_encoded += x264_10_cabac_size_unary
                            [14 as ::core::ffi::c_int as usize]
                            [(*cb).state[ctx as usize] as usize]
                            as ::core::ffi::c_int;
                        (*cb).state[ctx as usize] = x264_10_cabac_transition_unary
                            [14 as ::core::ffi::c_int as usize]
                            [(*cb).state[ctx as usize] as usize];
                        (*cb).f8_bits_encoded += (bs_size_ue_big(
                            (coeff_abs - 15 as ::core::ffi::c_int
                                + ((1 as ::core::ffi::c_int) << 0 as ::core::ffi::c_int)
                                - 1 as ::core::ffi::c_int)
                                as ::core::ffi::c_uint,
                        ) - 0 as ::core::ffi::c_int)
                            << 8 as ::core::ffi::c_int;
                    }
                    node_ctx = coeff_abs_level_transition[1 as ::core::ffi::c_int as usize]
                        [node_ctx as usize] as ::core::ffi::c_int;
                } else {
                    x264_cabac_size_decision(
                        cb,
                        ctx as ::core::ffi::c_long,
                        0 as ::core::ffi::c_long,
                    );
                    node_ctx = coeff_abs_level_transition[0 as ::core::ffi::c_int as usize]
                        [node_ctx as usize] as ::core::ffi::c_int;
                    (*cb).f8_bits_encoded += 256 as ::core::ffi::c_int;
                }
            } else {
                x264_cabac_size_decision(
                    cb,
                    (ctx_sig
                        + (if b_8x8 != 0 {
                            *sig_offset.offset(i as isize) as ::core::ffi::c_int
                        } else {
                            (if chroma422dc != 0 {
                                x264_coeff_flag_offset_chroma_422_dc[i as usize]
                                    as ::core::ffi::c_int
                            } else {
                                i
                            })
                        })) as ::core::ffi::c_long,
                    0 as ::core::ffi::c_long,
                );
            }
            i -= 1;
        }
    }
    #[no_mangle]
    #[c2rust::src_loc = "860:1"]
    pub unsafe extern "C" fn x264_10_cabac_block_residual_8x8_rd_c(
        mut h: *mut x264_t,
        mut cb: *mut x264_cabac_t,
        mut ctx_block_cat: ::core::ffi::c_int,
        mut l: *mut dctcoef,
    ) {
        cabac_block_residual_internal(
            h,
            cb,
            ctx_block_cat,
            l,
            1 as ::core::ffi::c_int,
            0 as ::core::ffi::c_int,
        );
    }
    #[no_mangle]
    #[c2rust::src_loc = "864:1"]
    pub unsafe extern "C" fn x264_10_cabac_block_residual_rd_c(
        mut h: *mut x264_t,
        mut cb: *mut x264_cabac_t,
        mut ctx_block_cat: ::core::ffi::c_int,
        mut l: *mut dctcoef,
    ) {
        cabac_block_residual_internal(
            h,
            cb,
            ctx_block_cat,
            l,
            0 as ::core::ffi::c_int,
            0 as ::core::ffi::c_int,
        );
    }
    #[inline(always)]
    #[c2rust::src_loc = "869:1"]
    pub unsafe extern "C" fn cabac_block_residual_8x8(
        mut h: *mut x264_t,
        mut cb: *mut x264_cabac_t,
        mut ctx_block_cat: ::core::ffi::c_int,
        mut l: *mut dctcoef,
    ) {
        x264_10_cabac_block_residual_8x8_rd_c(h, cb, ctx_block_cat, l);
    }
    #[inline(always)]
    #[c2rust::src_loc = "877:1"]
    pub unsafe extern "C" fn cabac_block_residual(
        mut h: *mut x264_t,
        mut cb: *mut x264_cabac_t,
        mut ctx_block_cat: ::core::ffi::c_int,
        mut l: *mut dctcoef,
    ) {
        x264_10_cabac_block_residual_rd_c(h, cb, ctx_block_cat, l);
    }
    #[c2rust::src_loc = "886:1"]
    pub unsafe extern "C" fn cabac_block_residual_422_dc(
        mut h: *mut x264_t,
        mut cb: *mut x264_cabac_t,
        mut ctx_block_cat: ::core::ffi::c_int,
        mut l: *mut dctcoef,
    ) {
        cabac_block_residual_internal(
            h,
            cb,
            DCT_CHROMA_DC as ::core::ffi::c_int,
            l,
            0 as ::core::ffi::c_int,
            1 as ::core::ffi::c_int,
        );
    }
    #[inline(always)]
    #[c2rust::src_loc = "917:1"]
    pub unsafe extern "C" fn macroblock_write_cabac_internal(
        mut h: *mut x264_t,
        mut cb: *mut x264_cabac_t,
        mut plane_count: ::core::ffi::c_int,
        mut chroma: ::core::ffi::c_int,
    ) {
        let i_mb_type: ::core::ffi::c_int = (*h).mb.i_type;
        if (*h).sh.i_type == SLICE_TYPE_P as ::core::ffi::c_int {
            cabac_mb_header_p(h, cb, i_mb_type, chroma);
        } else if (*h).sh.i_type == SLICE_TYPE_B as ::core::ffi::c_int {
            cabac_mb_header_b(h, cb, i_mb_type, chroma);
        } else {
            cabac_mb_header_i(h, cb, i_mb_type, SLICE_TYPE_I as ::core::ffi::c_int, chroma);
        }
        if i_mb_type != I_16x16 as ::core::ffi::c_int {
            cabac_cbp_luma(h, cb);
            if chroma != 0 {
                cabac_cbp_chroma(h, cb);
            }
        }
        if x264_mb_transform_8x8_allowed(h) != 0 && (*h).mb.i_cbp_luma != 0 {
            cabac_transform_size(h, cb);
        }
        if (*h).mb.i_cbp_luma != 0
            || chroma != 0 && (*h).mb.i_cbp_chroma != 0
            || i_mb_type == I_16x16 as ::core::ffi::c_int
        {
            let b_intra: ::core::ffi::c_int = (i_mb_type == I_4x4 as ::core::ffi::c_int
                || i_mb_type == I_8x8 as ::core::ffi::c_int
                || i_mb_type == I_16x16 as ::core::ffi::c_int
                || i_mb_type == I_PCM as ::core::ffi::c_int)
                as ::core::ffi::c_int;
            cabac_qp_delta(h, cb);
            if i_mb_type == I_16x16 as ::core::ffi::c_int {
                let mut p: ::core::ffi::c_int = 0 as ::core::ffi::c_int;
                while p < plane_count {
                    let mut ctxidxinc: ::core::ffi::c_int = cabac_cbf_ctxidxinc(
                        h,
                        ctx_cat_plane[DCT_LUMA_DC as ::core::ffi::c_int as usize][p as usize]
                            as ::core::ffi::c_int,
                        48 as ::core::ffi::c_int + p,
                        1 as ::core::ffi::c_int,
                        1 as ::core::ffi::c_int,
                    );
                    if (*h).mb.cache.non_zero_count
                        [x264_scan8[(48 as ::core::ffi::c_int + p) as usize] as usize]
                        != 0
                    {
                        x264_cabac_size_decision(
                            cb,
                            ctxidxinc as ::core::ffi::c_long,
                            1 as ::core::ffi::c_long,
                        );
                        cabac_block_residual(
                            h,
                            cb,
                            ctx_cat_plane[DCT_LUMA_DC as ::core::ffi::c_int as usize][p as usize]
                                as ::core::ffi::c_int,
                            (*(*h).dct.luma16x16_dc.as_mut_ptr().offset(p as isize)).as_mut_ptr(),
                        );
                    } else {
                        x264_cabac_size_decision(
                            cb,
                            ctxidxinc as ::core::ffi::c_long,
                            0 as ::core::ffi::c_long,
                        );
                    }
                    if (*h).mb.i_cbp_luma != 0 {
                        let mut i: ::core::ffi::c_int = p * 16 as ::core::ffi::c_int;
                        while i < p * 16 as ::core::ffi::c_int + 16 as ::core::ffi::c_int {
                            let mut ctxidxinc_0: ::core::ffi::c_int = cabac_cbf_ctxidxinc(
                                h,
                                ctx_cat_plane[DCT_LUMA_AC as ::core::ffi::c_int as usize]
                                    [p as usize]
                                    as ::core::ffi::c_int,
                                i,
                                1 as ::core::ffi::c_int,
                                0 as ::core::ffi::c_int,
                            );
                            if (*h).mb.cache.non_zero_count[x264_scan8[i as usize] as usize] != 0 {
                                x264_cabac_size_decision(
                                    cb,
                                    ctxidxinc_0 as ::core::ffi::c_long,
                                    1 as ::core::ffi::c_long,
                                );
                                cabac_block_residual(
                                    h,
                                    cb,
                                    ctx_cat_plane[DCT_LUMA_AC as ::core::ffi::c_int as usize]
                                        [p as usize]
                                        as ::core::ffi::c_int,
                                    (*(*h).dct.luma4x4.as_mut_ptr().offset(i as isize))
                                        .as_mut_ptr()
                                        .offset(1 as ::core::ffi::c_int as isize),
                                );
                            } else {
                                x264_cabac_size_decision(
                                    cb,
                                    ctxidxinc_0 as ::core::ffi::c_long,
                                    0 as ::core::ffi::c_long,
                                );
                            }
                            i += 1;
                        }
                    }
                    p += 1;
                }
            } else if (*h).mb.b_transform_8x8 != 0 {
                if plane_count == 3 as ::core::ffi::c_int {
                    let mut nnzbak: [[uint8_t; 8]; 3] = [[0; 8]; 3];
                    if (*h).mb.i_neighbour & MB_LEFT as ::core::ffi::c_int as ::core::ffi::c_uint
                        != 0
                        && *(*h)
                            .mb
                            .mb_transform_size
                            .offset((*h).mb.i_mb_left_xy[0 as ::core::ffi::c_int as usize] as isize)
                            == 0
                        && *(*h)
                            .mb
                            .cbp
                            .offset((*h).mb.i_mb_left_xy[0 as ::core::ffi::c_int as usize] as isize)
                            as ::core::ffi::c_int
                            & 0x1000 as ::core::ffi::c_int
                            == 0
                    {
                        nnzbak[0 as ::core::ffi::c_int as usize]
                            [0 as ::core::ffi::c_int as usize] = (*h).mb.cache.non_zero_count
                            [(x264_scan8[(16 as ::core::ffi::c_int * 0 as ::core::ffi::c_int
                                + 0 as ::core::ffi::c_int)
                                as usize] as ::core::ffi::c_int
                                - 1 as ::core::ffi::c_int) as usize];
                        (*h).mb.cache.non_zero_count[(x264_scan8[(16 as ::core::ffi::c_int
                            * 0 as ::core::ffi::c_int
                            + 0 as ::core::ffi::c_int)
                            as usize]
                            as ::core::ffi::c_int
                            - 1 as ::core::ffi::c_int)
                            as usize] = 0 as uint8_t;
                        nnzbak[0 as ::core::ffi::c_int as usize]
                            [1 as ::core::ffi::c_int as usize] = (*h).mb.cache.non_zero_count
                            [(x264_scan8[(16 as ::core::ffi::c_int * 0 as ::core::ffi::c_int
                                + 2 as ::core::ffi::c_int)
                                as usize] as ::core::ffi::c_int
                                - 1 as ::core::ffi::c_int) as usize];
                        (*h).mb.cache.non_zero_count[(x264_scan8[(16 as ::core::ffi::c_int
                            * 0 as ::core::ffi::c_int
                            + 2 as ::core::ffi::c_int)
                            as usize]
                            as ::core::ffi::c_int
                            - 1 as ::core::ffi::c_int)
                            as usize] = 0 as uint8_t;
                        nnzbak[1 as ::core::ffi::c_int as usize]
                            [0 as ::core::ffi::c_int as usize] = (*h).mb.cache.non_zero_count
                            [(x264_scan8[(16 as ::core::ffi::c_int * 1 as ::core::ffi::c_int
                                + 0 as ::core::ffi::c_int)
                                as usize] as ::core::ffi::c_int
                                - 1 as ::core::ffi::c_int) as usize];
                        (*h).mb.cache.non_zero_count[(x264_scan8[(16 as ::core::ffi::c_int
                            * 1 as ::core::ffi::c_int
                            + 0 as ::core::ffi::c_int)
                            as usize]
                            as ::core::ffi::c_int
                            - 1 as ::core::ffi::c_int)
                            as usize] = 0 as uint8_t;
                        nnzbak[1 as ::core::ffi::c_int as usize]
                            [1 as ::core::ffi::c_int as usize] = (*h).mb.cache.non_zero_count
                            [(x264_scan8[(16 as ::core::ffi::c_int * 1 as ::core::ffi::c_int
                                + 2 as ::core::ffi::c_int)
                                as usize] as ::core::ffi::c_int
                                - 1 as ::core::ffi::c_int) as usize];
                        (*h).mb.cache.non_zero_count[(x264_scan8[(16 as ::core::ffi::c_int
                            * 1 as ::core::ffi::c_int
                            + 2 as ::core::ffi::c_int)
                            as usize]
                            as ::core::ffi::c_int
                            - 1 as ::core::ffi::c_int)
                            as usize] = 0 as uint8_t;
                        nnzbak[2 as ::core::ffi::c_int as usize]
                            [0 as ::core::ffi::c_int as usize] = (*h).mb.cache.non_zero_count
                            [(x264_scan8[(16 as ::core::ffi::c_int * 2 as ::core::ffi::c_int
                                + 0 as ::core::ffi::c_int)
                                as usize] as ::core::ffi::c_int
                                - 1 as ::core::ffi::c_int) as usize];
                        (*h).mb.cache.non_zero_count[(x264_scan8[(16 as ::core::ffi::c_int
                            * 2 as ::core::ffi::c_int
                            + 0 as ::core::ffi::c_int)
                            as usize]
                            as ::core::ffi::c_int
                            - 1 as ::core::ffi::c_int)
                            as usize] = 0 as uint8_t;
                        nnzbak[2 as ::core::ffi::c_int as usize]
                            [1 as ::core::ffi::c_int as usize] = (*h).mb.cache.non_zero_count
                            [(x264_scan8[(16 as ::core::ffi::c_int * 2 as ::core::ffi::c_int
                                + 2 as ::core::ffi::c_int)
                                as usize] as ::core::ffi::c_int
                                - 1 as ::core::ffi::c_int) as usize];
                        (*h).mb.cache.non_zero_count[(x264_scan8[(16 as ::core::ffi::c_int
                            * 2 as ::core::ffi::c_int
                            + 2 as ::core::ffi::c_int)
                            as usize]
                            as ::core::ffi::c_int
                            - 1 as ::core::ffi::c_int)
                            as usize] = 0 as uint8_t;
                    }
                    if (*h).mb.i_neighbour & MB_LEFT as ::core::ffi::c_int as ::core::ffi::c_uint
                        != 0
                        && *(*h)
                            .mb
                            .mb_transform_size
                            .offset((*h).mb.i_mb_left_xy[1 as ::core::ffi::c_int as usize] as isize)
                            == 0
                        && *(*h)
                            .mb
                            .cbp
                            .offset((*h).mb.i_mb_left_xy[1 as ::core::ffi::c_int as usize] as isize)
                            as ::core::ffi::c_int
                            & 0x1000 as ::core::ffi::c_int
                            == 0
                    {
                        nnzbak[0 as ::core::ffi::c_int as usize]
                            [2 as ::core::ffi::c_int as usize] = (*h).mb.cache.non_zero_count
                            [(x264_scan8[(16 as ::core::ffi::c_int * 0 as ::core::ffi::c_int
                                + 8 as ::core::ffi::c_int)
                                as usize] as ::core::ffi::c_int
                                - 1 as ::core::ffi::c_int) as usize];
                        (*h).mb.cache.non_zero_count[(x264_scan8[(16 as ::core::ffi::c_int
                            * 0 as ::core::ffi::c_int
                            + 8 as ::core::ffi::c_int)
                            as usize]
                            as ::core::ffi::c_int
                            - 1 as ::core::ffi::c_int)
                            as usize] = 0 as uint8_t;
                        nnzbak[0 as ::core::ffi::c_int as usize]
                            [3 as ::core::ffi::c_int as usize] = (*h).mb.cache.non_zero_count
                            [(x264_scan8[(16 as ::core::ffi::c_int * 0 as ::core::ffi::c_int
                                + 10 as ::core::ffi::c_int)
                                as usize] as ::core::ffi::c_int
                                - 1 as ::core::ffi::c_int) as usize];
                        (*h).mb.cache.non_zero_count[(x264_scan8[(16 as ::core::ffi::c_int
                            * 0 as ::core::ffi::c_int
                            + 10 as ::core::ffi::c_int)
                            as usize]
                            as ::core::ffi::c_int
                            - 1 as ::core::ffi::c_int)
                            as usize] = 0 as uint8_t;
                        nnzbak[1 as ::core::ffi::c_int as usize]
                            [2 as ::core::ffi::c_int as usize] = (*h).mb.cache.non_zero_count
                            [(x264_scan8[(16 as ::core::ffi::c_int * 1 as ::core::ffi::c_int
                                + 8 as ::core::ffi::c_int)
                                as usize] as ::core::ffi::c_int
                                - 1 as ::core::ffi::c_int) as usize];
                        (*h).mb.cache.non_zero_count[(x264_scan8[(16 as ::core::ffi::c_int
                            * 1 as ::core::ffi::c_int
                            + 8 as ::core::ffi::c_int)
                            as usize]
                            as ::core::ffi::c_int
                            - 1 as ::core::ffi::c_int)
                            as usize] = 0 as uint8_t;
                        nnzbak[1 as ::core::ffi::c_int as usize]
                            [3 as ::core::ffi::c_int as usize] = (*h).mb.cache.non_zero_count
                            [(x264_scan8[(16 as ::core::ffi::c_int * 1 as ::core::ffi::c_int
                                + 10 as ::core::ffi::c_int)
                                as usize] as ::core::ffi::c_int
                                - 1 as ::core::ffi::c_int) as usize];
                        (*h).mb.cache.non_zero_count[(x264_scan8[(16 as ::core::ffi::c_int
                            * 1 as ::core::ffi::c_int
                            + 10 as ::core::ffi::c_int)
                            as usize]
                            as ::core::ffi::c_int
                            - 1 as ::core::ffi::c_int)
                            as usize] = 0 as uint8_t;
                        nnzbak[2 as ::core::ffi::c_int as usize]
                            [2 as ::core::ffi::c_int as usize] = (*h).mb.cache.non_zero_count
                            [(x264_scan8[(16 as ::core::ffi::c_int * 2 as ::core::ffi::c_int
                                + 8 as ::core::ffi::c_int)
                                as usize] as ::core::ffi::c_int
                                - 1 as ::core::ffi::c_int) as usize];
                        (*h).mb.cache.non_zero_count[(x264_scan8[(16 as ::core::ffi::c_int
                            * 2 as ::core::ffi::c_int
                            + 8 as ::core::ffi::c_int)
                            as usize]
                            as ::core::ffi::c_int
                            - 1 as ::core::ffi::c_int)
                            as usize] = 0 as uint8_t;
                        nnzbak[2 as ::core::ffi::c_int as usize]
                            [3 as ::core::ffi::c_int as usize] = (*h).mb.cache.non_zero_count
                            [(x264_scan8[(16 as ::core::ffi::c_int * 2 as ::core::ffi::c_int
                                + 10 as ::core::ffi::c_int)
                                as usize] as ::core::ffi::c_int
                                - 1 as ::core::ffi::c_int) as usize];
                        (*h).mb.cache.non_zero_count[(x264_scan8[(16 as ::core::ffi::c_int
                            * 2 as ::core::ffi::c_int
                            + 10 as ::core::ffi::c_int)
                            as usize]
                            as ::core::ffi::c_int
                            - 1 as ::core::ffi::c_int)
                            as usize] = 0 as uint8_t;
                    }
                    if (*h).mb.i_neighbour & MB_TOP as ::core::ffi::c_int as ::core::ffi::c_uint
                        != 0
                        && *(*h)
                            .mb
                            .mb_transform_size
                            .offset((*h).mb.i_mb_top_xy as isize)
                            == 0
                        && *(*h).mb.cbp.offset((*h).mb.i_mb_top_xy as isize) as ::core::ffi::c_int
                            & 0x1000 as ::core::ffi::c_int
                            == 0
                    {
                        (*(&mut *(*nnzbak.as_mut_ptr().offset(0 as ::core::ffi::c_int as isize))
                            .as_mut_ptr()
                            .offset(4 as ::core::ffi::c_int as isize)
                            as *mut uint8_t as *mut x264_union32_t))
                            .i = (*(&mut *(*h).mb.cache.non_zero_count.as_mut_ptr().offset(
                            (*x264_scan8.as_ptr().offset(
                                (16 as ::core::ffi::c_int * 0 as ::core::ffi::c_int) as isize,
                            ) as ::core::ffi::c_int
                                - 8 as ::core::ffi::c_int) as isize,
                        ) as *mut uint8_t
                            as *mut x264_union32_t))
                            .i;
                        (*(&mut *(*h).mb.cache.non_zero_count.as_mut_ptr().offset(
                            (*x264_scan8.as_ptr().offset(
                                (16 as ::core::ffi::c_int * 0 as ::core::ffi::c_int) as isize,
                            ) as ::core::ffi::c_int
                                - 8 as ::core::ffi::c_int) as isize,
                        ) as *mut uint8_t as *mut x264_union32_t))
                            .i = 0 as ::core::ffi::c_uint as uint32_t;
                        (*(&mut *(*nnzbak.as_mut_ptr().offset(1 as ::core::ffi::c_int as isize))
                            .as_mut_ptr()
                            .offset(4 as ::core::ffi::c_int as isize)
                            as *mut uint8_t as *mut x264_union32_t))
                            .i = (*(&mut *(*h).mb.cache.non_zero_count.as_mut_ptr().offset(
                            (*x264_scan8.as_ptr().offset(
                                (16 as ::core::ffi::c_int * 1 as ::core::ffi::c_int) as isize,
                            ) as ::core::ffi::c_int
                                - 8 as ::core::ffi::c_int) as isize,
                        ) as *mut uint8_t
                            as *mut x264_union32_t))
                            .i;
                        (*(&mut *(*h).mb.cache.non_zero_count.as_mut_ptr().offset(
                            (*x264_scan8.as_ptr().offset(
                                (16 as ::core::ffi::c_int * 1 as ::core::ffi::c_int) as isize,
                            ) as ::core::ffi::c_int
                                - 8 as ::core::ffi::c_int) as isize,
                        ) as *mut uint8_t as *mut x264_union32_t))
                            .i = 0 as ::core::ffi::c_uint as uint32_t;
                        (*(&mut *(*nnzbak.as_mut_ptr().offset(2 as ::core::ffi::c_int as isize))
                            .as_mut_ptr()
                            .offset(4 as ::core::ffi::c_int as isize)
                            as *mut uint8_t as *mut x264_union32_t))
                            .i = (*(&mut *(*h).mb.cache.non_zero_count.as_mut_ptr().offset(
                            (*x264_scan8.as_ptr().offset(
                                (16 as ::core::ffi::c_int * 2 as ::core::ffi::c_int) as isize,
                            ) as ::core::ffi::c_int
                                - 8 as ::core::ffi::c_int) as isize,
                        ) as *mut uint8_t
                            as *mut x264_union32_t))
                            .i;
                        (*(&mut *(*h).mb.cache.non_zero_count.as_mut_ptr().offset(
                            (*x264_scan8.as_ptr().offset(
                                (16 as ::core::ffi::c_int * 2 as ::core::ffi::c_int) as isize,
                            ) as ::core::ffi::c_int
                                - 8 as ::core::ffi::c_int) as isize,
                        ) as *mut uint8_t as *mut x264_union32_t))
                            .i = 0 as ::core::ffi::c_uint as uint32_t;
                    }
                    let mut p_0: ::core::ffi::c_int = 0 as ::core::ffi::c_int;
                    while p_0 < 3 as ::core::ffi::c_int {
                        let mut i_0: ::core::ffi::c_int = 0 as ::core::ffi::c_int;
                        let mut msk: ::core::ffi::c_int = (*h).mb.i_cbp_luma;
                        let mut skip: ::core::ffi::c_int = 0;
                        while msk != 0 && {
                            skip = x264_ctz_4bit(msk as uint32_t);
                            i_0 += skip;
                            msk >>= skip + 1 as ::core::ffi::c_int;
                            1 as ::core::ffi::c_int != 0
                        } {
                            let mut ctxidxinc_1: ::core::ffi::c_int = cabac_cbf_ctxidxinc(
                                h,
                                ctx_cat_plane[DCT_LUMA_8x8 as ::core::ffi::c_int as usize]
                                    [p_0 as usize]
                                    as ::core::ffi::c_int,
                                i_0 * 4 as ::core::ffi::c_int + p_0 * 16 as ::core::ffi::c_int,
                                b_intra,
                                0 as ::core::ffi::c_int,
                            );
                            if (*h).mb.cache.non_zero_count[x264_scan8[(i_0
                                * 4 as ::core::ffi::c_int
                                + p_0 * 16 as ::core::ffi::c_int)
                                as usize]
                                as usize]
                                != 0
                            {
                                x264_cabac_size_decision(
                                    cb,
                                    ctxidxinc_1 as ::core::ffi::c_long,
                                    1 as ::core::ffi::c_long,
                                );
                                cabac_block_residual_8x8(
                                    h,
                                    cb,
                                    ctx_cat_plane[DCT_LUMA_8x8 as ::core::ffi::c_int as usize]
                                        [p_0 as usize]
                                        as ::core::ffi::c_int,
                                    (*(*h)
                                        .dct
                                        .luma8x8
                                        .as_mut_ptr()
                                        .offset((i_0 + p_0 * 4 as ::core::ffi::c_int) as isize))
                                    .as_mut_ptr(),
                                );
                            } else {
                                x264_cabac_size_decision(
                                    cb,
                                    ctxidxinc_1 as ::core::ffi::c_long,
                                    0 as ::core::ffi::c_long,
                                );
                            }
                            i_0 += 1;
                        }
                        p_0 += 1;
                    }
                    if (*h).mb.i_neighbour & MB_LEFT as ::core::ffi::c_int as ::core::ffi::c_uint
                        != 0
                        && *(*h)
                            .mb
                            .mb_transform_size
                            .offset((*h).mb.i_mb_left_xy[0 as ::core::ffi::c_int as usize] as isize)
                            == 0
                        && *(*h)
                            .mb
                            .cbp
                            .offset((*h).mb.i_mb_left_xy[0 as ::core::ffi::c_int as usize] as isize)
                            as ::core::ffi::c_int
                            & 0x1000 as ::core::ffi::c_int
                            == 0
                    {
                        (*h).mb.cache.non_zero_count[(x264_scan8[(16 as ::core::ffi::c_int
                            * 0 as ::core::ffi::c_int
                            + 0 as ::core::ffi::c_int)
                            as usize]
                            as ::core::ffi::c_int
                            - 1 as ::core::ffi::c_int)
                            as usize] = nnzbak[0 as ::core::ffi::c_int as usize]
                            [0 as ::core::ffi::c_int as usize];
                        (*h).mb.cache.non_zero_count[(x264_scan8[(16 as ::core::ffi::c_int
                            * 0 as ::core::ffi::c_int
                            + 2 as ::core::ffi::c_int)
                            as usize]
                            as ::core::ffi::c_int
                            - 1 as ::core::ffi::c_int)
                            as usize] = nnzbak[0 as ::core::ffi::c_int as usize]
                            [1 as ::core::ffi::c_int as usize];
                        (*h).mb.cache.non_zero_count[(x264_scan8[(16 as ::core::ffi::c_int
                            * 1 as ::core::ffi::c_int
                            + 0 as ::core::ffi::c_int)
                            as usize]
                            as ::core::ffi::c_int
                            - 1 as ::core::ffi::c_int)
                            as usize] = nnzbak[1 as ::core::ffi::c_int as usize]
                            [0 as ::core::ffi::c_int as usize];
                        (*h).mb.cache.non_zero_count[(x264_scan8[(16 as ::core::ffi::c_int
                            * 1 as ::core::ffi::c_int
                            + 2 as ::core::ffi::c_int)
                            as usize]
                            as ::core::ffi::c_int
                            - 1 as ::core::ffi::c_int)
                            as usize] = nnzbak[1 as ::core::ffi::c_int as usize]
                            [1 as ::core::ffi::c_int as usize];
                        (*h).mb.cache.non_zero_count[(x264_scan8[(16 as ::core::ffi::c_int
                            * 2 as ::core::ffi::c_int
                            + 0 as ::core::ffi::c_int)
                            as usize]
                            as ::core::ffi::c_int
                            - 1 as ::core::ffi::c_int)
                            as usize] = nnzbak[2 as ::core::ffi::c_int as usize]
                            [0 as ::core::ffi::c_int as usize];
                        (*h).mb.cache.non_zero_count[(x264_scan8[(16 as ::core::ffi::c_int
                            * 2 as ::core::ffi::c_int
                            + 2 as ::core::ffi::c_int)
                            as usize]
                            as ::core::ffi::c_int
                            - 1 as ::core::ffi::c_int)
                            as usize] = nnzbak[2 as ::core::ffi::c_int as usize]
                            [1 as ::core::ffi::c_int as usize];
                    }
                    if (*h).mb.i_neighbour & MB_LEFT as ::core::ffi::c_int as ::core::ffi::c_uint
                        != 0
                        && *(*h)
                            .mb
                            .mb_transform_size
                            .offset((*h).mb.i_mb_left_xy[1 as ::core::ffi::c_int as usize] as isize)
                            == 0
                        && *(*h)
                            .mb
                            .cbp
                            .offset((*h).mb.i_mb_left_xy[1 as ::core::ffi::c_int as usize] as isize)
                            as ::core::ffi::c_int
                            & 0x1000 as ::core::ffi::c_int
                            == 0
                    {
                        (*h).mb.cache.non_zero_count[(x264_scan8[(16 as ::core::ffi::c_int
                            * 0 as ::core::ffi::c_int
                            + 8 as ::core::ffi::c_int)
                            as usize]
                            as ::core::ffi::c_int
                            - 1 as ::core::ffi::c_int)
                            as usize] = nnzbak[0 as ::core::ffi::c_int as usize]
                            [2 as ::core::ffi::c_int as usize];
                        (*h).mb.cache.non_zero_count[(x264_scan8[(16 as ::core::ffi::c_int
                            * 0 as ::core::ffi::c_int
                            + 10 as ::core::ffi::c_int)
                            as usize]
                            as ::core::ffi::c_int
                            - 1 as ::core::ffi::c_int)
                            as usize] = nnzbak[0 as ::core::ffi::c_int as usize]
                            [3 as ::core::ffi::c_int as usize];
                        (*h).mb.cache.non_zero_count[(x264_scan8[(16 as ::core::ffi::c_int
                            * 1 as ::core::ffi::c_int
                            + 8 as ::core::ffi::c_int)
                            as usize]
                            as ::core::ffi::c_int
                            - 1 as ::core::ffi::c_int)
                            as usize] = nnzbak[1 as ::core::ffi::c_int as usize]
                            [2 as ::core::ffi::c_int as usize];
                        (*h).mb.cache.non_zero_count[(x264_scan8[(16 as ::core::ffi::c_int
                            * 1 as ::core::ffi::c_int
                            + 10 as ::core::ffi::c_int)
                            as usize]
                            as ::core::ffi::c_int
                            - 1 as ::core::ffi::c_int)
                            as usize] = nnzbak[1 as ::core::ffi::c_int as usize]
                            [3 as ::core::ffi::c_int as usize];
                        (*h).mb.cache.non_zero_count[(x264_scan8[(16 as ::core::ffi::c_int
                            * 2 as ::core::ffi::c_int
                            + 8 as ::core::ffi::c_int)
                            as usize]
                            as ::core::ffi::c_int
                            - 1 as ::core::ffi::c_int)
                            as usize] = nnzbak[2 as ::core::ffi::c_int as usize]
                            [2 as ::core::ffi::c_int as usize];
                        (*h).mb.cache.non_zero_count[(x264_scan8[(16 as ::core::ffi::c_int
                            * 2 as ::core::ffi::c_int
                            + 10 as ::core::ffi::c_int)
                            as usize]
                            as ::core::ffi::c_int
                            - 1 as ::core::ffi::c_int)
                            as usize] = nnzbak[2 as ::core::ffi::c_int as usize]
                            [3 as ::core::ffi::c_int as usize];
                    }
                    if (*h).mb.i_neighbour & MB_TOP as ::core::ffi::c_int as ::core::ffi::c_uint
                        != 0
                        && *(*h)
                            .mb
                            .mb_transform_size
                            .offset((*h).mb.i_mb_top_xy as isize)
                            == 0
                        && *(*h).mb.cbp.offset((*h).mb.i_mb_top_xy as isize) as ::core::ffi::c_int
                            & 0x1000 as ::core::ffi::c_int
                            == 0
                    {
                        (*(&mut *(*h).mb.cache.non_zero_count.as_mut_ptr().offset(
                            (*x264_scan8.as_ptr().offset(
                                (16 as ::core::ffi::c_int * 0 as ::core::ffi::c_int) as isize,
                            ) as ::core::ffi::c_int
                                - 8 as ::core::ffi::c_int) as isize,
                        ) as *mut uint8_t as *mut x264_union32_t))
                            .i = (*(&mut *(*nnzbak
                            .as_mut_ptr()
                            .offset(0 as ::core::ffi::c_int as isize))
                        .as_mut_ptr()
                        .offset(4 as ::core::ffi::c_int as isize)
                            as *mut uint8_t
                            as *mut x264_union32_t))
                            .i;
                        (*(&mut *(*h).mb.cache.non_zero_count.as_mut_ptr().offset(
                            (*x264_scan8.as_ptr().offset(
                                (16 as ::core::ffi::c_int * 1 as ::core::ffi::c_int) as isize,
                            ) as ::core::ffi::c_int
                                - 8 as ::core::ffi::c_int) as isize,
                        ) as *mut uint8_t as *mut x264_union32_t))
                            .i = (*(&mut *(*nnzbak
                            .as_mut_ptr()
                            .offset(1 as ::core::ffi::c_int as isize))
                        .as_mut_ptr()
                        .offset(4 as ::core::ffi::c_int as isize)
                            as *mut uint8_t
                            as *mut x264_union32_t))
                            .i;
                        (*(&mut *(*h).mb.cache.non_zero_count.as_mut_ptr().offset(
                            (*x264_scan8.as_ptr().offset(
                                (16 as ::core::ffi::c_int * 2 as ::core::ffi::c_int) as isize,
                            ) as ::core::ffi::c_int
                                - 8 as ::core::ffi::c_int) as isize,
                        ) as *mut uint8_t as *mut x264_union32_t))
                            .i = (*(&mut *(*nnzbak
                            .as_mut_ptr()
                            .offset(2 as ::core::ffi::c_int as isize))
                        .as_mut_ptr()
                        .offset(4 as ::core::ffi::c_int as isize)
                            as *mut uint8_t
                            as *mut x264_union32_t))
                            .i;
                    }
                } else {
                    let mut i_1: ::core::ffi::c_int = 0 as ::core::ffi::c_int;
                    let mut msk_0: ::core::ffi::c_int = (*h).mb.i_cbp_luma;
                    let mut skip_0: ::core::ffi::c_int = 0;
                    while msk_0 != 0 && {
                        skip_0 = x264_ctz_4bit(msk_0 as uint32_t);
                        i_1 += skip_0;
                        msk_0 >>= skip_0 + 1 as ::core::ffi::c_int;
                        1 as ::core::ffi::c_int != 0
                    } {
                        cabac_block_residual_8x8(
                            h,
                            cb,
                            DCT_LUMA_8x8 as ::core::ffi::c_int,
                            (*(*h).dct.luma8x8.as_mut_ptr().offset(i_1 as isize)).as_mut_ptr(),
                        );
                        i_1 += 1;
                    }
                }
            } else {
                let mut p_1: ::core::ffi::c_int = 0 as ::core::ffi::c_int;
                while p_1 < plane_count {
                    let mut i8x8: ::core::ffi::c_int = 0 as ::core::ffi::c_int;
                    let mut msk_1: ::core::ffi::c_int = (*h).mb.i_cbp_luma;
                    let mut skip_1: ::core::ffi::c_int = 0;
                    while msk_1 != 0 && {
                        skip_1 = x264_ctz_4bit(msk_1 as uint32_t);
                        i8x8 += skip_1;
                        msk_1 >>= skip_1 + 1 as ::core::ffi::c_int;
                        1 as ::core::ffi::c_int != 0
                    } {
                        let mut i_2: ::core::ffi::c_int = 0 as ::core::ffi::c_int;
                        while i_2 < 4 as ::core::ffi::c_int {
                            let mut ctxidxinc_2: ::core::ffi::c_int = cabac_cbf_ctxidxinc(
                                h,
                                ctx_cat_plane[DCT_LUMA_4x4 as ::core::ffi::c_int as usize]
                                    [p_1 as usize]
                                    as ::core::ffi::c_int,
                                i_2 + i8x8 * 4 as ::core::ffi::c_int
                                    + p_1 * 16 as ::core::ffi::c_int,
                                b_intra,
                                0 as ::core::ffi::c_int,
                            );
                            if (*h).mb.cache.non_zero_count[x264_scan8[(i_2
                                + i8x8 * 4 as ::core::ffi::c_int
                                + p_1 * 16 as ::core::ffi::c_int)
                                as usize]
                                as usize]
                                != 0
                            {
                                x264_cabac_size_decision(
                                    cb,
                                    ctxidxinc_2 as ::core::ffi::c_long,
                                    1 as ::core::ffi::c_long,
                                );
                                cabac_block_residual(
                                    h,
                                    cb,
                                    ctx_cat_plane[DCT_LUMA_4x4 as ::core::ffi::c_int as usize]
                                        [p_1 as usize]
                                        as ::core::ffi::c_int,
                                    (*(*h).dct.luma4x4.as_mut_ptr().offset(
                                        (i_2 + i8x8 * 4 as ::core::ffi::c_int
                                            + p_1 * 16 as ::core::ffi::c_int)
                                            as isize,
                                    ))
                                    .as_mut_ptr(),
                                );
                            } else {
                                x264_cabac_size_decision(
                                    cb,
                                    ctxidxinc_2 as ::core::ffi::c_long,
                                    0 as ::core::ffi::c_long,
                                );
                            }
                            i_2 += 1;
                        }
                        i8x8 += 1;
                    }
                    p_1 += 1;
                }
            }
            if chroma != 0 && (*h).mb.i_cbp_chroma != 0 {
                if (*(*h).sps.as_mut_ptr()).i_chroma_format_idc == CHROMA_422 as ::core::ffi::c_int
                {
                    let mut ctxidxinc_3: ::core::ffi::c_int = cabac_cbf_ctxidxinc(
                        h,
                        DCT_CHROMA_DC as ::core::ffi::c_int,
                        49 as ::core::ffi::c_int + 0 as ::core::ffi::c_int,
                        b_intra,
                        1 as ::core::ffi::c_int,
                    );
                    if (*h).mb.cache.non_zero_count[x264_scan8
                        [(49 as ::core::ffi::c_int + 0 as ::core::ffi::c_int) as usize]
                        as usize]
                        != 0
                    {
                        x264_cabac_size_decision(
                            cb,
                            ctxidxinc_3 as ::core::ffi::c_long,
                            1 as ::core::ffi::c_long,
                        );
                        cabac_block_residual_422_dc(
                            h,
                            cb,
                            DCT_CHROMA_DC as ::core::ffi::c_int,
                            (*(*h)
                                .dct
                                .chroma_dc
                                .as_mut_ptr()
                                .offset(0 as ::core::ffi::c_int as isize))
                            .as_mut_ptr(),
                        );
                    } else {
                        x264_cabac_size_decision(
                            cb,
                            ctxidxinc_3 as ::core::ffi::c_long,
                            0 as ::core::ffi::c_long,
                        );
                    }
                    let mut ctxidxinc_4: ::core::ffi::c_int = cabac_cbf_ctxidxinc(
                        h,
                        DCT_CHROMA_DC as ::core::ffi::c_int,
                        49 as ::core::ffi::c_int + 1 as ::core::ffi::c_int,
                        b_intra,
                        1 as ::core::ffi::c_int,
                    );
                    if (*h).mb.cache.non_zero_count[x264_scan8
                        [(49 as ::core::ffi::c_int + 1 as ::core::ffi::c_int) as usize]
                        as usize]
                        != 0
                    {
                        x264_cabac_size_decision(
                            cb,
                            ctxidxinc_4 as ::core::ffi::c_long,
                            1 as ::core::ffi::c_long,
                        );
                        cabac_block_residual_422_dc(
                            h,
                            cb,
                            DCT_CHROMA_DC as ::core::ffi::c_int,
                            (*(*h)
                                .dct
                                .chroma_dc
                                .as_mut_ptr()
                                .offset(1 as ::core::ffi::c_int as isize))
                            .as_mut_ptr(),
                        );
                    } else {
                        x264_cabac_size_decision(
                            cb,
                            ctxidxinc_4 as ::core::ffi::c_long,
                            0 as ::core::ffi::c_long,
                        );
                    }
                } else {
                    let mut ctxidxinc_5: ::core::ffi::c_int = cabac_cbf_ctxidxinc(
                        h,
                        DCT_CHROMA_DC as ::core::ffi::c_int,
                        49 as ::core::ffi::c_int + 0 as ::core::ffi::c_int,
                        b_intra,
                        1 as ::core::ffi::c_int,
                    );
                    if (*h).mb.cache.non_zero_count[x264_scan8
                        [(49 as ::core::ffi::c_int + 0 as ::core::ffi::c_int) as usize]
                        as usize]
                        != 0
                    {
                        x264_cabac_size_decision(
                            cb,
                            ctxidxinc_5 as ::core::ffi::c_long,
                            1 as ::core::ffi::c_long,
                        );
                        cabac_block_residual(
                            h,
                            cb,
                            DCT_CHROMA_DC as ::core::ffi::c_int,
                            (*(*h)
                                .dct
                                .chroma_dc
                                .as_mut_ptr()
                                .offset(0 as ::core::ffi::c_int as isize))
                            .as_mut_ptr(),
                        );
                    } else {
                        x264_cabac_size_decision(
                            cb,
                            ctxidxinc_5 as ::core::ffi::c_long,
                            0 as ::core::ffi::c_long,
                        );
                    }
                    let mut ctxidxinc_6: ::core::ffi::c_int = cabac_cbf_ctxidxinc(
                        h,
                        DCT_CHROMA_DC as ::core::ffi::c_int,
                        49 as ::core::ffi::c_int + 1 as ::core::ffi::c_int,
                        b_intra,
                        1 as ::core::ffi::c_int,
                    );
                    if (*h).mb.cache.non_zero_count[x264_scan8
                        [(49 as ::core::ffi::c_int + 1 as ::core::ffi::c_int) as usize]
                        as usize]
                        != 0
                    {
                        x264_cabac_size_decision(
                            cb,
                            ctxidxinc_6 as ::core::ffi::c_long,
                            1 as ::core::ffi::c_long,
                        );
                        cabac_block_residual(
                            h,
                            cb,
                            DCT_CHROMA_DC as ::core::ffi::c_int,
                            (*(*h)
                                .dct
                                .chroma_dc
                                .as_mut_ptr()
                                .offset(1 as ::core::ffi::c_int as isize))
                            .as_mut_ptr(),
                        );
                    } else {
                        x264_cabac_size_decision(
                            cb,
                            ctxidxinc_6 as ::core::ffi::c_long,
                            0 as ::core::ffi::c_long,
                        );
                    }
                }
                if (*h).mb.i_cbp_chroma == 2 as ::core::ffi::c_int {
                    let mut step: ::core::ffi::c_int =
                        (8 as ::core::ffi::c_int) << (*h).mb.chroma_v_shift;
                    let mut i_3: ::core::ffi::c_int = 16 as ::core::ffi::c_int;
                    while i_3 < 3 as ::core::ffi::c_int * 16 as ::core::ffi::c_int {
                        let mut j: ::core::ffi::c_int = i_3;
                        while j < i_3 + 4 as ::core::ffi::c_int {
                            let mut ctxidxinc_7: ::core::ffi::c_int = cabac_cbf_ctxidxinc(
                                h,
                                DCT_CHROMA_AC as ::core::ffi::c_int,
                                j,
                                b_intra,
                                0 as ::core::ffi::c_int,
                            );
                            if (*h).mb.cache.non_zero_count[x264_scan8[j as usize] as usize] != 0 {
                                x264_cabac_size_decision(
                                    cb,
                                    ctxidxinc_7 as ::core::ffi::c_long,
                                    1 as ::core::ffi::c_long,
                                );
                                cabac_block_residual(
                                    h,
                                    cb,
                                    DCT_CHROMA_AC as ::core::ffi::c_int,
                                    (*(*h).dct.luma4x4.as_mut_ptr().offset(j as isize))
                                        .as_mut_ptr()
                                        .offset(1 as ::core::ffi::c_int as isize),
                                );
                            } else {
                                x264_cabac_size_decision(
                                    cb,
                                    ctxidxinc_7 as ::core::ffi::c_long,
                                    0 as ::core::ffi::c_long,
                                );
                            }
                            j += 1;
                        }
                        i_3 += step;
                    }
                }
            }
        }
    }
    #[c2rust::src_loc = "1088:1"]
    pub unsafe extern "C" fn macroblock_size_cabac(mut h: *mut x264_t, mut cb: *mut x264_cabac_t) {
        if (*(*h).sps.as_mut_ptr()).i_chroma_format_idc == CHROMA_444 as ::core::ffi::c_int {
            macroblock_write_cabac_internal(
                h,
                cb,
                3 as ::core::ffi::c_int,
                0 as ::core::ffi::c_int,
            );
        } else if (*(*h).sps.as_mut_ptr()).i_chroma_format_idc != 0 {
            macroblock_write_cabac_internal(
                h,
                cb,
                1 as ::core::ffi::c_int,
                1 as ::core::ffi::c_int,
            );
        } else {
            macroblock_write_cabac_internal(
                h,
                cb,
                1 as ::core::ffi::c_int,
                0 as ::core::ffi::c_int,
            );
        };
    }
    #[c2rust::src_loc = "1106:1"]
    pub unsafe extern "C" fn partition_size_cabac(
        mut h: *mut x264_t,
        mut cb: *mut x264_cabac_t,
        mut i8: ::core::ffi::c_int,
        mut i_pixel: ::core::ffi::c_int,
    ) {
        let i_mb_type: ::core::ffi::c_int = (*h).mb.i_type;
        let mut b_8x16: ::core::ffi::c_int =
            ((*h).mb.i_partition == D_8x16 as ::core::ffi::c_int) as ::core::ffi::c_int;
        let mut plane_count: ::core::ffi::c_int =
            if (*(*h).sps.as_mut_ptr()).i_chroma_format_idc == CHROMA_444 as ::core::ffi::c_int {
                3 as ::core::ffi::c_int
            } else {
                1 as ::core::ffi::c_int
            };
        if i_mb_type == P_8x8 as ::core::ffi::c_int {
            cabac_8x8_mvd(h, cb, i8);
            cabac_subpartition_p(
                cb,
                (*h).mb.i_sub_partition[i8 as usize] as ::core::ffi::c_int,
            );
        } else if i_mb_type == P_L0 as ::core::ffi::c_int {
            let mut mvd: uint16_t = cabac_mvd(
                h,
                cb,
                0 as ::core::ffi::c_int,
                4 as ::core::ffi::c_int * i8,
                4 as ::core::ffi::c_int >> b_8x16,
            );
            x264_macroblock_cache_mvd(
                h,
                block_idx_x[(4 as ::core::ffi::c_int * i8) as usize] as ::core::ffi::c_int,
                block_idx_y[(4 as ::core::ffi::c_int * i8) as usize] as ::core::ffi::c_int,
                4 as ::core::ffi::c_int >> b_8x16,
                (2 as ::core::ffi::c_int) << b_8x16,
                0 as ::core::ffi::c_int,
                mvd,
            );
        } else if i_mb_type > B_DIRECT as ::core::ffi::c_int
            && i_mb_type < B_8x8 as ::core::ffi::c_int
        {
            if x264_mb_type_list_table[i_mb_type as usize][0 as ::core::ffi::c_int as usize]
                [(i8 != 0) as ::core::ffi::c_int as usize]
                != 0
            {
                let mut mvd_0: uint16_t = cabac_mvd(
                    h,
                    cb,
                    0 as ::core::ffi::c_int,
                    4 as ::core::ffi::c_int * i8,
                    4 as ::core::ffi::c_int >> b_8x16,
                );
                x264_macroblock_cache_mvd(
                    h,
                    block_idx_x[(4 as ::core::ffi::c_int * i8) as usize] as ::core::ffi::c_int,
                    block_idx_y[(4 as ::core::ffi::c_int * i8) as usize] as ::core::ffi::c_int,
                    4 as ::core::ffi::c_int >> b_8x16,
                    (2 as ::core::ffi::c_int) << b_8x16,
                    0 as ::core::ffi::c_int,
                    mvd_0,
                );
            }
            if x264_mb_type_list_table[i_mb_type as usize][1 as ::core::ffi::c_int as usize]
                [(i8 != 0) as ::core::ffi::c_int as usize]
                != 0
            {
                let mut mvd_1: uint16_t = cabac_mvd(
                    h,
                    cb,
                    1 as ::core::ffi::c_int,
                    4 as ::core::ffi::c_int * i8,
                    4 as ::core::ffi::c_int >> b_8x16,
                );
                x264_macroblock_cache_mvd(
                    h,
                    block_idx_x[(4 as ::core::ffi::c_int * i8) as usize] as ::core::ffi::c_int,
                    block_idx_y[(4 as ::core::ffi::c_int * i8) as usize] as ::core::ffi::c_int,
                    4 as ::core::ffi::c_int >> b_8x16,
                    (2 as ::core::ffi::c_int) << b_8x16,
                    1 as ::core::ffi::c_int,
                    mvd_1,
                );
            }
        } else {
            if x264_mb_partition_listX_table[0 as ::core::ffi::c_int as usize]
                [(*h).mb.i_sub_partition[i8 as usize] as usize]
                != 0
            {
                let mut mvd_2: uint16_t = cabac_mvd(
                    h,
                    cb,
                    0 as ::core::ffi::c_int,
                    4 as ::core::ffi::c_int * i8,
                    2 as ::core::ffi::c_int,
                );
                x264_macroblock_cache_mvd(
                    h,
                    block_idx_x[(4 as ::core::ffi::c_int * i8) as usize] as ::core::ffi::c_int,
                    block_idx_y[(4 as ::core::ffi::c_int * i8) as usize] as ::core::ffi::c_int,
                    2 as ::core::ffi::c_int,
                    2 as ::core::ffi::c_int,
                    0 as ::core::ffi::c_int,
                    mvd_2,
                );
            }
            if x264_mb_partition_listX_table[1 as ::core::ffi::c_int as usize]
                [(*h).mb.i_sub_partition[i8 as usize] as usize]
                != 0
            {
                let mut mvd_3: uint16_t = cabac_mvd(
                    h,
                    cb,
                    1 as ::core::ffi::c_int,
                    4 as ::core::ffi::c_int * i8,
                    2 as ::core::ffi::c_int,
                );
                x264_macroblock_cache_mvd(
                    h,
                    block_idx_x[(4 as ::core::ffi::c_int * i8) as usize] as ::core::ffi::c_int,
                    block_idx_y[(4 as ::core::ffi::c_int * i8) as usize] as ::core::ffi::c_int,
                    2 as ::core::ffi::c_int,
                    2 as ::core::ffi::c_int,
                    1 as ::core::ffi::c_int,
                    mvd_3,
                );
            }
        }
        let mut j: ::core::ffi::c_int =
            (i_pixel < PIXEL_8x8 as ::core::ffi::c_int) as ::core::ffi::c_int;
        while j >= 0 as ::core::ffi::c_int {
            if (*h).mb.i_cbp_luma & (1 as ::core::ffi::c_int) << i8 != 0 {
                if (*h).mb.b_transform_8x8 != 0 {
                    if (*(*h).sps.as_mut_ptr()).i_chroma_format_idc
                        == CHROMA_444 as ::core::ffi::c_int
                    {
                        let mut p: ::core::ffi::c_int = 0 as ::core::ffi::c_int;
                        while p < 3 as ::core::ffi::c_int {
                            let mut ctxidxinc: ::core::ffi::c_int = cabac_cbf_ctxidxinc(
                                h,
                                ctx_cat_plane[DCT_LUMA_8x8 as ::core::ffi::c_int as usize]
                                    [p as usize]
                                    as ::core::ffi::c_int,
                                i8 * 4 as ::core::ffi::c_int + p * 16 as ::core::ffi::c_int,
                                0 as ::core::ffi::c_int,
                                0 as ::core::ffi::c_int,
                            );
                            if (*h).mb.cache.non_zero_count[x264_scan8[(i8
                                * 4 as ::core::ffi::c_int
                                + p * 16 as ::core::ffi::c_int)
                                as usize]
                                as usize]
                                != 0
                            {
                                x264_cabac_size_decision(
                                    cb,
                                    ctxidxinc as ::core::ffi::c_long,
                                    1 as ::core::ffi::c_long,
                                );
                                cabac_block_residual_8x8(
                                    h,
                                    cb,
                                    ctx_cat_plane[DCT_LUMA_8x8 as ::core::ffi::c_int as usize]
                                        [p as usize]
                                        as ::core::ffi::c_int,
                                    (*(*h)
                                        .dct
                                        .luma8x8
                                        .as_mut_ptr()
                                        .offset((i8 + p * 4 as ::core::ffi::c_int) as isize))
                                    .as_mut_ptr(),
                                );
                            } else {
                                x264_cabac_size_decision(
                                    cb,
                                    ctxidxinc as ::core::ffi::c_long,
                                    0 as ::core::ffi::c_long,
                                );
                            }
                            p += 1;
                        }
                    } else {
                        cabac_block_residual_8x8(
                            h,
                            cb,
                            DCT_LUMA_8x8 as ::core::ffi::c_int,
                            (*(*h).dct.luma8x8.as_mut_ptr().offset(i8 as isize)).as_mut_ptr(),
                        );
                    }
                } else {
                    let mut p_0: ::core::ffi::c_int = 0 as ::core::ffi::c_int;
                    while p_0 < plane_count {
                        let mut i4: ::core::ffi::c_int = 0 as ::core::ffi::c_int;
                        while i4 < 4 as ::core::ffi::c_int {
                            let mut ctxidxinc_0: ::core::ffi::c_int = cabac_cbf_ctxidxinc(
                                h,
                                ctx_cat_plane[DCT_LUMA_4x4 as ::core::ffi::c_int as usize]
                                    [p_0 as usize]
                                    as ::core::ffi::c_int,
                                i4 + i8 * 4 as ::core::ffi::c_int + p_0 * 16 as ::core::ffi::c_int,
                                0 as ::core::ffi::c_int,
                                0 as ::core::ffi::c_int,
                            );
                            if (*h).mb.cache.non_zero_count[x264_scan8[(i4
                                + i8 * 4 as ::core::ffi::c_int
                                + p_0 * 16 as ::core::ffi::c_int)
                                as usize]
                                as usize]
                                != 0
                            {
                                x264_cabac_size_decision(
                                    cb,
                                    ctxidxinc_0 as ::core::ffi::c_long,
                                    1 as ::core::ffi::c_long,
                                );
                                cabac_block_residual(
                                    h,
                                    cb,
                                    ctx_cat_plane[DCT_LUMA_4x4 as ::core::ffi::c_int as usize]
                                        [p_0 as usize]
                                        as ::core::ffi::c_int,
                                    (*(*h).dct.luma4x4.as_mut_ptr().offset(
                                        (i4 + i8 * 4 as ::core::ffi::c_int
                                            + p_0 * 16 as ::core::ffi::c_int)
                                            as isize,
                                    ))
                                    .as_mut_ptr(),
                                );
                            } else {
                                x264_cabac_size_decision(
                                    cb,
                                    ctxidxinc_0 as ::core::ffi::c_long,
                                    0 as ::core::ffi::c_long,
                                );
                            }
                            i4 += 1;
                        }
                        p_0 += 1;
                    }
                }
            }
            if (*h).mb.i_cbp_chroma != 0 {
                if (*(*h).sps.as_mut_ptr()).i_chroma_format_idc == CHROMA_422 as ::core::ffi::c_int
                {
                    let mut offset: ::core::ffi::c_int =
                        5 as ::core::ffi::c_int * i8 & 0x9 as ::core::ffi::c_int;
                    let mut ctxidxinc_1: ::core::ffi::c_int = cabac_cbf_ctxidxinc(
                        h,
                        DCT_CHROMA_AC as ::core::ffi::c_int,
                        16 as ::core::ffi::c_int + offset,
                        0 as ::core::ffi::c_int,
                        0 as ::core::ffi::c_int,
                    );
                    if (*h).mb.cache.non_zero_count
                        [x264_scan8[(16 as ::core::ffi::c_int + offset) as usize] as usize]
                        != 0
                    {
                        x264_cabac_size_decision(
                            cb,
                            ctxidxinc_1 as ::core::ffi::c_long,
                            1 as ::core::ffi::c_long,
                        );
                        cabac_block_residual(
                            h,
                            cb,
                            DCT_CHROMA_AC as ::core::ffi::c_int,
                            (*(*h)
                                .dct
                                .luma4x4
                                .as_mut_ptr()
                                .offset((16 as ::core::ffi::c_int + offset) as isize))
                            .as_mut_ptr()
                            .offset(1 as ::core::ffi::c_int as isize),
                        );
                    } else {
                        x264_cabac_size_decision(
                            cb,
                            ctxidxinc_1 as ::core::ffi::c_long,
                            0 as ::core::ffi::c_long,
                        );
                    }
                    let mut ctxidxinc_2: ::core::ffi::c_int = cabac_cbf_ctxidxinc(
                        h,
                        DCT_CHROMA_AC as ::core::ffi::c_int,
                        18 as ::core::ffi::c_int + offset,
                        0 as ::core::ffi::c_int,
                        0 as ::core::ffi::c_int,
                    );
                    if (*h).mb.cache.non_zero_count
                        [x264_scan8[(18 as ::core::ffi::c_int + offset) as usize] as usize]
                        != 0
                    {
                        x264_cabac_size_decision(
                            cb,
                            ctxidxinc_2 as ::core::ffi::c_long,
                            1 as ::core::ffi::c_long,
                        );
                        cabac_block_residual(
                            h,
                            cb,
                            DCT_CHROMA_AC as ::core::ffi::c_int,
                            (*(*h)
                                .dct
                                .luma4x4
                                .as_mut_ptr()
                                .offset((18 as ::core::ffi::c_int + offset) as isize))
                            .as_mut_ptr()
                            .offset(1 as ::core::ffi::c_int as isize),
                        );
                    } else {
                        x264_cabac_size_decision(
                            cb,
                            ctxidxinc_2 as ::core::ffi::c_long,
                            0 as ::core::ffi::c_long,
                        );
                    }
                    let mut ctxidxinc_3: ::core::ffi::c_int = cabac_cbf_ctxidxinc(
                        h,
                        DCT_CHROMA_AC as ::core::ffi::c_int,
                        32 as ::core::ffi::c_int + offset,
                        0 as ::core::ffi::c_int,
                        0 as ::core::ffi::c_int,
                    );
                    if (*h).mb.cache.non_zero_count
                        [x264_scan8[(32 as ::core::ffi::c_int + offset) as usize] as usize]
                        != 0
                    {
                        x264_cabac_size_decision(
                            cb,
                            ctxidxinc_3 as ::core::ffi::c_long,
                            1 as ::core::ffi::c_long,
                        );
                        cabac_block_residual(
                            h,
                            cb,
                            DCT_CHROMA_AC as ::core::ffi::c_int,
                            (*(*h)
                                .dct
                                .luma4x4
                                .as_mut_ptr()
                                .offset((32 as ::core::ffi::c_int + offset) as isize))
                            .as_mut_ptr()
                            .offset(1 as ::core::ffi::c_int as isize),
                        );
                    } else {
                        x264_cabac_size_decision(
                            cb,
                            ctxidxinc_3 as ::core::ffi::c_long,
                            0 as ::core::ffi::c_long,
                        );
                    }
                    let mut ctxidxinc_4: ::core::ffi::c_int = cabac_cbf_ctxidxinc(
                        h,
                        DCT_CHROMA_AC as ::core::ffi::c_int,
                        34 as ::core::ffi::c_int + offset,
                        0 as ::core::ffi::c_int,
                        0 as ::core::ffi::c_int,
                    );
                    if (*h).mb.cache.non_zero_count
                        [x264_scan8[(34 as ::core::ffi::c_int + offset) as usize] as usize]
                        != 0
                    {
                        x264_cabac_size_decision(
                            cb,
                            ctxidxinc_4 as ::core::ffi::c_long,
                            1 as ::core::ffi::c_long,
                        );
                        cabac_block_residual(
                            h,
                            cb,
                            DCT_CHROMA_AC as ::core::ffi::c_int,
                            (*(*h)
                                .dct
                                .luma4x4
                                .as_mut_ptr()
                                .offset((34 as ::core::ffi::c_int + offset) as isize))
                            .as_mut_ptr()
                            .offset(1 as ::core::ffi::c_int as isize),
                        );
                    } else {
                        x264_cabac_size_decision(
                            cb,
                            ctxidxinc_4 as ::core::ffi::c_long,
                            0 as ::core::ffi::c_long,
                        );
                    }
                } else {
                    let mut ctxidxinc_5: ::core::ffi::c_int = cabac_cbf_ctxidxinc(
                        h,
                        DCT_CHROMA_AC as ::core::ffi::c_int,
                        16 as ::core::ffi::c_int + i8,
                        0 as ::core::ffi::c_int,
                        0 as ::core::ffi::c_int,
                    );
                    if (*h).mb.cache.non_zero_count
                        [x264_scan8[(16 as ::core::ffi::c_int + i8) as usize] as usize]
                        != 0
                    {
                        x264_cabac_size_decision(
                            cb,
                            ctxidxinc_5 as ::core::ffi::c_long,
                            1 as ::core::ffi::c_long,
                        );
                        cabac_block_residual(
                            h,
                            cb,
                            DCT_CHROMA_AC as ::core::ffi::c_int,
                            (*(*h)
                                .dct
                                .luma4x4
                                .as_mut_ptr()
                                .offset((16 as ::core::ffi::c_int + i8) as isize))
                            .as_mut_ptr()
                            .offset(1 as ::core::ffi::c_int as isize),
                        );
                    } else {
                        x264_cabac_size_decision(
                            cb,
                            ctxidxinc_5 as ::core::ffi::c_long,
                            0 as ::core::ffi::c_long,
                        );
                    }
                    let mut ctxidxinc_6: ::core::ffi::c_int = cabac_cbf_ctxidxinc(
                        h,
                        DCT_CHROMA_AC as ::core::ffi::c_int,
                        32 as ::core::ffi::c_int + i8,
                        0 as ::core::ffi::c_int,
                        0 as ::core::ffi::c_int,
                    );
                    if (*h).mb.cache.non_zero_count
                        [x264_scan8[(32 as ::core::ffi::c_int + i8) as usize] as usize]
                        != 0
                    {
                        x264_cabac_size_decision(
                            cb,
                            ctxidxinc_6 as ::core::ffi::c_long,
                            1 as ::core::ffi::c_long,
                        );
                        cabac_block_residual(
                            h,
                            cb,
                            DCT_CHROMA_AC as ::core::ffi::c_int,
                            (*(*h)
                                .dct
                                .luma4x4
                                .as_mut_ptr()
                                .offset((32 as ::core::ffi::c_int + i8) as isize))
                            .as_mut_ptr()
                            .offset(1 as ::core::ffi::c_int as isize),
                        );
                    } else {
                        x264_cabac_size_decision(
                            cb,
                            ctxidxinc_6 as ::core::ffi::c_long,
                            0 as ::core::ffi::c_long,
                        );
                    }
                }
            }
            i8 += x264_pixel_size[i_pixel as usize].h as ::core::ffi::c_int
                >> 3 as ::core::ffi::c_int;
            j -= 1;
        }
    }
    #[c2rust::src_loc = "1171:1"]
    pub unsafe extern "C" fn subpartition_size_cabac(
        mut h: *mut x264_t,
        mut cb: *mut x264_cabac_t,
        mut i4: ::core::ffi::c_int,
        mut i_pixel: ::core::ffi::c_int,
    ) {
        let mut b_8x4: ::core::ffi::c_int =
            (i_pixel == PIXEL_8x4 as ::core::ffi::c_int) as ::core::ffi::c_int;
        let mut plane_count: ::core::ffi::c_int =
            if (*(*h).sps.as_mut_ptr()).i_chroma_format_idc == CHROMA_444 as ::core::ffi::c_int {
                3 as ::core::ffi::c_int
            } else {
                1 as ::core::ffi::c_int
            };
        if i_pixel == PIXEL_4x4 as ::core::ffi::c_int {
            let mut mvd: uint16_t =
                cabac_mvd(h, cb, 0 as ::core::ffi::c_int, i4, 1 as ::core::ffi::c_int);
            x264_macroblock_cache_mvd(
                h,
                block_idx_x[i4 as usize] as ::core::ffi::c_int,
                block_idx_y[i4 as usize] as ::core::ffi::c_int,
                1 as ::core::ffi::c_int,
                1 as ::core::ffi::c_int,
                0 as ::core::ffi::c_int,
                mvd,
            );
        } else {
            let mut mvd_0: uint16_t = cabac_mvd(
                h,
                cb,
                0 as ::core::ffi::c_int,
                i4,
                1 as ::core::ffi::c_int + b_8x4,
            );
            x264_macroblock_cache_mvd(
                h,
                block_idx_x[i4 as usize] as ::core::ffi::c_int,
                block_idx_y[i4 as usize] as ::core::ffi::c_int,
                1 as ::core::ffi::c_int + b_8x4,
                2 as ::core::ffi::c_int - b_8x4,
                0 as ::core::ffi::c_int,
                mvd_0,
            );
        }
        let mut p: ::core::ffi::c_int = 0 as ::core::ffi::c_int;
        while p < plane_count {
            let mut ctxidxinc: ::core::ffi::c_int = cabac_cbf_ctxidxinc(
                h,
                ctx_cat_plane[DCT_LUMA_4x4 as ::core::ffi::c_int as usize][p as usize]
                    as ::core::ffi::c_int,
                p * 16 as ::core::ffi::c_int + i4,
                0 as ::core::ffi::c_int,
                0 as ::core::ffi::c_int,
            );
            if (*h).mb.cache.non_zero_count
                [x264_scan8[(p * 16 as ::core::ffi::c_int + i4) as usize] as usize]
                != 0
            {
                x264_cabac_size_decision(
                    cb,
                    ctxidxinc as ::core::ffi::c_long,
                    1 as ::core::ffi::c_long,
                );
                cabac_block_residual(
                    h,
                    cb,
                    ctx_cat_plane[DCT_LUMA_4x4 as ::core::ffi::c_int as usize][p as usize]
                        as ::core::ffi::c_int,
                    (*(*h)
                        .dct
                        .luma4x4
                        .as_mut_ptr()
                        .offset((p * 16 as ::core::ffi::c_int + i4) as isize))
                    .as_mut_ptr(),
                );
            } else {
                x264_cabac_size_decision(
                    cb,
                    ctxidxinc as ::core::ffi::c_long,
                    0 as ::core::ffi::c_long,
                );
            }
            if i_pixel != PIXEL_4x4 as ::core::ffi::c_int {
                let mut ctxidxinc_0: ::core::ffi::c_int = cabac_cbf_ctxidxinc(
                    h,
                    ctx_cat_plane[DCT_LUMA_4x4 as ::core::ffi::c_int as usize][p as usize]
                        as ::core::ffi::c_int,
                    p * 16 as ::core::ffi::c_int + i4 + 2 as ::core::ffi::c_int - b_8x4,
                    0 as ::core::ffi::c_int,
                    0 as ::core::ffi::c_int,
                );
                if (*h).mb.cache.non_zero_count[x264_scan8
                    [(p * 16 as ::core::ffi::c_int + i4 + 2 as ::core::ffi::c_int - b_8x4) as usize]
                    as usize]
                    != 0
                {
                    x264_cabac_size_decision(
                        cb,
                        ctxidxinc_0 as ::core::ffi::c_long,
                        1 as ::core::ffi::c_long,
                    );
                    cabac_block_residual(
                        h,
                        cb,
                        ctx_cat_plane[DCT_LUMA_4x4 as ::core::ffi::c_int as usize][p as usize]
                            as ::core::ffi::c_int,
                        (*(*h).dct.luma4x4.as_mut_ptr().offset(
                            (p * 16 as ::core::ffi::c_int + i4 + 2 as ::core::ffi::c_int - b_8x4)
                                as isize,
                        ))
                        .as_mut_ptr(),
                    );
                } else {
                    x264_cabac_size_decision(
                        cb,
                        ctxidxinc_0 as ::core::ffi::c_long,
                        0 as ::core::ffi::c_long,
                    );
                }
            }
            p += 1;
        }
    }
    #[c2rust::src_loc = "1187:1"]
    pub unsafe extern "C" fn partition_i8x8_size_cabac(
        mut h: *mut x264_t,
        mut cb: *mut x264_cabac_t,
        mut i8: ::core::ffi::c_int,
        mut i_mode: ::core::ffi::c_int,
    ) {
        let i_pred: ::core::ffi::c_int =
            x264_mb_predict_intra4x4_mode(h, 4 as ::core::ffi::c_int * i8) as ::core::ffi::c_int;
        i_mode = x264_mb_pred_mode4x4_fix[(i_mode + 1 as ::core::ffi::c_int) as usize]
            as ::core::ffi::c_int;
        cabac_intra4x4_pred_mode(cb, i_pred, i_mode);
        cabac_cbp_luma(h, cb);
        if (*h).mb.i_cbp_luma & (1 as ::core::ffi::c_int) << i8 != 0 {
            if (*(*h).sps.as_mut_ptr()).i_chroma_format_idc == CHROMA_444 as ::core::ffi::c_int {
                let mut p: ::core::ffi::c_int = 0 as ::core::ffi::c_int;
                while p < 3 as ::core::ffi::c_int {
                    let mut ctxidxinc: ::core::ffi::c_int = cabac_cbf_ctxidxinc(
                        h,
                        ctx_cat_plane[DCT_LUMA_8x8 as ::core::ffi::c_int as usize][p as usize]
                            as ::core::ffi::c_int,
                        i8 * 4 as ::core::ffi::c_int + p * 16 as ::core::ffi::c_int,
                        1 as ::core::ffi::c_int,
                        0 as ::core::ffi::c_int,
                    );
                    if (*h).mb.cache.non_zero_count[x264_scan8
                        [(i8 * 4 as ::core::ffi::c_int + p * 16 as ::core::ffi::c_int) as usize]
                        as usize]
                        != 0
                    {
                        x264_cabac_size_decision(
                            cb,
                            ctxidxinc as ::core::ffi::c_long,
                            1 as ::core::ffi::c_long,
                        );
                        cabac_block_residual_8x8(
                            h,
                            cb,
                            ctx_cat_plane[DCT_LUMA_8x8 as ::core::ffi::c_int as usize][p as usize]
                                as ::core::ffi::c_int,
                            (*(*h)
                                .dct
                                .luma8x8
                                .as_mut_ptr()
                                .offset((i8 + p * 4 as ::core::ffi::c_int) as isize))
                            .as_mut_ptr(),
                        );
                    } else {
                        x264_cabac_size_decision(
                            cb,
                            ctxidxinc as ::core::ffi::c_long,
                            0 as ::core::ffi::c_long,
                        );
                    }
                    p += 1;
                }
            } else {
                cabac_block_residual_8x8(
                    h,
                    cb,
                    DCT_LUMA_8x8 as ::core::ffi::c_int,
                    (*(*h).dct.luma8x8.as_mut_ptr().offset(i8 as isize)).as_mut_ptr(),
                );
            }
        }
    }
    #[c2rust::src_loc = "1203:1"]
    pub unsafe extern "C" fn partition_i4x4_size_cabac(
        mut h: *mut x264_t,
        mut cb: *mut x264_cabac_t,
        mut i4: ::core::ffi::c_int,
        mut i_mode: ::core::ffi::c_int,
    ) {
        let i_pred: ::core::ffi::c_int = x264_mb_predict_intra4x4_mode(h, i4) as ::core::ffi::c_int;
        let mut plane_count: ::core::ffi::c_int =
            if (*(*h).sps.as_mut_ptr()).i_chroma_format_idc == CHROMA_444 as ::core::ffi::c_int {
                3 as ::core::ffi::c_int
            } else {
                1 as ::core::ffi::c_int
            };
        i_mode = x264_mb_pred_mode4x4_fix[(i_mode + 1 as ::core::ffi::c_int) as usize]
            as ::core::ffi::c_int;
        cabac_intra4x4_pred_mode(cb, i_pred, i_mode);
        let mut p: ::core::ffi::c_int = 0 as ::core::ffi::c_int;
        while p < plane_count {
            let mut ctxidxinc: ::core::ffi::c_int = cabac_cbf_ctxidxinc(
                h,
                ctx_cat_plane[DCT_LUMA_4x4 as ::core::ffi::c_int as usize][p as usize]
                    as ::core::ffi::c_int,
                i4 + p * 16 as ::core::ffi::c_int,
                1 as ::core::ffi::c_int,
                0 as ::core::ffi::c_int,
            );
            if (*h).mb.cache.non_zero_count
                [x264_scan8[(i4 + p * 16 as ::core::ffi::c_int) as usize] as usize]
                != 0
            {
                x264_cabac_size_decision(
                    cb,
                    ctxidxinc as ::core::ffi::c_long,
                    1 as ::core::ffi::c_long,
                );
                cabac_block_residual(
                    h,
                    cb,
                    ctx_cat_plane[DCT_LUMA_4x4 as ::core::ffi::c_int as usize][p as usize]
                        as ::core::ffi::c_int,
                    (*(*h)
                        .dct
                        .luma4x4
                        .as_mut_ptr()
                        .offset((i4 + p * 16 as ::core::ffi::c_int) as isize))
                    .as_mut_ptr(),
                );
            } else {
                x264_cabac_size_decision(
                    cb,
                    ctxidxinc as ::core::ffi::c_long,
                    0 as ::core::ffi::c_long,
                );
            }
            p += 1;
        }
    }
    #[c2rust::src_loc = "1213:1"]
    pub unsafe extern "C" fn chroma_size_cabac(mut h: *mut x264_t, mut cb: *mut x264_cabac_t) {
        cabac_intra_chroma_pred_mode(h, cb);
        cabac_cbp_chroma(h, cb);
        if (*h).mb.i_cbp_chroma != 0 {
            if (*(*h).sps.as_mut_ptr()).i_chroma_format_idc == CHROMA_422 as ::core::ffi::c_int {
                let mut ctxidxinc: ::core::ffi::c_int = cabac_cbf_ctxidxinc(
                    h,
                    DCT_CHROMA_DC as ::core::ffi::c_int,
                    49 as ::core::ffi::c_int + 0 as ::core::ffi::c_int,
                    1 as ::core::ffi::c_int,
                    1 as ::core::ffi::c_int,
                );
                if (*h).mb.cache.non_zero_count[x264_scan8
                    [(49 as ::core::ffi::c_int + 0 as ::core::ffi::c_int) as usize]
                    as usize]
                    != 0
                {
                    x264_cabac_size_decision(
                        cb,
                        ctxidxinc as ::core::ffi::c_long,
                        1 as ::core::ffi::c_long,
                    );
                    cabac_block_residual_422_dc(
                        h,
                        cb,
                        DCT_CHROMA_DC as ::core::ffi::c_int,
                        (*(*h)
                            .dct
                            .chroma_dc
                            .as_mut_ptr()
                            .offset(0 as ::core::ffi::c_int as isize))
                        .as_mut_ptr(),
                    );
                } else {
                    x264_cabac_size_decision(
                        cb,
                        ctxidxinc as ::core::ffi::c_long,
                        0 as ::core::ffi::c_long,
                    );
                }
                let mut ctxidxinc_0: ::core::ffi::c_int = cabac_cbf_ctxidxinc(
                    h,
                    DCT_CHROMA_DC as ::core::ffi::c_int,
                    49 as ::core::ffi::c_int + 1 as ::core::ffi::c_int,
                    1 as ::core::ffi::c_int,
                    1 as ::core::ffi::c_int,
                );
                if (*h).mb.cache.non_zero_count[x264_scan8
                    [(49 as ::core::ffi::c_int + 1 as ::core::ffi::c_int) as usize]
                    as usize]
                    != 0
                {
                    x264_cabac_size_decision(
                        cb,
                        ctxidxinc_0 as ::core::ffi::c_long,
                        1 as ::core::ffi::c_long,
                    );
                    cabac_block_residual_422_dc(
                        h,
                        cb,
                        DCT_CHROMA_DC as ::core::ffi::c_int,
                        (*(*h)
                            .dct
                            .chroma_dc
                            .as_mut_ptr()
                            .offset(1 as ::core::ffi::c_int as isize))
                        .as_mut_ptr(),
                    );
                } else {
                    x264_cabac_size_decision(
                        cb,
                        ctxidxinc_0 as ::core::ffi::c_long,
                        0 as ::core::ffi::c_long,
                    );
                }
            } else {
                let mut ctxidxinc_1: ::core::ffi::c_int = cabac_cbf_ctxidxinc(
                    h,
                    DCT_CHROMA_DC as ::core::ffi::c_int,
                    49 as ::core::ffi::c_int + 0 as ::core::ffi::c_int,
                    1 as ::core::ffi::c_int,
                    1 as ::core::ffi::c_int,
                );
                if (*h).mb.cache.non_zero_count[x264_scan8
                    [(49 as ::core::ffi::c_int + 0 as ::core::ffi::c_int) as usize]
                    as usize]
                    != 0
                {
                    x264_cabac_size_decision(
                        cb,
                        ctxidxinc_1 as ::core::ffi::c_long,
                        1 as ::core::ffi::c_long,
                    );
                    cabac_block_residual(
                        h,
                        cb,
                        DCT_CHROMA_DC as ::core::ffi::c_int,
                        (*(*h)
                            .dct
                            .chroma_dc
                            .as_mut_ptr()
                            .offset(0 as ::core::ffi::c_int as isize))
                        .as_mut_ptr(),
                    );
                } else {
                    x264_cabac_size_decision(
                        cb,
                        ctxidxinc_1 as ::core::ffi::c_long,
                        0 as ::core::ffi::c_long,
                    );
                }
                let mut ctxidxinc_2: ::core::ffi::c_int = cabac_cbf_ctxidxinc(
                    h,
                    DCT_CHROMA_DC as ::core::ffi::c_int,
                    49 as ::core::ffi::c_int + 1 as ::core::ffi::c_int,
                    1 as ::core::ffi::c_int,
                    1 as ::core::ffi::c_int,
                );
                if (*h).mb.cache.non_zero_count[x264_scan8
                    [(49 as ::core::ffi::c_int + 1 as ::core::ffi::c_int) as usize]
                    as usize]
                    != 0
                {
                    x264_cabac_size_decision(
                        cb,
                        ctxidxinc_2 as ::core::ffi::c_long,
                        1 as ::core::ffi::c_long,
                    );
                    cabac_block_residual(
                        h,
                        cb,
                        DCT_CHROMA_DC as ::core::ffi::c_int,
                        (*(*h)
                            .dct
                            .chroma_dc
                            .as_mut_ptr()
                            .offset(1 as ::core::ffi::c_int as isize))
                        .as_mut_ptr(),
                    );
                } else {
                    x264_cabac_size_decision(
                        cb,
                        ctxidxinc_2 as ::core::ffi::c_long,
                        0 as ::core::ffi::c_long,
                    );
                }
            }
            if (*h).mb.i_cbp_chroma == 2 as ::core::ffi::c_int {
                let mut step: ::core::ffi::c_int =
                    (8 as ::core::ffi::c_int) << (*h).mb.chroma_v_shift;
                let mut i: ::core::ffi::c_int = 16 as ::core::ffi::c_int;
                while i < 3 as ::core::ffi::c_int * 16 as ::core::ffi::c_int {
                    let mut j: ::core::ffi::c_int = i;
                    while j < i + 4 as ::core::ffi::c_int {
                        let mut ctxidxinc_3: ::core::ffi::c_int = cabac_cbf_ctxidxinc(
                            h,
                            DCT_CHROMA_AC as ::core::ffi::c_int,
                            j,
                            1 as ::core::ffi::c_int,
                            0 as ::core::ffi::c_int,
                        );
                        if (*h).mb.cache.non_zero_count[x264_scan8[j as usize] as usize] != 0 {
                            x264_cabac_size_decision(
                                cb,
                                ctxidxinc_3 as ::core::ffi::c_long,
                                1 as ::core::ffi::c_long,
                            );
                            cabac_block_residual(
                                h,
                                cb,
                                DCT_CHROMA_AC as ::core::ffi::c_int,
                                (*(*h).dct.luma4x4.as_mut_ptr().offset(j as isize))
                                    .as_mut_ptr()
                                    .offset(1 as ::core::ffi::c_int as isize),
                            );
                        } else {
                            x264_cabac_size_decision(
                                cb,
                                ctxidxinc_3 as ::core::ffi::c_long,
                                0 as ::core::ffi::c_long,
                            );
                        }
                        j += 1;
                    }
                    i += step;
                }
            }
        }
    }
    use super::assert_h::__assert_fail;
    use super::base_h::{
        x264_cabac_mvd_sum, x264_scan8, x264_union32_t, CHROMA_422, CHROMA_444, LUMA_DC,
        SLICE_TYPE_B, SLICE_TYPE_I, SLICE_TYPE_P,
    };
    use super::bitstream_h::bs_size_ue_big;
    use super::cabac_h::{x264_cabac_size_decision, x264_cabac_size_decision_noup, x264_cabac_t};
    use super::common_h::{dctcoef, x264_t, QP_MAX_SPEC};
    use super::macroblock_h::{
        block_idx_x, block_idx_y, ctx_cat_plane, pack8to16, x264_10_mb_predict_mv,
        x264_mb_partition_listX_table, x264_mb_predict_intra4x4_mode,
        x264_mb_transform_8x8_allowed, x264_mb_type_list_table, B_8x8, DCT_LUMA_4x4, DCT_LUMA_8x8,
        D_16x16, D_16x8, D_8x16, D_BI_8x8, D_DIRECT_8x8, D_L0_4x8, D_L0_8x4, D_L0_8x8, D_L1_8x8,
        I_16x16, I_4x4, I_8x8, P_8x8, B_BI_BI, B_DIRECT, B_L0_L0, B_SKIP, DCT_CHROMA_AC,
        DCT_CHROMA_DC, DCT_LUMA_AC, DCT_LUMA_DC, I_PCM, MB_LEFT, MB_TOP, P_L0,
    };
    use super::osdep_h::x264_ctz_4bit;
    use super::pixel_h::{x264_pixel_size, PIXEL_4x4, PIXEL_8x4, PIXEL_8x8};
    use super::predict_h::{
        x264_mb_chroma_pred_mode_fix, x264_mb_pred_mode16x16_fix, x264_mb_pred_mode4x4_fix,
    };
    use super::rdo_c::{
        cabac_size_5ones, cabac_transition_5ones, x264_10_cabac_size_unary,
        x264_10_cabac_transition_unary,
    };
    use super::rectangle_h::x264_macroblock_cache_mvd;
    use super::stdint_intn_h::{int16_t, int8_t};
    use super::stdint_uintn_h::{uint16_t, uint32_t, uint8_t};
    use super::stdlib_h::abs;
    use super::tables_h::{
        x264_coeff_abs_level_m1_offset, x264_coeff_flag_offset_chroma_422_dc, x264_count_cat_m1,
        x264_last_coeff_flag_offset, x264_last_coeff_flag_offset_8x8,
        x264_significant_coeff_flag_offset, x264_significant_coeff_flag_offset_8x8,
    };
}
#[c2rust::header_src = "/home/nwplayer123/Hacks/hex264/x264/encoder/cavlc.c:28"]
pub mod cavlc_c {
    #[c2rust::src_loc = "36:22"]
    pub static mut cbp_to_golomb: [[[uint8_t; 48]; 2]; 2] = [
        [
            [
                0 as ::core::ffi::c_int as uint8_t,
                1 as ::core::ffi::c_int as uint8_t,
                2 as ::core::ffi::c_int as uint8_t,
                5 as ::core::ffi::c_int as uint8_t,
                3 as ::core::ffi::c_int as uint8_t,
                6 as ::core::ffi::c_int as uint8_t,
                14 as ::core::ffi::c_int as uint8_t,
                10 as ::core::ffi::c_int as uint8_t,
                4 as ::core::ffi::c_int as uint8_t,
                15 as ::core::ffi::c_int as uint8_t,
                7 as ::core::ffi::c_int as uint8_t,
                11 as ::core::ffi::c_int as uint8_t,
                8 as ::core::ffi::c_int as uint8_t,
                12 as ::core::ffi::c_int as uint8_t,
                13 as ::core::ffi::c_int as uint8_t,
                9 as ::core::ffi::c_int as uint8_t,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
            ],
            [
                1 as ::core::ffi::c_int as uint8_t,
                10 as ::core::ffi::c_int as uint8_t,
                11 as ::core::ffi::c_int as uint8_t,
                6 as ::core::ffi::c_int as uint8_t,
                12 as ::core::ffi::c_int as uint8_t,
                7 as ::core::ffi::c_int as uint8_t,
                14 as ::core::ffi::c_int as uint8_t,
                2 as ::core::ffi::c_int as uint8_t,
                13 as ::core::ffi::c_int as uint8_t,
                15 as ::core::ffi::c_int as uint8_t,
                8 as ::core::ffi::c_int as uint8_t,
                3 as ::core::ffi::c_int as uint8_t,
                9 as ::core::ffi::c_int as uint8_t,
                4 as ::core::ffi::c_int as uint8_t,
                5 as ::core::ffi::c_int as uint8_t,
                0 as ::core::ffi::c_int as uint8_t,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
            ],
        ],
        [
            [
                0 as ::core::ffi::c_int as uint8_t,
                2 as ::core::ffi::c_int as uint8_t,
                3 as ::core::ffi::c_int as uint8_t,
                7 as ::core::ffi::c_int as uint8_t,
                4 as ::core::ffi::c_int as uint8_t,
                8 as ::core::ffi::c_int as uint8_t,
                17 as ::core::ffi::c_int as uint8_t,
                13 as ::core::ffi::c_int as uint8_t,
                5 as ::core::ffi::c_int as uint8_t,
                18 as ::core::ffi::c_int as uint8_t,
                9 as ::core::ffi::c_int as uint8_t,
                14 as ::core::ffi::c_int as uint8_t,
                10 as ::core::ffi::c_int as uint8_t,
                15 as ::core::ffi::c_int as uint8_t,
                16 as ::core::ffi::c_int as uint8_t,
                11 as ::core::ffi::c_int as uint8_t,
                1 as ::core::ffi::c_int as uint8_t,
                32 as ::core::ffi::c_int as uint8_t,
                33 as ::core::ffi::c_int as uint8_t,
                36 as ::core::ffi::c_int as uint8_t,
                34 as ::core::ffi::c_int as uint8_t,
                37 as ::core::ffi::c_int as uint8_t,
                44 as ::core::ffi::c_int as uint8_t,
                40 as ::core::ffi::c_int as uint8_t,
                35 as ::core::ffi::c_int as uint8_t,
                45 as ::core::ffi::c_int as uint8_t,
                38 as ::core::ffi::c_int as uint8_t,
                41 as ::core::ffi::c_int as uint8_t,
                39 as ::core::ffi::c_int as uint8_t,
                42 as ::core::ffi::c_int as uint8_t,
                43 as ::core::ffi::c_int as uint8_t,
                19 as ::core::ffi::c_int as uint8_t,
                6 as ::core::ffi::c_int as uint8_t,
                24 as ::core::ffi::c_int as uint8_t,
                25 as ::core::ffi::c_int as uint8_t,
                20 as ::core::ffi::c_int as uint8_t,
                26 as ::core::ffi::c_int as uint8_t,
                21 as ::core::ffi::c_int as uint8_t,
                46 as ::core::ffi::c_int as uint8_t,
                28 as ::core::ffi::c_int as uint8_t,
                27 as ::core::ffi::c_int as uint8_t,
                47 as ::core::ffi::c_int as uint8_t,
                22 as ::core::ffi::c_int as uint8_t,
                29 as ::core::ffi::c_int as uint8_t,
                23 as ::core::ffi::c_int as uint8_t,
                30 as ::core::ffi::c_int as uint8_t,
                31 as ::core::ffi::c_int as uint8_t,
                12 as ::core::ffi::c_int as uint8_t,
            ],
            [
                3 as ::core::ffi::c_int as uint8_t,
                29 as ::core::ffi::c_int as uint8_t,
                30 as ::core::ffi::c_int as uint8_t,
                17 as ::core::ffi::c_int as uint8_t,
                31 as ::core::ffi::c_int as uint8_t,
                18 as ::core::ffi::c_int as uint8_t,
                37 as ::core::ffi::c_int as uint8_t,
                8 as ::core::ffi::c_int as uint8_t,
                32 as ::core::ffi::c_int as uint8_t,
                38 as ::core::ffi::c_int as uint8_t,
                19 as ::core::ffi::c_int as uint8_t,
                9 as ::core::ffi::c_int as uint8_t,
                20 as ::core::ffi::c_int as uint8_t,
                10 as ::core::ffi::c_int as uint8_t,
                11 as ::core::ffi::c_int as uint8_t,
                2 as ::core::ffi::c_int as uint8_t,
                16 as ::core::ffi::c_int as uint8_t,
                33 as ::core::ffi::c_int as uint8_t,
                34 as ::core::ffi::c_int as uint8_t,
                21 as ::core::ffi::c_int as uint8_t,
                35 as ::core::ffi::c_int as uint8_t,
                22 as ::core::ffi::c_int as uint8_t,
                39 as ::core::ffi::c_int as uint8_t,
                4 as ::core::ffi::c_int as uint8_t,
                36 as ::core::ffi::c_int as uint8_t,
                40 as ::core::ffi::c_int as uint8_t,
                23 as ::core::ffi::c_int as uint8_t,
                5 as ::core::ffi::c_int as uint8_t,
                24 as ::core::ffi::c_int as uint8_t,
                6 as ::core::ffi::c_int as uint8_t,
                7 as ::core::ffi::c_int as uint8_t,
                1 as ::core::ffi::c_int as uint8_t,
                41 as ::core::ffi::c_int as uint8_t,
                42 as ::core::ffi::c_int as uint8_t,
                43 as ::core::ffi::c_int as uint8_t,
                25 as ::core::ffi::c_int as uint8_t,
                44 as ::core::ffi::c_int as uint8_t,
                26 as ::core::ffi::c_int as uint8_t,
                46 as ::core::ffi::c_int as uint8_t,
                12 as ::core::ffi::c_int as uint8_t,
                45 as ::core::ffi::c_int as uint8_t,
                47 as ::core::ffi::c_int as uint8_t,
                27 as ::core::ffi::c_int as uint8_t,
                13 as ::core::ffi::c_int as uint8_t,
                28 as ::core::ffi::c_int as uint8_t,
                14 as ::core::ffi::c_int as uint8_t,
                15 as ::core::ffi::c_int as uint8_t,
                0 as ::core::ffi::c_int as uint8_t,
            ],
        ],
    ];
    #[c2rust::src_loc = "48:22"]
    pub static mut mb_type_b_to_golomb: [[uint8_t; 9]; 3] = [
        [
            4 as ::core::ffi::c_int as uint8_t,
            8 as ::core::ffi::c_int as uint8_t,
            12 as ::core::ffi::c_int as uint8_t,
            10 as ::core::ffi::c_int as uint8_t,
            6 as ::core::ffi::c_int as uint8_t,
            14 as ::core::ffi::c_int as uint8_t,
            16 as ::core::ffi::c_int as uint8_t,
            18 as ::core::ffi::c_int as uint8_t,
            20 as ::core::ffi::c_int as uint8_t,
        ],
        [
            5 as ::core::ffi::c_int as uint8_t,
            9 as ::core::ffi::c_int as uint8_t,
            13 as ::core::ffi::c_int as uint8_t,
            11 as ::core::ffi::c_int as uint8_t,
            7 as ::core::ffi::c_int as uint8_t,
            15 as ::core::ffi::c_int as uint8_t,
            17 as ::core::ffi::c_int as uint8_t,
            19 as ::core::ffi::c_int as uint8_t,
            21 as ::core::ffi::c_int as uint8_t,
        ],
        [
            1 as ::core::ffi::c_int as uint8_t,
            -(1 as ::core::ffi::c_int) as uint8_t,
            -(1 as ::core::ffi::c_int) as uint8_t,
            -(1 as ::core::ffi::c_int) as uint8_t,
            2 as ::core::ffi::c_int as uint8_t,
            -(1 as ::core::ffi::c_int) as uint8_t,
            -(1 as ::core::ffi::c_int) as uint8_t,
            -(1 as ::core::ffi::c_int) as uint8_t,
            3 as ::core::ffi::c_int as uint8_t,
        ],
    ];
    #[c2rust::src_loc = "55:22"]
    pub static mut subpartition_p_to_golomb: [uint8_t; 4] = [
        3 as ::core::ffi::c_int as uint8_t,
        1 as ::core::ffi::c_int as uint8_t,
        2 as ::core::ffi::c_int as uint8_t,
        0 as ::core::ffi::c_int as uint8_t,
    ];
    #[c2rust::src_loc = "60:22"]
    pub static mut subpartition_b_to_golomb: [uint8_t; 13] = [
        10 as ::core::ffi::c_int as uint8_t,
        4 as ::core::ffi::c_int as uint8_t,
        5 as ::core::ffi::c_int as uint8_t,
        1 as ::core::ffi::c_int as uint8_t,
        11 as ::core::ffi::c_int as uint8_t,
        6 as ::core::ffi::c_int as uint8_t,
        7 as ::core::ffi::c_int as uint8_t,
        2 as ::core::ffi::c_int as uint8_t,
        12 as ::core::ffi::c_int as uint8_t,
        8 as ::core::ffi::c_int as uint8_t,
        9 as ::core::ffi::c_int as uint8_t,
        3 as ::core::ffi::c_int as uint8_t,
        0 as ::core::ffi::c_int as uint8_t,
    ];
    #[inline]
    #[c2rust::src_loc = "70:1"]
    pub unsafe extern "C" fn cavlc_block_residual_escape(
        mut h: *mut x264_t,
        mut i_suffix_length: ::core::ffi::c_int,
        mut level: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int {
        let mut s: *mut bs_t = &mut (*h).out.bs;
        pub static mut next_suffix: [uint16_t; 7] = [
            0 as ::core::ffi::c_int as uint16_t,
            3 as ::core::ffi::c_int as uint16_t,
            6 as ::core::ffi::c_int as uint16_t,
            12 as ::core::ffi::c_int as uint16_t,
            24 as ::core::ffi::c_int as uint16_t,
            48 as ::core::ffi::c_int as uint16_t,
            0xffff as ::core::ffi::c_int as uint16_t,
        ];
        let mut i_level_prefix: ::core::ffi::c_int = 15 as ::core::ffi::c_int;
        let mut mask: ::core::ffi::c_int = level >> 31 as ::core::ffi::c_int;
        let mut abs_level: ::core::ffi::c_int = (level ^ mask) - mask;
        let mut i_level_code: ::core::ffi::c_int =
            abs_level * 2 as ::core::ffi::c_int - mask - 2 as ::core::ffi::c_int;
        if i_level_code >> i_suffix_length < 15 as ::core::ffi::c_int {
            (*s).i_bits_encoded +=
                (i_level_code >> i_suffix_length) + 1 as ::core::ffi::c_int + i_suffix_length;
        } else {
            i_level_code -= (15 as ::core::ffi::c_int) << i_suffix_length;
            if i_suffix_length == 0 as ::core::ffi::c_int {
                i_level_code -= 15 as ::core::ffi::c_int;
            }
            if i_level_code >= (1 as ::core::ffi::c_int) << 12 as ::core::ffi::c_int {
                if (*(*h).sps.as_mut_ptr()).i_profile_idc >= PROFILE_HIGH as ::core::ffi::c_int {
                    while i_level_code
                        >= (1 as ::core::ffi::c_int) << i_level_prefix - 3 as ::core::ffi::c_int
                    {
                        i_level_code -=
                            (1 as ::core::ffi::c_int) << i_level_prefix - 3 as ::core::ffi::c_int;
                        i_level_prefix += 1;
                    }
                } else {
                    (*s).i_bits_encoded += 2000 as ::core::ffi::c_int;
                }
            }
            (*s).i_bits_encoded += i_level_prefix + 1 as ::core::ffi::c_int;
            (*s).i_bits_encoded += i_level_prefix - 3 as ::core::ffi::c_int;
        }
        if i_suffix_length == 0 as ::core::ffi::c_int {
            i_suffix_length += 1;
        }
        if abs_level > next_suffix[i_suffix_length as usize] as ::core::ffi::c_int {
            i_suffix_length += 1;
        }
        return i_suffix_length;
    }
    #[c2rust::src_loc = "121:1"]
    pub unsafe extern "C" fn cavlc_block_residual_internal(
        mut h: *mut x264_t,
        mut ctx_block_cat: ::core::ffi::c_int,
        mut l: *mut dctcoef,
        mut nC: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int {
        let mut s: *mut bs_t = &mut (*h).out.bs;
        pub static mut ctz_index: [uint8_t; 8] = [
            3 as ::core::ffi::c_int as uint8_t,
            0 as ::core::ffi::c_int as uint8_t,
            1 as ::core::ffi::c_int as uint8_t,
            0 as ::core::ffi::c_int as uint8_t,
            2 as ::core::ffi::c_int as uint8_t,
            0 as ::core::ffi::c_int as uint8_t,
            1 as ::core::ffi::c_int as uint8_t,
            0 as ::core::ffi::c_int as uint8_t,
        ];
        pub static mut count_cat: [uint8_t; 14] = [
            16 as ::core::ffi::c_int as uint8_t,
            15 as ::core::ffi::c_int as uint8_t,
            16 as ::core::ffi::c_int as uint8_t,
            0 as ::core::ffi::c_int as uint8_t,
            15 as ::core::ffi::c_int as uint8_t,
            64 as ::core::ffi::c_int as uint8_t,
            16 as ::core::ffi::c_int as uint8_t,
            15 as ::core::ffi::c_int as uint8_t,
            16 as ::core::ffi::c_int as uint8_t,
            64 as ::core::ffi::c_int as uint8_t,
            16 as ::core::ffi::c_int as uint8_t,
            15 as ::core::ffi::c_int as uint8_t,
            16 as ::core::ffi::c_int as uint8_t,
            64 as ::core::ffi::c_int as uint8_t,
        ];
        let mut runlevel: x264_run_level_t = x264_run_level_t {
            last: 0,
            mask: 0,
            level: [0; 18],
        };
        let mut i_total: ::core::ffi::c_int = 0;
        let mut i_trailing: ::core::ffi::c_int = 0;
        let mut i_total_zero: ::core::ffi::c_int = 0;
        let mut i_suffix_length: ::core::ffi::c_int = 0;
        let mut i_sign: ::core::ffi::c_uint = 0;
        i_total = (*h).quantf.coeff_level_run[ctx_block_cat as usize]
            .expect("non-null function pointer")(l, &mut runlevel);
        &mut *x264_10_run_before
            .as_mut_ptr()
            .offset(runlevel.mask as isize) as *mut uint32_t;
        i_total_zero = (runlevel.last + 1 as int32_t - i_total as int32_t) as ::core::ffi::c_int;
        runlevel.level[(i_total + 0 as ::core::ffi::c_int) as usize] =
            2 as ::core::ffi::c_int as dctcoef;
        runlevel.level[(i_total + 1 as ::core::ffi::c_int) as usize] =
            2 as ::core::ffi::c_int as dctcoef;
        i_trailing = ((runlevel.level[0 as ::core::ffi::c_int as usize] + 1 as dctcoef
            | 1 as dctcoef - runlevel.level[0 as ::core::ffi::c_int as usize])
            >> 31 as ::core::ffi::c_int
            & 1 as dctcoef
            | (runlevel.level[1 as ::core::ffi::c_int as usize] + 1 as dctcoef
                | 1 as dctcoef - runlevel.level[1 as ::core::ffi::c_int as usize])
                >> 31 as ::core::ffi::c_int
                & 2 as dctcoef
            | (runlevel.level[2 as ::core::ffi::c_int as usize] + 1 as dctcoef
                | 1 as dctcoef - runlevel.level[2 as ::core::ffi::c_int as usize])
                >> 31 as ::core::ffi::c_int
                & 4 as dctcoef) as ::core::ffi::c_int;
        i_trailing = ctz_index[i_trailing as usize] as ::core::ffi::c_int;
        i_sign = (runlevel.level[2 as ::core::ffi::c_int as usize] >> 31 as ::core::ffi::c_int
            & 1 as dctcoef
            | runlevel.level[1 as ::core::ffi::c_int as usize] >> 31 as ::core::ffi::c_int
                & 2 as dctcoef
            | runlevel.level[0 as ::core::ffi::c_int as usize] >> 31 as ::core::ffi::c_int
                & 4 as dctcoef) as ::core::ffi::c_uint;
        i_sign >>= 3 as ::core::ffi::c_int - i_trailing;
        (*s).i_bits_encoded += x264_coeff_token[nC as usize]
            [(i_total - 1 as ::core::ffi::c_int) as usize][i_trailing as usize]
            .i_size as ::core::ffi::c_int;
        i_suffix_length = (i_total > 10 as ::core::ffi::c_int
            && i_trailing < 3 as ::core::ffi::c_int)
            as ::core::ffi::c_int;
        (*s).i_bits_encoded += i_trailing;
        if i_trailing < i_total {
            let mut val: ::core::ffi::c_int = runlevel.level[i_trailing as usize];
            let mut val_original: ::core::ffi::c_int =
                runlevel.level[i_trailing as usize] + LEVEL_TABLE_SIZE / 2 as ::core::ffi::c_int;
            val -= (val >> 31 as ::core::ffi::c_int | 1 as ::core::ffi::c_int)
                & -((i_trailing < 3 as ::core::ffi::c_int) as ::core::ffi::c_int);
            val += LEVEL_TABLE_SIZE / 2 as ::core::ffi::c_int;
            if (val_original as ::core::ffi::c_uint) < LEVEL_TABLE_SIZE as ::core::ffi::c_uint {
                (*s).i_bits_encoded += x264_10_level_token[i_suffix_length as usize][val as usize]
                    .i_size as ::core::ffi::c_int;
                i_suffix_length = x264_10_level_token[i_suffix_length as usize]
                    [val_original as usize]
                    .i_next as ::core::ffi::c_int;
            } else {
                i_suffix_length = cavlc_block_residual_escape(
                    h,
                    i_suffix_length,
                    val - LEVEL_TABLE_SIZE / 2 as ::core::ffi::c_int,
                );
            }
            let mut i: ::core::ffi::c_int = i_trailing + 1 as ::core::ffi::c_int;
            while i < i_total {
                val = (runlevel.level[i as usize] + LEVEL_TABLE_SIZE as dctcoef / 2 as dctcoef)
                    as ::core::ffi::c_int;
                if (val as ::core::ffi::c_uint) < LEVEL_TABLE_SIZE as ::core::ffi::c_uint {
                    (*s).i_bits_encoded += x264_10_level_token[i_suffix_length as usize]
                        [val as usize]
                        .i_size as ::core::ffi::c_int;
                    i_suffix_length = x264_10_level_token[i_suffix_length as usize][val as usize]
                        .i_next as ::core::ffi::c_int;
                } else {
                    i_suffix_length = cavlc_block_residual_escape(
                        h,
                        i_suffix_length,
                        val - LEVEL_TABLE_SIZE / 2 as ::core::ffi::c_int,
                    );
                }
                i += 1;
            }
        }
        if ctx_block_cat == DCT_CHROMA_DC as ::core::ffi::c_int {
            if i_total < 8 as ::core::ffi::c_int >> (*h).mb.chroma_v_shift {
                let mut total_zeros: vlc_t = if (*(*h).sps.as_mut_ptr()).i_chroma_format_idc
                    == CHROMA_420 as ::core::ffi::c_int
                {
                    x264_total_zeros_2x2_dc[(i_total - 1 as ::core::ffi::c_int) as usize]
                        [i_total_zero as usize]
                } else {
                    x264_total_zeros_2x4_dc[(i_total - 1 as ::core::ffi::c_int) as usize]
                        [i_total_zero as usize]
                };
                (*s).i_bits_encoded += total_zeros.i_size as ::core::ffi::c_int;
            }
        } else if (i_total as uint8_t as ::core::ffi::c_int)
            < count_cat[ctx_block_cat as usize] as ::core::ffi::c_int
        {
            (*s).i_bits_encoded += x264_total_zeros[(i_total - 1 as ::core::ffi::c_int) as usize]
                [i_total_zero as usize]
                .i_size as ::core::ffi::c_int;
        }
        let mut zero_run_code: ::core::ffi::c_int =
            x264_10_run_before[runlevel.mask as usize] as ::core::ffi::c_int;
        (*s).i_bits_encoded += zero_run_code & 0x1f as ::core::ffi::c_int;
        return i_total;
    }
    #[c2rust::src_loc = "198:22"]
    pub static mut ct_index: [uint8_t; 17] = [
        0 as ::core::ffi::c_int as uint8_t,
        0 as ::core::ffi::c_int as uint8_t,
        1 as ::core::ffi::c_int as uint8_t,
        1 as ::core::ffi::c_int as uint8_t,
        2 as ::core::ffi::c_int as uint8_t,
        2 as ::core::ffi::c_int as uint8_t,
        2 as ::core::ffi::c_int as uint8_t,
        2 as ::core::ffi::c_int as uint8_t,
        3 as ::core::ffi::c_int as uint8_t,
        3 as ::core::ffi::c_int as uint8_t,
        3 as ::core::ffi::c_int as uint8_t,
        3 as ::core::ffi::c_int as uint8_t,
        3 as ::core::ffi::c_int as uint8_t,
        3 as ::core::ffi::c_int as uint8_t,
        3 as ::core::ffi::c_int as uint8_t,
        3 as ::core::ffi::c_int as uint8_t,
        3 as ::core::ffi::c_int as uint8_t,
    ];
    #[c2rust::src_loc = "211:1"]
    pub unsafe extern "C" fn cavlc_qp_delta(mut h: *mut x264_t) {
        let mut s: *mut bs_t = &mut (*h).out.bs;
        let mut i_dqp: ::core::ffi::c_int = (*h).mb.i_qp - (*h).mb.i_last_qp;
        if (*h).mb.i_type == I_16x16 as ::core::ffi::c_int
            && (*h).mb.i_cbp_luma | (*h).mb.i_cbp_chroma == 0
            && (*h).mb.cache.non_zero_count[x264_scan8[LUMA_DC as usize] as usize] == 0
            && (*h).mb.cache.non_zero_count
                [x264_scan8[(CHROMA_DC + 0 as ::core::ffi::c_int) as usize] as usize]
                == 0
            && (*h).mb.cache.non_zero_count
                [x264_scan8[(CHROMA_DC + 1 as ::core::ffi::c_int) as usize] as usize]
                == 0
            && (*h).mb.i_qp > (*h).mb.i_last_qp
        {
            i_dqp = 0 as ::core::ffi::c_int;
        }
        if i_dqp != 0 {
            if i_dqp < -(QP_MAX_SPEC + 1 as ::core::ffi::c_int) / 2 as ::core::ffi::c_int {
                i_dqp += QP_MAX_SPEC + 1 as ::core::ffi::c_int;
            } else if i_dqp > QP_MAX_SPEC / 2 as ::core::ffi::c_int {
                i_dqp -= QP_MAX_SPEC + 1 as ::core::ffi::c_int;
            }
        }
        (*s).i_bits_encoded += bs_size_se(i_dqp);
    }
    #[c2rust::src_loc = "241:1"]
    pub unsafe extern "C" fn cavlc_mvd(
        mut h: *mut x264_t,
        mut i_list: ::core::ffi::c_int,
        mut idx: ::core::ffi::c_int,
        mut width: ::core::ffi::c_int,
    ) {
        let mut s: *mut bs_t = &mut (*h).out.bs;
        let mut mvp: [int16_t; 2] = [0; 2];
        x264_10_mb_predict_mv(h, i_list, idx, width, mvp.as_mut_ptr());
        (*s).i_bits_encoded += bs_size_se(
            (*h).mb.cache.mv[i_list as usize][x264_scan8[idx as usize] as usize]
                [0 as ::core::ffi::c_int as usize] as ::core::ffi::c_int
                - mvp[0 as ::core::ffi::c_int as usize] as ::core::ffi::c_int,
        );
        (*s).i_bits_encoded += bs_size_se(
            (*h).mb.cache.mv[i_list as usize][x264_scan8[idx as usize] as usize]
                [1 as ::core::ffi::c_int as usize] as ::core::ffi::c_int
                - mvp[1 as ::core::ffi::c_int as usize] as ::core::ffi::c_int,
        );
    }
    #[inline]
    #[c2rust::src_loc = "250:1"]
    pub unsafe extern "C" fn cavlc_8x8_mvd(mut h: *mut x264_t, mut i: ::core::ffi::c_int) {
        match (*h).mb.i_sub_partition[i as usize] as ::core::ffi::c_int {
            3 => {
                cavlc_mvd(
                    h,
                    0 as ::core::ffi::c_int,
                    4 as ::core::ffi::c_int * i,
                    2 as ::core::ffi::c_int,
                );
            }
            1 => {
                cavlc_mvd(
                    h,
                    0 as ::core::ffi::c_int,
                    4 as ::core::ffi::c_int * i + 0 as ::core::ffi::c_int,
                    2 as ::core::ffi::c_int,
                );
                cavlc_mvd(
                    h,
                    0 as ::core::ffi::c_int,
                    4 as ::core::ffi::c_int * i + 2 as ::core::ffi::c_int,
                    2 as ::core::ffi::c_int,
                );
            }
            2 => {
                cavlc_mvd(
                    h,
                    0 as ::core::ffi::c_int,
                    4 as ::core::ffi::c_int * i + 0 as ::core::ffi::c_int,
                    1 as ::core::ffi::c_int,
                );
                cavlc_mvd(
                    h,
                    0 as ::core::ffi::c_int,
                    4 as ::core::ffi::c_int * i + 1 as ::core::ffi::c_int,
                    1 as ::core::ffi::c_int,
                );
            }
            0 => {
                cavlc_mvd(
                    h,
                    0 as ::core::ffi::c_int,
                    4 as ::core::ffi::c_int * i + 0 as ::core::ffi::c_int,
                    1 as ::core::ffi::c_int,
                );
                cavlc_mvd(
                    h,
                    0 as ::core::ffi::c_int,
                    4 as ::core::ffi::c_int * i + 1 as ::core::ffi::c_int,
                    1 as ::core::ffi::c_int,
                );
                cavlc_mvd(
                    h,
                    0 as ::core::ffi::c_int,
                    4 as ::core::ffi::c_int * i + 2 as ::core::ffi::c_int,
                    1 as ::core::ffi::c_int,
                );
                cavlc_mvd(
                    h,
                    0 as ::core::ffi::c_int,
                    4 as ::core::ffi::c_int * i + 3 as ::core::ffi::c_int,
                    1 as ::core::ffi::c_int,
                );
            }
            _ => {}
        };
    }
    #[inline(always)]
    #[c2rust::src_loc = "274:1"]
    pub unsafe extern "C" fn cavlc_macroblock_luma_residual(
        mut h: *mut x264_t,
        mut plane_count: ::core::ffi::c_int,
    ) {
        if (*h).mb.b_transform_8x8 != 0 {
            let mut p: ::core::ffi::c_int = 0 as ::core::ffi::c_int;
            while p < plane_count {
                let mut i8: ::core::ffi::c_int = 0 as ::core::ffi::c_int;
                while i8 < 4 as ::core::ffi::c_int {
                    if (*h).mb.cache.non_zero_count[x264_scan8
                        [(p * 16 as ::core::ffi::c_int + i8 * 4 as ::core::ffi::c_int) as usize]
                        as usize]
                        != 0
                    {
                        (*h).zigzagf
                            .interleave_8x8_cavlc
                            .expect("non-null function pointer")(
                            (*(*h).dct.luma4x4.as_mut_ptr().offset(
                                (p * 16 as ::core::ffi::c_int + i8 * 4 as ::core::ffi::c_int)
                                    as isize,
                            ))
                            .as_mut_ptr(),
                            (*(*h)
                                .dct
                                .luma8x8
                                .as_mut_ptr()
                                .offset((p * 4 as ::core::ffi::c_int + i8) as isize))
                            .as_mut_ptr(),
                            &mut *(*h).mb.cache.non_zero_count.as_mut_ptr().offset(
                                *x264_scan8.as_ptr().offset(
                                    (p * 16 as ::core::ffi::c_int + i8 * 4 as ::core::ffi::c_int)
                                        as isize,
                                ) as isize,
                            ),
                        );
                    }
                    i8 += 1;
                }
                p += 1;
            }
        }
        let mut p_0: ::core::ffi::c_int = 0 as ::core::ffi::c_int;
        while p_0 < plane_count {
            let mut i8_0: ::core::ffi::c_int = 0 as ::core::ffi::c_int;
            let mut msk: ::core::ffi::c_int = (*h).mb.i_cbp_luma;
            let mut skip: ::core::ffi::c_int = 0;
            while msk != 0 && {
                skip = x264_ctz_4bit(msk as uint32_t);
                i8_0 += skip;
                msk >>= skip + 1 as ::core::ffi::c_int;
                1 as ::core::ffi::c_int != 0
            } {
                let mut i4: ::core::ffi::c_int = 0 as ::core::ffi::c_int;
                while i4 < 4 as ::core::ffi::c_int {
                    let mut nC: ::core::ffi::c_int = if DCT_LUMA_4x4 as ::core::ffi::c_int
                        == DCT_CHROMA_DC as ::core::ffi::c_int
                    {
                        5 as ::core::ffi::c_int - (*h).mb.chroma_v_shift
                    } else {
                        ct_index[x264_mb_predict_non_zero_code(
                            h,
                            if DCT_LUMA_4x4 as ::core::ffi::c_int
                                == DCT_LUMA_DC as ::core::ffi::c_int
                            {
                                (i4 + i8_0 * 4 as ::core::ffi::c_int
                                    + p_0 * 16 as ::core::ffi::c_int
                                    - LUMA_DC)
                                    * 16 as ::core::ffi::c_int
                            } else {
                                i4 + i8_0 * 4 as ::core::ffi::c_int + p_0 * 16 as ::core::ffi::c_int
                            },
                        ) as usize] as ::core::ffi::c_int
                    };
                    let mut nnz: *mut uint8_t =
                        &mut *(*h).mb.cache.non_zero_count.as_mut_ptr().offset(
                            *x264_scan8.as_ptr().offset(
                                (i4 + i8_0 * 4 as ::core::ffi::c_int
                                    + p_0 * 16 as ::core::ffi::c_int)
                                    as isize,
                            ) as isize,
                        ) as *mut uint8_t;
                    if *nnz == 0 {
                        (*h).out.bs.i_bits_encoded +=
                            x264_coeff0_token[nC as usize].i_size as ::core::ffi::c_int;
                    } else {
                        *nnz = cavlc_block_residual_internal(
                            h,
                            DCT_LUMA_4x4 as ::core::ffi::c_int,
                            (*(*h).dct.luma4x4.as_mut_ptr().offset(
                                (i4 + i8_0 * 4 as ::core::ffi::c_int
                                    + p_0 * 16 as ::core::ffi::c_int)
                                    as isize,
                            ))
                            .as_mut_ptr(),
                            nC,
                        ) as uint8_t;
                    }
                    i4 += 1;
                }
                i8_0 += 1;
            }
            p_0 += 1;
        }
    }
    #[inline(always)]
    #[c2rust::src_loc = "293:1"]
    pub unsafe extern "C" fn cavlc_partition_luma_residual(
        mut h: *mut x264_t,
        mut i8: ::core::ffi::c_int,
        mut p: ::core::ffi::c_int,
    ) {
        if (*h).mb.b_transform_8x8 != 0
            && (*h).mb.cache.non_zero_count[x264_scan8
                [(i8 * 4 as ::core::ffi::c_int + p * 16 as ::core::ffi::c_int) as usize]
                as usize] as ::core::ffi::c_int
                != 0
        {
            (*h).zigzagf
                .interleave_8x8_cavlc
                .expect("non-null function pointer")(
                (*(*h).dct.luma4x4.as_mut_ptr().offset(
                    (i8 * 4 as ::core::ffi::c_int + p * 16 as ::core::ffi::c_int) as isize,
                ))
                .as_mut_ptr(),
                (*(*h)
                    .dct
                    .luma8x8
                    .as_mut_ptr()
                    .offset((i8 + p * 4 as ::core::ffi::c_int) as isize))
                .as_mut_ptr(),
                &mut *(*h).mb.cache.non_zero_count.as_mut_ptr().offset(
                    *x264_scan8.as_ptr().offset(
                        (i8 * 4 as ::core::ffi::c_int + p * 16 as ::core::ffi::c_int) as isize,
                    ) as isize,
                ),
            );
        }
        if (*h).mb.i_cbp_luma & (1 as ::core::ffi::c_int) << i8 != 0 {
            let mut i4: ::core::ffi::c_int = 0 as ::core::ffi::c_int;
            while i4 < 4 as ::core::ffi::c_int {
                let mut nC: ::core::ffi::c_int = if DCT_LUMA_4x4 as ::core::ffi::c_int
                    == DCT_CHROMA_DC as ::core::ffi::c_int
                {
                    5 as ::core::ffi::c_int - (*h).mb.chroma_v_shift
                } else {
                    ct_index[x264_mb_predict_non_zero_code(
                        h,
                        if DCT_LUMA_4x4 as ::core::ffi::c_int == DCT_LUMA_DC as ::core::ffi::c_int {
                            (i4 + i8 * 4 as ::core::ffi::c_int + p * 16 as ::core::ffi::c_int
                                - LUMA_DC)
                                * 16 as ::core::ffi::c_int
                        } else {
                            i4 + i8 * 4 as ::core::ffi::c_int + p * 16 as ::core::ffi::c_int
                        },
                    ) as usize] as ::core::ffi::c_int
                };
                let mut nnz: *mut uint8_t = &mut *(*h).mb.cache.non_zero_count.as_mut_ptr().offset(
                    *x264_scan8.as_ptr().offset(
                        (i4 + i8 * 4 as ::core::ffi::c_int + p * 16 as ::core::ffi::c_int) as isize,
                    ) as isize,
                ) as *mut uint8_t;
                if *nnz == 0 {
                    (*h).out.bs.i_bits_encoded +=
                        x264_coeff0_token[nC as usize].i_size as ::core::ffi::c_int;
                } else {
                    *nnz = cavlc_block_residual_internal(
                        h,
                        DCT_LUMA_4x4 as ::core::ffi::c_int,
                        (*(*h).dct.luma4x4.as_mut_ptr().offset(
                            (i4 + i8 * 4 as ::core::ffi::c_int + p * 16 as ::core::ffi::c_int)
                                as isize,
                        ))
                        .as_mut_ptr(),
                        nC,
                    ) as uint8_t;
                }
                i4 += 1;
            }
        }
    }
    #[c2rust::src_loc = "305:1"]
    pub unsafe extern "C" fn cavlc_mb_header_i(
        mut h: *mut x264_t,
        mut i_mb_type: ::core::ffi::c_int,
        mut i_mb_i_offset: ::core::ffi::c_int,
        mut chroma: ::core::ffi::c_int,
    ) {
        let mut s: *mut bs_t = &mut (*h).out.bs;
        if i_mb_type == I_16x16 as ::core::ffi::c_int {
            (*s).i_bits_encoded += bs_size_ue(
                (i_mb_i_offset
                    + 1 as ::core::ffi::c_int
                    + x264_mb_pred_mode16x16_fix[(*h).mb.i_intra16x16_pred_mode as usize]
                        as ::core::ffi::c_int
                    + (*h).mb.i_cbp_chroma * 4 as ::core::ffi::c_int
                    + (if (*h).mb.i_cbp_luma == 0 as ::core::ffi::c_int {
                        0 as ::core::ffi::c_int
                    } else {
                        12 as ::core::ffi::c_int
                    })) as ::core::ffi::c_uint,
            );
        } else {
            let mut di: ::core::ffi::c_int = if i_mb_type == I_8x8 as ::core::ffi::c_int {
                4 as ::core::ffi::c_int
            } else {
                1 as ::core::ffi::c_int
            };
            (*s).i_bits_encoded +=
                bs_size_ue((i_mb_i_offset + 0 as ::core::ffi::c_int) as ::core::ffi::c_uint);
            if (*(*h).pps.as_mut_ptr()).b_transform_8x8_mode != 0 {
                (*s).i_bits_encoded += 1 as ::core::ffi::c_int;
            }
            let mut i: ::core::ffi::c_int = 0 as ::core::ffi::c_int;
            while i < 16 as ::core::ffi::c_int {
                let mut i_pred: ::core::ffi::c_int = x264_mb_predict_intra4x4_mode(h, i);
                let mut i_mode: ::core::ffi::c_int =
                    x264_mb_pred_mode4x4_fix[((*h).mb.cache.intra4x4_pred_mode
                        [x264_scan8[i as usize] as usize]
                        as ::core::ffi::c_int
                        + 1 as ::core::ffi::c_int)
                        as usize] as ::core::ffi::c_int;
                if i_pred == i_mode {
                    (*s).i_bits_encoded += 1 as ::core::ffi::c_int;
                } else {
                    (*s).i_bits_encoded += 4 as ::core::ffi::c_int;
                }
                i += di;
            }
        }
        if chroma != 0 {
            (*s).i_bits_encoded += bs_size_ue(
                x264_mb_chroma_pred_mode_fix[(*h).mb.i_chroma_pred_mode as usize]
                    as ::core::ffi::c_uint,
            );
        }
    }
    #[inline(always)]
    #[c2rust::src_loc = "337:1"]
    pub unsafe extern "C" fn cavlc_mb_header_p(
        mut h: *mut x264_t,
        mut i_mb_type: ::core::ffi::c_int,
        mut chroma: ::core::ffi::c_int,
    ) {
        let mut s: *mut bs_t = &mut (*h).out.bs;
        if i_mb_type == P_L0 as ::core::ffi::c_int {
            if (*h).mb.i_partition == D_16x16 as ::core::ffi::c_int {
                (*s).i_bits_encoded += 1 as ::core::ffi::c_int;
                if (*h).mb.pic.i_fref[0 as ::core::ffi::c_int as usize] > 1 as ::core::ffi::c_int {
                    (*s).i_bits_encoded += bs_size_te(
                        (*h).mb.pic.i_fref[0 as ::core::ffi::c_int as usize]
                            - 1 as ::core::ffi::c_int,
                        (*h).mb.cache.ref_0[0 as ::core::ffi::c_int as usize]
                            [x264_scan8[0 as ::core::ffi::c_int as usize] as usize]
                            as ::core::ffi::c_int,
                    );
                }
                cavlc_mvd(
                    h,
                    0 as ::core::ffi::c_int,
                    0 as ::core::ffi::c_int,
                    4 as ::core::ffi::c_int,
                );
            } else if (*h).mb.i_partition == D_16x8 as ::core::ffi::c_int {
                (*s).i_bits_encoded += bs_size_ue(1 as ::core::ffi::c_uint);
                if (*h).mb.pic.i_fref[0 as ::core::ffi::c_int as usize] > 1 as ::core::ffi::c_int {
                    (*s).i_bits_encoded += bs_size_te(
                        (*h).mb.pic.i_fref[0 as ::core::ffi::c_int as usize]
                            - 1 as ::core::ffi::c_int,
                        (*h).mb.cache.ref_0[0 as ::core::ffi::c_int as usize]
                            [x264_scan8[0 as ::core::ffi::c_int as usize] as usize]
                            as ::core::ffi::c_int,
                    );
                    (*s).i_bits_encoded += bs_size_te(
                        (*h).mb.pic.i_fref[0 as ::core::ffi::c_int as usize]
                            - 1 as ::core::ffi::c_int,
                        (*h).mb.cache.ref_0[0 as ::core::ffi::c_int as usize]
                            [x264_scan8[8 as ::core::ffi::c_int as usize] as usize]
                            as ::core::ffi::c_int,
                    );
                }
                cavlc_mvd(
                    h,
                    0 as ::core::ffi::c_int,
                    0 as ::core::ffi::c_int,
                    4 as ::core::ffi::c_int,
                );
                cavlc_mvd(
                    h,
                    0 as ::core::ffi::c_int,
                    8 as ::core::ffi::c_int,
                    4 as ::core::ffi::c_int,
                );
            } else if (*h).mb.i_partition == D_8x16 as ::core::ffi::c_int {
                (*s).i_bits_encoded += bs_size_ue(2 as ::core::ffi::c_uint);
                if (*h).mb.pic.i_fref[0 as ::core::ffi::c_int as usize] > 1 as ::core::ffi::c_int {
                    (*s).i_bits_encoded += bs_size_te(
                        (*h).mb.pic.i_fref[0 as ::core::ffi::c_int as usize]
                            - 1 as ::core::ffi::c_int,
                        (*h).mb.cache.ref_0[0 as ::core::ffi::c_int as usize]
                            [x264_scan8[0 as ::core::ffi::c_int as usize] as usize]
                            as ::core::ffi::c_int,
                    );
                    (*s).i_bits_encoded += bs_size_te(
                        (*h).mb.pic.i_fref[0 as ::core::ffi::c_int as usize]
                            - 1 as ::core::ffi::c_int,
                        (*h).mb.cache.ref_0[0 as ::core::ffi::c_int as usize]
                            [x264_scan8[4 as ::core::ffi::c_int as usize] as usize]
                            as ::core::ffi::c_int,
                    );
                }
                cavlc_mvd(
                    h,
                    0 as ::core::ffi::c_int,
                    0 as ::core::ffi::c_int,
                    2 as ::core::ffi::c_int,
                );
                cavlc_mvd(
                    h,
                    0 as ::core::ffi::c_int,
                    4 as ::core::ffi::c_int,
                    2 as ::core::ffi::c_int,
                );
            }
        } else if i_mb_type == P_8x8 as ::core::ffi::c_int {
            let mut b_sub_ref: ::core::ffi::c_int = 0;
            if (*h).mb.cache.ref_0[0 as ::core::ffi::c_int as usize]
                [x264_scan8[0 as ::core::ffi::c_int as usize] as usize]
                as ::core::ffi::c_int
                | (*h).mb.cache.ref_0[0 as ::core::ffi::c_int as usize]
                    [x264_scan8[4 as ::core::ffi::c_int as usize] as usize]
                    as ::core::ffi::c_int
                | (*h).mb.cache.ref_0[0 as ::core::ffi::c_int as usize]
                    [x264_scan8[8 as ::core::ffi::c_int as usize] as usize]
                    as ::core::ffi::c_int
                | (*h).mb.cache.ref_0[0 as ::core::ffi::c_int as usize]
                    [x264_scan8[12 as ::core::ffi::c_int as usize] as usize]
                    as ::core::ffi::c_int
                == 0 as ::core::ffi::c_int
            {
                (*s).i_bits_encoded += bs_size_ue(4 as ::core::ffi::c_uint);
                b_sub_ref = 0 as ::core::ffi::c_int;
            } else {
                (*s).i_bits_encoded += bs_size_ue(3 as ::core::ffi::c_uint);
                b_sub_ref = 1 as ::core::ffi::c_int;
            }
            if (*h).param.analyse.inter & X264_ANALYSE_PSUB8x8 != 0 {
                let mut i: ::core::ffi::c_int = 0 as ::core::ffi::c_int;
                while i < 4 as ::core::ffi::c_int {
                    (*s).i_bits_encoded += bs_size_ue(
                        subpartition_p_to_golomb[(*h).mb.i_sub_partition[i as usize] as usize]
                            as ::core::ffi::c_uint,
                    );
                    i += 1;
                }
            } else {
                (*s).i_bits_encoded += 4 as ::core::ffi::c_int;
            }
            if b_sub_ref != 0 {
                (*s).i_bits_encoded += bs_size_te(
                    (*h).mb.pic.i_fref[0 as ::core::ffi::c_int as usize] - 1 as ::core::ffi::c_int,
                    (*h).mb.cache.ref_0[0 as ::core::ffi::c_int as usize]
                        [x264_scan8[0 as ::core::ffi::c_int as usize] as usize]
                        as ::core::ffi::c_int,
                );
                (*s).i_bits_encoded += bs_size_te(
                    (*h).mb.pic.i_fref[0 as ::core::ffi::c_int as usize] - 1 as ::core::ffi::c_int,
                    (*h).mb.cache.ref_0[0 as ::core::ffi::c_int as usize]
                        [x264_scan8[4 as ::core::ffi::c_int as usize] as usize]
                        as ::core::ffi::c_int,
                );
                (*s).i_bits_encoded += bs_size_te(
                    (*h).mb.pic.i_fref[0 as ::core::ffi::c_int as usize] - 1 as ::core::ffi::c_int,
                    (*h).mb.cache.ref_0[0 as ::core::ffi::c_int as usize]
                        [x264_scan8[8 as ::core::ffi::c_int as usize] as usize]
                        as ::core::ffi::c_int,
                );
                (*s).i_bits_encoded += bs_size_te(
                    (*h).mb.pic.i_fref[0 as ::core::ffi::c_int as usize] - 1 as ::core::ffi::c_int,
                    (*h).mb.cache.ref_0[0 as ::core::ffi::c_int as usize]
                        [x264_scan8[12 as ::core::ffi::c_int as usize] as usize]
                        as ::core::ffi::c_int,
                );
            }
            let mut i_0: ::core::ffi::c_int = 0 as ::core::ffi::c_int;
            while i_0 < 4 as ::core::ffi::c_int {
                cavlc_8x8_mvd(h, i_0);
                i_0 += 1;
            }
        } else {
            cavlc_mb_header_i(h, i_mb_type, 5 as ::core::ffi::c_int, chroma);
        };
    }
    #[inline(always)]
    #[c2rust::src_loc = "411:1"]
    pub unsafe extern "C" fn cavlc_mb_header_b(
        mut h: *mut x264_t,
        mut i_mb_type: ::core::ffi::c_int,
        mut chroma: ::core::ffi::c_int,
    ) {
        let mut s: *mut bs_t = &mut (*h).out.bs;
        if i_mb_type == B_8x8 as ::core::ffi::c_int {
            (*s).i_bits_encoded += bs_size_ue(22 as ::core::ffi::c_uint);
            let mut i: ::core::ffi::c_int = 0 as ::core::ffi::c_int;
            while i < 4 as ::core::ffi::c_int {
                (*s).i_bits_encoded += bs_size_ue(
                    subpartition_b_to_golomb[(*h).mb.i_sub_partition[i as usize] as usize]
                        as ::core::ffi::c_uint,
                );
                i += 1;
            }
            if (*h).mb.pic.i_fref[0 as ::core::ffi::c_int as usize] > 1 as ::core::ffi::c_int {
                let mut i_0: ::core::ffi::c_int = 0 as ::core::ffi::c_int;
                while i_0 < 4 as ::core::ffi::c_int {
                    if x264_mb_partition_listX_table[0 as ::core::ffi::c_int as usize]
                        [(*h).mb.i_sub_partition[i_0 as usize] as usize]
                        != 0
                    {
                        (*s).i_bits_encoded += bs_size_te(
                            (*h).mb.pic.i_fref[0 as ::core::ffi::c_int as usize]
                                - 1 as ::core::ffi::c_int,
                            (*h).mb.cache.ref_0[0 as ::core::ffi::c_int as usize]
                                [x264_scan8[(i_0 * 4 as ::core::ffi::c_int) as usize] as usize]
                                as ::core::ffi::c_int,
                        );
                    }
                    i_0 += 1;
                }
            }
            if (*h).mb.pic.i_fref[1 as ::core::ffi::c_int as usize] > 1 as ::core::ffi::c_int {
                let mut i_1: ::core::ffi::c_int = 0 as ::core::ffi::c_int;
                while i_1 < 4 as ::core::ffi::c_int {
                    if x264_mb_partition_listX_table[1 as ::core::ffi::c_int as usize]
                        [(*h).mb.i_sub_partition[i_1 as usize] as usize]
                        != 0
                    {
                        (*s).i_bits_encoded += bs_size_te(
                            (*h).mb.pic.i_fref[1 as ::core::ffi::c_int as usize]
                                - 1 as ::core::ffi::c_int,
                            (*h).mb.cache.ref_0[1 as ::core::ffi::c_int as usize]
                                [x264_scan8[(i_1 * 4 as ::core::ffi::c_int) as usize] as usize]
                                as ::core::ffi::c_int,
                        );
                    }
                    i_1 += 1;
                }
            }
            let mut i_2: ::core::ffi::c_int = 0 as ::core::ffi::c_int;
            while i_2 < 4 as ::core::ffi::c_int {
                if x264_mb_partition_listX_table[0 as ::core::ffi::c_int as usize]
                    [(*h).mb.i_sub_partition[i_2 as usize] as usize]
                    != 0
                {
                    cavlc_mvd(
                        h,
                        0 as ::core::ffi::c_int,
                        4 as ::core::ffi::c_int * i_2,
                        2 as ::core::ffi::c_int,
                    );
                }
                i_2 += 1;
            }
            let mut i_3: ::core::ffi::c_int = 0 as ::core::ffi::c_int;
            while i_3 < 4 as ::core::ffi::c_int {
                if x264_mb_partition_listX_table[1 as ::core::ffi::c_int as usize]
                    [(*h).mb.i_sub_partition[i_3 as usize] as usize]
                    != 0
                {
                    cavlc_mvd(
                        h,
                        1 as ::core::ffi::c_int,
                        4 as ::core::ffi::c_int * i_3,
                        2 as ::core::ffi::c_int,
                    );
                }
                i_3 += 1;
            }
        } else if i_mb_type >= B_L0_L0 as ::core::ffi::c_int
            && i_mb_type <= B_BI_BI as ::core::ffi::c_int
        {
            let mut b_list: *const [uint8_t; 2] =
                (*x264_mb_type_list_table.as_ptr().offset(i_mb_type as isize)).as_ptr()
                    as *const [uint8_t; 2];
            let i_ref0_max: ::core::ffi::c_int =
                (*h).mb.pic.i_fref[0 as ::core::ffi::c_int as usize] - 1 as ::core::ffi::c_int;
            let i_ref1_max: ::core::ffi::c_int =
                (*h).mb.pic.i_fref[1 as ::core::ffi::c_int as usize] - 1 as ::core::ffi::c_int;
            (*s).i_bits_encoded += bs_size_ue(
                mb_type_b_to_golomb[((*h).mb.i_partition - D_16x8 as ::core::ffi::c_int) as usize]
                    [(i_mb_type - B_L0_L0 as ::core::ffi::c_int) as usize]
                    as ::core::ffi::c_uint,
            );
            if (*h).mb.i_partition == D_16x16 as ::core::ffi::c_int {
                if i_ref0_max != 0
                    && (*b_list.offset(0 as ::core::ffi::c_int as isize))
                        [0 as ::core::ffi::c_int as usize]
                        as ::core::ffi::c_int
                        != 0
                {
                    (*s).i_bits_encoded += bs_size_te(
                        i_ref0_max,
                        (*h).mb.cache.ref_0[0 as ::core::ffi::c_int as usize]
                            [x264_scan8[0 as ::core::ffi::c_int as usize] as usize]
                            as ::core::ffi::c_int,
                    );
                }
                if i_ref1_max != 0
                    && (*b_list.offset(1 as ::core::ffi::c_int as isize))
                        [0 as ::core::ffi::c_int as usize]
                        as ::core::ffi::c_int
                        != 0
                {
                    (*s).i_bits_encoded += bs_size_te(
                        i_ref1_max,
                        (*h).mb.cache.ref_0[1 as ::core::ffi::c_int as usize]
                            [x264_scan8[0 as ::core::ffi::c_int as usize] as usize]
                            as ::core::ffi::c_int,
                    );
                }
                if (*b_list.offset(0 as ::core::ffi::c_int as isize))
                    [0 as ::core::ffi::c_int as usize]
                    != 0
                {
                    cavlc_mvd(
                        h,
                        0 as ::core::ffi::c_int,
                        0 as ::core::ffi::c_int,
                        4 as ::core::ffi::c_int,
                    );
                }
                if (*b_list.offset(1 as ::core::ffi::c_int as isize))
                    [0 as ::core::ffi::c_int as usize]
                    != 0
                {
                    cavlc_mvd(
                        h,
                        1 as ::core::ffi::c_int,
                        0 as ::core::ffi::c_int,
                        4 as ::core::ffi::c_int,
                    );
                }
            } else {
                if i_ref0_max != 0
                    && (*b_list.offset(0 as ::core::ffi::c_int as isize))
                        [0 as ::core::ffi::c_int as usize]
                        as ::core::ffi::c_int
                        != 0
                {
                    (*s).i_bits_encoded += bs_size_te(
                        i_ref0_max,
                        (*h).mb.cache.ref_0[0 as ::core::ffi::c_int as usize]
                            [x264_scan8[0 as ::core::ffi::c_int as usize] as usize]
                            as ::core::ffi::c_int,
                    );
                }
                if i_ref0_max != 0
                    && (*b_list.offset(0 as ::core::ffi::c_int as isize))
                        [1 as ::core::ffi::c_int as usize]
                        as ::core::ffi::c_int
                        != 0
                {
                    (*s).i_bits_encoded += bs_size_te(
                        i_ref0_max,
                        (*h).mb.cache.ref_0[0 as ::core::ffi::c_int as usize]
                            [x264_scan8[12 as ::core::ffi::c_int as usize] as usize]
                            as ::core::ffi::c_int,
                    );
                }
                if i_ref1_max != 0
                    && (*b_list.offset(1 as ::core::ffi::c_int as isize))
                        [0 as ::core::ffi::c_int as usize]
                        as ::core::ffi::c_int
                        != 0
                {
                    (*s).i_bits_encoded += bs_size_te(
                        i_ref1_max,
                        (*h).mb.cache.ref_0[1 as ::core::ffi::c_int as usize]
                            [x264_scan8[0 as ::core::ffi::c_int as usize] as usize]
                            as ::core::ffi::c_int,
                    );
                }
                if i_ref1_max != 0
                    && (*b_list.offset(1 as ::core::ffi::c_int as isize))
                        [1 as ::core::ffi::c_int as usize]
                        as ::core::ffi::c_int
                        != 0
                {
                    (*s).i_bits_encoded += bs_size_te(
                        i_ref1_max,
                        (*h).mb.cache.ref_0[1 as ::core::ffi::c_int as usize]
                            [x264_scan8[12 as ::core::ffi::c_int as usize] as usize]
                            as ::core::ffi::c_int,
                    );
                }
                if (*h).mb.i_partition == D_16x8 as ::core::ffi::c_int {
                    if (*b_list.offset(0 as ::core::ffi::c_int as isize))
                        [0 as ::core::ffi::c_int as usize]
                        != 0
                    {
                        cavlc_mvd(
                            h,
                            0 as ::core::ffi::c_int,
                            0 as ::core::ffi::c_int,
                            4 as ::core::ffi::c_int,
                        );
                    }
                    if (*b_list.offset(0 as ::core::ffi::c_int as isize))
                        [1 as ::core::ffi::c_int as usize]
                        != 0
                    {
                        cavlc_mvd(
                            h,
                            0 as ::core::ffi::c_int,
                            8 as ::core::ffi::c_int,
                            4 as ::core::ffi::c_int,
                        );
                    }
                    if (*b_list.offset(1 as ::core::ffi::c_int as isize))
                        [0 as ::core::ffi::c_int as usize]
                        != 0
                    {
                        cavlc_mvd(
                            h,
                            1 as ::core::ffi::c_int,
                            0 as ::core::ffi::c_int,
                            4 as ::core::ffi::c_int,
                        );
                    }
                    if (*b_list.offset(1 as ::core::ffi::c_int as isize))
                        [1 as ::core::ffi::c_int as usize]
                        != 0
                    {
                        cavlc_mvd(
                            h,
                            1 as ::core::ffi::c_int,
                            8 as ::core::ffi::c_int,
                            4 as ::core::ffi::c_int,
                        );
                    }
                } else {
                    if (*b_list.offset(0 as ::core::ffi::c_int as isize))
                        [0 as ::core::ffi::c_int as usize]
                        != 0
                    {
                        cavlc_mvd(
                            h,
                            0 as ::core::ffi::c_int,
                            0 as ::core::ffi::c_int,
                            2 as ::core::ffi::c_int,
                        );
                    }
                    if (*b_list.offset(0 as ::core::ffi::c_int as isize))
                        [1 as ::core::ffi::c_int as usize]
                        != 0
                    {
                        cavlc_mvd(
                            h,
                            0 as ::core::ffi::c_int,
                            4 as ::core::ffi::c_int,
                            2 as ::core::ffi::c_int,
                        );
                    }
                    if (*b_list.offset(1 as ::core::ffi::c_int as isize))
                        [0 as ::core::ffi::c_int as usize]
                        != 0
                    {
                        cavlc_mvd(
                            h,
                            1 as ::core::ffi::c_int,
                            0 as ::core::ffi::c_int,
                            2 as ::core::ffi::c_int,
                        );
                    }
                    if (*b_list.offset(1 as ::core::ffi::c_int as isize))
                        [1 as ::core::ffi::c_int as usize]
                        != 0
                    {
                        cavlc_mvd(
                            h,
                            1 as ::core::ffi::c_int,
                            4 as ::core::ffi::c_int,
                            2 as ::core::ffi::c_int,
                        );
                    }
                }
            }
        } else if i_mb_type == B_DIRECT as ::core::ffi::c_int {
            (*s).i_bits_encoded += 1 as ::core::ffi::c_int;
        } else {
            cavlc_mb_header_i(h, i_mb_type, 23 as ::core::ffi::c_int, chroma);
        };
    }
    #[c2rust::src_loc = "487:1"]
    pub unsafe extern "C" fn macroblock_size_cavlc(mut h: *mut x264_t) {
        let mut s: *mut bs_t = &mut (*h).out.bs;
        let i_mb_type: ::core::ffi::c_int = (*h).mb.i_type;
        let mut plane_count: ::core::ffi::c_int =
            if (*(*h).sps.as_mut_ptr()).i_chroma_format_idc == CHROMA_444 as ::core::ffi::c_int {
                3 as ::core::ffi::c_int
            } else {
                1 as ::core::ffi::c_int
            };
        let mut chroma: ::core::ffi::c_int = ((*(*h).sps.as_mut_ptr()).i_chroma_format_idc
            == CHROMA_420 as ::core::ffi::c_int
            || (*(*h).sps.as_mut_ptr()).i_chroma_format_idc == CHROMA_422 as ::core::ffi::c_int)
            as ::core::ffi::c_int;
        (*s).i_bits_encoded = 0 as ::core::ffi::c_int;
        if (*h).sh.b_mbaff != 0
            && ((*h).mb.i_mb_y & 1 as ::core::ffi::c_int == 0
                || (*(*h)
                    .mb
                    .type_0
                    .offset(((*h).mb.i_mb_xy - (*h).mb.i_mb_stride) as isize)
                    as ::core::ffi::c_int
                    == P_SKIP as ::core::ffi::c_int
                    || *(*h)
                        .mb
                        .type_0
                        .offset(((*h).mb.i_mb_xy - (*h).mb.i_mb_stride) as isize)
                        as ::core::ffi::c_int
                        == B_SKIP as ::core::ffi::c_int))
        {
            (*s).i_bits_encoded += 1 as ::core::ffi::c_int;
        }
        if (*h).sh.i_type == SLICE_TYPE_P as ::core::ffi::c_int {
            cavlc_mb_header_p(h, i_mb_type, chroma);
        } else if (*h).sh.i_type == SLICE_TYPE_B as ::core::ffi::c_int {
            cavlc_mb_header_b(h, i_mb_type, chroma);
        } else {
            cavlc_mb_header_i(h, i_mb_type, 0 as ::core::ffi::c_int, chroma);
        }
        if i_mb_type != I_16x16 as ::core::ffi::c_int {
            (*s).i_bits_encoded += bs_size_ue(
                cbp_to_golomb[chroma as usize][(i_mb_type == I_4x4 as ::core::ffi::c_int
                    || i_mb_type == I_8x8 as ::core::ffi::c_int
                    || i_mb_type == I_16x16 as ::core::ffi::c_int
                    || i_mb_type == I_PCM as ::core::ffi::c_int)
                    as ::core::ffi::c_int as usize][((*h).mb.i_cbp_chroma
                    << 4 as ::core::ffi::c_int
                    | (*h).mb.i_cbp_luma)
                    as usize] as ::core::ffi::c_uint,
            );
        }
        if x264_mb_transform_8x8_allowed(h) != 0 && (*h).mb.i_cbp_luma != 0 {
            (*s).i_bits_encoded += 1 as ::core::ffi::c_int;
        }
        if i_mb_type == I_16x16 as ::core::ffi::c_int {
            cavlc_qp_delta(h);
            let mut p: ::core::ffi::c_int = 0 as ::core::ffi::c_int;
            while p < plane_count {
                let mut nC: ::core::ffi::c_int = if DCT_LUMA_DC as ::core::ffi::c_int
                    == DCT_CHROMA_DC as ::core::ffi::c_int
                {
                    5 as ::core::ffi::c_int - (*h).mb.chroma_v_shift
                } else {
                    ct_index[x264_mb_predict_non_zero_code(
                        h,
                        if DCT_LUMA_DC as ::core::ffi::c_int == DCT_LUMA_DC as ::core::ffi::c_int {
                            (48 as ::core::ffi::c_int + p - LUMA_DC) * 16 as ::core::ffi::c_int
                        } else {
                            48 as ::core::ffi::c_int + p
                        },
                    ) as usize] as ::core::ffi::c_int
                };
                let mut nnz: *mut uint8_t = &mut *(*h).mb.cache.non_zero_count.as_mut_ptr().offset(
                    *x264_scan8
                        .as_ptr()
                        .offset((48 as ::core::ffi::c_int + p) as isize)
                        as isize,
                ) as *mut uint8_t;
                if *nnz == 0 {
                    (*h).out.bs.i_bits_encoded +=
                        x264_coeff0_token[nC as usize].i_size as ::core::ffi::c_int;
                } else {
                    *nnz = cavlc_block_residual_internal(
                        h,
                        DCT_LUMA_DC as ::core::ffi::c_int,
                        (*(*h).dct.luma16x16_dc.as_mut_ptr().offset(p as isize)).as_mut_ptr(),
                        nC,
                    ) as uint8_t;
                }
                if (*h).mb.i_cbp_luma != 0 {
                    let mut i: ::core::ffi::c_int = p * 16 as ::core::ffi::c_int;
                    while i < p * 16 as ::core::ffi::c_int + 16 as ::core::ffi::c_int {
                        let mut nC_0: ::core::ffi::c_int = if DCT_LUMA_AC as ::core::ffi::c_int
                            == DCT_CHROMA_DC as ::core::ffi::c_int
                        {
                            5 as ::core::ffi::c_int - (*h).mb.chroma_v_shift
                        } else {
                            ct_index[x264_mb_predict_non_zero_code(
                                h,
                                if DCT_LUMA_AC as ::core::ffi::c_int
                                    == DCT_LUMA_DC as ::core::ffi::c_int
                                {
                                    (i - LUMA_DC) * 16 as ::core::ffi::c_int
                                } else {
                                    i
                                },
                            ) as usize] as ::core::ffi::c_int
                        };
                        let mut nnz_0: *mut uint8_t = &mut *(*h)
                            .mb
                            .cache
                            .non_zero_count
                            .as_mut_ptr()
                            .offset(*x264_scan8.as_ptr().offset(i as isize) as isize)
                            as *mut uint8_t;
                        if *nnz_0 == 0 {
                            (*h).out.bs.i_bits_encoded +=
                                x264_coeff0_token[nC_0 as usize].i_size as ::core::ffi::c_int;
                        } else {
                            *nnz_0 = cavlc_block_residual_internal(
                                h,
                                DCT_LUMA_AC as ::core::ffi::c_int,
                                (*(*h).dct.luma4x4.as_mut_ptr().offset(i as isize))
                                    .as_mut_ptr()
                                    .offset(1 as ::core::ffi::c_int as isize),
                                nC_0,
                            ) as uint8_t;
                        }
                        i += 1;
                    }
                }
                p += 1;
            }
        } else if (*h).mb.i_cbp_luma | (*h).mb.i_cbp_chroma != 0 {
            cavlc_qp_delta(h);
            cavlc_macroblock_luma_residual(h, plane_count);
        }
        if (*h).mb.i_cbp_chroma != 0 {
            let mut nC_1: ::core::ffi::c_int = if DCT_CHROMA_DC as ::core::ffi::c_int
                == DCT_CHROMA_DC as ::core::ffi::c_int
            {
                5 as ::core::ffi::c_int - (*h).mb.chroma_v_shift
            } else {
                ct_index[x264_mb_predict_non_zero_code(
                    h,
                    if DCT_CHROMA_DC as ::core::ffi::c_int == DCT_LUMA_DC as ::core::ffi::c_int {
                        (49 as ::core::ffi::c_int + 0 as ::core::ffi::c_int - LUMA_DC)
                            * 16 as ::core::ffi::c_int
                    } else {
                        49 as ::core::ffi::c_int + 0 as ::core::ffi::c_int
                    },
                ) as usize] as ::core::ffi::c_int
            };
            let mut nnz_1: *mut uint8_t = &mut *(*h).mb.cache.non_zero_count.as_mut_ptr().offset(
                *x264_scan8
                    .as_ptr()
                    .offset((49 as ::core::ffi::c_int + 0 as ::core::ffi::c_int) as isize)
                    as isize,
            ) as *mut uint8_t;
            if *nnz_1 == 0 {
                (*h).out.bs.i_bits_encoded +=
                    x264_coeff0_token[nC_1 as usize].i_size as ::core::ffi::c_int;
            } else {
                *nnz_1 = cavlc_block_residual_internal(
                    h,
                    DCT_CHROMA_DC as ::core::ffi::c_int,
                    (*(*h)
                        .dct
                        .chroma_dc
                        .as_mut_ptr()
                        .offset(0 as ::core::ffi::c_int as isize))
                    .as_mut_ptr(),
                    nC_1,
                ) as uint8_t;
            }
            let mut nC_2: ::core::ffi::c_int = if DCT_CHROMA_DC as ::core::ffi::c_int
                == DCT_CHROMA_DC as ::core::ffi::c_int
            {
                5 as ::core::ffi::c_int - (*h).mb.chroma_v_shift
            } else {
                ct_index[x264_mb_predict_non_zero_code(
                    h,
                    if DCT_CHROMA_DC as ::core::ffi::c_int == DCT_LUMA_DC as ::core::ffi::c_int {
                        (49 as ::core::ffi::c_int + 1 as ::core::ffi::c_int - LUMA_DC)
                            * 16 as ::core::ffi::c_int
                    } else {
                        49 as ::core::ffi::c_int + 1 as ::core::ffi::c_int
                    },
                ) as usize] as ::core::ffi::c_int
            };
            let mut nnz_2: *mut uint8_t = &mut *(*h).mb.cache.non_zero_count.as_mut_ptr().offset(
                *x264_scan8
                    .as_ptr()
                    .offset((49 as ::core::ffi::c_int + 1 as ::core::ffi::c_int) as isize)
                    as isize,
            ) as *mut uint8_t;
            if *nnz_2 == 0 {
                (*h).out.bs.i_bits_encoded +=
                    x264_coeff0_token[nC_2 as usize].i_size as ::core::ffi::c_int;
            } else {
                *nnz_2 = cavlc_block_residual_internal(
                    h,
                    DCT_CHROMA_DC as ::core::ffi::c_int,
                    (*(*h)
                        .dct
                        .chroma_dc
                        .as_mut_ptr()
                        .offset(1 as ::core::ffi::c_int as isize))
                    .as_mut_ptr(),
                    nC_2,
                ) as uint8_t;
            }
            if (*h).mb.i_cbp_chroma == 2 as ::core::ffi::c_int {
                let mut step: ::core::ffi::c_int =
                    (8 as ::core::ffi::c_int) << (*h).mb.chroma_v_shift;
                let mut i_0: ::core::ffi::c_int = 16 as ::core::ffi::c_int;
                while i_0 < 3 as ::core::ffi::c_int * 16 as ::core::ffi::c_int {
                    let mut j: ::core::ffi::c_int = i_0;
                    while j < i_0 + 4 as ::core::ffi::c_int {
                        let mut nC_3: ::core::ffi::c_int = if DCT_CHROMA_AC as ::core::ffi::c_int
                            == DCT_CHROMA_DC as ::core::ffi::c_int
                        {
                            5 as ::core::ffi::c_int - (*h).mb.chroma_v_shift
                        } else {
                            ct_index[x264_mb_predict_non_zero_code(
                                h,
                                if DCT_CHROMA_AC as ::core::ffi::c_int
                                    == DCT_LUMA_DC as ::core::ffi::c_int
                                {
                                    (j - LUMA_DC) * 16 as ::core::ffi::c_int
                                } else {
                                    j
                                },
                            ) as usize] as ::core::ffi::c_int
                        };
                        let mut nnz_3: *mut uint8_t = &mut *(*h)
                            .mb
                            .cache
                            .non_zero_count
                            .as_mut_ptr()
                            .offset(*x264_scan8.as_ptr().offset(j as isize) as isize)
                            as *mut uint8_t;
                        if *nnz_3 == 0 {
                            (*h).out.bs.i_bits_encoded +=
                                x264_coeff0_token[nC_3 as usize].i_size as ::core::ffi::c_int;
                        } else {
                            *nnz_3 = cavlc_block_residual_internal(
                                h,
                                DCT_CHROMA_AC as ::core::ffi::c_int,
                                (*(*h).dct.luma4x4.as_mut_ptr().offset(j as isize))
                                    .as_mut_ptr()
                                    .offset(1 as ::core::ffi::c_int as isize),
                                nC_3,
                            ) as uint8_t;
                        }
                        j += 1;
                    }
                    i_0 += step;
                }
            }
        }
    }
    #[c2rust::src_loc = "605:1"]
    pub unsafe extern "C" fn partition_size_cavlc(
        mut h: *mut x264_t,
        mut i8: ::core::ffi::c_int,
        mut i_pixel: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int {
        let mut s: *mut bs_t = &mut (*h).out.bs;
        let i_mb_type: ::core::ffi::c_int = (*h).mb.i_type;
        let mut b_8x16: ::core::ffi::c_int =
            ((*h).mb.i_partition == D_8x16 as ::core::ffi::c_int) as ::core::ffi::c_int;
        let mut plane_count: ::core::ffi::c_int =
            if (*(*h).sps.as_mut_ptr()).i_chroma_format_idc == CHROMA_444 as ::core::ffi::c_int {
                3 as ::core::ffi::c_int
            } else {
                1 as ::core::ffi::c_int
            };
        let mut j: ::core::ffi::c_int = 0;
        (*h).out.bs.i_bits_encoded = 0 as ::core::ffi::c_int;
        if i_mb_type == P_8x8 as ::core::ffi::c_int {
            cavlc_8x8_mvd(h, i8);
            (*s).i_bits_encoded += bs_size_ue(
                subpartition_p_to_golomb[(*h).mb.i_sub_partition[i8 as usize] as usize]
                    as ::core::ffi::c_uint,
            );
        } else if i_mb_type == P_L0 as ::core::ffi::c_int {
            cavlc_mvd(
                h,
                0 as ::core::ffi::c_int,
                4 as ::core::ffi::c_int * i8,
                4 as ::core::ffi::c_int >> b_8x16,
            );
        } else if i_mb_type > B_DIRECT as ::core::ffi::c_int
            && i_mb_type < B_8x8 as ::core::ffi::c_int
        {
            if x264_mb_type_list_table[i_mb_type as usize][0 as ::core::ffi::c_int as usize]
                [(i8 != 0) as ::core::ffi::c_int as usize]
                != 0
            {
                cavlc_mvd(
                    h,
                    0 as ::core::ffi::c_int,
                    4 as ::core::ffi::c_int * i8,
                    4 as ::core::ffi::c_int >> b_8x16,
                );
            }
            if x264_mb_type_list_table[i_mb_type as usize][1 as ::core::ffi::c_int as usize]
                [(i8 != 0) as ::core::ffi::c_int as usize]
                != 0
            {
                cavlc_mvd(
                    h,
                    1 as ::core::ffi::c_int,
                    4 as ::core::ffi::c_int * i8,
                    4 as ::core::ffi::c_int >> b_8x16,
                );
            }
        } else {
            if x264_mb_partition_listX_table[0 as ::core::ffi::c_int as usize]
                [(*h).mb.i_sub_partition[i8 as usize] as usize]
                != 0
            {
                cavlc_mvd(
                    h,
                    0 as ::core::ffi::c_int,
                    4 as ::core::ffi::c_int * i8,
                    2 as ::core::ffi::c_int,
                );
            }
            if x264_mb_partition_listX_table[1 as ::core::ffi::c_int as usize]
                [(*h).mb.i_sub_partition[i8 as usize] as usize]
                != 0
            {
                cavlc_mvd(
                    h,
                    1 as ::core::ffi::c_int,
                    4 as ::core::ffi::c_int * i8,
                    2 as ::core::ffi::c_int,
                );
            }
        }
        j = (i_pixel < PIXEL_8x8 as ::core::ffi::c_int) as ::core::ffi::c_int;
        while j >= 0 as ::core::ffi::c_int {
            let mut p: ::core::ffi::c_int = 0 as ::core::ffi::c_int;
            while p < plane_count {
                cavlc_partition_luma_residual(h, i8, p);
                p += 1;
            }
            if (*h).mb.i_cbp_chroma != 0 {
                if (*(*h).sps.as_mut_ptr()).i_chroma_format_idc == CHROMA_422 as ::core::ffi::c_int
                {
                    let mut offset: ::core::ffi::c_int =
                        5 as ::core::ffi::c_int * i8 & 0x9 as ::core::ffi::c_int;
                    let mut nC: ::core::ffi::c_int = if DCT_CHROMA_AC as ::core::ffi::c_int
                        == DCT_CHROMA_DC as ::core::ffi::c_int
                    {
                        5 as ::core::ffi::c_int - (*h).mb.chroma_v_shift
                    } else {
                        ct_index[x264_mb_predict_non_zero_code(
                            h,
                            if DCT_CHROMA_AC as ::core::ffi::c_int
                                == DCT_LUMA_DC as ::core::ffi::c_int
                            {
                                (16 as ::core::ffi::c_int + offset - LUMA_DC)
                                    * 16 as ::core::ffi::c_int
                            } else {
                                16 as ::core::ffi::c_int + offset
                            },
                        ) as usize] as ::core::ffi::c_int
                    };
                    let mut nnz: *mut uint8_t =
                        &mut *(*h).mb.cache.non_zero_count.as_mut_ptr().offset(
                            *x264_scan8
                                .as_ptr()
                                .offset((16 as ::core::ffi::c_int + offset) as isize)
                                as isize,
                        ) as *mut uint8_t;
                    if *nnz == 0 {
                        (*h).out.bs.i_bits_encoded +=
                            x264_coeff0_token[nC as usize].i_size as ::core::ffi::c_int;
                    } else {
                        *nnz = cavlc_block_residual_internal(
                            h,
                            DCT_CHROMA_AC as ::core::ffi::c_int,
                            (*(*h)
                                .dct
                                .luma4x4
                                .as_mut_ptr()
                                .offset((16 as ::core::ffi::c_int + offset) as isize))
                            .as_mut_ptr()
                            .offset(1 as ::core::ffi::c_int as isize),
                            nC,
                        ) as uint8_t;
                    }
                    let mut nC_0: ::core::ffi::c_int = if DCT_CHROMA_AC as ::core::ffi::c_int
                        == DCT_CHROMA_DC as ::core::ffi::c_int
                    {
                        5 as ::core::ffi::c_int - (*h).mb.chroma_v_shift
                    } else {
                        ct_index[x264_mb_predict_non_zero_code(
                            h,
                            if DCT_CHROMA_AC as ::core::ffi::c_int
                                == DCT_LUMA_DC as ::core::ffi::c_int
                            {
                                (18 as ::core::ffi::c_int + offset - LUMA_DC)
                                    * 16 as ::core::ffi::c_int
                            } else {
                                18 as ::core::ffi::c_int + offset
                            },
                        ) as usize] as ::core::ffi::c_int
                    };
                    let mut nnz_0: *mut uint8_t =
                        &mut *(*h).mb.cache.non_zero_count.as_mut_ptr().offset(
                            *x264_scan8
                                .as_ptr()
                                .offset((18 as ::core::ffi::c_int + offset) as isize)
                                as isize,
                        ) as *mut uint8_t;
                    if *nnz_0 == 0 {
                        (*h).out.bs.i_bits_encoded +=
                            x264_coeff0_token[nC_0 as usize].i_size as ::core::ffi::c_int;
                    } else {
                        *nnz_0 = cavlc_block_residual_internal(
                            h,
                            DCT_CHROMA_AC as ::core::ffi::c_int,
                            (*(*h)
                                .dct
                                .luma4x4
                                .as_mut_ptr()
                                .offset((18 as ::core::ffi::c_int + offset) as isize))
                            .as_mut_ptr()
                            .offset(1 as ::core::ffi::c_int as isize),
                            nC_0,
                        ) as uint8_t;
                    }
                    let mut nC_1: ::core::ffi::c_int = if DCT_CHROMA_AC as ::core::ffi::c_int
                        == DCT_CHROMA_DC as ::core::ffi::c_int
                    {
                        5 as ::core::ffi::c_int - (*h).mb.chroma_v_shift
                    } else {
                        ct_index[x264_mb_predict_non_zero_code(
                            h,
                            if DCT_CHROMA_AC as ::core::ffi::c_int
                                == DCT_LUMA_DC as ::core::ffi::c_int
                            {
                                (32 as ::core::ffi::c_int + offset - LUMA_DC)
                                    * 16 as ::core::ffi::c_int
                            } else {
                                32 as ::core::ffi::c_int + offset
                            },
                        ) as usize] as ::core::ffi::c_int
                    };
                    let mut nnz_1: *mut uint8_t =
                        &mut *(*h).mb.cache.non_zero_count.as_mut_ptr().offset(
                            *x264_scan8
                                .as_ptr()
                                .offset((32 as ::core::ffi::c_int + offset) as isize)
                                as isize,
                        ) as *mut uint8_t;
                    if *nnz_1 == 0 {
                        (*h).out.bs.i_bits_encoded +=
                            x264_coeff0_token[nC_1 as usize].i_size as ::core::ffi::c_int;
                    } else {
                        *nnz_1 = cavlc_block_residual_internal(
                            h,
                            DCT_CHROMA_AC as ::core::ffi::c_int,
                            (*(*h)
                                .dct
                                .luma4x4
                                .as_mut_ptr()
                                .offset((32 as ::core::ffi::c_int + offset) as isize))
                            .as_mut_ptr()
                            .offset(1 as ::core::ffi::c_int as isize),
                            nC_1,
                        ) as uint8_t;
                    }
                    let mut nC_2: ::core::ffi::c_int = if DCT_CHROMA_AC as ::core::ffi::c_int
                        == DCT_CHROMA_DC as ::core::ffi::c_int
                    {
                        5 as ::core::ffi::c_int - (*h).mb.chroma_v_shift
                    } else {
                        ct_index[x264_mb_predict_non_zero_code(
                            h,
                            if DCT_CHROMA_AC as ::core::ffi::c_int
                                == DCT_LUMA_DC as ::core::ffi::c_int
                            {
                                (34 as ::core::ffi::c_int + offset - LUMA_DC)
                                    * 16 as ::core::ffi::c_int
                            } else {
                                34 as ::core::ffi::c_int + offset
                            },
                        ) as usize] as ::core::ffi::c_int
                    };
                    let mut nnz_2: *mut uint8_t =
                        &mut *(*h).mb.cache.non_zero_count.as_mut_ptr().offset(
                            *x264_scan8
                                .as_ptr()
                                .offset((34 as ::core::ffi::c_int + offset) as isize)
                                as isize,
                        ) as *mut uint8_t;
                    if *nnz_2 == 0 {
                        (*h).out.bs.i_bits_encoded +=
                            x264_coeff0_token[nC_2 as usize].i_size as ::core::ffi::c_int;
                    } else {
                        *nnz_2 = cavlc_block_residual_internal(
                            h,
                            DCT_CHROMA_AC as ::core::ffi::c_int,
                            (*(*h)
                                .dct
                                .luma4x4
                                .as_mut_ptr()
                                .offset((34 as ::core::ffi::c_int + offset) as isize))
                            .as_mut_ptr()
                            .offset(1 as ::core::ffi::c_int as isize),
                            nC_2,
                        ) as uint8_t;
                    }
                } else {
                    let mut nC_3: ::core::ffi::c_int = if DCT_CHROMA_AC as ::core::ffi::c_int
                        == DCT_CHROMA_DC as ::core::ffi::c_int
                    {
                        5 as ::core::ffi::c_int - (*h).mb.chroma_v_shift
                    } else {
                        ct_index[x264_mb_predict_non_zero_code(
                            h,
                            if DCT_CHROMA_AC as ::core::ffi::c_int
                                == DCT_LUMA_DC as ::core::ffi::c_int
                            {
                                (16 as ::core::ffi::c_int + i8 - LUMA_DC) * 16 as ::core::ffi::c_int
                            } else {
                                16 as ::core::ffi::c_int + i8
                            },
                        ) as usize] as ::core::ffi::c_int
                    };
                    let mut nnz_3: *mut uint8_t =
                        &mut *(*h).mb.cache.non_zero_count.as_mut_ptr().offset(
                            *x264_scan8
                                .as_ptr()
                                .offset((16 as ::core::ffi::c_int + i8) as isize)
                                as isize,
                        ) as *mut uint8_t;
                    if *nnz_3 == 0 {
                        (*h).out.bs.i_bits_encoded +=
                            x264_coeff0_token[nC_3 as usize].i_size as ::core::ffi::c_int;
                    } else {
                        *nnz_3 = cavlc_block_residual_internal(
                            h,
                            DCT_CHROMA_AC as ::core::ffi::c_int,
                            (*(*h)
                                .dct
                                .luma4x4
                                .as_mut_ptr()
                                .offset((16 as ::core::ffi::c_int + i8) as isize))
                            .as_mut_ptr()
                            .offset(1 as ::core::ffi::c_int as isize),
                            nC_3,
                        ) as uint8_t;
                    }
                    let mut nC_4: ::core::ffi::c_int = if DCT_CHROMA_AC as ::core::ffi::c_int
                        == DCT_CHROMA_DC as ::core::ffi::c_int
                    {
                        5 as ::core::ffi::c_int - (*h).mb.chroma_v_shift
                    } else {
                        ct_index[x264_mb_predict_non_zero_code(
                            h,
                            if DCT_CHROMA_AC as ::core::ffi::c_int
                                == DCT_LUMA_DC as ::core::ffi::c_int
                            {
                                (32 as ::core::ffi::c_int + i8 - LUMA_DC) * 16 as ::core::ffi::c_int
                            } else {
                                32 as ::core::ffi::c_int + i8
                            },
                        ) as usize] as ::core::ffi::c_int
                    };
                    let mut nnz_4: *mut uint8_t =
                        &mut *(*h).mb.cache.non_zero_count.as_mut_ptr().offset(
                            *x264_scan8
                                .as_ptr()
                                .offset((32 as ::core::ffi::c_int + i8) as isize)
                                as isize,
                        ) as *mut uint8_t;
                    if *nnz_4 == 0 {
                        (*h).out.bs.i_bits_encoded +=
                            x264_coeff0_token[nC_4 as usize].i_size as ::core::ffi::c_int;
                    } else {
                        *nnz_4 = cavlc_block_residual_internal(
                            h,
                            DCT_CHROMA_AC as ::core::ffi::c_int,
                            (*(*h)
                                .dct
                                .luma4x4
                                .as_mut_ptr()
                                .offset((32 as ::core::ffi::c_int + i8) as isize))
                            .as_mut_ptr()
                            .offset(1 as ::core::ffi::c_int as isize),
                            nC_4,
                        ) as uint8_t;
                    }
                }
            }
            i8 += x264_pixel_size[i_pixel as usize].h as ::core::ffi::c_int
                >> 3 as ::core::ffi::c_int;
            j -= 1;
        }
        return (*h).out.bs.i_bits_encoded;
    }
    #[c2rust::src_loc = "661:1"]
    pub unsafe extern "C" fn subpartition_size_cavlc(
        mut h: *mut x264_t,
        mut i4: ::core::ffi::c_int,
        mut i_pixel: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int {
        let mut plane_count: ::core::ffi::c_int =
            if (*(*h).sps.as_mut_ptr()).i_chroma_format_idc == CHROMA_444 as ::core::ffi::c_int {
                3 as ::core::ffi::c_int
            } else {
                1 as ::core::ffi::c_int
            };
        let mut b_8x4: ::core::ffi::c_int =
            (i_pixel == PIXEL_8x4 as ::core::ffi::c_int) as ::core::ffi::c_int;
        (*h).out.bs.i_bits_encoded = 0 as ::core::ffi::c_int;
        cavlc_mvd(
            h,
            0 as ::core::ffi::c_int,
            i4,
            1 as ::core::ffi::c_int + b_8x4,
        );
        let mut p: ::core::ffi::c_int = 0 as ::core::ffi::c_int;
        while p < plane_count {
            let mut nC: ::core::ffi::c_int =
                if DCT_LUMA_4x4 as ::core::ffi::c_int == DCT_CHROMA_DC as ::core::ffi::c_int {
                    5 as ::core::ffi::c_int - (*h).mb.chroma_v_shift
                } else {
                    ct_index[x264_mb_predict_non_zero_code(
                        h,
                        if DCT_LUMA_4x4 as ::core::ffi::c_int == DCT_LUMA_DC as ::core::ffi::c_int {
                            (p * 16 as ::core::ffi::c_int + i4 - LUMA_DC) * 16 as ::core::ffi::c_int
                        } else {
                            p * 16 as ::core::ffi::c_int + i4
                        },
                    ) as usize] as ::core::ffi::c_int
                };
            let mut nnz: *mut uint8_t = &mut *(*h).mb.cache.non_zero_count.as_mut_ptr().offset(
                *x264_scan8
                    .as_ptr()
                    .offset((p * 16 as ::core::ffi::c_int + i4) as isize) as isize,
            ) as *mut uint8_t;
            if *nnz == 0 {
                (*h).out.bs.i_bits_encoded +=
                    x264_coeff0_token[nC as usize].i_size as ::core::ffi::c_int;
            } else {
                *nnz = cavlc_block_residual_internal(
                    h,
                    DCT_LUMA_4x4 as ::core::ffi::c_int,
                    (*(*h)
                        .dct
                        .luma4x4
                        .as_mut_ptr()
                        .offset((p * 16 as ::core::ffi::c_int + i4) as isize))
                    .as_mut_ptr(),
                    nC,
                ) as uint8_t;
            }
            if i_pixel != PIXEL_4x4 as ::core::ffi::c_int {
                let mut nC_0: ::core::ffi::c_int = if DCT_LUMA_4x4 as ::core::ffi::c_int
                    == DCT_CHROMA_DC as ::core::ffi::c_int
                {
                    5 as ::core::ffi::c_int - (*h).mb.chroma_v_shift
                } else {
                    ct_index[x264_mb_predict_non_zero_code(
                        h,
                        if DCT_LUMA_4x4 as ::core::ffi::c_int == DCT_LUMA_DC as ::core::ffi::c_int {
                            (p * 16 as ::core::ffi::c_int + i4 + 2 as ::core::ffi::c_int
                                - b_8x4
                                - LUMA_DC)
                                * 16 as ::core::ffi::c_int
                        } else {
                            p * 16 as ::core::ffi::c_int + i4 + 2 as ::core::ffi::c_int - b_8x4
                        },
                    ) as usize] as ::core::ffi::c_int
                };
                let mut nnz_0: *mut uint8_t =
                    &mut *(*h).mb.cache.non_zero_count.as_mut_ptr().offset(
                        *x264_scan8.as_ptr().offset(
                            (p * 16 as ::core::ffi::c_int + i4 + 2 as ::core::ffi::c_int - b_8x4)
                                as isize,
                        ) as isize,
                    ) as *mut uint8_t;
                if *nnz_0 == 0 {
                    (*h).out.bs.i_bits_encoded +=
                        x264_coeff0_token[nC_0 as usize].i_size as ::core::ffi::c_int;
                } else {
                    *nnz_0 = cavlc_block_residual_internal(
                        h,
                        DCT_LUMA_4x4 as ::core::ffi::c_int,
                        (*(*h).dct.luma4x4.as_mut_ptr().offset(
                            (p * 16 as ::core::ffi::c_int + i4 + 2 as ::core::ffi::c_int - b_8x4)
                                as isize,
                        ))
                        .as_mut_ptr(),
                        nC_0,
                    ) as uint8_t;
                }
            }
            p += 1;
        }
        return (*h).out.bs.i_bits_encoded;
    }
    #[c2rust::src_loc = "677:1"]
    pub unsafe extern "C" fn cavlc_intra4x4_pred_size(
        mut h: *mut x264_t,
        mut i4: ::core::ffi::c_int,
        mut i_mode: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int {
        if x264_mb_predict_intra4x4_mode(h, i4)
            == x264_mb_pred_mode4x4_fix[(i_mode + 1 as ::core::ffi::c_int) as usize]
                as ::core::ffi::c_int
        {
            return 1 as ::core::ffi::c_int;
        } else {
            return 4 as ::core::ffi::c_int;
        };
    }
    #[c2rust::src_loc = "685:1"]
    pub unsafe extern "C" fn partition_i8x8_size_cavlc(
        mut h: *mut x264_t,
        mut i8: ::core::ffi::c_int,
        mut i_mode: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int {
        let mut plane_count: ::core::ffi::c_int =
            if (*(*h).sps.as_mut_ptr()).i_chroma_format_idc == CHROMA_444 as ::core::ffi::c_int {
                3 as ::core::ffi::c_int
            } else {
                1 as ::core::ffi::c_int
            };
        (*h).out.bs.i_bits_encoded =
            cavlc_intra4x4_pred_size(h, 4 as ::core::ffi::c_int * i8, i_mode);
        (*h).out.bs.i_bits_encoded += bs_size_ue(
            cbp_to_golomb[!((*(*h).sps.as_mut_ptr()).i_chroma_format_idc
                == CHROMA_444 as ::core::ffi::c_int) as ::core::ffi::c_int
                as usize][1 as ::core::ffi::c_int as usize]
                [((*h).mb.i_cbp_chroma << 4 as ::core::ffi::c_int | (*h).mb.i_cbp_luma) as usize]
                as ::core::ffi::c_uint,
        );
        let mut p: ::core::ffi::c_int = 0 as ::core::ffi::c_int;
        while p < plane_count {
            cavlc_partition_luma_residual(h, i8, p);
            p += 1;
        }
        return (*h).out.bs.i_bits_encoded;
    }
    #[c2rust::src_loc = "695:1"]
    pub unsafe extern "C" fn partition_i4x4_size_cavlc(
        mut h: *mut x264_t,
        mut i4: ::core::ffi::c_int,
        mut i_mode: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int {
        let mut plane_count: ::core::ffi::c_int =
            if (*(*h).sps.as_mut_ptr()).i_chroma_format_idc == CHROMA_444 as ::core::ffi::c_int {
                3 as ::core::ffi::c_int
            } else {
                1 as ::core::ffi::c_int
            };
        (*h).out.bs.i_bits_encoded = cavlc_intra4x4_pred_size(h, i4, i_mode);
        let mut p: ::core::ffi::c_int = 0 as ::core::ffi::c_int;
        while p < plane_count {
            let mut nC: ::core::ffi::c_int =
                if DCT_LUMA_4x4 as ::core::ffi::c_int == DCT_CHROMA_DC as ::core::ffi::c_int {
                    5 as ::core::ffi::c_int - (*h).mb.chroma_v_shift
                } else {
                    ct_index[x264_mb_predict_non_zero_code(
                        h,
                        if DCT_LUMA_4x4 as ::core::ffi::c_int == DCT_LUMA_DC as ::core::ffi::c_int {
                            (p * 16 as ::core::ffi::c_int + i4 - LUMA_DC) * 16 as ::core::ffi::c_int
                        } else {
                            p * 16 as ::core::ffi::c_int + i4
                        },
                    ) as usize] as ::core::ffi::c_int
                };
            let mut nnz: *mut uint8_t = &mut *(*h).mb.cache.non_zero_count.as_mut_ptr().offset(
                *x264_scan8
                    .as_ptr()
                    .offset((p * 16 as ::core::ffi::c_int + i4) as isize) as isize,
            ) as *mut uint8_t;
            if *nnz == 0 {
                (*h).out.bs.i_bits_encoded +=
                    x264_coeff0_token[nC as usize].i_size as ::core::ffi::c_int;
            } else {
                *nnz = cavlc_block_residual_internal(
                    h,
                    DCT_LUMA_4x4 as ::core::ffi::c_int,
                    (*(*h)
                        .dct
                        .luma4x4
                        .as_mut_ptr()
                        .offset((p * 16 as ::core::ffi::c_int + i4) as isize))
                    .as_mut_ptr(),
                    nC,
                ) as uint8_t;
            }
            p += 1;
        }
        return (*h).out.bs.i_bits_encoded;
    }
    #[c2rust::src_loc = "704:1"]
    pub unsafe extern "C" fn chroma_size_cavlc(mut h: *mut x264_t) -> ::core::ffi::c_int {
        (*h).out.bs.i_bits_encoded = bs_size_ue(
            x264_mb_chroma_pred_mode_fix[(*h).mb.i_chroma_pred_mode as usize]
                as ::core::ffi::c_uint,
        );
        if (*h).mb.i_cbp_chroma != 0 {
            let mut nC: ::core::ffi::c_int = if DCT_CHROMA_DC as ::core::ffi::c_int
                == DCT_CHROMA_DC as ::core::ffi::c_int
            {
                5 as ::core::ffi::c_int - (*h).mb.chroma_v_shift
            } else {
                ct_index[x264_mb_predict_non_zero_code(
                    h,
                    if DCT_CHROMA_DC as ::core::ffi::c_int == DCT_LUMA_DC as ::core::ffi::c_int {
                        (49 as ::core::ffi::c_int + 0 as ::core::ffi::c_int - LUMA_DC)
                            * 16 as ::core::ffi::c_int
                    } else {
                        49 as ::core::ffi::c_int + 0 as ::core::ffi::c_int
                    },
                ) as usize] as ::core::ffi::c_int
            };
            let mut nnz: *mut uint8_t = &mut *(*h).mb.cache.non_zero_count.as_mut_ptr().offset(
                *x264_scan8
                    .as_ptr()
                    .offset((49 as ::core::ffi::c_int + 0 as ::core::ffi::c_int) as isize)
                    as isize,
            ) as *mut uint8_t;
            if *nnz == 0 {
                (*h).out.bs.i_bits_encoded +=
                    x264_coeff0_token[nC as usize].i_size as ::core::ffi::c_int;
            } else {
                *nnz = cavlc_block_residual_internal(
                    h,
                    DCT_CHROMA_DC as ::core::ffi::c_int,
                    (*(*h)
                        .dct
                        .chroma_dc
                        .as_mut_ptr()
                        .offset(0 as ::core::ffi::c_int as isize))
                    .as_mut_ptr(),
                    nC,
                ) as uint8_t;
            }
            let mut nC_0: ::core::ffi::c_int = if DCT_CHROMA_DC as ::core::ffi::c_int
                == DCT_CHROMA_DC as ::core::ffi::c_int
            {
                5 as ::core::ffi::c_int - (*h).mb.chroma_v_shift
            } else {
                ct_index[x264_mb_predict_non_zero_code(
                    h,
                    if DCT_CHROMA_DC as ::core::ffi::c_int == DCT_LUMA_DC as ::core::ffi::c_int {
                        (49 as ::core::ffi::c_int + 1 as ::core::ffi::c_int - LUMA_DC)
                            * 16 as ::core::ffi::c_int
                    } else {
                        49 as ::core::ffi::c_int + 1 as ::core::ffi::c_int
                    },
                ) as usize] as ::core::ffi::c_int
            };
            let mut nnz_0: *mut uint8_t = &mut *(*h).mb.cache.non_zero_count.as_mut_ptr().offset(
                *x264_scan8
                    .as_ptr()
                    .offset((49 as ::core::ffi::c_int + 1 as ::core::ffi::c_int) as isize)
                    as isize,
            ) as *mut uint8_t;
            if *nnz_0 == 0 {
                (*h).out.bs.i_bits_encoded +=
                    x264_coeff0_token[nC_0 as usize].i_size as ::core::ffi::c_int;
            } else {
                *nnz_0 = cavlc_block_residual_internal(
                    h,
                    DCT_CHROMA_DC as ::core::ffi::c_int,
                    (*(*h)
                        .dct
                        .chroma_dc
                        .as_mut_ptr()
                        .offset(1 as ::core::ffi::c_int as isize))
                    .as_mut_ptr(),
                    nC_0,
                ) as uint8_t;
            }
            if (*h).mb.i_cbp_chroma == 2 as ::core::ffi::c_int {
                let mut step: ::core::ffi::c_int =
                    (8 as ::core::ffi::c_int) << (*h).mb.chroma_v_shift;
                let mut i: ::core::ffi::c_int = 16 as ::core::ffi::c_int;
                while i < 3 as ::core::ffi::c_int * 16 as ::core::ffi::c_int {
                    let mut j: ::core::ffi::c_int = i;
                    while j < i + 4 as ::core::ffi::c_int {
                        let mut nC_1: ::core::ffi::c_int = if DCT_CHROMA_AC as ::core::ffi::c_int
                            == DCT_CHROMA_DC as ::core::ffi::c_int
                        {
                            5 as ::core::ffi::c_int - (*h).mb.chroma_v_shift
                        } else {
                            ct_index[x264_mb_predict_non_zero_code(
                                h,
                                if DCT_CHROMA_AC as ::core::ffi::c_int
                                    == DCT_LUMA_DC as ::core::ffi::c_int
                                {
                                    (j - LUMA_DC) * 16 as ::core::ffi::c_int
                                } else {
                                    j
                                },
                            ) as usize] as ::core::ffi::c_int
                        };
                        let mut nnz_1: *mut uint8_t = &mut *(*h)
                            .mb
                            .cache
                            .non_zero_count
                            .as_mut_ptr()
                            .offset(*x264_scan8.as_ptr().offset(j as isize) as isize)
                            as *mut uint8_t;
                        if *nnz_1 == 0 {
                            (*h).out.bs.i_bits_encoded +=
                                x264_coeff0_token[nC_1 as usize].i_size as ::core::ffi::c_int;
                        } else {
                            *nnz_1 = cavlc_block_residual_internal(
                                h,
                                DCT_CHROMA_AC as ::core::ffi::c_int,
                                (*(*h).dct.luma4x4.as_mut_ptr().offset(j as isize))
                                    .as_mut_ptr()
                                    .offset(1 as ::core::ffi::c_int as isize),
                                nC_1,
                            ) as uint8_t;
                        }
                        j += 1;
                    }
                    i += step;
                }
            }
        }
        return (*h).out.bs.i_bits_encoded;
    }
    use super::base_h::{
        x264_scan8, CHROMA_420, CHROMA_422, CHROMA_444, CHROMA_DC, LUMA_DC, PROFILE_HIGH,
        SLICE_TYPE_B, SLICE_TYPE_P,
    };
    use super::bitstream_h::{
        bs_size_se, bs_size_te, bs_size_ue, bs_t, x264_10_level_token, x264_10_run_before,
        x264_run_level_t, LEVEL_TABLE_SIZE,
    };
    use super::common_h::{dctcoef, x264_t, QP_BD_OFFSET, QP_MAX_SPEC};
    use super::macroblock_h::{
        x264_10_mb_predict_mv, x264_mb_partition_listX_table, x264_mb_predict_intra4x4_mode,
        x264_mb_predict_non_zero_code, x264_mb_transform_8x8_allowed, x264_mb_type_list_table,
        B_8x8, DCT_LUMA_4x4, D_16x16, D_16x8, D_8x16, I_16x16, I_4x4, I_8x8, P_8x8, B_BI_BI,
        B_DIRECT, B_L0_L0, B_SKIP, DCT_CHROMA_AC, DCT_CHROMA_DC, DCT_LUMA_AC, DCT_LUMA_DC, I_PCM,
        P_L0, P_SKIP,
    };
    use super::osdep_h::x264_ctz_4bit;
    use super::pixel_h::{x264_pixel_size, PIXEL_4x4, PIXEL_8x4, PIXEL_8x8};
    use super::predict_h::{
        x264_mb_chroma_pred_mode_fix, x264_mb_pred_mode16x16_fix, x264_mb_pred_mode4x4_fix,
    };
    use super::stdint_intn_h::{int16_t, int32_t, int8_t};
    use super::stdint_uintn_h::{uint16_t, uint32_t, uint8_t};
    use super::tables_h::{
        vlc_t, x264_coeff0_token, x264_coeff_token, x264_total_zeros, x264_total_zeros_2x2_dc,
        x264_total_zeros_2x4_dc,
    };
    use super::x264_h::X264_ANALYSE_PSUB8x8;
}
#[c2rust::header_src = "/home/nwplayer123/Hacks/hex264/x264/encoder/ratecontrol.h:28"]
pub mod ratecontrol_h {
    use super::common_h::x264_t;
    extern "C" {
        #[c2rust::src_loc = "65:1"]
        pub fn x264_10_ratecontrol_slice_type(
            _: *mut x264_t,
            i_frame: ::core::ffi::c_int,
        ) -> ::core::ffi::c_int;
        #[c2rust::src_loc = "73:1"]
        pub fn x264_10_ratecontrol_mb_qp(h: *mut x264_t) -> ::core::ffi::c_int;
    }
}
#[c2rust::header_src = "/usr/lib/clang/21/include/limits.h:28"]
pub mod limits_h {
    #[c2rust::src_loc = "50:9"]
    pub const INT_MAX: ::core::ffi::c_int = __INT_MAX__;
    use super::internal::__INT_MAX__;
}
#[c2rust::header_src = "/usr/include/stdlib.h:28"]
pub mod stdlib_h {
    extern "C" {
        #[c2rust::src_loc = "980:1"]
        pub fn abs(__x: ::core::ffi::c_int) -> ::core::ffi::c_int;
    }
}
#[c2rust::header_src = "/usr/include/bits/mathcalls.h:28"]
pub mod mathcalls_h {
    extern "C" {
        #[c2rust::src_loc = "355:1"]
        pub fn round(__x: ::core::ffi::c_double) -> ::core::ffi::c_double;
        #[c2rust::src_loc = "170:1"]
        pub fn log2f(__x: ::core::ffi::c_float) -> ::core::ffi::c_float;
        #[c2rust::src_loc = "180:1"]
        pub fn sqrtf(__x: ::core::ffi::c_float) -> ::core::ffi::c_float;
        #[c2rust::src_loc = "216:1"]
        pub fn fabsf(__x: ::core::ffi::c_float) -> ::core::ffi::c_float;
    }
}
#[c2rust::header_src = "/usr/lib/clang/21/include/__stddef_null.h:28"]
pub mod __stddef_null_h {
    #[c2rust::src_loc = "26:9"]
    pub const NULL: *mut ::core::ffi::c_void = 0 as *mut ::core::ffi::c_void;
}
#[c2rust::header_src = "/home/nwplayer123/Hacks/hex264/x264/config.h:28"]
pub mod config_h {
    #[c2rust::src_loc = "26:9"]
    pub const HAVE_INTERLACED: ::core::ffi::c_int = 1 as ::core::ffi::c_int;
}
#[c2rust::header_src = "/usr/include/assert.h:28"]
pub mod assert_h {
    extern "C" {
        #[c2rust::src_loc = "67:1"]
        pub fn __assert_fail(
            __assertion: *const ::core::ffi::c_char,
            __file: *const ::core::ffi::c_char,
            __line: ::core::ffi::c_uint,
            __function: *const ::core::ffi::c_char,
        ) -> !;
    }
}
pub use self::__stddef_null_h::NULL;
pub use self::__stddef_size_t_h::size_t;
use self::assert_h::__assert_fail;
pub use self::atomic_wide_counter_h::{C2RustUnnamed, __atomic_wide_counter};
pub use self::base_h::{
    chroma_format_e, profile_e, slice_type_e, x264_cabac_mvd_sum, x264_clip3, x264_clip3f,
    x264_exp2fix8, x264_free, x264_log2, x264_malloc, x264_median, x264_median_mv, x264_scan8,
    x264_union16_t, x264_union32_t, x264_union64_t, CHROMA_400, CHROMA_420, CHROMA_422, CHROMA_444,
    CHROMA_DC, LUMA_DC, PROFILE_BASELINE, PROFILE_HIGH, PROFILE_HIGH10, PROFILE_HIGH422,
    PROFILE_HIGH444_PREDICTIVE, PROFILE_MAIN, SLICE_TYPE_B, SLICE_TYPE_I, SLICE_TYPE_P,
    X264_BFRAME_MAX, X264_SCAN8_0, X264_WEIGHTP_FAKE,
};
pub use self::bitstream_h::{
    bs_s, bs_size_se, bs_size_te, bs_size_ue, bs_size_ue_big, bs_t, vlc_large_t,
    x264_10_level_token, x264_10_run_before, x264_bitstream_function_t, x264_run_level_t,
    x264_ue_size_tab, LEVEL_TABLE_SIZE,
};
pub use self::cabac_c::{
    cabac_8x8_mvd, cabac_block_residual, cabac_block_residual_422_dc, cabac_block_residual_8x8,
    cabac_block_residual_internal, cabac_cbf_ctxidxinc, cabac_cbp_chroma, cabac_cbp_luma,
    cabac_intra4x4_pred_mode, cabac_intra_chroma_pred_mode, cabac_mb_header_b, cabac_mb_header_i,
    cabac_mb_header_p, cabac_mb_type_intra, cabac_mvd, cabac_mvd_cpn, cabac_qp_delta, cabac_ref_b,
    cabac_ref_internal, cabac_ref_p, cabac_subpartition_b, cabac_subpartition_p,
    cabac_transform_size, chroma_size_cabac, coeff_abs_level1_ctx, coeff_abs_level_transition,
    coeff_abs_levelgt1_ctx, coeff_abs_levelgt1_ctx_chroma_dc, macroblock_size_cabac,
    macroblock_write_cabac_internal, partition_i4x4_size_cabac, partition_i8x8_size_cabac,
    partition_size_cabac, subpartition_size_cabac, x264_10_cabac_block_residual_8x8_rd_c,
    x264_10_cabac_block_residual_rd_c,
};
pub use self::cabac_h::{
    x264_cabac_size_decision, x264_cabac_size_decision2, x264_cabac_size_decision_noup,
    x264_cabac_size_decision_noup2, x264_cabac_t,
};
pub use self::cavlc_c::{
    cavlc_8x8_mvd, cavlc_block_residual_escape, cavlc_block_residual_internal,
    cavlc_intra4x4_pred_size, cavlc_macroblock_luma_residual, cavlc_mb_header_b, cavlc_mb_header_i,
    cavlc_mb_header_p, cavlc_mvd, cavlc_partition_luma_residual, cavlc_qp_delta, cbp_to_golomb,
    chroma_size_cavlc, ct_index, macroblock_size_cavlc, mb_type_b_to_golomb,
    partition_i4x4_size_cavlc, partition_i8x8_size_cavlc, partition_size_cavlc,
    subpartition_b_to_golomb, subpartition_p_to_golomb, subpartition_size_cavlc,
};
pub use self::common_h::{
    dctcoef, pixel, pixel4, udctcoef, x264_10_log, x264_frame_stat_t, x264_left_table_t,
    x264_lookahead_t, x264_ratecontrol_t, x264_slice_header_t, x264_t, C2RustUnnamed_10,
    C2RustUnnamed_11, C2RustUnnamed_12, C2RustUnnamed_13, C2RustUnnamed_17, C2RustUnnamed_18,
    C2RustUnnamed_6, C2RustUnnamed_7, C2RustUnnamed_8, C2RustUnnamed_9, FDEC_STRIDE, FENC_STRIDE,
    QP_BD_OFFSET, QP_MAX, QP_MAX_SPEC, SIZEOF_PIXEL, X264_LOOKAHEAD_QP,
};
pub use self::config_h::HAVE_INTERLACED;
pub use self::dct_h::{x264_dct_function_t, x264_zigzag_function_t};
pub use self::encoder_macroblock_h::{
    x264_10_macroblock_encode, x264_10_macroblock_encode_p4x4, x264_10_macroblock_encode_p8x8,
    x264_10_macroblock_probe_skip, x264_10_mb_encode_chroma, x264_10_predict_lossless_16x16,
    x264_10_predict_lossless_4x4, x264_10_predict_lossless_8x8, x264_10_predict_lossless_chroma,
    x264_mb_encode_i4x4, x264_mb_encode_i8x8, x264_quant_4x4, x264_quant_8x8,
};
pub use self::frame_h::{
    x264_10_frame_cond_wait, x264_10_frame_expand_border_chroma, x264_10_macroblock_deblock,
    x264_10_weight_scale_plane, x264_deblock_function_t, x264_deblock_inter_t,
    x264_deblock_intra_t, x264_frame, x264_frame_t, x264_sync_frame_list_t, LOWRES_COST_MASK,
    LOWRES_COST_SHIFT, PADH, PADV,
};
pub use self::internal::{__va_list_tag, BIT_DEPTH, __INT_MAX__};
pub use self::limits_h::INT_MAX;
pub use self::macroblock_h::{
    block_idx_x, block_idx_xy_fdec, block_idx_xy_fenc, block_idx_y, cabac_ctx_block_cat_e,
    ctx_cat_plane, macroblock_position_e, mb_class_e, mb_partition_e, pack16to32, pack8to16,
    x264_10_mb_mc, x264_10_mb_predict_mv, x264_10_mb_predict_mv_16x16,
    x264_10_mb_predict_mv_direct16x16, x264_10_mb_predict_mv_ref16x16,
    x264_mb_partition_listX_table, x264_mb_predict_intra4x4_mode, x264_mb_predict_non_zero_code,
    x264_mb_transform_8x8_allowed, x264_mb_type_list_table, x264_pred_i4x4_neighbors,
    x264_transform_allowed, x264_zigzag_scan4, x264_zigzag_scan8, B_8x8, DCT_CHROMAU_4x4,
    DCT_CHROMAU_8x8, DCT_CHROMAV_4x4, DCT_CHROMAV_8x8, DCT_LUMA_4x4, DCT_LUMA_8x8, D_16x16, D_16x8,
    D_8x16, D_8x8, D_BI_4x4, D_BI_4x8, D_BI_8x4, D_BI_8x8, D_DIRECT_8x8, D_L0_4x4, D_L0_4x8,
    D_L0_8x4, D_L0_8x8, D_L1_4x4, D_L1_4x8, D_L1_8x4, D_L1_8x8, I_16x16, I_4x4, I_8x8, P_8x8,
    ALL_NEIGHBORS, B_BI_BI, B_BI_L0, B_BI_L1, B_DIRECT, B_L0_BI, B_L0_L0, B_L0_L1, B_L1_BI,
    B_L1_L0, B_L1_L1, B_SKIP, DCT_CHROMAU_AC, DCT_CHROMAU_DC, DCT_CHROMAV_AC, DCT_CHROMAV_DC,
    DCT_CHROMA_AC, DCT_CHROMA_DC, DCT_LUMA_AC, DCT_LUMA_DC, I_PCM, MB_LEFT, MB_PRIVATE, MB_TOP,
    MB_TOPLEFT, MB_TOPRIGHT, P_L0, P_SKIP, X264_MBTYPE_MAX, X264_PARTTYPE_MAX,
};
use self::mathcalls_h::{fabsf, log2f, round, sqrtf};
pub use self::mc_h::{weight_fn_t, x264_mc_functions_t, x264_weight_t};
pub use self::me_h::{
    x264_10_me_refine_bidir_rd, x264_10_me_refine_bidir_satd, x264_10_me_refine_qpel,
    x264_10_me_refine_qpel_rd, x264_10_me_refine_qpel_refdupe, x264_10_me_search_ref, x264_me_t,
    COST_MAX, COST_MAX64,
};
pub use self::osdep_h::{x264_ctz_4bit, WORD_SIZE};
pub use self::pixel_h::{
    x264_pixel_cmp_t, x264_pixel_cmp_x3_t, x264_pixel_cmp_x4_t, x264_pixel_function_t,
    x264_pixel_size, C2RustUnnamed_19, C2RustUnnamed_20, PIXEL_16x16, PIXEL_16x8, PIXEL_2x2,
    PIXEL_2x4, PIXEL_2x8, PIXEL_4x16, PIXEL_4x2, PIXEL_4x4, PIXEL_4x8, PIXEL_8x16, PIXEL_8x4,
    PIXEL_8x8,
};
pub use self::predict_h::{
    intra16x16_pred_e, intra4x4_pred_e, intra_chroma_pred_e, x264_mb_chroma_pred_mode_fix,
    x264_mb_pred_mode16x16_fix, x264_mb_pred_mode4x4_fix, x264_predict8x8_t,
    x264_predict_8x8_filter_t, x264_predict_t, I_PRED_16x16_DC, I_PRED_16x16_DC_128,
    I_PRED_16x16_DC_LEFT, I_PRED_16x16_DC_TOP, I_PRED_16x16_H, I_PRED_16x16_P, I_PRED_16x16_V,
    I_PRED_4x4_DC, I_PRED_4x4_DC_128, I_PRED_4x4_DC_LEFT, I_PRED_4x4_DC_TOP, I_PRED_4x4_DDL,
    I_PRED_4x4_DDR, I_PRED_4x4_H, I_PRED_4x4_HD, I_PRED_4x4_HU, I_PRED_4x4_V, I_PRED_4x4_VL,
    I_PRED_4x4_VR, I_PRED_CHROMA_DC, I_PRED_CHROMA_DC_128, I_PRED_CHROMA_DC_LEFT,
    I_PRED_CHROMA_DC_TOP, I_PRED_CHROMA_H, I_PRED_CHROMA_P, I_PRED_CHROMA_V,
};
pub use self::pthreadtypes_h::{pthread_cond_t, pthread_mutex_t, pthread_t};
pub use self::quant_h::x264_quant_function_t;
use self::ratecontrol_h::{x264_10_ratecontrol_mb_qp, x264_10_ratecontrol_slice_type};
pub use self::rdo_c::{
    cabac_size_5ones, cabac_transition_5ones, cached_hadamard, cached_satd, quant_trellis_cabac,
    quant_trellis_cavlc, rd_cost_chroma, rd_cost_i4x4, rd_cost_i8x8, rd_cost_mb, rd_cost_subpart,
    ssd_mb, ssd_plane, trellis_coef, trellis_coef0_0, trellis_coef0_1, trellis_coef1_0,
    trellis_coef1_1, trellis_coefn_0, trellis_coefn_1, trellis_dc_shortcut, trellis_level_t,
    trellis_node_t, x264_10_cabac_size_unary, x264_10_cabac_transition_unary,
    x264_10_quant_4x4_trellis, x264_10_quant_8x8_trellis, x264_10_quant_chroma_dc_trellis,
    x264_10_quant_luma_dc_trellis, x264_10_rd_cost_part, x264_10_rdo_init, zigzag_scan2x2,
    zigzag_scan2x4, CABAC_SIZE_BITS, LAMBDA_BITS, TRELLIS_SCORE_BIAS, TRELLIS_SCORE_MAX,
};
pub use self::rectangle_h::{
    x264_10_cache_mv_func_table, x264_10_cache_mvd_func_table, x264_10_cache_ref_func_table,
    x264_macroblock_cache_intra8x8_pred, x264_macroblock_cache_mv, x264_macroblock_cache_mvd,
    x264_macroblock_cache_rect, x264_macroblock_cache_ref, x264_macroblock_cache_skip,
};
pub use self::set_h::{
    cqm4_e, cqm8_e, x264_pps_t, x264_sps_t, C2RustUnnamed_14, C2RustUnnamed_15, C2RustUnnamed_16,
    CQM_4IC, CQM_4IY, CQM_4PC, CQM_4PY, CQM_8IC, CQM_8IY, CQM_8PC, CQM_8PY,
};
pub use self::slicetype_c::{
    calculate_durations, delta_tfi_divisor, lowres_context_init, macroblock_tree,
    macroblock_tree_finish, macroblock_tree_propagate, scenecut, scenecut_internal,
    slicetype_frame_cost, slicetype_frame_cost_recalculate, slicetype_mb_cost, slicetype_path,
    slicetype_path_cost, slicetype_slice_cost, vbv_frame_cost, vbv_lookahead, weight_cost_chroma,
    weight_cost_chroma444, weight_cost_init_chroma, weight_cost_init_chroma444,
    weight_cost_init_luma, weight_cost_luma, weight_get_h264, weight_slice_header_cost,
    x264_10_rc_analyse_slice, x264_10_slicetype_analyse, x264_10_slicetype_decide,
    x264_10_weights_analyse, x264_slicetype_slice_t, COST_EST, COST_EST_AQ, INTRA_MBS,
    MBTREE_PRECISION, NUM_INTS, NUM_ROWS, PAD_SIZE,
};
pub use self::stdint_h::{intptr_t, uintptr_t};
pub use self::stdint_intn_h::{int16_t, int32_t, int64_t, int8_t};
pub use self::stdint_uintn_h::{uint16_t, uint32_t, uint64_t, uint8_t};
use self::stdlib_h::abs;
use self::string_h::{memcpy, memset, strcpy};
pub use self::struct_mutex_h::__pthread_mutex_s;
pub use self::tables_h::{
    vlc_t, x264_cabac_entropy, x264_cabac_transition, x264_chroma_lambda2_offset_tab,
    x264_coeff0_token, x264_coeff_abs_level_m1_offset, x264_coeff_flag_offset_chroma_422_dc,
    x264_coeff_token, x264_count_cat_m1, x264_dct4_weight2_tab, x264_dct4_weight_tab,
    x264_dct8_weight2_tab, x264_dct8_weight_tab, x264_exp2_lut, x264_lambda2_tab, x264_lambda_tab,
    x264_last_coeff_flag_offset, x264_last_coeff_flag_offset_8x8, x264_log2_lut, x264_log2_lz_lut,
    x264_significant_coeff_flag_offset, x264_significant_coeff_flag_offset_8x8, x264_total_zeros,
    x264_total_zeros_2x2_dc, x264_total_zeros_2x4_dc, x264_trellis_lambda2_tab, x264_zero,
};
pub use self::thread_shared_types_h::{
    __pthread_cond_s, __pthread_internal_list, __pthread_list_t,
};
use self::threadpool_h::{x264_10_threadpool_run, x264_10_threadpool_wait, x264_threadpool_t};
pub use self::types_h::{
    __int16_t, __int32_t, __int64_t, __int8_t, __uint16_t, __uint32_t, __uint64_t, __uint8_t,
};
pub use self::util_h::{x264_union128_sse_t, M128_ZERO};
pub use self::x264_h::{
    x264_b_pyramid_names, x264_hrd_t, x264_nal_t, x264_param_t, x264_sei_payload_t, x264_sei_t,
    x264_zone_t, C2RustUnnamed_0, C2RustUnnamed_1, C2RustUnnamed_2, C2RustUnnamed_3,
    C2RustUnnamed_4, C2RustUnnamed_5, X264_ANALYSE_BSUB16x16, X264_ANALYSE_I4x4, X264_ANALYSE_I8x8,
    X264_ANALYSE_PSUB16x16, X264_ANALYSE_PSUB8x8, X264_B_ADAPT_FAST, X264_B_ADAPT_TRELLIS,
    X264_B_PYRAMID_NORMAL, X264_LOG_DEBUG, X264_LOG_ERROR, X264_LOG_WARNING, X264_MBINFO_CONSTANT,
    X264_ME_DIA, X264_ME_ESA, X264_RC_CQP, X264_TYPE_AUTO, X264_TYPE_B, X264_TYPE_BREF,
    X264_TYPE_I, X264_TYPE_IDR, X264_TYPE_KEYFRAME, X264_TYPE_P, X264_WEIGHTP_SIMPLE,
};
#[derive(Copy, Clone)]
#[repr(C)]
#[c2rust::src_loc = "56:9"]
pub struct x264_mb_analysis_t {
    pub i_lambda: ::core::ffi::c_int,
    pub i_lambda2: ::core::ffi::c_int,
    pub i_qp: ::core::ffi::c_int,
    pub p_cost_mv: *mut uint16_t,
    pub p_cost_ref: [*mut uint16_t; 2],
    pub i_mbrd: ::core::ffi::c_int,
    pub b_fast_intra: ::core::ffi::c_int,
    pub b_force_intra: ::core::ffi::c_int,
    pub b_avoid_topright: ::core::ffi::c_int,
    pub b_try_skip: ::core::ffi::c_int,
    pub i_satd_i16x16: ::core::ffi::c_int,
    pub i_satd_i16x16_dir: [::core::ffi::c_int; 7],
    pub i_predict16x16: ::core::ffi::c_int,
    pub i_satd_i8x8: ::core::ffi::c_int,
    pub i_cbp_i8x8_luma: ::core::ffi::c_int,
    pub i_satd_i8x8_dir: [[uint16_t; 16]; 4],
    pub i_predict8x8: [::core::ffi::c_int; 4],
    pub i_satd_i4x4: ::core::ffi::c_int,
    pub i_predict4x4: [::core::ffi::c_int; 16],
    pub i_satd_pcm: ::core::ffi::c_int,
    pub i_satd_chroma: ::core::ffi::c_int,
    pub i_satd_chroma_dir: [::core::ffi::c_int; 7],
    pub i_predict8x8chroma: ::core::ffi::c_int,
    pub l0: x264_mb_analysis_list_t,
    pub l1: x264_mb_analysis_list_t,
    pub i_cost16x16bi: ::core::ffi::c_int,
    pub i_cost16x16direct: ::core::ffi::c_int,
    pub i_cost8x8bi: ::core::ffi::c_int,
    pub i_cost8x8direct: [::core::ffi::c_int; 4],
    pub i_satd8x8: [[::core::ffi::c_int; 4]; 3],
    pub i_cost_est16x8: [::core::ffi::c_int; 2],
    pub i_cost_est8x16: [::core::ffi::c_int; 2],
    pub i_cost16x8bi: ::core::ffi::c_int,
    pub i_cost8x16bi: ::core::ffi::c_int,
    pub i_rd16x16bi: ::core::ffi::c_int,
    pub i_rd16x16direct: ::core::ffi::c_int,
    pub i_rd16x8bi: ::core::ffi::c_int,
    pub i_rd8x16bi: ::core::ffi::c_int,
    pub i_rd8x8bi: ::core::ffi::c_int,
    pub i_mb_partition16x8: [::core::ffi::c_int; 2],
    pub i_mb_partition8x16: [::core::ffi::c_int; 2],
    pub i_mb_type16x8: ::core::ffi::c_int,
    pub i_mb_type8x16: ::core::ffi::c_int,
    pub b_direct_available: ::core::ffi::c_int,
    pub b_early_terminate: ::core::ffi::c_int,
}
#[derive(Copy, Clone)]
#[repr(C)]
#[c2rust::src_loc = "35:9"]
pub struct x264_mb_analysis_list_t {
    pub me16x16: x264_me_t,
    pub bi16x16: x264_me_t,
    pub me8x8: [x264_me_t; 4],
    pub me4x4: [[x264_me_t; 4]; 4],
    pub me8x4: [[x264_me_t; 2]; 4],
    pub me4x8: [[x264_me_t; 2]; 4],
    pub me16x8: [x264_me_t; 2],
    pub me8x16: [x264_me_t; 2],
    pub i_rd16x16: ::core::ffi::c_int,
    pub i_cost8x8: ::core::ffi::c_int,
    pub i_cost4x4: [::core::ffi::c_int; 4],
    pub i_cost8x4: [::core::ffi::c_int; 4],
    pub i_cost4x8: [::core::ffi::c_int; 4],
    pub i_cost16x8: ::core::ffi::c_int,
    pub i_cost8x16: ::core::ffi::c_int,
    pub mvc: [[[int16_t; 2]; 6]; 32],
}
#[c2rust::src_loc = "124:22"]
static mut i_mb_b_cost_table: [uint8_t; 19] = [
    9 as ::core::ffi::c_int as uint8_t,
    9 as ::core::ffi::c_int as uint8_t,
    9 as ::core::ffi::c_int as uint8_t,
    9 as ::core::ffi::c_int as uint8_t,
    0 as ::core::ffi::c_int as uint8_t,
    0 as ::core::ffi::c_int as uint8_t,
    0 as ::core::ffi::c_int as uint8_t,
    1 as ::core::ffi::c_int as uint8_t,
    3 as ::core::ffi::c_int as uint8_t,
    7 as ::core::ffi::c_int as uint8_t,
    7 as ::core::ffi::c_int as uint8_t,
    7 as ::core::ffi::c_int as uint8_t,
    3 as ::core::ffi::c_int as uint8_t,
    7 as ::core::ffi::c_int as uint8_t,
    7 as ::core::ffi::c_int as uint8_t,
    7 as ::core::ffi::c_int as uint8_t,
    5 as ::core::ffi::c_int as uint8_t,
    9 as ::core::ffi::c_int as uint8_t,
    0 as ::core::ffi::c_int as uint8_t,
];
#[c2rust::src_loc = "128:22"]
static mut i_mb_b16x8_cost_table: [uint8_t; 17] = [
    0 as ::core::ffi::c_int as uint8_t,
    0 as ::core::ffi::c_int as uint8_t,
    0 as ::core::ffi::c_int as uint8_t,
    0 as ::core::ffi::c_int as uint8_t,
    0 as ::core::ffi::c_int as uint8_t,
    0 as ::core::ffi::c_int as uint8_t,
    0 as ::core::ffi::c_int as uint8_t,
    0 as ::core::ffi::c_int as uint8_t,
    5 as ::core::ffi::c_int as uint8_t,
    7 as ::core::ffi::c_int as uint8_t,
    7 as ::core::ffi::c_int as uint8_t,
    7 as ::core::ffi::c_int as uint8_t,
    5 as ::core::ffi::c_int as uint8_t,
    7 as ::core::ffi::c_int as uint8_t,
    9 as ::core::ffi::c_int as uint8_t,
    9 as ::core::ffi::c_int as uint8_t,
    9 as ::core::ffi::c_int as uint8_t,
];
#[c2rust::src_loc = "132:22"]
static mut i_sub_mb_b_cost_table: [uint8_t; 13] = [
    7 as ::core::ffi::c_int as uint8_t,
    5 as ::core::ffi::c_int as uint8_t,
    5 as ::core::ffi::c_int as uint8_t,
    3 as ::core::ffi::c_int as uint8_t,
    7 as ::core::ffi::c_int as uint8_t,
    5 as ::core::ffi::c_int as uint8_t,
    7 as ::core::ffi::c_int as uint8_t,
    3 as ::core::ffi::c_int as uint8_t,
    7 as ::core::ffi::c_int as uint8_t,
    7 as ::core::ffi::c_int as uint8_t,
    7 as ::core::ffi::c_int as uint8_t,
    5 as ::core::ffi::c_int as uint8_t,
    1 as ::core::ffi::c_int as uint8_t,
];
#[c2rust::src_loc = "136:22"]
static mut i_sub_mb_p_cost_table: [uint8_t; 4] = [
    5 as ::core::ffi::c_int as uint8_t,
    3 as ::core::ffi::c_int as uint8_t,
    3 as ::core::ffi::c_int as uint8_t,
    1 as ::core::ffi::c_int as uint8_t,
];
#[c2rust::src_loc = "143:1"]
unsafe extern "C" fn init_costs(
    mut h: *mut x264_t,
    mut logs: *mut ::core::ffi::c_float,
    mut qp: ::core::ffi::c_int,
) -> ::core::ffi::c_int {
    let mut cost_i4x4_mode: *mut uint16_t = 0 as *mut uint16_t;
    let mut current_block: u64;
    if !(*h).cost_mv[qp as usize].is_null() {
        return 0 as ::core::ffi::c_int;
    }
    let mut mv_range: ::core::ffi::c_int = (*h).param.analyse.i_mv_range << (*h).param.b_interlaced;
    let mut lambda: ::core::ffi::c_int = x264_lambda_tab[qp as usize] as ::core::ffi::c_int;
    (*h).cost_mv[qp as usize] = x264_malloc(
        ((4 as ::core::ffi::c_int * 4 as ::core::ffi::c_int * mv_range + 1 as ::core::ffi::c_int)
            as usize)
            .wrapping_mul(::core::mem::size_of::<uint16_t>() as usize) as int64_t,
    ) as *mut uint16_t;
    if !(*h).cost_mv[qp as usize].is_null() {
        (*h).cost_mv[qp as usize] = (*h).cost_mv[qp as usize]
            .offset((2 as ::core::ffi::c_int * 4 as ::core::ffi::c_int * mv_range) as isize);
        let mut i: ::core::ffi::c_int = 0 as ::core::ffi::c_int;
        while i <= 2 as ::core::ffi::c_int * 4 as ::core::ffi::c_int * mv_range {
            let ref mut fresh2 = *(*h).cost_mv[qp as usize].offset(i as isize);
            *fresh2 = (if ((lambda as ::core::ffi::c_float * *logs.offset(i as isize) + 0.5f32)
                as ::core::ffi::c_int)
                < 65535 as ::core::ffi::c_int
            {
                (lambda as ::core::ffi::c_float * *logs.offset(i as isize) + 0.5f32)
                    as ::core::ffi::c_int
            } else {
                65535 as ::core::ffi::c_int
            }) as uint16_t;
            *(*h).cost_mv[qp as usize].offset(-i as isize) = *fresh2;
            i += 1;
        }
        let mut i_0: ::core::ffi::c_int = 0 as ::core::ffi::c_int;
        while i_0 < 3 as ::core::ffi::c_int {
            let mut j: ::core::ffi::c_int = 0 as ::core::ffi::c_int;
            while j < 33 as ::core::ffi::c_int {
                (*(*h).cost_table).ref_0[qp as usize][i_0 as usize][j as usize] = (if i_0 != 0 {
                    if lambda * bs_size_te(i_0, j) < 65535 as ::core::ffi::c_int {
                        lambda * bs_size_te(i_0, j)
                    } else {
                        65535 as ::core::ffi::c_int
                    }
                } else {
                    0 as ::core::ffi::c_int
                })
                    as uint16_t;
                j += 1;
            }
            i_0 += 1;
        }
        if (*h).param.analyse.i_me_method >= X264_ME_ESA
            && (*h).cost_mv_fpel[qp as usize][0 as ::core::ffi::c_int as usize].is_null()
        {
            let mut j_0: ::core::ffi::c_int = 0 as ::core::ffi::c_int;
            loop {
                if !(j_0 < 4 as ::core::ffi::c_int) {
                    current_block = 11194104282611034094;
                    break;
                }
                (*h).cost_mv_fpel[qp as usize][j_0 as usize] = x264_malloc(
                    ((4 as ::core::ffi::c_int * mv_range + 1 as ::core::ffi::c_int) as usize)
                        .wrapping_mul(::core::mem::size_of::<uint16_t>() as usize)
                        as int64_t,
                ) as *mut uint16_t;
                if (*h).cost_mv_fpel[qp as usize][j_0 as usize].is_null() {
                    current_block = 7965308608183717162;
                    break;
                }
                (*h).cost_mv_fpel[qp as usize][j_0 as usize] = (*h).cost_mv_fpel[qp as usize]
                    [j_0 as usize]
                    .offset((2 as ::core::ffi::c_int * mv_range) as isize);
                let mut i_1: ::core::ffi::c_int = -(2 as ::core::ffi::c_int) * mv_range;
                while i_1 < 2 as ::core::ffi::c_int * mv_range {
                    *(*h).cost_mv_fpel[qp as usize][j_0 as usize].offset(i_1 as isize) = *(*h)
                        .cost_mv[qp as usize]
                        .offset((i_1 * 4 as ::core::ffi::c_int + j_0) as isize);
                    i_1 += 1;
                }
                j_0 += 1;
            }
        } else {
            current_block = 11194104282611034094;
        }
        match current_block {
            7965308608183717162 => {}
            _ => {
                cost_i4x4_mode = (*(*(*h).cost_table)
                    .i4x4_mode
                    .as_mut_ptr()
                    .offset(qp as isize))
                .as_mut_ptr();
                let mut i_2: ::core::ffi::c_int = 0 as ::core::ffi::c_int;
                while i_2 < 17 as ::core::ffi::c_int {
                    *cost_i4x4_mode.offset(i_2 as isize) = (3 as ::core::ffi::c_int
                        * lambda
                        * (i_2 != 8 as ::core::ffi::c_int) as ::core::ffi::c_int)
                        as uint16_t;
                    i_2 += 1;
                }
                return 0 as ::core::ffi::c_int;
            }
        }
    }
    return -(1 as ::core::ffi::c_int);
}
#[no_mangle]
#[c2rust::src_loc = "179:1"]
pub unsafe extern "C" fn x264_10_analyse_init_costs(mut h: *mut x264_t) -> ::core::ffi::c_int {
    let mut current_block: u64;
    let mut mv_range: ::core::ffi::c_int = (*h).param.analyse.i_mv_range << (*h).param.b_interlaced;
    let mut logs: *mut ::core::ffi::c_float = x264_malloc(
        ((2 as ::core::ffi::c_int * 4 as ::core::ffi::c_int * mv_range + 1 as ::core::ffi::c_int)
            as usize)
            .wrapping_mul(::core::mem::size_of::<::core::ffi::c_float>() as usize)
            as int64_t,
    ) as *mut ::core::ffi::c_float;
    if logs.is_null() {
        return -(1 as ::core::ffi::c_int);
    }
    *logs.offset(0 as ::core::ffi::c_int as isize) = 0.718f32;
    let mut i: ::core::ffi::c_int = 1 as ::core::ffi::c_int;
    while i <= 2 as ::core::ffi::c_int * 4 as ::core::ffi::c_int * mv_range {
        *logs.offset(i as isize) =
            log2f((i + 1 as ::core::ffi::c_int) as ::core::ffi::c_float) * 2.0f32 + 1.718f32;
        i += 1;
    }
    let mut qp: ::core::ffi::c_int = if (*h).param.rc.i_qp_min
        < 51 as ::core::ffi::c_int
            + 6 as ::core::ffi::c_int * (10 as ::core::ffi::c_int - 8 as ::core::ffi::c_int)
    {
        (*h).param.rc.i_qp_min
    } else {
        51 as ::core::ffi::c_int
            + 6 as ::core::ffi::c_int * (10 as ::core::ffi::c_int - 8 as ::core::ffi::c_int)
    };
    loop {
        if !(qp <= (*h).param.rc.i_qp_max) {
            current_block = 10886091980245723256;
            break;
        }
        if init_costs(h, logs, qp) != 0 {
            current_block = 15663036285462993308;
            break;
        }
        qp += 1;
    }
    match current_block {
        10886091980245723256 => {
            if !(init_costs(h, logs, X264_LOOKAHEAD_QP) != 0) {
                x264_free(logs as *mut ::core::ffi::c_void);
                return 0 as ::core::ffi::c_int;
            }
        }
        _ => {}
    }
    x264_free(logs as *mut ::core::ffi::c_void);
    return -(1 as ::core::ffi::c_int);
}
#[no_mangle]
#[c2rust::src_loc = "204:1"]
pub unsafe extern "C" fn x264_10_analyse_free_costs(mut h: *mut x264_t) {
    let mut mv_range: ::core::ffi::c_int = (*h).param.analyse.i_mv_range << (*h).param.b_interlaced;
    let mut i: ::core::ffi::c_int = 0 as ::core::ffi::c_int;
    while i < QP_MAX + 1 as ::core::ffi::c_int {
        if !(*h).cost_mv[i as usize].is_null() {
            x264_free(
                (*h).cost_mv[i as usize].offset(
                    -((2 as ::core::ffi::c_int * 4 as ::core::ffi::c_int * mv_range) as isize),
                ) as *mut ::core::ffi::c_void,
            );
        }
        let mut j: ::core::ffi::c_int = 0 as ::core::ffi::c_int;
        while j < 4 as ::core::ffi::c_int {
            if !(*h).cost_mv_fpel[i as usize][j as usize].is_null() {
                x264_free(
                    (*h).cost_mv_fpel[i as usize][j as usize]
                        .offset(-((2 as ::core::ffi::c_int * mv_range) as isize))
                        as *mut ::core::ffi::c_void,
                );
            }
            j += 1;
        }
        i += 1;
    }
}
#[no_mangle]
#[c2rust::src_loc = "219:1"]
pub unsafe extern "C" fn x264_10_analyse_weight_frame(
    mut h: *mut x264_t,
    mut end: ::core::ffi::c_int,
) {
    let mut j: ::core::ffi::c_int = 0 as ::core::ffi::c_int;
    while j < (*h).i_ref[0 as ::core::ffi::c_int as usize] {
        if !(*h).sh.weight[j as usize][0 as ::core::ffi::c_int as usize]
            .weightfn
            .is_null()
        {
            let mut frame: *mut x264_frame_t =
                (*h).fref[0 as ::core::ffi::c_int as usize][j as usize];
            let mut width: ::core::ffi::c_int = (*frame).i_width[0 as ::core::ffi::c_int as usize]
                + ((if 32 as ::core::ffi::c_int
                    > 64 as ::core::ffi::c_int
                        / ::core::mem::size_of::<pixel>() as ::core::ffi::c_int
                {
                    32 as ::core::ffi::c_int
                } else {
                    64 as ::core::ffi::c_int / ::core::mem::size_of::<pixel>() as ::core::ffi::c_int
                }) + PADH);
            let mut i_padv: ::core::ffi::c_int = PADV << (*h).param.b_interlaced;
            let mut offset: ::core::ffi::c_int = 0;
            let mut height: ::core::ffi::c_int = 0;
            let mut src: *mut pixel = (*frame).filtered[0 as ::core::ffi::c_int as usize]
                [0 as ::core::ffi::c_int as usize]
                .offset(-(((*frame).i_stride[0 as ::core::ffi::c_int as usize] * i_padv) as isize))
                .offset(
                    -((if 32 as ::core::ffi::c_int
                        > 64 as ::core::ffi::c_int
                            / ::core::mem::size_of::<pixel>() as ::core::ffi::c_int
                    {
                        32 as ::core::ffi::c_int
                    } else {
                        64 as ::core::ffi::c_int
                            / ::core::mem::size_of::<pixel>() as ::core::ffi::c_int
                    }) as isize),
                );
            height = (if 16 as ::core::ffi::c_int + end + i_padv
                < (*(*h).fref[0 as ::core::ffi::c_int as usize][j as usize]).i_lines
                    [0 as ::core::ffi::c_int as usize]
                    + i_padv * 2 as ::core::ffi::c_int
            {
                16 as ::core::ffi::c_int + end + i_padv
            } else {
                (*(*h).fref[0 as ::core::ffi::c_int as usize][j as usize]).i_lines
                    [0 as ::core::ffi::c_int as usize]
                    + i_padv * 2 as ::core::ffi::c_int
            }) - (*(*h).fenc).i_lines_weighted;
            offset =
                (*(*h).fenc).i_lines_weighted * (*frame).i_stride[0 as ::core::ffi::c_int as usize];
            (*(*h).fenc).i_lines_weighted += height;
            if height != 0 {
                let mut k: ::core::ffi::c_int = j;
                while k < (*h).i_ref[0 as ::core::ffi::c_int as usize] {
                    if !(*h).sh.weight[k as usize][0 as ::core::ffi::c_int as usize]
                        .weightfn
                        .is_null()
                    {
                        let mut dst: *mut pixel = (*(*h).fenc).weighted[k as usize]
                            .offset(
                                -(((*(*h).fenc).i_stride[0 as ::core::ffi::c_int as usize] * i_padv)
                                    as isize),
                            )
                            .offset(
                                -((if 32 as ::core::ffi::c_int
                                    > 64 as ::core::ffi::c_int
                                        / ::core::mem::size_of::<pixel>() as ::core::ffi::c_int
                                {
                                    32 as ::core::ffi::c_int
                                } else {
                                    64 as ::core::ffi::c_int
                                        / ::core::mem::size_of::<pixel>() as ::core::ffi::c_int
                                }) as isize),
                            );
                        x264_10_weight_scale_plane(
                            h,
                            dst.offset(offset as isize),
                            (*frame).i_stride[0 as ::core::ffi::c_int as usize] as intptr_t,
                            src.offset(offset as isize),
                            (*frame).i_stride[0 as ::core::ffi::c_int as usize] as intptr_t,
                            width,
                            height,
                            &mut *(*(*h).sh.weight.as_mut_ptr().offset(k as isize))
                                .as_mut_ptr()
                                .offset(0 as ::core::ffi::c_int as isize),
                        );
                    }
                    k += 1;
                }
            }
            break;
        } else {
            j += 1;
        }
    }
}
#[c2rust::src_loc = "248:1"]
unsafe extern "C" fn mb_analyse_load_costs(mut h: *mut x264_t, mut a: *mut x264_mb_analysis_t) {
    (*a).p_cost_mv = (*h).cost_mv[(*a).i_qp as usize];
    (*a).p_cost_ref[0 as ::core::ffi::c_int as usize] = (*(*(*(*h).cost_table)
        .ref_0
        .as_mut_ptr()
        .offset((*a).i_qp as isize))
    .as_mut_ptr()
    .offset((x264_clip3
        as unsafe extern "C" fn(
            ::core::ffi::c_int,
            ::core::ffi::c_int,
            ::core::ffi::c_int,
        ) -> ::core::ffi::c_int)(
        (*h).sh.i_num_ref_idx_l0_active - 1 as ::core::ffi::c_int,
        0 as ::core::ffi::c_int,
        2 as ::core::ffi::c_int,
    ) as isize))
    .as_mut_ptr();
    (*a).p_cost_ref[1 as ::core::ffi::c_int as usize] = (*(*(*(*h).cost_table)
        .ref_0
        .as_mut_ptr()
        .offset((*a).i_qp as isize))
    .as_mut_ptr()
    .offset((x264_clip3
        as unsafe extern "C" fn(
            ::core::ffi::c_int,
            ::core::ffi::c_int,
            ::core::ffi::c_int,
        ) -> ::core::ffi::c_int)(
        (*h).sh.i_num_ref_idx_l1_active - 1 as ::core::ffi::c_int,
        0 as ::core::ffi::c_int,
        2 as ::core::ffi::c_int,
    ) as isize))
    .as_mut_ptr();
}
#[c2rust::src_loc = "255:1"]
unsafe extern "C" fn mb_analyse_init_qp(
    mut h: *mut x264_t,
    mut a: *mut x264_mb_analysis_t,
    mut qp: ::core::ffi::c_int,
) {
    let mut effective_chroma_qp: ::core::ffi::c_int = *(*h).chroma_qp_table.offset(
        (if qp
            < 51 as ::core::ffi::c_int
                + 6 as ::core::ffi::c_int * (10 as ::core::ffi::c_int - 8 as ::core::ffi::c_int)
        {
            qp
        } else {
            51 as ::core::ffi::c_int
                + 6 as ::core::ffi::c_int * (10 as ::core::ffi::c_int - 8 as ::core::ffi::c_int)
        }) as isize,
    ) as ::core::ffi::c_int
        + (if qp
            - (51 as ::core::ffi::c_int
                + 6 as ::core::ffi::c_int * (10 as ::core::ffi::c_int - 8 as ::core::ffi::c_int))
            > 0 as ::core::ffi::c_int
        {
            qp - (51 as ::core::ffi::c_int
                + 6 as ::core::ffi::c_int * (10 as ::core::ffi::c_int - 8 as ::core::ffi::c_int))
        } else {
            0 as ::core::ffi::c_int
        });
    (*a).i_lambda = x264_lambda_tab[qp as usize] as ::core::ffi::c_int;
    (*a).i_lambda2 = x264_lambda2_tab[qp as usize];
    (*h).mb.b_trellis = ((*h).param.analyse.i_trellis > 1 as ::core::ffi::c_int && (*a).i_mbrd != 0)
        as ::core::ffi::c_int;
    if (*h).param.analyse.i_trellis != 0 {
        (*h).mb.i_trellis_lambda2[0 as ::core::ffi::c_int as usize]
            [0 as ::core::ffi::c_int as usize] =
            x264_trellis_lambda2_tab[0 as ::core::ffi::c_int as usize][qp as usize];
        (*h).mb.i_trellis_lambda2[0 as ::core::ffi::c_int as usize]
            [1 as ::core::ffi::c_int as usize] =
            x264_trellis_lambda2_tab[1 as ::core::ffi::c_int as usize][qp as usize];
        (*h).mb.i_trellis_lambda2[1 as ::core::ffi::c_int as usize]
            [0 as ::core::ffi::c_int as usize] = x264_trellis_lambda2_tab
            [0 as ::core::ffi::c_int as usize][effective_chroma_qp as usize];
        (*h).mb.i_trellis_lambda2[1 as ::core::ffi::c_int as usize]
            [1 as ::core::ffi::c_int as usize] = x264_trellis_lambda2_tab
            [1 as ::core::ffi::c_int as usize][effective_chroma_qp as usize];
    }
    (*h).mb.i_psy_rd_lambda = (*a).i_lambda;
    let mut chroma_offset_idx: ::core::ffi::c_int =
        if (qp - effective_chroma_qp + 12 as ::core::ffi::c_int) < 36 as ::core::ffi::c_int {
            qp - effective_chroma_qp + 12 as ::core::ffi::c_int
        } else {
            36 as ::core::ffi::c_int
        };
    (*h).mb.i_chroma_lambda2_offset = if (*h).param.analyse.b_psy != 0 {
        x264_chroma_lambda2_offset_tab[chroma_offset_idx as usize] as ::core::ffi::c_int
    } else {
        256 as ::core::ffi::c_int
    };
    if qp > QP_MAX_SPEC {
        (*h).nr_offset = (*(*h)
            .nr_offset_emergency
            .offset((qp - QP_MAX_SPEC - 1 as ::core::ffi::c_int) as isize))
        .as_mut_ptr() as *mut [udctcoef; 64];
        (*h).nr_residual_sum = (*(*h)
            .nr_residual_sum_buf
            .as_mut_ptr()
            .offset(1 as ::core::ffi::c_int as isize))
        .as_mut_ptr() as *mut [uint32_t; 64];
        (*h).nr_count = (*(*h)
            .nr_count_buf
            .as_mut_ptr()
            .offset(1 as ::core::ffi::c_int as isize))
        .as_mut_ptr();
        (*h).mb.b_noise_reduction = 1 as ::core::ffi::c_int;
        qp = QP_MAX_SPEC;
    } else {
        (*h).nr_offset = (*h).nr_offset_denoise.as_mut_ptr() as *mut [udctcoef; 64];
        (*h).nr_residual_sum = (*(*h)
            .nr_residual_sum_buf
            .as_mut_ptr()
            .offset(0 as ::core::ffi::c_int as isize))
        .as_mut_ptr() as *mut [uint32_t; 64];
        (*h).nr_count = (*(*h)
            .nr_count_buf
            .as_mut_ptr()
            .offset(0 as ::core::ffi::c_int as isize))
        .as_mut_ptr();
        (*h).mb.b_noise_reduction = 0 as ::core::ffi::c_int;
    }
    (*h).mb.i_qp = qp;
    (*a).i_qp = (*h).mb.i_qp;
    (*h).mb.i_chroma_qp = *(*h).chroma_qp_table.offset(qp as isize) as ::core::ffi::c_int;
}
#[c2rust::src_loc = "294:1"]
unsafe extern "C" fn mb_analyse_init(
    mut h: *mut x264_t,
    mut a: *mut x264_mb_analysis_t,
    mut qp: ::core::ffi::c_int,
) {
    let mut subme: ::core::ffi::c_int = (*h).param.analyse.i_subpel_refine
        - ((*h).sh.i_type == SLICE_TYPE_B as ::core::ffi::c_int) as ::core::ffi::c_int;
    (*a).i_mbrd = (subme >= 6 as ::core::ffi::c_int) as ::core::ffi::c_int
        + (subme >= 8 as ::core::ffi::c_int) as ::core::ffi::c_int
        + ((*h).param.analyse.i_subpel_refine >= 10 as ::core::ffi::c_int) as ::core::ffi::c_int;
    (*h).mb.b_deblock_rdo = ((*h).param.analyse.i_subpel_refine >= 9 as ::core::ffi::c_int
        && (*h).sh.i_disable_deblocking_filter_idc != 1 as ::core::ffi::c_int)
        as ::core::ffi::c_int;
    (*a).b_early_terminate =
        ((*h).param.analyse.i_subpel_refine < 11 as ::core::ffi::c_int) as ::core::ffi::c_int;
    mb_analyse_init_qp(h, a, qp);
    (*h).mb.b_transform_8x8 = 0 as ::core::ffi::c_int;
    (*a).i_satd_i4x4 = COST_MAX;
    (*a).i_satd_i8x8 = (*a).i_satd_i4x4;
    (*a).i_satd_i16x16 = (*a).i_satd_i8x8;
    (*a).i_satd_chroma = if (*(*h).sps.as_mut_ptr()).i_chroma_format_idc != 0 {
        COST_MAX
    } else {
        0 as ::core::ffi::c_int
    };
    let mut pcm_cost: uint64_t = ((256 as ::core::ffi::c_int * 10 as ::core::ffi::c_int
        + 2 as ::core::ffi::c_int
            * (if (*(*h).sps.as_mut_ptr()).i_chroma_format_idc != 0 {
                256 as ::core::ffi::c_int * 10 as ::core::ffi::c_int
                    >> (*h).mb.chroma_h_shift + (*h).mb.chroma_v_shift
            } else {
                0 as ::core::ffi::c_int
            })
        + 16 as ::core::ffi::c_int) as uint64_t)
        .wrapping_mul((*a).i_lambda2 as uint64_t)
        .wrapping_add(128 as uint64_t)
        >> 8 as ::core::ffi::c_int;
    (*a).i_satd_pcm = (if (*h).param.i_avcintra_class == 0
        && (*h).mb.i_psy_rd == 0
        && (*a).i_mbrd != 0
        && pcm_cost < COST_MAX as uint64_t
    {
        pcm_cost
    } else {
        COST_MAX as uint64_t
    }) as ::core::ffi::c_int;
    (*a).b_fast_intra = 0 as ::core::ffi::c_int;
    (*a).b_avoid_topright = 0 as ::core::ffi::c_int;
    (*h).mb.i_skip_intra = if (*h).mb.b_lossless != 0 {
        0 as ::core::ffi::c_int
    } else if (*a).i_mbrd != 0 {
        2 as ::core::ffi::c_int
    } else {
        ((*h).param.analyse.i_trellis == 0 && (*h).param.analyse.i_noise_reduction == 0)
            as ::core::ffi::c_int
    };
    if (*h).sh.i_type != SLICE_TYPE_I as ::core::ffi::c_int {
        let mut i_fmv_range: ::core::ffi::c_int =
            4 as ::core::ffi::c_int * (*h).param.analyse.i_mv_range;
        let mut i_fpel_border: ::core::ffi::c_int = 6 as ::core::ffi::c_int;
        (*h).mb.mv_min[0 as ::core::ffi::c_int as usize] = 4 as ::core::ffi::c_int
            * (-(16 as ::core::ffi::c_int) * (*h).mb.i_mb_x - 24 as ::core::ffi::c_int);
        (*h).mb.mv_max[0 as ::core::ffi::c_int as usize] = 4 as ::core::ffi::c_int
            * (16 as ::core::ffi::c_int
                * ((*h).mb.i_mb_width - (*h).mb.i_mb_x - 1 as ::core::ffi::c_int)
                + 24 as ::core::ffi::c_int);
        (*h).mb.mv_min_spel[0 as ::core::ffi::c_int as usize] =
            if (*h).mb.mv_min[0 as ::core::ffi::c_int as usize] > -i_fmv_range {
                (*h).mb.mv_min[0 as ::core::ffi::c_int as usize]
            } else {
                -i_fmv_range
            };
        (*h).mb.mv_max_spel[0 as ::core::ffi::c_int as usize] = if (*h).mb.mv_max
            [0 as ::core::ffi::c_int as usize]
            < i_fmv_range - 1 as ::core::ffi::c_int
        {
            (*h).mb.mv_max[0 as ::core::ffi::c_int as usize]
        } else {
            i_fmv_range - 1 as ::core::ffi::c_int
        };
        if (*h).param.b_intra_refresh != 0 && (*h).sh.i_type == SLICE_TYPE_P as ::core::ffi::c_int {
            let mut max_x: ::core::ffi::c_int = ((*(*h).fref[0 as ::core::ffi::c_int as usize]
                [0 as ::core::ffi::c_int as usize])
                .i_pir_end_col
                * 16 as ::core::ffi::c_int
                - 3 as ::core::ffi::c_int)
                * 4 as ::core::ffi::c_int;
            let mut max_mv: ::core::ffi::c_int =
                max_x - 4 as ::core::ffi::c_int * 16 as ::core::ffi::c_int * (*h).mb.i_mb_x;
            if max_mv > 0 as ::core::ffi::c_int && (*h).mb.i_mb_x < (*(*h).fdec).i_pir_start_col {
                (*h).mb.mv_max_spel[0 as ::core::ffi::c_int as usize] =
                    if (*h).mb.mv_max_spel[0 as ::core::ffi::c_int as usize] < max_mv {
                        (*h).mb.mv_max_spel[0 as ::core::ffi::c_int as usize]
                    } else {
                        max_mv
                    };
            }
        }
        (*h).mb.mv_limit_fpel[0 as ::core::ffi::c_int as usize][0 as ::core::ffi::c_int as usize] =
            (((*h).mb.mv_min_spel[0 as ::core::ffi::c_int as usize] >> 2 as ::core::ffi::c_int)
                + i_fpel_border) as int16_t;
        (*h).mb.mv_limit_fpel[1 as ::core::ffi::c_int as usize][0 as ::core::ffi::c_int as usize] =
            (((*h).mb.mv_max_spel[0 as ::core::ffi::c_int as usize] >> 2 as ::core::ffi::c_int)
                - i_fpel_border) as int16_t;
        if (*h).mb.i_mb_x == 0 as ::core::ffi::c_int
            && (*h).mb.i_mb_y & (*h).param.b_interlaced == 0
        {
            let mut mb_y: ::core::ffi::c_int = (*h).mb.i_mb_y >> (*h).sh.b_mbaff;
            let mut thread_mvy_range: ::core::ffi::c_int = i_fmv_range;
            if (*h).i_thread_frames > 1 as ::core::ffi::c_int {
                let mut pix_y: ::core::ffi::c_int =
                    ((*h).mb.i_mb_y | (*h).param.b_interlaced) * 16 as ::core::ffi::c_int;
                let mut thresh: ::core::ffi::c_int = pix_y + (*h).param.analyse.i_mv_range_thread;
                let mut i: ::core::ffi::c_int =
                    ((*h).sh.i_type == SLICE_TYPE_B as ::core::ffi::c_int) as ::core::ffi::c_int;
                while i >= 0 as ::core::ffi::c_int {
                    let mut j: ::core::ffi::c_int = 0 as ::core::ffi::c_int;
                    while j < (*h).i_ref[i as usize] {
                        let mut completed: ::core::ffi::c_int = x264_10_frame_cond_wait(
                            (*(*h).fref[i as usize][j as usize]).orig as *mut x264_frame_t,
                            thresh,
                        );
                        thread_mvy_range = if thread_mvy_range < completed - pix_y {
                            thread_mvy_range
                        } else {
                            completed - pix_y
                        };
                        j += 1;
                    }
                    i -= 1;
                }
                if (*h).param.b_deterministic != 0 {
                    thread_mvy_range = (*h).param.analyse.i_mv_range_thread;
                }
                if (*h).param.b_interlaced != 0 {
                    thread_mvy_range >>= 1 as ::core::ffi::c_int;
                }
                x264_10_analyse_weight_frame(h, pix_y + thread_mvy_range);
            }
            if (*h).param.b_interlaced != 0 {
                let mut i_0: ::core::ffi::c_int = 0 as ::core::ffi::c_int;
                while i_0 < 3 as ::core::ffi::c_int {
                    let mut j_0: ::core::ffi::c_int =
                        (i_0 == 2 as ::core::ffi::c_int) as ::core::ffi::c_int;
                    mb_y = ((*h).mb.i_mb_y >> j_0)
                        + (i_0 == 1 as ::core::ffi::c_int) as ::core::ffi::c_int;
                    (*h).mb.mv_miny_row[i_0 as usize] = 4 as ::core::ffi::c_int
                        * (-(16 as ::core::ffi::c_int) * mb_y - 24 as ::core::ffi::c_int);
                    (*h).mb.mv_maxy_row[i_0 as usize] = 4 as ::core::ffi::c_int
                        * (16 as ::core::ffi::c_int
                            * (((*h).mb.i_mb_height >> j_0) - mb_y - 1 as ::core::ffi::c_int)
                            + 24 as ::core::ffi::c_int);
                    (*h).mb.mv_miny_spel_row[i_0 as usize] =
                        if (*h).mb.mv_miny_row[i_0 as usize] > -i_fmv_range {
                            (*h).mb.mv_miny_row[i_0 as usize]
                        } else {
                            -i_fmv_range
                        };
                    (*h).mb.mv_maxy_spel_row[i_0 as usize] = if (*h).mb.mv_maxy_row[i_0 as usize]
                        < (if (i_fmv_range - 1 as ::core::ffi::c_int)
                            < 4 as ::core::ffi::c_int * thread_mvy_range
                        {
                            i_fmv_range - 1 as ::core::ffi::c_int
                        } else {
                            4 as ::core::ffi::c_int * thread_mvy_range
                        }) {
                        (*h).mb.mv_maxy_row[i_0 as usize]
                    } else if (i_fmv_range - 1 as ::core::ffi::c_int)
                        < 4 as ::core::ffi::c_int * thread_mvy_range
                    {
                        i_fmv_range - 1 as ::core::ffi::c_int
                    } else {
                        4 as ::core::ffi::c_int * thread_mvy_range
                    };
                    (*h).mb.mv_miny_fpel_row[i_0 as usize] =
                        ((*h).mb.mv_miny_spel_row[i_0 as usize] >> 2 as ::core::ffi::c_int)
                            + i_fpel_border;
                    (*h).mb.mv_maxy_fpel_row[i_0 as usize] =
                        ((*h).mb.mv_maxy_spel_row[i_0 as usize] >> 2 as ::core::ffi::c_int)
                            - i_fpel_border;
                    i_0 += 1;
                }
            } else {
                (*h).mb.mv_min[1 as ::core::ffi::c_int as usize] = 4 as ::core::ffi::c_int
                    * (-(16 as ::core::ffi::c_int) * mb_y - 24 as ::core::ffi::c_int);
                (*h).mb.mv_max[1 as ::core::ffi::c_int as usize] = 4 as ::core::ffi::c_int
                    * (16 as ::core::ffi::c_int
                        * ((*h).mb.i_mb_height - mb_y - 1 as ::core::ffi::c_int)
                        + 24 as ::core::ffi::c_int);
                (*h).mb.mv_min_spel[1 as ::core::ffi::c_int as usize] =
                    if (*h).mb.mv_min[1 as ::core::ffi::c_int as usize] > -i_fmv_range {
                        (*h).mb.mv_min[1 as ::core::ffi::c_int as usize]
                    } else {
                        -i_fmv_range
                    };
                (*h).mb.mv_max_spel[1 as ::core::ffi::c_int as usize] = if (*h).mb.mv_max
                    [1 as ::core::ffi::c_int as usize]
                    < (if (i_fmv_range - 1 as ::core::ffi::c_int)
                        < 4 as ::core::ffi::c_int * thread_mvy_range
                    {
                        i_fmv_range - 1 as ::core::ffi::c_int
                    } else {
                        4 as ::core::ffi::c_int * thread_mvy_range
                    }) {
                    (*h).mb.mv_max[1 as ::core::ffi::c_int as usize]
                } else if (i_fmv_range - 1 as ::core::ffi::c_int)
                    < 4 as ::core::ffi::c_int * thread_mvy_range
                {
                    i_fmv_range - 1 as ::core::ffi::c_int
                } else {
                    4 as ::core::ffi::c_int * thread_mvy_range
                };
                (*h).mb.mv_limit_fpel[0 as ::core::ffi::c_int as usize]
                    [1 as ::core::ffi::c_int as usize] =
                    (((*h).mb.mv_min_spel[1 as ::core::ffi::c_int as usize]
                        >> 2 as ::core::ffi::c_int)
                        + i_fpel_border) as int16_t;
                (*h).mb.mv_limit_fpel[1 as ::core::ffi::c_int as usize]
                    [1 as ::core::ffi::c_int as usize] =
                    (((*h).mb.mv_max_spel[1 as ::core::ffi::c_int as usize]
                        >> 2 as ::core::ffi::c_int)
                        - i_fpel_border) as int16_t;
            }
        }
        if (*h).param.b_interlaced != 0 {
            let mut i_1: ::core::ffi::c_int = if (*h).mb.b_interlaced != 0 {
                2 as ::core::ffi::c_int
            } else {
                (*h).mb.i_mb_y & 1 as ::core::ffi::c_int
            };
            (*h).mb.mv_min[1 as ::core::ffi::c_int as usize] = (*h).mb.mv_miny_row[i_1 as usize];
            (*h).mb.mv_max[1 as ::core::ffi::c_int as usize] = (*h).mb.mv_maxy_row[i_1 as usize];
            (*h).mb.mv_min_spel[1 as ::core::ffi::c_int as usize] =
                (*h).mb.mv_miny_spel_row[i_1 as usize];
            (*h).mb.mv_max_spel[1 as ::core::ffi::c_int as usize] =
                (*h).mb.mv_maxy_spel_row[i_1 as usize];
            (*h).mb.mv_limit_fpel[0 as ::core::ffi::c_int as usize]
                [1 as ::core::ffi::c_int as usize] =
                (*h).mb.mv_miny_fpel_row[i_1 as usize] as int16_t;
            (*h).mb.mv_limit_fpel[1 as ::core::ffi::c_int as usize]
                [1 as ::core::ffi::c_int as usize] =
                (*h).mb.mv_maxy_fpel_row[i_1 as usize] as int16_t;
        }
        (*a).l0.i_cost8x16 = COST_MAX;
        (*a).l0.i_cost16x8 = (*a).l0.i_cost8x16;
        (*a).l0.i_cost8x8 = (*a).l0.i_cost16x8;
        (*a).l0.i_rd16x16 = (*a).l0.i_cost8x8;
        (*a).l0.me16x16.cost = (*a).l0.i_rd16x16;
        if (*h).sh.i_type == SLICE_TYPE_B as ::core::ffi::c_int {
            (*a).i_cost8x16bi = COST_MAX;
            (*a).i_cost16x8bi = (*a).i_cost8x16bi;
            (*a).i_cost8x8bi = (*a).i_cost16x8bi;
            (*a).i_cost16x16direct = (*a).i_cost8x8bi;
            (*a).i_cost16x16bi = (*a).i_cost16x16direct;
            (*a).i_rd8x16bi = (*a).i_cost16x16bi;
            (*a).i_rd16x8bi = (*a).i_rd8x16bi;
            (*a).i_rd8x8bi = (*a).i_rd16x8bi;
            (*a).i_rd16x16direct = (*a).i_rd8x8bi;
            (*a).i_rd16x16bi = (*a).i_rd16x16direct;
            (*a).l1.i_cost8x16 = (*a).i_rd16x16bi;
            (*a).l1.i_cost16x8 = (*a).l1.i_cost8x16;
            (*a).i_cost8x8direct[3 as ::core::ffi::c_int as usize] = (*a).l1.i_cost16x8;
            (*a).i_cost8x8direct[2 as ::core::ffi::c_int as usize] =
                (*a).i_cost8x8direct[3 as ::core::ffi::c_int as usize];
            (*a).i_cost8x8direct[1 as ::core::ffi::c_int as usize] =
                (*a).i_cost8x8direct[2 as ::core::ffi::c_int as usize];
            (*a).i_cost8x8direct[0 as ::core::ffi::c_int as usize] =
                (*a).i_cost8x8direct[1 as ::core::ffi::c_int as usize];
            (*a).l1.i_cost8x8 = (*a).i_cost8x8direct[0 as ::core::ffi::c_int as usize];
            (*a).l1.i_rd16x16 = (*a).l1.i_cost8x8;
            (*a).l1.me16x16.cost = (*a).l1.i_rd16x16;
        } else if (*h).param.analyse.inter & X264_ANALYSE_PSUB8x8 != 0 {
            let mut i_2: ::core::ffi::c_int = 0 as ::core::ffi::c_int;
            while i_2 < 4 as ::core::ffi::c_int {
                (*a).l0.i_cost4x8[i_2 as usize] = COST_MAX;
                (*a).l0.i_cost8x4[i_2 as usize] = (*a).l0.i_cost4x8[i_2 as usize];
                (*a).l0.i_cost4x4[i_2 as usize] = (*a).l0.i_cost8x4[i_2 as usize];
                i_2 += 1;
            }
        }
        if (*a).b_early_terminate != 0
            && (*h).mb.i_mb_xy - (*h).sh.i_first_mb > 4 as ::core::ffi::c_int
        {
            if !((*h).mb.i_mb_type_left[0 as ::core::ffi::c_int as usize]
                == I_4x4 as ::core::ffi::c_int
                || (*h).mb.i_mb_type_left[0 as ::core::ffi::c_int as usize]
                    == I_8x8 as ::core::ffi::c_int
                || (*h).mb.i_mb_type_left[0 as ::core::ffi::c_int as usize]
                    == I_16x16 as ::core::ffi::c_int
                || (*h).mb.i_mb_type_left[0 as ::core::ffi::c_int as usize]
                    == I_PCM as ::core::ffi::c_int
                || ((*h).mb.i_mb_type_top == I_4x4 as ::core::ffi::c_int
                    || (*h).mb.i_mb_type_top == I_8x8 as ::core::ffi::c_int
                    || (*h).mb.i_mb_type_top == I_16x16 as ::core::ffi::c_int
                    || (*h).mb.i_mb_type_top == I_PCM as ::core::ffi::c_int)
                || ((*h).mb.i_mb_type_topleft == I_4x4 as ::core::ffi::c_int
                    || (*h).mb.i_mb_type_topleft == I_8x8 as ::core::ffi::c_int
                    || (*h).mb.i_mb_type_topleft == I_16x16 as ::core::ffi::c_int
                    || (*h).mb.i_mb_type_topleft == I_PCM as ::core::ffi::c_int)
                || ((*h).mb.i_mb_type_topright == I_4x4 as ::core::ffi::c_int
                    || (*h).mb.i_mb_type_topright == I_8x8 as ::core::ffi::c_int
                    || (*h).mb.i_mb_type_topright == I_16x16 as ::core::ffi::c_int
                    || (*h).mb.i_mb_type_topright == I_PCM as ::core::ffi::c_int)
                || (*h).sh.i_type == SLICE_TYPE_P as ::core::ffi::c_int
                    && (*(*(*h).fref[0 as ::core::ffi::c_int as usize]
                        [0 as ::core::ffi::c_int as usize])
                        .mb_type
                        .offset((*h).mb.i_mb_xy as isize)
                        as ::core::ffi::c_int
                        == I_4x4 as ::core::ffi::c_int
                        || *(*(*h).fref[0 as ::core::ffi::c_int as usize]
                            [0 as ::core::ffi::c_int as usize])
                            .mb_type
                            .offset((*h).mb.i_mb_xy as isize)
                            as ::core::ffi::c_int
                            == I_8x8 as ::core::ffi::c_int
                        || *(*(*h).fref[0 as ::core::ffi::c_int as usize]
                            [0 as ::core::ffi::c_int as usize])
                            .mb_type
                            .offset((*h).mb.i_mb_xy as isize)
                            as ::core::ffi::c_int
                            == I_16x16 as ::core::ffi::c_int
                        || *(*(*h).fref[0 as ::core::ffi::c_int as usize]
                            [0 as ::core::ffi::c_int as usize])
                            .mb_type
                            .offset((*h).mb.i_mb_xy as isize)
                            as ::core::ffi::c_int
                            == I_PCM as ::core::ffi::c_int)
                || (*h).mb.i_mb_xy - (*h).sh.i_first_mb
                    < 3 as ::core::ffi::c_int
                        * ((*h).stat.frame.i_mb_count[I_4x4 as ::core::ffi::c_int as usize]
                            + (*h).stat.frame.i_mb_count[I_8x8 as ::core::ffi::c_int as usize]
                            + (*h).stat.frame.i_mb_count[I_16x16 as ::core::ffi::c_int as usize]
                            + (*h).stat.frame.i_mb_count[I_PCM as ::core::ffi::c_int as usize]))
            {
                (*a).b_fast_intra = 1 as ::core::ffi::c_int;
            }
        }
        (*h).mb.b_skip_mc = 0 as ::core::ffi::c_int;
        if (*h).param.b_intra_refresh != 0
            && (*h).sh.i_type == SLICE_TYPE_P as ::core::ffi::c_int
            && (*h).mb.i_mb_x >= (*(*h).fdec).i_pir_start_col
            && (*h).mb.i_mb_x <= (*(*h).fdec).i_pir_end_col
        {
            (*a).b_force_intra = 1 as ::core::ffi::c_int;
            (*a).b_fast_intra = 0 as ::core::ffi::c_int;
            (*a).b_avoid_topright =
                ((*h).mb.i_mb_x == (*(*h).fdec).i_pir_end_col) as ::core::ffi::c_int;
        } else {
            (*a).b_force_intra = 0 as ::core::ffi::c_int;
        }
    }
}
#[c2rust::src_loc = "476:21"]
static mut i16x16_mode_available: [[int8_t; 5]; 5] = [
    [
        I_PRED_16x16_DC_128 as ::core::ffi::c_int as int8_t,
        -(1 as ::core::ffi::c_int) as int8_t,
        -(1 as ::core::ffi::c_int) as int8_t,
        -(1 as ::core::ffi::c_int) as int8_t,
        -(1 as ::core::ffi::c_int) as int8_t,
    ],
    [
        I_PRED_16x16_DC_LEFT as ::core::ffi::c_int as int8_t,
        I_PRED_16x16_H as ::core::ffi::c_int as int8_t,
        -(1 as ::core::ffi::c_int) as int8_t,
        -(1 as ::core::ffi::c_int) as int8_t,
        -(1 as ::core::ffi::c_int) as int8_t,
    ],
    [
        I_PRED_16x16_DC_TOP as ::core::ffi::c_int as int8_t,
        I_PRED_16x16_V as ::core::ffi::c_int as int8_t,
        -(1 as ::core::ffi::c_int) as int8_t,
        -(1 as ::core::ffi::c_int) as int8_t,
        -(1 as ::core::ffi::c_int) as int8_t,
    ],
    [
        I_PRED_16x16_V as ::core::ffi::c_int as int8_t,
        I_PRED_16x16_H as ::core::ffi::c_int as int8_t,
        I_PRED_16x16_DC as ::core::ffi::c_int as int8_t,
        -(1 as ::core::ffi::c_int) as int8_t,
        -(1 as ::core::ffi::c_int) as int8_t,
    ],
    [
        I_PRED_16x16_V as ::core::ffi::c_int as int8_t,
        I_PRED_16x16_H as ::core::ffi::c_int as int8_t,
        I_PRED_16x16_DC as ::core::ffi::c_int as int8_t,
        I_PRED_16x16_P as ::core::ffi::c_int as int8_t,
        -(1 as ::core::ffi::c_int) as int8_t,
    ],
];
#[c2rust::src_loc = "485:21"]
static mut chroma_mode_available: [[int8_t; 5]; 5] = [
    [
        I_PRED_CHROMA_DC_128 as ::core::ffi::c_int as int8_t,
        -(1 as ::core::ffi::c_int) as int8_t,
        -(1 as ::core::ffi::c_int) as int8_t,
        -(1 as ::core::ffi::c_int) as int8_t,
        -(1 as ::core::ffi::c_int) as int8_t,
    ],
    [
        I_PRED_CHROMA_DC_LEFT as ::core::ffi::c_int as int8_t,
        I_PRED_CHROMA_H as ::core::ffi::c_int as int8_t,
        -(1 as ::core::ffi::c_int) as int8_t,
        -(1 as ::core::ffi::c_int) as int8_t,
        -(1 as ::core::ffi::c_int) as int8_t,
    ],
    [
        I_PRED_CHROMA_DC_TOP as ::core::ffi::c_int as int8_t,
        I_PRED_CHROMA_V as ::core::ffi::c_int as int8_t,
        -(1 as ::core::ffi::c_int) as int8_t,
        -(1 as ::core::ffi::c_int) as int8_t,
        -(1 as ::core::ffi::c_int) as int8_t,
    ],
    [
        I_PRED_CHROMA_V as ::core::ffi::c_int as int8_t,
        I_PRED_CHROMA_H as ::core::ffi::c_int as int8_t,
        I_PRED_CHROMA_DC as ::core::ffi::c_int as int8_t,
        -(1 as ::core::ffi::c_int) as int8_t,
        -(1 as ::core::ffi::c_int) as int8_t,
    ],
    [
        I_PRED_CHROMA_V as ::core::ffi::c_int as int8_t,
        I_PRED_CHROMA_H as ::core::ffi::c_int as int8_t,
        I_PRED_CHROMA_DC as ::core::ffi::c_int as int8_t,
        I_PRED_CHROMA_P as ::core::ffi::c_int as int8_t,
        -(1 as ::core::ffi::c_int) as int8_t,
    ],
];
#[c2rust::src_loc = "494:21"]
static mut i8x8_mode_available: [[[int8_t; 10]; 5]; 2] = [
    [
        [
            I_PRED_4x4_DC_128 as ::core::ffi::c_int as int8_t,
            -(1 as ::core::ffi::c_int) as int8_t,
            -(1 as ::core::ffi::c_int) as int8_t,
            -(1 as ::core::ffi::c_int) as int8_t,
            -(1 as ::core::ffi::c_int) as int8_t,
            -(1 as ::core::ffi::c_int) as int8_t,
            -(1 as ::core::ffi::c_int) as int8_t,
            -(1 as ::core::ffi::c_int) as int8_t,
            -(1 as ::core::ffi::c_int) as int8_t,
            -(1 as ::core::ffi::c_int) as int8_t,
        ],
        [
            I_PRED_4x4_DC_LEFT as ::core::ffi::c_int as int8_t,
            I_PRED_4x4_H as ::core::ffi::c_int as int8_t,
            I_PRED_4x4_HU as ::core::ffi::c_int as int8_t,
            -(1 as ::core::ffi::c_int) as int8_t,
            -(1 as ::core::ffi::c_int) as int8_t,
            -(1 as ::core::ffi::c_int) as int8_t,
            -(1 as ::core::ffi::c_int) as int8_t,
            -(1 as ::core::ffi::c_int) as int8_t,
            -(1 as ::core::ffi::c_int) as int8_t,
            -(1 as ::core::ffi::c_int) as int8_t,
        ],
        [
            I_PRED_4x4_DC_TOP as ::core::ffi::c_int as int8_t,
            I_PRED_4x4_V as ::core::ffi::c_int as int8_t,
            I_PRED_4x4_DDL as ::core::ffi::c_int as int8_t,
            I_PRED_4x4_VL as ::core::ffi::c_int as int8_t,
            -(1 as ::core::ffi::c_int) as int8_t,
            -(1 as ::core::ffi::c_int) as int8_t,
            -(1 as ::core::ffi::c_int) as int8_t,
            -(1 as ::core::ffi::c_int) as int8_t,
            -(1 as ::core::ffi::c_int) as int8_t,
            -(1 as ::core::ffi::c_int) as int8_t,
        ],
        [
            I_PRED_4x4_DC as ::core::ffi::c_int as int8_t,
            I_PRED_4x4_H as ::core::ffi::c_int as int8_t,
            I_PRED_4x4_V as ::core::ffi::c_int as int8_t,
            I_PRED_4x4_DDL as ::core::ffi::c_int as int8_t,
            I_PRED_4x4_VL as ::core::ffi::c_int as int8_t,
            I_PRED_4x4_HU as ::core::ffi::c_int as int8_t,
            -(1 as ::core::ffi::c_int) as int8_t,
            -(1 as ::core::ffi::c_int) as int8_t,
            -(1 as ::core::ffi::c_int) as int8_t,
            -(1 as ::core::ffi::c_int) as int8_t,
        ],
        [
            I_PRED_4x4_DC as ::core::ffi::c_int as int8_t,
            I_PRED_4x4_H as ::core::ffi::c_int as int8_t,
            I_PRED_4x4_V as ::core::ffi::c_int as int8_t,
            I_PRED_4x4_DDL as ::core::ffi::c_int as int8_t,
            I_PRED_4x4_DDR as ::core::ffi::c_int as int8_t,
            I_PRED_4x4_VR as ::core::ffi::c_int as int8_t,
            I_PRED_4x4_HD as ::core::ffi::c_int as int8_t,
            I_PRED_4x4_VL as ::core::ffi::c_int as int8_t,
            I_PRED_4x4_HU as ::core::ffi::c_int as int8_t,
            -(1 as ::core::ffi::c_int) as int8_t,
        ],
    ],
    [
        [
            I_PRED_4x4_DC_128 as ::core::ffi::c_int as int8_t,
            -(1 as ::core::ffi::c_int) as int8_t,
            -(1 as ::core::ffi::c_int) as int8_t,
            -(1 as ::core::ffi::c_int) as int8_t,
            -(1 as ::core::ffi::c_int) as int8_t,
            -(1 as ::core::ffi::c_int) as int8_t,
            -(1 as ::core::ffi::c_int) as int8_t,
            -(1 as ::core::ffi::c_int) as int8_t,
            -(1 as ::core::ffi::c_int) as int8_t,
            -(1 as ::core::ffi::c_int) as int8_t,
        ],
        [
            I_PRED_4x4_DC_LEFT as ::core::ffi::c_int as int8_t,
            I_PRED_4x4_H as ::core::ffi::c_int as int8_t,
            I_PRED_4x4_HU as ::core::ffi::c_int as int8_t,
            -(1 as ::core::ffi::c_int) as int8_t,
            -(1 as ::core::ffi::c_int) as int8_t,
            -(1 as ::core::ffi::c_int) as int8_t,
            -(1 as ::core::ffi::c_int) as int8_t,
            -(1 as ::core::ffi::c_int) as int8_t,
            -(1 as ::core::ffi::c_int) as int8_t,
            -(1 as ::core::ffi::c_int) as int8_t,
        ],
        [
            -(1 as ::core::ffi::c_int) as int8_t,
            -(1 as ::core::ffi::c_int) as int8_t,
            -(1 as ::core::ffi::c_int) as int8_t,
            -(1 as ::core::ffi::c_int) as int8_t,
            -(1 as ::core::ffi::c_int) as int8_t,
            -(1 as ::core::ffi::c_int) as int8_t,
            -(1 as ::core::ffi::c_int) as int8_t,
            -(1 as ::core::ffi::c_int) as int8_t,
            -(1 as ::core::ffi::c_int) as int8_t,
            -(1 as ::core::ffi::c_int) as int8_t,
        ],
        [
            I_PRED_4x4_H as ::core::ffi::c_int as int8_t,
            I_PRED_4x4_HU as ::core::ffi::c_int as int8_t,
            -(1 as ::core::ffi::c_int) as int8_t,
            -(1 as ::core::ffi::c_int) as int8_t,
            -(1 as ::core::ffi::c_int) as int8_t,
            -(1 as ::core::ffi::c_int) as int8_t,
            -(1 as ::core::ffi::c_int) as int8_t,
            -(1 as ::core::ffi::c_int) as int8_t,
            -(1 as ::core::ffi::c_int) as int8_t,
            -(1 as ::core::ffi::c_int) as int8_t,
        ],
        [
            I_PRED_4x4_H as ::core::ffi::c_int as int8_t,
            I_PRED_4x4_HD as ::core::ffi::c_int as int8_t,
            I_PRED_4x4_HU as ::core::ffi::c_int as int8_t,
            -(1 as ::core::ffi::c_int) as int8_t,
            -(1 as ::core::ffi::c_int) as int8_t,
            -(1 as ::core::ffi::c_int) as int8_t,
            -(1 as ::core::ffi::c_int) as int8_t,
            -(1 as ::core::ffi::c_int) as int8_t,
            -(1 as ::core::ffi::c_int) as int8_t,
            -(1 as ::core::ffi::c_int) as int8_t,
        ],
    ],
];
#[c2rust::src_loc = "512:21"]
static mut i4x4_mode_available: [[[int8_t; 10]; 5]; 2] = [
    [
        [
            I_PRED_4x4_DC_128 as ::core::ffi::c_int as int8_t,
            -(1 as ::core::ffi::c_int) as int8_t,
            -(1 as ::core::ffi::c_int) as int8_t,
            -(1 as ::core::ffi::c_int) as int8_t,
            -(1 as ::core::ffi::c_int) as int8_t,
            -(1 as ::core::ffi::c_int) as int8_t,
            -(1 as ::core::ffi::c_int) as int8_t,
            -(1 as ::core::ffi::c_int) as int8_t,
            -(1 as ::core::ffi::c_int) as int8_t,
            -(1 as ::core::ffi::c_int) as int8_t,
        ],
        [
            I_PRED_4x4_DC_LEFT as ::core::ffi::c_int as int8_t,
            I_PRED_4x4_H as ::core::ffi::c_int as int8_t,
            I_PRED_4x4_HU as ::core::ffi::c_int as int8_t,
            -(1 as ::core::ffi::c_int) as int8_t,
            -(1 as ::core::ffi::c_int) as int8_t,
            -(1 as ::core::ffi::c_int) as int8_t,
            -(1 as ::core::ffi::c_int) as int8_t,
            -(1 as ::core::ffi::c_int) as int8_t,
            -(1 as ::core::ffi::c_int) as int8_t,
            -(1 as ::core::ffi::c_int) as int8_t,
        ],
        [
            I_PRED_4x4_DC_TOP as ::core::ffi::c_int as int8_t,
            I_PRED_4x4_V as ::core::ffi::c_int as int8_t,
            I_PRED_4x4_DDL as ::core::ffi::c_int as int8_t,
            I_PRED_4x4_VL as ::core::ffi::c_int as int8_t,
            -(1 as ::core::ffi::c_int) as int8_t,
            -(1 as ::core::ffi::c_int) as int8_t,
            -(1 as ::core::ffi::c_int) as int8_t,
            -(1 as ::core::ffi::c_int) as int8_t,
            -(1 as ::core::ffi::c_int) as int8_t,
            -(1 as ::core::ffi::c_int) as int8_t,
        ],
        [
            I_PRED_4x4_DC as ::core::ffi::c_int as int8_t,
            I_PRED_4x4_H as ::core::ffi::c_int as int8_t,
            I_PRED_4x4_V as ::core::ffi::c_int as int8_t,
            I_PRED_4x4_DDL as ::core::ffi::c_int as int8_t,
            I_PRED_4x4_VL as ::core::ffi::c_int as int8_t,
            I_PRED_4x4_HU as ::core::ffi::c_int as int8_t,
            -(1 as ::core::ffi::c_int) as int8_t,
            -(1 as ::core::ffi::c_int) as int8_t,
            -(1 as ::core::ffi::c_int) as int8_t,
            -(1 as ::core::ffi::c_int) as int8_t,
        ],
        [
            I_PRED_4x4_DC as ::core::ffi::c_int as int8_t,
            I_PRED_4x4_H as ::core::ffi::c_int as int8_t,
            I_PRED_4x4_V as ::core::ffi::c_int as int8_t,
            I_PRED_4x4_DDL as ::core::ffi::c_int as int8_t,
            I_PRED_4x4_DDR as ::core::ffi::c_int as int8_t,
            I_PRED_4x4_VR as ::core::ffi::c_int as int8_t,
            I_PRED_4x4_HD as ::core::ffi::c_int as int8_t,
            I_PRED_4x4_VL as ::core::ffi::c_int as int8_t,
            I_PRED_4x4_HU as ::core::ffi::c_int as int8_t,
            -(1 as ::core::ffi::c_int) as int8_t,
        ],
    ],
    [
        [
            I_PRED_4x4_DC_128 as ::core::ffi::c_int as int8_t,
            -(1 as ::core::ffi::c_int) as int8_t,
            -(1 as ::core::ffi::c_int) as int8_t,
            -(1 as ::core::ffi::c_int) as int8_t,
            -(1 as ::core::ffi::c_int) as int8_t,
            -(1 as ::core::ffi::c_int) as int8_t,
            -(1 as ::core::ffi::c_int) as int8_t,
            -(1 as ::core::ffi::c_int) as int8_t,
            -(1 as ::core::ffi::c_int) as int8_t,
            -(1 as ::core::ffi::c_int) as int8_t,
        ],
        [
            I_PRED_4x4_DC_LEFT as ::core::ffi::c_int as int8_t,
            I_PRED_4x4_H as ::core::ffi::c_int as int8_t,
            I_PRED_4x4_HU as ::core::ffi::c_int as int8_t,
            -(1 as ::core::ffi::c_int) as int8_t,
            -(1 as ::core::ffi::c_int) as int8_t,
            -(1 as ::core::ffi::c_int) as int8_t,
            -(1 as ::core::ffi::c_int) as int8_t,
            -(1 as ::core::ffi::c_int) as int8_t,
            -(1 as ::core::ffi::c_int) as int8_t,
            -(1 as ::core::ffi::c_int) as int8_t,
        ],
        [
            I_PRED_4x4_DC_TOP as ::core::ffi::c_int as int8_t,
            I_PRED_4x4_V as ::core::ffi::c_int as int8_t,
            -(1 as ::core::ffi::c_int) as int8_t,
            -(1 as ::core::ffi::c_int) as int8_t,
            -(1 as ::core::ffi::c_int) as int8_t,
            -(1 as ::core::ffi::c_int) as int8_t,
            -(1 as ::core::ffi::c_int) as int8_t,
            -(1 as ::core::ffi::c_int) as int8_t,
            -(1 as ::core::ffi::c_int) as int8_t,
            -(1 as ::core::ffi::c_int) as int8_t,
        ],
        [
            I_PRED_4x4_DC as ::core::ffi::c_int as int8_t,
            I_PRED_4x4_H as ::core::ffi::c_int as int8_t,
            I_PRED_4x4_V as ::core::ffi::c_int as int8_t,
            I_PRED_4x4_HU as ::core::ffi::c_int as int8_t,
            -(1 as ::core::ffi::c_int) as int8_t,
            -(1 as ::core::ffi::c_int) as int8_t,
            -(1 as ::core::ffi::c_int) as int8_t,
            -(1 as ::core::ffi::c_int) as int8_t,
            -(1 as ::core::ffi::c_int) as int8_t,
            -(1 as ::core::ffi::c_int) as int8_t,
        ],
        [
            I_PRED_4x4_DC as ::core::ffi::c_int as int8_t,
            I_PRED_4x4_H as ::core::ffi::c_int as int8_t,
            I_PRED_4x4_V as ::core::ffi::c_int as int8_t,
            I_PRED_4x4_DDR as ::core::ffi::c_int as int8_t,
            I_PRED_4x4_VR as ::core::ffi::c_int as int8_t,
            I_PRED_4x4_HD as ::core::ffi::c_int as int8_t,
            I_PRED_4x4_HU as ::core::ffi::c_int as int8_t,
            -(1 as ::core::ffi::c_int) as int8_t,
            -(1 as ::core::ffi::c_int) as int8_t,
            -(1 as ::core::ffi::c_int) as int8_t,
        ],
    ],
];
#[inline(always)]
#[c2rust::src_loc = "530:1"]
unsafe extern "C" fn predict_16x16_mode_available(
    mut i_neighbour: ::core::ffi::c_int,
) -> *const int8_t {
    let mut idx: ::core::ffi::c_int = i_neighbour
        & (MB_TOP as ::core::ffi::c_int
            | MB_LEFT as ::core::ffi::c_int
            | MB_TOPLEFT as ::core::ffi::c_int);
    idx = if idx
        == MB_TOP as ::core::ffi::c_int
            | MB_LEFT as ::core::ffi::c_int
            | MB_TOPLEFT as ::core::ffi::c_int
    {
        4 as ::core::ffi::c_int
    } else {
        idx & (MB_TOP as ::core::ffi::c_int | MB_LEFT as ::core::ffi::c_int)
    };
    return (*i16x16_mode_available.as_ptr().offset(idx as isize)).as_ptr();
}
#[inline(always)]
#[c2rust::src_loc = "537:1"]
unsafe extern "C" fn predict_chroma_mode_available(
    mut i_neighbour: ::core::ffi::c_int,
) -> *const int8_t {
    let mut idx: ::core::ffi::c_int = i_neighbour
        & (MB_TOP as ::core::ffi::c_int
            | MB_LEFT as ::core::ffi::c_int
            | MB_TOPLEFT as ::core::ffi::c_int);
    idx = if idx
        == MB_TOP as ::core::ffi::c_int
            | MB_LEFT as ::core::ffi::c_int
            | MB_TOPLEFT as ::core::ffi::c_int
    {
        4 as ::core::ffi::c_int
    } else {
        idx & (MB_TOP as ::core::ffi::c_int | MB_LEFT as ::core::ffi::c_int)
    };
    return (*chroma_mode_available.as_ptr().offset(idx as isize)).as_ptr();
}
#[inline(always)]
#[c2rust::src_loc = "544:1"]
unsafe extern "C" fn predict_8x8_mode_available(
    mut force_intra: ::core::ffi::c_int,
    mut i_neighbour: ::core::ffi::c_int,
    mut i: ::core::ffi::c_int,
) -> *const int8_t {
    let mut avoid_topright: ::core::ffi::c_int =
        (force_intra != 0 && i & 1 as ::core::ffi::c_int != 0) as ::core::ffi::c_int;
    let mut idx: ::core::ffi::c_int = i_neighbour
        & (MB_TOP as ::core::ffi::c_int
            | MB_LEFT as ::core::ffi::c_int
            | MB_TOPLEFT as ::core::ffi::c_int);
    idx = if idx
        == MB_TOP as ::core::ffi::c_int
            | MB_LEFT as ::core::ffi::c_int
            | MB_TOPLEFT as ::core::ffi::c_int
    {
        4 as ::core::ffi::c_int
    } else {
        idx & (MB_TOP as ::core::ffi::c_int | MB_LEFT as ::core::ffi::c_int)
    };
    return (*(*i8x8_mode_available.as_ptr().offset(avoid_topright as isize))
        .as_ptr()
        .offset(idx as isize))
    .as_ptr();
}
#[inline(always)]
#[c2rust::src_loc = "552:1"]
unsafe extern "C" fn predict_4x4_mode_available(
    mut force_intra: ::core::ffi::c_int,
    mut i_neighbour: ::core::ffi::c_int,
    mut i: ::core::ffi::c_int,
) -> *const int8_t {
    let mut avoid_topright: ::core::ffi::c_int = (force_intra != 0
        && i & 5 as ::core::ffi::c_int == 5 as ::core::ffi::c_int)
        as ::core::ffi::c_int;
    let mut idx: ::core::ffi::c_int = i_neighbour
        & (MB_TOP as ::core::ffi::c_int
            | MB_LEFT as ::core::ffi::c_int
            | MB_TOPLEFT as ::core::ffi::c_int);
    idx = if idx
        == MB_TOP as ::core::ffi::c_int
            | MB_LEFT as ::core::ffi::c_int
            | MB_TOPLEFT as ::core::ffi::c_int
    {
        4 as ::core::ffi::c_int
    } else {
        idx & (MB_TOP as ::core::ffi::c_int | MB_LEFT as ::core::ffi::c_int)
    };
    return (*(*i4x4_mode_available.as_ptr().offset(avoid_topright as isize))
        .as_ptr()
        .offset(idx as isize))
    .as_ptr();
}
#[inline]
#[c2rust::src_loc = "561:1"]
unsafe extern "C" fn psy_trellis_init(mut h: *mut x264_t, mut do_both_dct: ::core::ffi::c_int) {
    if do_both_dct != 0 || (*h).mb.b_transform_8x8 != 0 {
        (*h).dctf.sub16x16_dct8.expect("non-null function pointer")(
            (*h).mb.pic.fenc_dct8.as_mut_ptr(),
            (*h).mb.pic.p_fenc[0 as ::core::ffi::c_int as usize],
            x264_zero.as_mut_ptr() as *mut pixel,
        );
    }
    if do_both_dct != 0 || (*h).mb.b_transform_8x8 == 0 {
        (*h).dctf.sub16x16_dct.expect("non-null function pointer")(
            (*h).mb.pic.fenc_dct4.as_mut_ptr(),
            (*h).mb.pic.p_fenc[0 as ::core::ffi::c_int as usize],
            x264_zero.as_mut_ptr() as *mut pixel,
        );
    }
}
#[inline]
#[c2rust::src_loc = "570:1"]
unsafe extern "C" fn mb_init_fenc_cache(mut h: *mut x264_t, mut b_satd: ::core::ffi::c_int) {
    if (*h).param.analyse.i_trellis == 2 as ::core::ffi::c_int && (*h).mb.i_psy_trellis != 0 {
        psy_trellis_init(h, (*h).param.analyse.b_transform_8x8);
    }
    if (*h).mb.i_psy_rd == 0 {
        return;
    }
    (*(&mut *(*h)
        .mb
        .pic
        .fenc_hadamard_cache
        .as_mut_ptr()
        .offset(0 as ::core::ffi::c_int as isize) as *mut uint64_t
        as *mut x264_union128_sse_t))
        .i = M128_ZERO;
    (*(&mut *(*h)
        .mb
        .pic
        .fenc_hadamard_cache
        .as_mut_ptr()
        .offset(2 as ::core::ffi::c_int as isize) as *mut uint64_t
        as *mut x264_union128_sse_t))
        .i = M128_ZERO;
    (*(&mut *(*h)
        .mb
        .pic
        .fenc_hadamard_cache
        .as_mut_ptr()
        .offset(4 as ::core::ffi::c_int as isize) as *mut uint64_t
        as *mut x264_union128_sse_t))
        .i = M128_ZERO;
    (*(&mut *(*h)
        .mb
        .pic
        .fenc_hadamard_cache
        .as_mut_ptr()
        .offset(6 as ::core::ffi::c_int as isize) as *mut uint64_t
        as *mut x264_union128_sse_t))
        .i = M128_ZERO;
    (*h).mb.pic.fenc_hadamard_cache[8 as ::core::ffi::c_int as usize] = 0 as uint64_t;
    if b_satd != 0 {
        (*h).mc.memzero_aligned.expect("non-null function pointer")(
            (*h).mb.pic.fenc_satd_cache.as_mut_ptr() as *mut ::core::ffi::c_void,
            ::core::mem::size_of::<[uint32_t; 32]>() as size_t,
        );
    }
}
#[c2rust::src_loc = "586:1"]
unsafe extern "C" fn mb_analyse_intra_chroma(mut h: *mut x264_t, mut a: *mut x264_mb_analysis_t) {
    if (*a).i_satd_chroma < COST_MAX {
        return;
    }
    if (*(*h).sps.as_mut_ptr()).i_chroma_format_idc == CHROMA_444 as ::core::ffi::c_int {
        if (*h).mb.b_chroma_me == 0 {
            (*a).i_satd_chroma = 0 as ::core::ffi::c_int;
            return;
        }
        if (*h).mb.b_lossless != 0 {
            x264_10_predict_lossless_16x16(h, 1 as ::core::ffi::c_int, (*a).i_predict16x16);
            x264_10_predict_lossless_16x16(h, 2 as ::core::ffi::c_int, (*a).i_predict16x16);
        } else {
            (*h).predict_16x16[(*a).i_predict16x16 as usize].expect("non-null function pointer")(
                (*h).mb.pic.p_fdec[1 as ::core::ffi::c_int as usize],
            );
            (*h).predict_16x16[(*a).i_predict16x16 as usize].expect("non-null function pointer")(
                (*h).mb.pic.p_fdec[2 as ::core::ffi::c_int as usize],
            );
        }
        (*a).i_satd_chroma = (*h).pixf.mbcmp[PIXEL_16x16 as ::core::ffi::c_int as usize]
            .expect("non-null function pointer")(
            (*h).mb.pic.p_fenc[1 as ::core::ffi::c_int as usize],
            FENC_STRIDE as intptr_t,
            (*h).mb.pic.p_fdec[1 as ::core::ffi::c_int as usize],
            FDEC_STRIDE as intptr_t,
        ) + (*h).pixf.mbcmp[PIXEL_16x16 as ::core::ffi::c_int as usize]
            .expect("non-null function pointer")(
            (*h).mb.pic.p_fenc[2 as ::core::ffi::c_int as usize],
            FENC_STRIDE as intptr_t,
            (*h).mb.pic.p_fdec[2 as ::core::ffi::c_int as usize],
            FDEC_STRIDE as intptr_t,
        );
        return;
    }
    let mut predict_mode: *const int8_t =
        predict_chroma_mode_available((*h).mb.i_neighbour_intra as ::core::ffi::c_int);
    let mut chromapix: ::core::ffi::c_int =
        (*h).luma2chroma_pixel[PIXEL_16x16 as ::core::ffi::c_int as usize] as ::core::ffi::c_int;
    if *predict_mode.offset(3 as ::core::ffi::c_int as isize) as ::core::ffi::c_int
        >= 0 as ::core::ffi::c_int
        && (*h).mb.b_lossless == 0
    {
        let mut satdu: [::core::ffi::c_int; 4] = [0; 4];
        let mut satdv: [::core::ffi::c_int; 4] = [0; 4];
        (*h).pixf
            .intra_mbcmp_x3_chroma
            .expect("non-null function pointer")(
            (*h).mb.pic.p_fenc[1 as ::core::ffi::c_int as usize],
            (*h).mb.pic.p_fdec[1 as ::core::ffi::c_int as usize],
            satdu.as_mut_ptr(),
        );
        (*h).pixf
            .intra_mbcmp_x3_chroma
            .expect("non-null function pointer")(
            (*h).mb.pic.p_fenc[2 as ::core::ffi::c_int as usize],
            (*h).mb.pic.p_fdec[2 as ::core::ffi::c_int as usize],
            satdv.as_mut_ptr(),
        );
        (*h).predict_chroma[I_PRED_CHROMA_P as ::core::ffi::c_int as usize]
            .expect("non-null function pointer")(
            (*h).mb.pic.p_fdec[1 as ::core::ffi::c_int as usize],
        );
        (*h).predict_chroma[I_PRED_CHROMA_P as ::core::ffi::c_int as usize]
            .expect("non-null function pointer")(
            (*h).mb.pic.p_fdec[2 as ::core::ffi::c_int as usize],
        );
        satdu[I_PRED_CHROMA_P as ::core::ffi::c_int as usize] = (*h).pixf.mbcmp[chromapix as usize]
            .expect("non-null function pointer")(
            (*h).mb.pic.p_fenc[1 as ::core::ffi::c_int as usize],
            FENC_STRIDE as intptr_t,
            (*h).mb.pic.p_fdec[1 as ::core::ffi::c_int as usize],
            FDEC_STRIDE as intptr_t,
        );
        satdv[I_PRED_CHROMA_P as ::core::ffi::c_int as usize] = (*h).pixf.mbcmp[chromapix as usize]
            .expect("non-null function pointer")(
            (*h).mb.pic.p_fenc[2 as ::core::ffi::c_int as usize],
            FENC_STRIDE as intptr_t,
            (*h).mb.pic.p_fdec[2 as ::core::ffi::c_int as usize],
            FDEC_STRIDE as intptr_t,
        );
        while *predict_mode as ::core::ffi::c_int >= 0 as ::core::ffi::c_int {
            let mut i_mode: ::core::ffi::c_int = *predict_mode as ::core::ffi::c_int;
            let mut i_satd: ::core::ffi::c_int = satdu[i_mode as usize]
                + satdv[i_mode as usize]
                + (*a).i_lambda * bs_size_ue(i_mode as ::core::ffi::c_uint);
            (*a).i_satd_chroma_dir[i_mode as usize] = i_satd;
            if i_satd < (*a).i_satd_chroma {
                (*a).i_satd_chroma = i_satd;
                (*a).i_predict8x8chroma = i_mode;
            }
            predict_mode = predict_mode.offset(1);
        }
    } else {
        while *predict_mode as ::core::ffi::c_int >= 0 as ::core::ffi::c_int {
            let mut i_satd_0: ::core::ffi::c_int = 0;
            let mut i_mode_0: ::core::ffi::c_int = *predict_mode as ::core::ffi::c_int;
            if (*h).mb.b_lossless != 0 {
                x264_10_predict_lossless_chroma(h, i_mode_0);
            } else {
                (*h).predict_chroma[i_mode_0 as usize].expect("non-null function pointer")(
                    (*h).mb.pic.p_fdec[1 as ::core::ffi::c_int as usize],
                );
                (*h).predict_chroma[i_mode_0 as usize].expect("non-null function pointer")(
                    (*h).mb.pic.p_fdec[2 as ::core::ffi::c_int as usize],
                );
            }
            i_satd_0 = (*h).pixf.mbcmp[chromapix as usize].expect("non-null function pointer")(
                (*h).mb.pic.p_fenc[1 as ::core::ffi::c_int as usize],
                FENC_STRIDE as intptr_t,
                (*h).mb.pic.p_fdec[1 as ::core::ffi::c_int as usize],
                FDEC_STRIDE as intptr_t,
            ) + (*h).pixf.mbcmp[chromapix as usize].expect("non-null function pointer")(
                (*h).mb.pic.p_fenc[2 as ::core::ffi::c_int as usize],
                FENC_STRIDE as intptr_t,
                (*h).mb.pic.p_fdec[2 as ::core::ffi::c_int as usize],
                FDEC_STRIDE as intptr_t,
            ) + (*a).i_lambda
                * bs_size_ue(
                    x264_mb_chroma_pred_mode_fix[i_mode_0 as usize] as ::core::ffi::c_uint,
                );
            (*a).i_satd_chroma_dir[i_mode_0 as usize] = i_satd_0;
            if i_satd_0 < (*a).i_satd_chroma {
                (*a).i_satd_chroma = i_satd_0;
                (*a).i_predict8x8chroma = i_mode_0;
            }
            predict_mode = predict_mode.offset(1);
        }
    }
    (*h).mb.i_chroma_pred_mode = (*a).i_predict8x8chroma;
}
#[c2rust::src_loc = "668:1"]
unsafe extern "C" fn mb_analyse_intra(
    mut h: *mut x264_t,
    mut a: *mut x264_mb_analysis_t,
    mut i_satd_inter: ::core::ffi::c_int,
) {
    let flags: ::core::ffi::c_uint = if (*h).sh.i_type == SLICE_TYPE_I as ::core::ffi::c_int {
        (*h).param.analyse.intra
    } else {
        (*h).param.analyse.inter
    };
    let mut p_src: *mut pixel = (*h).mb.pic.p_fenc[0 as ::core::ffi::c_int as usize];
    let mut p_dst: *mut pixel = (*h).mb.pic.p_fdec[0 as ::core::ffi::c_int as usize];
    static mut intra_analysis_shortcut: [[[[int8_t; 5]; 2]; 2]; 2] = [
        [
            [
                [
                    I_PRED_4x4_HU as ::core::ffi::c_int as int8_t,
                    -(1 as ::core::ffi::c_int) as int8_t,
                    -(1 as ::core::ffi::c_int) as int8_t,
                    -(1 as ::core::ffi::c_int) as int8_t,
                    -(1 as ::core::ffi::c_int) as int8_t,
                ],
                [
                    I_PRED_4x4_DDL as ::core::ffi::c_int as int8_t,
                    I_PRED_4x4_VL as ::core::ffi::c_int as int8_t,
                    -(1 as ::core::ffi::c_int) as int8_t,
                    -(1 as ::core::ffi::c_int) as int8_t,
                    -(1 as ::core::ffi::c_int) as int8_t,
                ],
            ],
            [
                [
                    I_PRED_4x4_DDR as ::core::ffi::c_int as int8_t,
                    I_PRED_4x4_HD as ::core::ffi::c_int as int8_t,
                    I_PRED_4x4_HU as ::core::ffi::c_int as int8_t,
                    -(1 as ::core::ffi::c_int) as int8_t,
                    -(1 as ::core::ffi::c_int) as int8_t,
                ],
                [
                    I_PRED_4x4_DDL as ::core::ffi::c_int as int8_t,
                    I_PRED_4x4_DDR as ::core::ffi::c_int as int8_t,
                    I_PRED_4x4_VR as ::core::ffi::c_int as int8_t,
                    I_PRED_4x4_VL as ::core::ffi::c_int as int8_t,
                    -(1 as ::core::ffi::c_int) as int8_t,
                ],
            ],
        ],
        [
            [
                [
                    I_PRED_4x4_HU as ::core::ffi::c_int as int8_t,
                    -(1 as ::core::ffi::c_int) as int8_t,
                    -(1 as ::core::ffi::c_int) as int8_t,
                    -(1 as ::core::ffi::c_int) as int8_t,
                    -(1 as ::core::ffi::c_int) as int8_t,
                ],
                [
                    -(1 as ::core::ffi::c_int) as int8_t,
                    -(1 as ::core::ffi::c_int) as int8_t,
                    -(1 as ::core::ffi::c_int) as int8_t,
                    -(1 as ::core::ffi::c_int) as int8_t,
                    -(1 as ::core::ffi::c_int) as int8_t,
                ],
            ],
            [
                [
                    I_PRED_4x4_DDR as ::core::ffi::c_int as int8_t,
                    I_PRED_4x4_HD as ::core::ffi::c_int as int8_t,
                    I_PRED_4x4_HU as ::core::ffi::c_int as int8_t,
                    -(1 as ::core::ffi::c_int) as int8_t,
                    -(1 as ::core::ffi::c_int) as int8_t,
                ],
                [
                    I_PRED_4x4_DDR as ::core::ffi::c_int as int8_t,
                    I_PRED_4x4_VR as ::core::ffi::c_int as int8_t,
                    -(1 as ::core::ffi::c_int) as int8_t,
                    -(1 as ::core::ffi::c_int) as int8_t,
                    -(1 as ::core::ffi::c_int) as int8_t,
                ],
            ],
        ],
    ];
    let mut idx: ::core::ffi::c_int = 0;
    let mut lambda: ::core::ffi::c_int = (*a).i_lambda;
    if (*h).param.i_avcintra_class == 0 {
        let mut predict_mode: *const int8_t =
            predict_16x16_mode_available((*h).mb.i_neighbour_intra as ::core::ffi::c_int);
        static mut i16x16_thresh_lut: [uint8_t; 11] = [
            2 as ::core::ffi::c_int as uint8_t,
            2 as ::core::ffi::c_int as uint8_t,
            2 as ::core::ffi::c_int as uint8_t,
            3 as ::core::ffi::c_int as uint8_t,
            3 as ::core::ffi::c_int as uint8_t,
            4 as ::core::ffi::c_int as uint8_t,
            4 as ::core::ffi::c_int as uint8_t,
            4 as ::core::ffi::c_int as uint8_t,
            4 as ::core::ffi::c_int as uint8_t,
            4 as ::core::ffi::c_int as uint8_t,
            4 as ::core::ffi::c_int as uint8_t,
        ];
        let mut i16x16_thresh: ::core::ffi::c_int = if (*a).b_fast_intra != 0 {
            i16x16_thresh_lut[(*h).mb.i_subpel_refine as usize] as ::core::ffi::c_int * i_satd_inter
                >> 1 as ::core::ffi::c_int
        } else {
            COST_MAX
        };
        if (*h).mb.b_lossless == 0
            && *predict_mode.offset(3 as ::core::ffi::c_int as isize) as ::core::ffi::c_int
                >= 0 as ::core::ffi::c_int
        {
            (*h).pixf
                .intra_mbcmp_x3_16x16
                .expect("non-null function pointer")(
                p_src,
                p_dst,
                (*a).i_satd_i16x16_dir.as_mut_ptr(),
            );
            (*a).i_satd_i16x16_dir[0 as ::core::ffi::c_int as usize] +=
                lambda * bs_size_ue(0 as ::core::ffi::c_uint);
            (*a).i_satd_i16x16_dir[1 as ::core::ffi::c_int as usize] +=
                lambda * bs_size_ue(1 as ::core::ffi::c_uint);
            (*a).i_satd_i16x16_dir[2 as ::core::ffi::c_int as usize] +=
                lambda * bs_size_ue(2 as ::core::ffi::c_uint);
            if (*a).i_satd_i16x16_dir[0 as ::core::ffi::c_int as usize] < (*a).i_satd_i16x16 {
                (*a).i_satd_i16x16 = (*a).i_satd_i16x16_dir[0 as ::core::ffi::c_int as usize];
                (*a).i_predict16x16 = 0 as ::core::ffi::c_int;
            }
            if (*a).i_satd_i16x16_dir[1 as ::core::ffi::c_int as usize] < (*a).i_satd_i16x16 {
                (*a).i_satd_i16x16 = (*a).i_satd_i16x16_dir[1 as ::core::ffi::c_int as usize];
                (*a).i_predict16x16 = 1 as ::core::ffi::c_int;
            }
            if (*a).i_satd_i16x16_dir[2 as ::core::ffi::c_int as usize] < (*a).i_satd_i16x16 {
                (*a).i_satd_i16x16 = (*a).i_satd_i16x16_dir[2 as ::core::ffi::c_int as usize];
                (*a).i_predict16x16 = 2 as ::core::ffi::c_int;
            }
            if (*a).i_satd_i16x16 <= i16x16_thresh {
                (*h).predict_16x16[I_PRED_16x16_P as ::core::ffi::c_int as usize]
                    .expect("non-null function pointer")(p_dst);
                (*a).i_satd_i16x16_dir[I_PRED_16x16_P as ::core::ffi::c_int as usize] =
                    (*h).pixf.mbcmp[PIXEL_16x16 as ::core::ffi::c_int as usize]
                        .expect("non-null function pointer")(
                        p_src,
                        FENC_STRIDE as intptr_t,
                        p_dst,
                        FDEC_STRIDE as intptr_t,
                    );
                (*a).i_satd_i16x16_dir[I_PRED_16x16_P as ::core::ffi::c_int as usize] +=
                    lambda * bs_size_ue(3 as ::core::ffi::c_uint);
                if (*a).i_satd_i16x16_dir[I_PRED_16x16_P as ::core::ffi::c_int as usize]
                    < (*a).i_satd_i16x16
                {
                    (*a).i_satd_i16x16 =
                        (*a).i_satd_i16x16_dir[I_PRED_16x16_P as ::core::ffi::c_int as usize];
                    (*a).i_predict16x16 = 3 as ::core::ffi::c_int;
                }
            }
        } else {
            while *predict_mode as ::core::ffi::c_int >= 0 as ::core::ffi::c_int {
                let mut i_satd: ::core::ffi::c_int = 0;
                let mut i_mode: ::core::ffi::c_int = *predict_mode as ::core::ffi::c_int;
                if (*h).mb.b_lossless != 0 {
                    x264_10_predict_lossless_16x16(h, 0 as ::core::ffi::c_int, i_mode);
                } else {
                    (*h).predict_16x16[i_mode as usize].expect("non-null function pointer")(p_dst);
                }
                i_satd = (*h).pixf.mbcmp[PIXEL_16x16 as ::core::ffi::c_int as usize]
                    .expect("non-null function pointer")(
                    p_src,
                    FENC_STRIDE as intptr_t,
                    p_dst,
                    FDEC_STRIDE as intptr_t,
                ) + lambda
                    * bs_size_ue(
                        x264_mb_pred_mode16x16_fix[i_mode as usize] as ::core::ffi::c_uint,
                    );
                if i_satd < (*a).i_satd_i16x16 {
                    (*a).i_satd_i16x16 = i_satd;
                    (*a).i_predict16x16 = i_mode;
                }
                (*a).i_satd_i16x16_dir[i_mode as usize] = i_satd;
                predict_mode = predict_mode.offset(1);
            }
        }
        if (*h).sh.i_type == SLICE_TYPE_B as ::core::ffi::c_int {
            (*a).i_satd_i16x16 += lambda
                * i_mb_b_cost_table[I_16x16 as ::core::ffi::c_int as usize] as ::core::ffi::c_int;
        }
        if (*a).i_satd_i16x16 > i16x16_thresh {
            return;
        }
    }
    let mut cost_i4x4_mode: *mut uint16_t = (*(*(*h).cost_table)
        .i4x4_mode
        .as_mut_ptr()
        .offset((*a).i_qp as isize))
    .as_mut_ptr()
    .offset(8 as ::core::ffi::c_int as isize);
    if flags & X264_ANALYSE_I8x8 != 0 {
        let mut edge: [pixel; 36] = [0; 36];
        let mut sa8d: x264_pixel_cmp_t = if (*h).pixf.mbcmp[0 as ::core::ffi::c_int as usize]
            == (*h).pixf.satd[0 as ::core::ffi::c_int as usize]
        {
            (*h).pixf.sa8d[PIXEL_8x8 as ::core::ffi::c_int as usize]
        } else {
            (*h).pixf.mbcmp[PIXEL_8x8 as ::core::ffi::c_int as usize]
        };
        let mut i_satd_thresh: ::core::ffi::c_int = if (*a).i_mbrd != 0 {
            COST_MAX
        } else if i_satd_inter < (*a).i_satd_i16x16 {
            i_satd_inter
        } else {
            (*a).i_satd_i16x16
        };
        let mut i_cost: ::core::ffi::c_int = lambda * 4 as ::core::ffi::c_int;
        (*h).mb.i_cbp_luma = 0 as ::core::ffi::c_int;
        if (*h).sh.i_type == SLICE_TYPE_B as ::core::ffi::c_int {
            i_cost += lambda
                * i_mb_b_cost_table[I_8x8 as ::core::ffi::c_int as usize] as ::core::ffi::c_int;
        }
        idx = 0 as ::core::ffi::c_int;
        loop {
            let mut x: ::core::ffi::c_int = idx & 1 as ::core::ffi::c_int;
            let mut y: ::core::ffi::c_int = idx >> 1 as ::core::ffi::c_int;
            let mut p_src_by: *mut pixel = p_src
                .offset((8 as ::core::ffi::c_int * x) as isize)
                .offset((8 as ::core::ffi::c_int * y * FENC_STRIDE) as isize);
            let mut p_dst_by: *mut pixel = p_dst
                .offset((8 as ::core::ffi::c_int * x) as isize)
                .offset((8 as ::core::ffi::c_int * y * FDEC_STRIDE) as isize);
            let mut i_best: ::core::ffi::c_int = COST_MAX;
            let mut i_pred_mode: ::core::ffi::c_int =
                x264_mb_predict_intra4x4_mode(h, 4 as ::core::ffi::c_int * idx);
            let mut predict_mode_0: *const int8_t = predict_8x8_mode_available(
                (*a).b_avoid_topright,
                (*h).mb.i_neighbour8[idx as usize] as ::core::ffi::c_int,
                idx,
            );
            (*h).predict_8x8_filter.expect("non-null function pointer")(
                p_dst_by,
                edge.as_mut_ptr(),
                (*h).mb.i_neighbour8[idx as usize] as ::core::ffi::c_int,
                ALL_NEIGHBORS as ::core::ffi::c_int,
            );
            if (*h).pixf.intra_mbcmp_x9_8x8.is_some()
                && *predict_mode_0.offset(8 as ::core::ffi::c_int as isize) as ::core::ffi::c_int
                    >= 0 as ::core::ffi::c_int
            {
                i_best = (*h)
                    .pixf
                    .intra_mbcmp_x9_8x8
                    .expect("non-null function pointer")(
                    p_src_by,
                    p_dst_by,
                    edge.as_mut_ptr(),
                    cost_i4x4_mode.offset(-(i_pred_mode as isize)),
                    (*(*a).i_satd_i8x8_dir.as_mut_ptr().offset(idx as isize)).as_mut_ptr(),
                );
                i_cost += i_best & 0xffff as ::core::ffi::c_int;
                i_best >>= 16 as ::core::ffi::c_int;
                (*a).i_predict8x8[idx as usize] = i_best;
                if idx == 3 as ::core::ffi::c_int || i_cost > i_satd_thresh {
                    break;
                }
                x264_macroblock_cache_intra8x8_pred(
                    h,
                    2 as ::core::ffi::c_int * x,
                    2 as ::core::ffi::c_int * y,
                    i_best,
                );
            } else {
                if (*h).mb.b_lossless == 0
                    && *predict_mode_0.offset(5 as ::core::ffi::c_int as isize)
                        as ::core::ffi::c_int
                        >= 0 as ::core::ffi::c_int
                {
                    let mut satd: [int32_t; 4] = [0; 4];
                    (*h).pixf
                        .intra_mbcmp_x3_8x8
                        .expect("non-null function pointer")(
                        p_src_by,
                        edge.as_mut_ptr(),
                        satd.as_mut_ptr() as *mut ::core::ffi::c_int,
                    );
                    let mut favor_vertical: ::core::ffi::c_int = (satd
                        [I_PRED_4x4_H as ::core::ffi::c_int as usize]
                        > satd[I_PRED_4x4_V as ::core::ffi::c_int as usize])
                        as ::core::ffi::c_int;
                    if i_pred_mode < 3 as ::core::ffi::c_int {
                        satd[i_pred_mode as usize] = (satd[i_pred_mode as usize]
                            as ::core::ffi::c_int
                            - 3 as ::core::ffi::c_int * lambda)
                            as int32_t;
                    }
                    let mut i: ::core::ffi::c_int = 2 as ::core::ffi::c_int;
                    while i >= 0 as ::core::ffi::c_int {
                        let mut cost: ::core::ffi::c_int = satd[i as usize];
                        (*a).i_satd_i8x8_dir[idx as usize][i as usize] =
                            (cost + 4 as ::core::ffi::c_int * lambda) as uint16_t;
                        if cost < i_best {
                            i_best = cost;
                            (*a).i_predict8x8[idx as usize] = i;
                        }
                        i -= 1;
                    }
                    if (*a).i_mbrd < 1 as ::core::ffi::c_int + (*a).b_fast_intra {
                        predict_mode_0 = (*(*(*intra_analysis_shortcut
                            .as_ptr()
                            .offset((*a).b_avoid_topright as isize))
                        .as_ptr()
                        .offset(
                            (*predict_mode_0.offset(8 as ::core::ffi::c_int as isize)
                                as ::core::ffi::c_int
                                >= 0 as ::core::ffi::c_int)
                                as ::core::ffi::c_int as isize,
                        ))
                        .as_ptr()
                        .offset(favor_vertical as isize))
                        .as_ptr();
                    } else {
                        predict_mode_0 = predict_mode_0.offset(3 as ::core::ffi::c_int as isize);
                    }
                }
                while *predict_mode_0 as ::core::ffi::c_int >= 0 as ::core::ffi::c_int
                    && (i_best >= 0 as ::core::ffi::c_int || (*a).i_mbrd >= 2 as ::core::ffi::c_int)
                {
                    let mut i_satd_0: ::core::ffi::c_int = 0;
                    let mut i_mode_0: ::core::ffi::c_int = *predict_mode_0 as ::core::ffi::c_int;
                    if (*h).mb.b_lossless != 0 {
                        x264_10_predict_lossless_8x8(
                            h,
                            p_dst_by,
                            0 as ::core::ffi::c_int,
                            idx,
                            i_mode_0,
                            edge.as_mut_ptr(),
                        );
                    } else {
                        (*h).predict_8x8[i_mode_0 as usize].expect("non-null function pointer")(
                            p_dst_by,
                            edge.as_mut_ptr(),
                        );
                    }
                    i_satd_0 = sa8d.expect("non-null function pointer")(
                        p_dst_by,
                        FDEC_STRIDE as intptr_t,
                        p_src_by,
                        FENC_STRIDE as intptr_t,
                    );
                    if i_pred_mode
                        == x264_mb_pred_mode4x4_fix[(i_mode_0 + 1 as ::core::ffi::c_int) as usize]
                            as ::core::ffi::c_int
                    {
                        i_satd_0 -= 3 as ::core::ffi::c_int * lambda;
                    }
                    if i_satd_0 < i_best {
                        i_best = i_satd_0;
                        (*a).i_predict8x8[idx as usize] = i_mode_0;
                    }
                    (*a).i_satd_i8x8_dir[idx as usize][i_mode_0 as usize] =
                        (i_satd_0 + 4 as ::core::ffi::c_int * lambda) as uint16_t;
                    predict_mode_0 = predict_mode_0.offset(1);
                }
                i_cost += i_best + 3 as ::core::ffi::c_int * lambda;
                if idx == 3 as ::core::ffi::c_int || i_cost > i_satd_thresh {
                    break;
                }
                if (*h).mb.b_lossless != 0 {
                    x264_10_predict_lossless_8x8(
                        h,
                        p_dst_by,
                        0 as ::core::ffi::c_int,
                        idx,
                        (*a).i_predict8x8[idx as usize],
                        edge.as_mut_ptr(),
                    );
                } else {
                    (*h).predict_8x8[(*a).i_predict8x8[idx as usize] as usize]
                        .expect("non-null function pointer")(
                        p_dst_by, edge.as_mut_ptr()
                    );
                }
                x264_macroblock_cache_intra8x8_pred(
                    h,
                    2 as ::core::ffi::c_int * x,
                    2 as ::core::ffi::c_int * y,
                    (*a).i_predict8x8[idx as usize],
                );
            }
            x264_mb_encode_i8x8(
                h,
                0 as ::core::ffi::c_int,
                idx,
                (*a).i_qp,
                (*a).i_predict8x8[idx as usize],
                edge.as_mut_ptr(),
                0 as ::core::ffi::c_int,
            );
            idx += 1;
        }
        if idx == 3 as ::core::ffi::c_int {
            (*a).i_satd_i8x8 = i_cost;
            if (*h).mb.i_skip_intra != 0 {
                (*h).mc.copy[PIXEL_16x16 as ::core::ffi::c_int as usize]
                    .expect("non-null function pointer")(
                    (*h).mb.pic.i8x8_fdec_buf.as_mut_ptr(),
                    16 as intptr_t,
                    p_dst,
                    FDEC_STRIDE as intptr_t,
                    16 as ::core::ffi::c_int,
                );
                (*h).mb.pic.i8x8_nnz_buf[0 as ::core::ffi::c_int as usize] =
                    (*(&mut *(*h).mb.cache.non_zero_count.as_mut_ptr().offset(
                        *x264_scan8.as_ptr().offset(0 as ::core::ffi::c_int as isize) as isize,
                    ) as *mut uint8_t as *mut x264_union32_t))
                        .i;
                (*h).mb.pic.i8x8_nnz_buf[1 as ::core::ffi::c_int as usize] =
                    (*(&mut *(*h).mb.cache.non_zero_count.as_mut_ptr().offset(
                        *x264_scan8.as_ptr().offset(2 as ::core::ffi::c_int as isize) as isize,
                    ) as *mut uint8_t as *mut x264_union32_t))
                        .i;
                (*h).mb.pic.i8x8_nnz_buf[2 as ::core::ffi::c_int as usize] =
                    (*(&mut *(*h).mb.cache.non_zero_count.as_mut_ptr().offset(
                        *x264_scan8.as_ptr().offset(8 as ::core::ffi::c_int as isize) as isize,
                    ) as *mut uint8_t as *mut x264_union32_t))
                        .i;
                (*h).mb.pic.i8x8_nnz_buf[3 as ::core::ffi::c_int as usize] =
                    (*(&mut *(*h).mb.cache.non_zero_count.as_mut_ptr().offset(
                        *x264_scan8
                            .as_ptr()
                            .offset(10 as ::core::ffi::c_int as isize)
                            as isize,
                    ) as *mut uint8_t as *mut x264_union32_t))
                        .i;
                (*h).mb.pic.i8x8_cbp = (*h).mb.i_cbp_luma;
                if (*h).mb.i_skip_intra == 2 as ::core::ffi::c_int {
                    (*h).mc.memcpy_aligned.expect("non-null function pointer")(
                        (*h).mb.pic.i8x8_dct_buf.as_mut_ptr() as *mut ::core::ffi::c_void,
                        (*h).dct.luma8x8.as_mut_ptr() as *const ::core::ffi::c_void,
                        ::core::mem::size_of::<[[dctcoef; 64]; 3]>() as size_t,
                    );
                }
            }
        } else {
            static mut cost_div_fix8: [uint16_t; 3] = [
                1024 as ::core::ffi::c_int as uint16_t,
                512 as ::core::ffi::c_int as uint16_t,
                341 as ::core::ffi::c_int as uint16_t,
            ];
            (*a).i_satd_i8x8 = COST_MAX;
            i_cost = i_cost * cost_div_fix8[idx as usize] as ::core::ffi::c_int
                >> 8 as ::core::ffi::c_int;
        }
        static mut i8x8_thresh: [uint8_t; 11] = [
            4 as ::core::ffi::c_int as uint8_t,
            4 as ::core::ffi::c_int as uint8_t,
            4 as ::core::ffi::c_int as uint8_t,
            5 as ::core::ffi::c_int as uint8_t,
            5 as ::core::ffi::c_int as uint8_t,
            5 as ::core::ffi::c_int as uint8_t,
            6 as ::core::ffi::c_int as uint8_t,
            6 as ::core::ffi::c_int as uint8_t,
            6 as ::core::ffi::c_int as uint8_t,
            6 as ::core::ffi::c_int as uint8_t,
            6 as ::core::ffi::c_int as uint8_t,
        ];
        if (*a).b_early_terminate != 0
            && (if i_cost < (*a).i_satd_i16x16 {
                i_cost
            } else {
                (*a).i_satd_i16x16
            }) > i_satd_inter
                * i8x8_thresh[(*h).mb.i_subpel_refine as usize] as ::core::ffi::c_int
                >> 2 as ::core::ffi::c_int
        {
            return;
        }
    }
    if flags & X264_ANALYSE_I4x4 != 0 {
        let mut i_cost_0: ::core::ffi::c_int =
            lambda * (24 as ::core::ffi::c_int + 16 as ::core::ffi::c_int);
        let mut i_satd_thresh_0: ::core::ffi::c_int = if (*a).b_early_terminate != 0 {
            if i_satd_inter
                < (if (*a).i_satd_i16x16 < (*a).i_satd_i8x8 {
                    (*a).i_satd_i16x16
                } else {
                    (*a).i_satd_i8x8
                })
            {
                i_satd_inter
            } else if (*a).i_satd_i16x16 < (*a).i_satd_i8x8 {
                (*a).i_satd_i16x16
            } else {
                (*a).i_satd_i8x8
            }
        } else {
            COST_MAX
        };
        (*h).mb.i_cbp_luma = 0 as ::core::ffi::c_int;
        if (*a).b_early_terminate != 0 && (*a).i_mbrd != 0 {
            i_satd_thresh_0 = i_satd_thresh_0 * (10 as ::core::ffi::c_int - (*a).b_fast_intra)
                / 8 as ::core::ffi::c_int;
        }
        if (*h).sh.i_type == SLICE_TYPE_B as ::core::ffi::c_int {
            i_cost_0 += lambda
                * i_mb_b_cost_table[I_4x4 as ::core::ffi::c_int as usize] as ::core::ffi::c_int;
        }
        idx = 0 as ::core::ffi::c_int;
        loop {
            let mut p_src_by_0: *mut pixel =
                p_src.offset(block_idx_xy_fenc[idx as usize] as ::core::ffi::c_int as isize);
            let mut p_dst_by_0: *mut pixel =
                p_dst.offset(block_idx_xy_fdec[idx as usize] as ::core::ffi::c_int as isize);
            let mut i_best_0: ::core::ffi::c_int = COST_MAX;
            let mut i_pred_mode_0: ::core::ffi::c_int = x264_mb_predict_intra4x4_mode(h, idx);
            let mut predict_mode_1: *const int8_t = predict_4x4_mode_available(
                (*a).b_avoid_topright,
                (*h).mb.i_neighbour4[idx as usize] as ::core::ffi::c_int,
                idx,
            );
            if (*h).mb.i_neighbour4[idx as usize]
                & (MB_TOPRIGHT as ::core::ffi::c_int | MB_TOP as ::core::ffi::c_int)
                    as ::core::ffi::c_uint
                == MB_TOP as ::core::ffi::c_int as ::core::ffi::c_uint
            {
                (*(&mut *p_dst_by_0
                    .offset((4 as ::core::ffi::c_int - 32 as ::core::ffi::c_int) as isize)
                    as *mut pixel as *mut x264_union64_t))
                    .i = (*p_dst_by_0
                    .offset((3 as ::core::ffi::c_int - 32 as ::core::ffi::c_int) as isize)
                    as ::core::ffi::c_ulonglong)
                    .wrapping_mul(0x1000100010001 as ::core::ffi::c_ulonglong)
                    as uint64_t;
            }
            if (*h).pixf.intra_mbcmp_x9_4x4.is_some()
                && *predict_mode_1.offset(8 as ::core::ffi::c_int as isize) as ::core::ffi::c_int
                    >= 0 as ::core::ffi::c_int
            {
                i_best_0 = (*h)
                    .pixf
                    .intra_mbcmp_x9_4x4
                    .expect("non-null function pointer")(
                    p_src_by_0,
                    p_dst_by_0,
                    cost_i4x4_mode.offset(-(i_pred_mode_0 as isize)),
                );
                i_cost_0 += i_best_0 & 0xffff as ::core::ffi::c_int;
                i_best_0 >>= 16 as ::core::ffi::c_int;
                (*a).i_predict4x4[idx as usize] = i_best_0;
                if i_cost_0 > i_satd_thresh_0 || idx == 15 as ::core::ffi::c_int {
                    break;
                }
                (*h).mb.cache.intra4x4_pred_mode[x264_scan8[idx as usize] as usize] =
                    i_best_0 as int8_t;
            } else {
                if (*h).mb.b_lossless == 0
                    && *predict_mode_1.offset(5 as ::core::ffi::c_int as isize)
                        as ::core::ffi::c_int
                        >= 0 as ::core::ffi::c_int
                {
                    let mut satd_0: [int32_t; 4] = [0; 4];
                    (*h).pixf
                        .intra_mbcmp_x3_4x4
                        .expect("non-null function pointer")(
                        p_src_by_0,
                        p_dst_by_0,
                        satd_0.as_mut_ptr() as *mut ::core::ffi::c_int,
                    );
                    let mut favor_vertical_0: ::core::ffi::c_int = (satd_0
                        [I_PRED_4x4_H as ::core::ffi::c_int as usize]
                        > satd_0[I_PRED_4x4_V as ::core::ffi::c_int as usize])
                        as ::core::ffi::c_int;
                    if i_pred_mode_0 < 3 as ::core::ffi::c_int {
                        satd_0[i_pred_mode_0 as usize] = (satd_0[i_pred_mode_0 as usize]
                            as ::core::ffi::c_int
                            - 3 as ::core::ffi::c_int * lambda)
                            as int32_t;
                    }
                    i_best_0 =
                        satd_0[I_PRED_4x4_DC as ::core::ffi::c_int as usize] as ::core::ffi::c_int;
                    (*a).i_predict4x4[idx as usize] = I_PRED_4x4_DC as ::core::ffi::c_int;
                    if satd_0[I_PRED_4x4_H as ::core::ffi::c_int as usize] < i_best_0 as int32_t {
                        i_best_0 = satd_0[I_PRED_4x4_H as ::core::ffi::c_int as usize]
                            as ::core::ffi::c_int;
                        (*a).i_predict4x4[idx as usize] = I_PRED_4x4_H as ::core::ffi::c_int;
                    }
                    if satd_0[I_PRED_4x4_V as ::core::ffi::c_int as usize] < i_best_0 as int32_t {
                        i_best_0 = satd_0[I_PRED_4x4_V as ::core::ffi::c_int as usize]
                            as ::core::ffi::c_int;
                        (*a).i_predict4x4[idx as usize] = I_PRED_4x4_V as ::core::ffi::c_int;
                    }
                    if (*a).i_mbrd < 1 as ::core::ffi::c_int + (*a).b_fast_intra {
                        predict_mode_1 = (*(*(*intra_analysis_shortcut
                            .as_ptr()
                            .offset((*a).b_avoid_topright as isize))
                        .as_ptr()
                        .offset(
                            (*predict_mode_1.offset(8 as ::core::ffi::c_int as isize)
                                as ::core::ffi::c_int
                                >= 0 as ::core::ffi::c_int)
                                as ::core::ffi::c_int as isize,
                        ))
                        .as_ptr()
                        .offset(favor_vertical_0 as isize))
                        .as_ptr();
                    } else {
                        predict_mode_1 = predict_mode_1.offset(3 as ::core::ffi::c_int as isize);
                    }
                }
                if i_best_0 > 0 as ::core::ffi::c_int {
                    while *predict_mode_1 as ::core::ffi::c_int >= 0 as ::core::ffi::c_int {
                        let mut i_satd_1: ::core::ffi::c_int = 0;
                        let mut i_mode_1: ::core::ffi::c_int =
                            *predict_mode_1 as ::core::ffi::c_int;
                        if (*h).mb.b_lossless != 0 {
                            x264_10_predict_lossless_4x4(
                                h,
                                p_dst_by_0,
                                0 as ::core::ffi::c_int,
                                idx,
                                i_mode_1,
                            );
                        } else {
                            (*h).predict_4x4[i_mode_1 as usize].expect("non-null function pointer")(
                                p_dst_by_0,
                            );
                        }
                        i_satd_1 = (*h).pixf.mbcmp[PIXEL_4x4 as ::core::ffi::c_int as usize]
                            .expect("non-null function pointer")(
                            p_src_by_0,
                            FENC_STRIDE as intptr_t,
                            p_dst_by_0,
                            FDEC_STRIDE as intptr_t,
                        );
                        if i_pred_mode_0
                            == x264_mb_pred_mode4x4_fix
                                [(i_mode_1 + 1 as ::core::ffi::c_int) as usize]
                                as ::core::ffi::c_int
                        {
                            i_satd_1 -= lambda * 3 as ::core::ffi::c_int;
                            if i_satd_1 <= 0 as ::core::ffi::c_int {
                                i_best_0 = i_satd_1;
                                (*a).i_predict4x4[idx as usize] = i_mode_1;
                                break;
                            }
                        }
                        if i_satd_1 < i_best_0 {
                            i_best_0 = i_satd_1;
                            (*a).i_predict4x4[idx as usize] = i_mode_1;
                        }
                        predict_mode_1 = predict_mode_1.offset(1);
                    }
                }
                i_cost_0 += i_best_0 + 3 as ::core::ffi::c_int * lambda;
                if i_cost_0 > i_satd_thresh_0 || idx == 15 as ::core::ffi::c_int {
                    break;
                }
                if (*h).mb.b_lossless != 0 {
                    x264_10_predict_lossless_4x4(
                        h,
                        p_dst_by_0,
                        0 as ::core::ffi::c_int,
                        idx,
                        (*a).i_predict4x4[idx as usize],
                    );
                } else {
                    (*h).predict_4x4[(*a).i_predict4x4[idx as usize] as usize]
                        .expect("non-null function pointer")(p_dst_by_0);
                }
                (*h).mb.cache.intra4x4_pred_mode[x264_scan8[idx as usize] as usize] =
                    (*a).i_predict4x4[idx as usize] as int8_t;
            }
            x264_mb_encode_i4x4(
                h,
                0 as ::core::ffi::c_int,
                idx,
                (*a).i_qp,
                (*a).i_predict4x4[idx as usize],
                0 as ::core::ffi::c_int,
            );
            idx += 1;
        }
        if idx == 15 as ::core::ffi::c_int {
            (*a).i_satd_i4x4 = i_cost_0;
            if (*h).mb.i_skip_intra != 0 {
                (*h).mc.copy[PIXEL_16x16 as ::core::ffi::c_int as usize]
                    .expect("non-null function pointer")(
                    (*h).mb.pic.i4x4_fdec_buf.as_mut_ptr(),
                    16 as intptr_t,
                    p_dst,
                    FDEC_STRIDE as intptr_t,
                    16 as ::core::ffi::c_int,
                );
                (*h).mb.pic.i4x4_nnz_buf[0 as ::core::ffi::c_int as usize] =
                    (*(&mut *(*h).mb.cache.non_zero_count.as_mut_ptr().offset(
                        *x264_scan8.as_ptr().offset(0 as ::core::ffi::c_int as isize) as isize,
                    ) as *mut uint8_t as *mut x264_union32_t))
                        .i;
                (*h).mb.pic.i4x4_nnz_buf[1 as ::core::ffi::c_int as usize] =
                    (*(&mut *(*h).mb.cache.non_zero_count.as_mut_ptr().offset(
                        *x264_scan8.as_ptr().offset(2 as ::core::ffi::c_int as isize) as isize,
                    ) as *mut uint8_t as *mut x264_union32_t))
                        .i;
                (*h).mb.pic.i4x4_nnz_buf[2 as ::core::ffi::c_int as usize] =
                    (*(&mut *(*h).mb.cache.non_zero_count.as_mut_ptr().offset(
                        *x264_scan8.as_ptr().offset(8 as ::core::ffi::c_int as isize) as isize,
                    ) as *mut uint8_t as *mut x264_union32_t))
                        .i;
                (*h).mb.pic.i4x4_nnz_buf[3 as ::core::ffi::c_int as usize] =
                    (*(&mut *(*h).mb.cache.non_zero_count.as_mut_ptr().offset(
                        *x264_scan8
                            .as_ptr()
                            .offset(10 as ::core::ffi::c_int as isize)
                            as isize,
                    ) as *mut uint8_t as *mut x264_union32_t))
                        .i;
                (*h).mb.pic.i4x4_cbp = (*h).mb.i_cbp_luma;
                if (*h).mb.i_skip_intra == 2 as ::core::ffi::c_int {
                    (*h).mc.memcpy_aligned.expect("non-null function pointer")(
                        (*h).mb.pic.i4x4_dct_buf.as_mut_ptr() as *mut ::core::ffi::c_void,
                        (*h).dct.luma4x4.as_mut_ptr() as *const ::core::ffi::c_void,
                        ::core::mem::size_of::<[[dctcoef; 16]; 15]>() as size_t,
                    );
                }
            }
        } else {
            (*a).i_satd_i4x4 = COST_MAX;
        }
    }
}
#[c2rust::src_loc = "982:1"]
unsafe extern "C" fn intra_rd(
    mut h: *mut x264_t,
    mut a: *mut x264_mb_analysis_t,
    mut i_satd_thresh: ::core::ffi::c_int,
) {
    if (*a).b_early_terminate == 0 {
        i_satd_thresh = COST_MAX;
    }
    if (*a).i_satd_i16x16 < i_satd_thresh {
        (*h).mb.i_type = I_16x16 as ::core::ffi::c_int;
        analyse_update_cache(h, a);
        (*a).i_satd_i16x16 = rd_cost_mb(h, (*a).i_lambda2);
    } else {
        (*a).i_satd_i16x16 = COST_MAX;
    }
    if (*a).i_satd_i4x4 < i_satd_thresh {
        (*h).mb.i_type = I_4x4 as ::core::ffi::c_int;
        analyse_update_cache(h, a);
        (*a).i_satd_i4x4 = rd_cost_mb(h, (*a).i_lambda2);
    } else {
        (*a).i_satd_i4x4 = COST_MAX;
    }
    if (*a).i_satd_i8x8 < i_satd_thresh {
        (*h).mb.i_type = I_8x8 as ::core::ffi::c_int;
        analyse_update_cache(h, a);
        (*a).i_satd_i8x8 = rd_cost_mb(h, (*a).i_lambda2);
        (*a).i_cbp_i8x8_luma = (*h).mb.i_cbp_luma;
    } else {
        (*a).i_satd_i8x8 = COST_MAX;
    };
}
#[c2rust::src_loc = "1016:1"]
unsafe extern "C" fn intra_rd_refine(mut h: *mut x264_t, mut a: *mut x264_mb_analysis_t) {
    let mut i_satd: uint64_t = 0;
    let mut i_best: uint64_t = 0;
    let mut plane_count: ::core::ffi::c_int =
        if (*(*h).sps.as_mut_ptr()).i_chroma_format_idc == CHROMA_444 as ::core::ffi::c_int {
            3 as ::core::ffi::c_int
        } else {
            1 as ::core::ffi::c_int
        };
    (*h).mb.i_skip_intra = 0 as ::core::ffi::c_int;
    if (*h).mb.i_type == I_16x16 as ::core::ffi::c_int {
        let mut old_pred_mode: ::core::ffi::c_int = (*a).i_predict16x16;
        let mut predict_mode: *const int8_t =
            predict_16x16_mode_available((*h).mb.i_neighbour_intra as ::core::ffi::c_int);
        let mut i_thresh: ::core::ffi::c_int = if (*a).b_early_terminate != 0 {
            (*a).i_satd_i16x16_dir[old_pred_mode as usize] * 9 as ::core::ffi::c_int
                / 8 as ::core::ffi::c_int
        } else {
            COST_MAX
        };
        i_best = (*a).i_satd_i16x16 as uint64_t;
        while *predict_mode as ::core::ffi::c_int >= 0 as ::core::ffi::c_int {
            let mut i_mode: ::core::ffi::c_int = *predict_mode as ::core::ffi::c_int;
            if !(i_mode == old_pred_mode || (*a).i_satd_i16x16_dir[i_mode as usize] > i_thresh) {
                (*h).mb.i_intra16x16_pred_mode = i_mode;
                i_satd = rd_cost_mb(h, (*a).i_lambda2) as uint64_t;
                if i_satd < i_best {
                    i_best = i_satd;
                    (*a).i_predict16x16 = i_mode;
                }
            }
            predict_mode = predict_mode.offset(1);
        }
    }
    if (*(*h).sps.as_mut_ptr()).i_chroma_format_idc == CHROMA_420 as ::core::ffi::c_int
        || (*(*h).sps.as_mut_ptr()).i_chroma_format_idc == CHROMA_422 as ::core::ffi::c_int
    {
        let mut predict_mode_0: *const int8_t =
            predict_chroma_mode_available((*h).mb.i_neighbour_intra as ::core::ffi::c_int);
        if *predict_mode_0.offset(1 as ::core::ffi::c_int as isize) as ::core::ffi::c_int
            >= 0 as ::core::ffi::c_int
        {
            let mut predict_mode_sorted: [int8_t; 4] = [0; 4];
            let mut i_max: ::core::ffi::c_int = 0;
            let mut i_thresh_0: ::core::ffi::c_int = if (*a).b_early_terminate != 0 {
                (*a).i_satd_chroma * 5 as ::core::ffi::c_int / 4 as ::core::ffi::c_int
            } else {
                COST_MAX
            };
            i_max = 0 as ::core::ffi::c_int;
            while *predict_mode_0 as ::core::ffi::c_int >= 0 as ::core::ffi::c_int {
                let mut i_mode_0: ::core::ffi::c_int = *predict_mode_0 as ::core::ffi::c_int;
                if (*a).i_satd_chroma_dir[i_mode_0 as usize] < i_thresh_0
                    && i_mode_0 != (*a).i_predict8x8chroma
                {
                    let fresh4 = i_max;
                    i_max = i_max + 1;
                    predict_mode_sorted[fresh4 as usize] = i_mode_0 as int8_t;
                }
                predict_mode_0 = predict_mode_0.offset(1);
            }
            if i_max > 0 as ::core::ffi::c_int {
                let mut i_cbp_chroma_best: ::core::ffi::c_int = (*h).mb.i_cbp_chroma;
                let mut i_chroma_lambda: ::core::ffi::c_int =
                    x264_lambda2_tab[(*h).mb.i_chroma_qp as usize];
                i_best = rd_cost_chroma(
                    h,
                    i_chroma_lambda,
                    (*a).i_predict8x8chroma,
                    0 as ::core::ffi::c_int,
                );
                let mut i: ::core::ffi::c_int = 0 as ::core::ffi::c_int;
                while i < i_max {
                    let mut i_mode_1: ::core::ffi::c_int =
                        predict_mode_sorted[i as usize] as ::core::ffi::c_int;
                    if (*h).mb.b_lossless != 0 {
                        x264_10_predict_lossless_chroma(h, i_mode_1);
                    } else {
                        (*h).predict_chroma[i_mode_1 as usize].expect("non-null function pointer")(
                            (*h).mb.pic.p_fdec[1 as ::core::ffi::c_int as usize],
                        );
                        (*h).predict_chroma[i_mode_1 as usize].expect("non-null function pointer")(
                            (*h).mb.pic.p_fdec[2 as ::core::ffi::c_int as usize],
                        );
                    }
                    i_satd = rd_cost_chroma(
                        h,
                        i_chroma_lambda,
                        i_mode_1,
                        ((*h).mb.i_cbp_chroma != 0 as ::core::ffi::c_int) as ::core::ffi::c_int,
                    );
                    if i_satd < i_best {
                        i_best = i_satd;
                        (*a).i_predict8x8chroma = i_mode_1;
                        i_cbp_chroma_best = (*h).mb.i_cbp_chroma;
                    }
                    i += 1;
                }
                (*h).mb.i_chroma_pred_mode = (*a).i_predict8x8chroma;
                (*h).mb.i_cbp_chroma = i_cbp_chroma_best;
            }
        }
    }
    if (*h).mb.i_type == I_4x4 as ::core::ffi::c_int {
        let mut pels: [[pixel4; 4]; 3] =
            [[0 as ::core::ffi::c_int as pixel4, 0, 0, 0], [0; 4], [0; 4]];
        let mut nnz: [::core::ffi::c_int; 3] = [0 as ::core::ffi::c_int; 3];
        let mut idx: ::core::ffi::c_int = 0 as ::core::ffi::c_int;
        while idx < 16 as ::core::ffi::c_int {
            let mut dst: [*mut pixel; 3] = [
                (*h).mb.pic.p_fdec[0 as ::core::ffi::c_int as usize]
                    .offset(block_idx_xy_fdec[idx as usize] as ::core::ffi::c_int as isize),
                if (*(*h).sps.as_mut_ptr()).i_chroma_format_idc != 0 {
                    (*h).mb.pic.p_fdec[1 as ::core::ffi::c_int as usize]
                        .offset(block_idx_xy_fdec[idx as usize] as ::core::ffi::c_int as isize)
                } else {
                    0 as *mut pixel
                },
                if (*(*h).sps.as_mut_ptr()).i_chroma_format_idc != 0 {
                    (*h).mb.pic.p_fdec[2 as ::core::ffi::c_int as usize]
                        .offset(block_idx_xy_fdec[idx as usize] as ::core::ffi::c_int as isize)
                } else {
                    0 as *mut pixel
                },
            ];
            i_best = COST_MAX64 as uint64_t;
            let mut predict_mode_1: *const int8_t = predict_4x4_mode_available(
                (*a).b_avoid_topright,
                (*h).mb.i_neighbour4[idx as usize] as ::core::ffi::c_int,
                idx,
            );
            if (*h).mb.i_neighbour4[idx as usize]
                & (MB_TOPRIGHT as ::core::ffi::c_int | MB_TOP as ::core::ffi::c_int)
                    as ::core::ffi::c_uint
                == MB_TOP as ::core::ffi::c_int as ::core::ffi::c_uint
            {
                let mut p: ::core::ffi::c_int = 0 as ::core::ffi::c_int;
                while p < plane_count {
                    (*(dst[p as usize]
                        .offset(4 as ::core::ffi::c_int as isize)
                        .offset(-(32 as ::core::ffi::c_int as isize))
                        as *mut x264_union64_t))
                        .i = (*dst[p as usize]
                        .offset((3 as ::core::ffi::c_int - 32 as ::core::ffi::c_int) as isize)
                        as ::core::ffi::c_ulonglong)
                        .wrapping_mul(0x1000100010001 as ::core::ffi::c_ulonglong)
                        as uint64_t;
                    p += 1;
                }
            }
            while *predict_mode_1 as ::core::ffi::c_int >= 0 as ::core::ffi::c_int {
                let mut i_mode_2: ::core::ffi::c_int = *predict_mode_1 as ::core::ffi::c_int;
                i_satd = rd_cost_i4x4(h, (*a).i_lambda2, idx, i_mode_2);
                if i_best > i_satd {
                    (*a).i_predict4x4[idx as usize] = i_mode_2;
                    i_best = i_satd;
                    let mut p_0: ::core::ffi::c_int = 0 as ::core::ffi::c_int;
                    while p_0 < plane_count {
                        pels[p_0 as usize][0 as ::core::ffi::c_int as usize] = (*(dst[p_0 as usize]
                            .offset((0 as ::core::ffi::c_int * 32 as ::core::ffi::c_int) as isize)
                            as *mut x264_union64_t))
                            .i
                            as pixel4;
                        pels[p_0 as usize][1 as ::core::ffi::c_int as usize] = (*(dst[p_0 as usize]
                            .offset((1 as ::core::ffi::c_int * 32 as ::core::ffi::c_int) as isize)
                            as *mut x264_union64_t))
                            .i
                            as pixel4;
                        pels[p_0 as usize][2 as ::core::ffi::c_int as usize] = (*(dst[p_0 as usize]
                            .offset((2 as ::core::ffi::c_int * 32 as ::core::ffi::c_int) as isize)
                            as *mut x264_union64_t))
                            .i
                            as pixel4;
                        pels[p_0 as usize][3 as ::core::ffi::c_int as usize] = (*(dst[p_0 as usize]
                            .offset((3 as ::core::ffi::c_int * 32 as ::core::ffi::c_int) as isize)
                            as *mut x264_union64_t))
                            .i
                            as pixel4;
                        nnz[p_0 as usize] = (*h).mb.cache.non_zero_count
                            [x264_scan8[(idx + p_0 * 16 as ::core::ffi::c_int) as usize] as usize]
                            as ::core::ffi::c_int;
                        p_0 += 1;
                    }
                }
                predict_mode_1 = predict_mode_1.offset(1);
            }
            let mut p_1: ::core::ffi::c_int = 0 as ::core::ffi::c_int;
            while p_1 < plane_count {
                (*(dst[p_1 as usize]
                    .offset((0 as ::core::ffi::c_int * 32 as ::core::ffi::c_int) as isize)
                    as *mut x264_union64_t))
                    .i = pels[p_1 as usize][0 as ::core::ffi::c_int as usize] as uint64_t;
                (*(dst[p_1 as usize]
                    .offset((1 as ::core::ffi::c_int * 32 as ::core::ffi::c_int) as isize)
                    as *mut x264_union64_t))
                    .i = pels[p_1 as usize][1 as ::core::ffi::c_int as usize] as uint64_t;
                (*(dst[p_1 as usize]
                    .offset((2 as ::core::ffi::c_int * 32 as ::core::ffi::c_int) as isize)
                    as *mut x264_union64_t))
                    .i = pels[p_1 as usize][2 as ::core::ffi::c_int as usize] as uint64_t;
                (*(dst[p_1 as usize]
                    .offset((3 as ::core::ffi::c_int * 32 as ::core::ffi::c_int) as isize)
                    as *mut x264_union64_t))
                    .i = pels[p_1 as usize][3 as ::core::ffi::c_int as usize] as uint64_t;
                (*h).mb.cache.non_zero_count
                    [x264_scan8[(idx + p_1 * 16 as ::core::ffi::c_int) as usize] as usize] =
                    nnz[p_1 as usize] as uint8_t;
                p_1 += 1;
            }
            (*h).mb.cache.intra4x4_pred_mode[x264_scan8[idx as usize] as usize] =
                (*a).i_predict4x4[idx as usize] as int8_t;
            idx += 1;
        }
    } else if (*h).mb.i_type == I_8x8 as ::core::ffi::c_int {
        let mut edge: [[pixel; 32]; 4] = [[0; 32]; 4];
        let mut pels_h: [[pixel4; 2]; 3] = [[0 as ::core::ffi::c_int as pixel4, 0], [0; 2], [0; 2]];
        let mut pels_v: [[pixel; 7]; 3] = [
            [0 as ::core::ffi::c_int as pixel, 0, 0, 0, 0, 0, 0],
            [0; 7],
            [0; 7],
        ];
        let mut nnz_0: [[uint16_t; 2]; 3] =
            [[0 as ::core::ffi::c_int as uint16_t, 0], [0; 2], [0; 2]];
        let mut idx_0: ::core::ffi::c_int = 0 as ::core::ffi::c_int;
        while idx_0 < 4 as ::core::ffi::c_int {
            let mut x: ::core::ffi::c_int = idx_0 & 1 as ::core::ffi::c_int;
            let mut y: ::core::ffi::c_int = idx_0 >> 1 as ::core::ffi::c_int;
            let mut s8: ::core::ffi::c_int =
                X264_SCAN8_0 + 2 as ::core::ffi::c_int * x + 16 as ::core::ffi::c_int * y;
            let mut dst_0: [*mut pixel; 3] = [
                (*h).mb.pic.p_fdec[0 as ::core::ffi::c_int as usize]
                    .offset((8 as ::core::ffi::c_int * x) as isize)
                    .offset((8 as ::core::ffi::c_int * y * FDEC_STRIDE) as isize),
                if (*(*h).sps.as_mut_ptr()).i_chroma_format_idc != 0 {
                    (*h).mb.pic.p_fdec[1 as ::core::ffi::c_int as usize]
                        .offset((8 as ::core::ffi::c_int * x) as isize)
                        .offset((8 as ::core::ffi::c_int * y * FDEC_STRIDE) as isize)
                } else {
                    0 as *mut pixel
                },
                if (*(*h).sps.as_mut_ptr()).i_chroma_format_idc != 0 {
                    (*h).mb.pic.p_fdec[2 as ::core::ffi::c_int as usize]
                        .offset((8 as ::core::ffi::c_int * x) as isize)
                        .offset((8 as ::core::ffi::c_int * y * FDEC_STRIDE) as isize)
                } else {
                    0 as *mut pixel
                },
            ];
            let mut cbp_luma_new: ::core::ffi::c_int = 0 as ::core::ffi::c_int;
            let mut i_thresh_1: ::core::ffi::c_int = if (*a).b_early_terminate != 0 {
                (*a).i_satd_i8x8_dir[idx_0 as usize][(*a).i_predict8x8[idx_0 as usize] as usize]
                    as ::core::ffi::c_int
                    * 11 as ::core::ffi::c_int
                    / 8 as ::core::ffi::c_int
            } else {
                COST_MAX
            };
            i_best = COST_MAX64 as uint64_t;
            let mut predict_mode_2: *const int8_t = predict_8x8_mode_available(
                (*a).b_avoid_topright,
                (*h).mb.i_neighbour8[idx_0 as usize] as ::core::ffi::c_int,
                idx_0,
            );
            let mut p_2: ::core::ffi::c_int = 0 as ::core::ffi::c_int;
            while p_2 < plane_count {
                (*h).predict_8x8_filter.expect("non-null function pointer")(
                    dst_0[p_2 as usize],
                    (*edge.as_mut_ptr().offset(p_2 as isize)).as_mut_ptr(),
                    (*h).mb.i_neighbour8[idx_0 as usize] as ::core::ffi::c_int,
                    ALL_NEIGHBORS as ::core::ffi::c_int,
                );
                p_2 += 1;
            }
            while *predict_mode_2 as ::core::ffi::c_int >= 0 as ::core::ffi::c_int {
                let mut i_mode_3: ::core::ffi::c_int = *predict_mode_2 as ::core::ffi::c_int;
                if !((*a).i_satd_i8x8_dir[idx_0 as usize][i_mode_3 as usize] as ::core::ffi::c_int
                    > i_thresh_1)
                {
                    (*h).mb.i_cbp_luma = (*a).i_cbp_i8x8_luma;
                    i_satd = rd_cost_i8x8(h, (*a).i_lambda2, idx_0, i_mode_3, edge.as_mut_ptr());
                    if i_best > i_satd {
                        (*a).i_predict8x8[idx_0 as usize] = i_mode_3;
                        cbp_luma_new = (*h).mb.i_cbp_luma;
                        i_best = i_satd;
                        let mut p_3: ::core::ffi::c_int = 0 as ::core::ffi::c_int;
                        while p_3 < plane_count {
                            pels_h[p_3 as usize][0 as ::core::ffi::c_int as usize] = (*(dst_0
                                [p_3 as usize]
                                .offset(
                                    (7 as ::core::ffi::c_int * 32 as ::core::ffi::c_int) as isize,
                                )
                                .offset(0 as ::core::ffi::c_int as isize)
                                as *mut x264_union64_t))
                                .i
                                as pixel4;
                            pels_h[p_3 as usize][1 as ::core::ffi::c_int as usize] = (*(dst_0
                                [p_3 as usize]
                                .offset(
                                    (7 as ::core::ffi::c_int * 32 as ::core::ffi::c_int) as isize,
                                )
                                .offset(4 as ::core::ffi::c_int as isize)
                                as *mut x264_union64_t))
                                .i
                                as pixel4;
                            if idx_0 & 1 as ::core::ffi::c_int == 0 {
                                let mut j: ::core::ffi::c_int = 0 as ::core::ffi::c_int;
                                while j < 7 as ::core::ffi::c_int {
                                    pels_v[p_3 as usize][j as usize] = *dst_0[p_3 as usize].offset(
                                        (7 as ::core::ffi::c_int + j * FDEC_STRIDE) as isize,
                                    );
                                    j += 1;
                                }
                            }
                            nnz_0[p_3 as usize][0 as ::core::ffi::c_int as usize] =
                                (*(&mut *(*h).mb.cache.non_zero_count.as_mut_ptr().offset(
                                    (s8 + 0 as ::core::ffi::c_int * 8 as ::core::ffi::c_int
                                        + p_3 * 16 as ::core::ffi::c_int)
                                        as isize,
                                ) as *mut uint8_t
                                    as *mut x264_union16_t))
                                    .i;
                            nnz_0[p_3 as usize][1 as ::core::ffi::c_int as usize] =
                                (*(&mut *(*h).mb.cache.non_zero_count.as_mut_ptr().offset(
                                    (s8 + 1 as ::core::ffi::c_int * 8 as ::core::ffi::c_int
                                        + p_3 * 16 as ::core::ffi::c_int)
                                        as isize,
                                ) as *mut uint8_t
                                    as *mut x264_union16_t))
                                    .i;
                            p_3 += 1;
                        }
                    }
                }
                predict_mode_2 = predict_mode_2.offset(1);
            }
            (*a).i_cbp_i8x8_luma = cbp_luma_new;
            let mut p_4: ::core::ffi::c_int = 0 as ::core::ffi::c_int;
            while p_4 < plane_count {
                (*(dst_0[p_4 as usize]
                    .offset((7 as ::core::ffi::c_int * 32 as ::core::ffi::c_int) as isize)
                    .offset(0 as ::core::ffi::c_int as isize)
                    as *mut x264_union64_t))
                    .i = pels_h[p_4 as usize][0 as ::core::ffi::c_int as usize] as uint64_t;
                (*(dst_0[p_4 as usize]
                    .offset((7 as ::core::ffi::c_int * 32 as ::core::ffi::c_int) as isize)
                    .offset(4 as ::core::ffi::c_int as isize)
                    as *mut x264_union64_t))
                    .i = pels_h[p_4 as usize][1 as ::core::ffi::c_int as usize] as uint64_t;
                if idx_0 & 1 as ::core::ffi::c_int == 0 {
                    let mut j_0: ::core::ffi::c_int = 0 as ::core::ffi::c_int;
                    while j_0 < 7 as ::core::ffi::c_int {
                        *dst_0[p_4 as usize]
                            .offset((7 as ::core::ffi::c_int + j_0 * FDEC_STRIDE) as isize) =
                            pels_v[p_4 as usize][j_0 as usize];
                        j_0 += 1;
                    }
                }
                (*(&mut *(*h).mb.cache.non_zero_count.as_mut_ptr().offset(
                    (s8 + 0 as ::core::ffi::c_int * 8 as ::core::ffi::c_int
                        + p_4 * 16 as ::core::ffi::c_int) as isize,
                ) as *mut uint8_t as *mut x264_union16_t))
                    .i = nnz_0[p_4 as usize][0 as ::core::ffi::c_int as usize];
                (*(&mut *(*h).mb.cache.non_zero_count.as_mut_ptr().offset(
                    (s8 + 1 as ::core::ffi::c_int * 8 as ::core::ffi::c_int
                        + p_4 * 16 as ::core::ffi::c_int) as isize,
                ) as *mut uint8_t as *mut x264_union16_t))
                    .i = nnz_0[p_4 as usize][1 as ::core::ffi::c_int as usize];
                p_4 += 1;
            }
            x264_macroblock_cache_intra8x8_pred(
                h,
                2 as ::core::ffi::c_int * x,
                2 as ::core::ffi::c_int * y,
                (*a).i_predict8x8[idx_0 as usize],
            );
            idx_0 += 1;
        }
    }
}
#[c2rust::src_loc = "1255:1"]
unsafe extern "C" fn mb_analyse_inter_p16x16(mut h: *mut x264_t, mut a: *mut x264_mb_analysis_t) {
    let mut m: x264_me_t = x264_me_t {
        i_pixel: 0,
        p_cost_mv: 0 as *mut uint16_t,
        i_ref_cost: 0,
        i_ref: 0,
        weight: 0 as *const x264_weight_t,
        p_fref: [0 as *mut pixel; 12],
        p_fref_w: 0 as *mut pixel,
        p_fenc: [0 as *mut pixel; 3],
        integral: 0 as *mut uint16_t,
        i_stride: [0; 3],
        mvp: [0; 2],
        cost_mv: 0,
        cost: 0,
        mv: [0; 2],
    };
    let mut i_mvc: ::core::ffi::c_int = 0;
    let mut mvc: [[int16_t; 2]; 8] = [[0; 2]; 8];
    let mut i_halfpel_thresh: ::core::ffi::c_int = INT_MAX;
    let mut p_halfpel_thresh: *mut ::core::ffi::c_int = if (*a).b_early_terminate != 0
        && (*h).mb.pic.i_fref[0 as ::core::ffi::c_int as usize] > 1 as ::core::ffi::c_int
    {
        &mut i_halfpel_thresh
    } else {
        0 as *mut ::core::ffi::c_int
    };
    m.i_pixel = PIXEL_16x16 as ::core::ffi::c_int;
    m.p_cost_mv = (*a).p_cost_mv;
    m.i_stride[0 as ::core::ffi::c_int as usize] =
        (*h).mb.pic.i_stride[0 as ::core::ffi::c_int as usize];
    m.i_stride[1 as ::core::ffi::c_int as usize] =
        (*h).mb.pic.i_stride[1 as ::core::ffi::c_int as usize];
    m.i_stride[2 as ::core::ffi::c_int as usize] =
        (*h).mb.pic.i_stride[2 as ::core::ffi::c_int as usize];
    m.p_fenc[0 as ::core::ffi::c_int as usize] = &mut *(*(*h)
        .mb
        .pic
        .p_fenc
        .as_mut_ptr()
        .offset(0 as ::core::ffi::c_int as isize))
    .offset((0 as ::core::ffi::c_int + 0 as ::core::ffi::c_int * FENC_STRIDE) as isize)
        as *mut pixel;
    if (*(*h).sps.as_mut_ptr()).i_chroma_format_idc != 0 {
        m.p_fenc[1 as ::core::ffi::c_int as usize] = &mut *(*(*h)
            .mb
            .pic
            .p_fenc
            .as_mut_ptr()
            .offset(1 as ::core::ffi::c_int as isize))
        .offset(
            ((0 as ::core::ffi::c_int >> (*h).mb.chroma_h_shift)
                + (0 as ::core::ffi::c_int >> (*h).mb.chroma_v_shift) * FENC_STRIDE)
                as isize,
        ) as *mut pixel;
        m.p_fenc[2 as ::core::ffi::c_int as usize] = &mut *(*(*h)
            .mb
            .pic
            .p_fenc
            .as_mut_ptr()
            .offset(2 as ::core::ffi::c_int as isize))
        .offset(
            ((0 as ::core::ffi::c_int >> (*h).mb.chroma_h_shift)
                + (0 as ::core::ffi::c_int >> (*h).mb.chroma_v_shift) * FENC_STRIDE)
                as isize,
        ) as *mut pixel;
    }
    (*a).l0.me16x16.cost = INT_MAX;
    let mut i_ref: ::core::ffi::c_int = 0 as ::core::ffi::c_int;
    while i_ref < (*h).mb.pic.i_fref[0 as ::core::ffi::c_int as usize] {
        m.i_ref_cost = *(*a).p_cost_ref[0 as ::core::ffi::c_int as usize].offset(i_ref as isize)
            as ::core::ffi::c_int;
        i_halfpel_thresh -= m.i_ref_cost;
        m.p_fref[0 as ::core::ffi::c_int as usize] = &mut *(*(*(*(*h)
            .mb
            .pic
            .p_fref
            .as_mut_ptr()
            .offset(0 as ::core::ffi::c_int as isize))
        .as_mut_ptr()
        .offset(i_ref as isize))
        .as_mut_ptr()
        .offset(0 as ::core::ffi::c_int as isize))
        .offset(
            (0 as ::core::ffi::c_int
                + 0 as ::core::ffi::c_int
                    * *m.i_stride
                        .as_mut_ptr()
                        .offset(0 as ::core::ffi::c_int as isize)) as isize,
        ) as *mut pixel;
        m.p_fref_w = m.p_fref[0 as ::core::ffi::c_int as usize];
        if (*h).param.analyse.i_subpel_refine != 0 {
            m.p_fref[1 as ::core::ffi::c_int as usize] = &mut *(*(*(*(*h)
                .mb
                .pic
                .p_fref
                .as_mut_ptr()
                .offset(0 as ::core::ffi::c_int as isize))
            .as_mut_ptr()
            .offset(i_ref as isize))
            .as_mut_ptr()
            .offset(1 as ::core::ffi::c_int as isize))
            .offset(
                (0 as ::core::ffi::c_int
                    + 0 as ::core::ffi::c_int
                        * *m.i_stride
                            .as_mut_ptr()
                            .offset(0 as ::core::ffi::c_int as isize)) as isize,
            ) as *mut pixel;
            m.p_fref[2 as ::core::ffi::c_int as usize] = &mut *(*(*(*(*h)
                .mb
                .pic
                .p_fref
                .as_mut_ptr()
                .offset(0 as ::core::ffi::c_int as isize))
            .as_mut_ptr()
            .offset(i_ref as isize))
            .as_mut_ptr()
            .offset(2 as ::core::ffi::c_int as isize))
            .offset(
                (0 as ::core::ffi::c_int
                    + 0 as ::core::ffi::c_int
                        * *m.i_stride
                            .as_mut_ptr()
                            .offset(0 as ::core::ffi::c_int as isize)) as isize,
            ) as *mut pixel;
            m.p_fref[3 as ::core::ffi::c_int as usize] = &mut *(*(*(*(*h)
                .mb
                .pic
                .p_fref
                .as_mut_ptr()
                .offset(0 as ::core::ffi::c_int as isize))
            .as_mut_ptr()
            .offset(i_ref as isize))
            .as_mut_ptr()
            .offset(3 as ::core::ffi::c_int as isize))
            .offset(
                (0 as ::core::ffi::c_int
                    + 0 as ::core::ffi::c_int
                        * *m.i_stride
                            .as_mut_ptr()
                            .offset(0 as ::core::ffi::c_int as isize)) as isize,
            ) as *mut pixel;
        }
        if (*(*h).sps.as_mut_ptr()).i_chroma_format_idc == CHROMA_444 as ::core::ffi::c_int {
            m.p_fref[4 as ::core::ffi::c_int as usize] = &mut *(*(*(*(*h)
                .mb
                .pic
                .p_fref
                .as_mut_ptr()
                .offset(0 as ::core::ffi::c_int as isize))
            .as_mut_ptr()
            .offset(i_ref as isize))
            .as_mut_ptr()
            .offset(4 as ::core::ffi::c_int as isize))
            .offset(
                (0 as ::core::ffi::c_int
                    + 0 as ::core::ffi::c_int
                        * *m.i_stride
                            .as_mut_ptr()
                            .offset(1 as ::core::ffi::c_int as isize)) as isize,
            ) as *mut pixel;
            m.p_fref[8 as ::core::ffi::c_int as usize] = &mut *(*(*(*(*h)
                .mb
                .pic
                .p_fref
                .as_mut_ptr()
                .offset(0 as ::core::ffi::c_int as isize))
            .as_mut_ptr()
            .offset(i_ref as isize))
            .as_mut_ptr()
            .offset(8 as ::core::ffi::c_int as isize))
            .offset(
                (0 as ::core::ffi::c_int
                    + 0 as ::core::ffi::c_int
                        * *m.i_stride
                            .as_mut_ptr()
                            .offset(2 as ::core::ffi::c_int as isize)) as isize,
            ) as *mut pixel;
            if (*h).param.analyse.i_subpel_refine != 0 {
                m.p_fref[5 as ::core::ffi::c_int as usize] = &mut *(*(*(*(*h)
                    .mb
                    .pic
                    .p_fref
                    .as_mut_ptr()
                    .offset(0 as ::core::ffi::c_int as isize))
                .as_mut_ptr()
                .offset(i_ref as isize))
                .as_mut_ptr()
                .offset(5 as ::core::ffi::c_int as isize))
                .offset(
                    (0 as ::core::ffi::c_int
                        + 0 as ::core::ffi::c_int
                            * *m.i_stride
                                .as_mut_ptr()
                                .offset(1 as ::core::ffi::c_int as isize))
                        as isize,
                ) as *mut pixel;
                m.p_fref[6 as ::core::ffi::c_int as usize] = &mut *(*(*(*(*h)
                    .mb
                    .pic
                    .p_fref
                    .as_mut_ptr()
                    .offset(0 as ::core::ffi::c_int as isize))
                .as_mut_ptr()
                .offset(i_ref as isize))
                .as_mut_ptr()
                .offset(6 as ::core::ffi::c_int as isize))
                .offset(
                    (0 as ::core::ffi::c_int
                        + 0 as ::core::ffi::c_int
                            * *m.i_stride
                                .as_mut_ptr()
                                .offset(1 as ::core::ffi::c_int as isize))
                        as isize,
                ) as *mut pixel;
                m.p_fref[7 as ::core::ffi::c_int as usize] = &mut *(*(*(*(*h)
                    .mb
                    .pic
                    .p_fref
                    .as_mut_ptr()
                    .offset(0 as ::core::ffi::c_int as isize))
                .as_mut_ptr()
                .offset(i_ref as isize))
                .as_mut_ptr()
                .offset(7 as ::core::ffi::c_int as isize))
                .offset(
                    (0 as ::core::ffi::c_int
                        + 0 as ::core::ffi::c_int
                            * *m.i_stride
                                .as_mut_ptr()
                                .offset(1 as ::core::ffi::c_int as isize))
                        as isize,
                ) as *mut pixel;
                m.p_fref[9 as ::core::ffi::c_int as usize] = &mut *(*(*(*(*h)
                    .mb
                    .pic
                    .p_fref
                    .as_mut_ptr()
                    .offset(0 as ::core::ffi::c_int as isize))
                .as_mut_ptr()
                .offset(i_ref as isize))
                .as_mut_ptr()
                .offset(9 as ::core::ffi::c_int as isize))
                .offset(
                    (0 as ::core::ffi::c_int
                        + 0 as ::core::ffi::c_int
                            * *m.i_stride
                                .as_mut_ptr()
                                .offset(2 as ::core::ffi::c_int as isize))
                        as isize,
                ) as *mut pixel;
                m.p_fref[10 as ::core::ffi::c_int as usize] = &mut *(*(*(*(*h)
                    .mb
                    .pic
                    .p_fref
                    .as_mut_ptr()
                    .offset(0 as ::core::ffi::c_int as isize))
                .as_mut_ptr()
                .offset(i_ref as isize))
                .as_mut_ptr()
                .offset(10 as ::core::ffi::c_int as isize))
                .offset(
                    (0 as ::core::ffi::c_int
                        + 0 as ::core::ffi::c_int
                            * *m.i_stride
                                .as_mut_ptr()
                                .offset(2 as ::core::ffi::c_int as isize))
                        as isize,
                ) as *mut pixel;
                m.p_fref[11 as ::core::ffi::c_int as usize] = &mut *(*(*(*(*h)
                    .mb
                    .pic
                    .p_fref
                    .as_mut_ptr()
                    .offset(0 as ::core::ffi::c_int as isize))
                .as_mut_ptr()
                .offset(i_ref as isize))
                .as_mut_ptr()
                .offset(11 as ::core::ffi::c_int as isize))
                .offset(
                    (0 as ::core::ffi::c_int
                        + 0 as ::core::ffi::c_int
                            * *m.i_stride
                                .as_mut_ptr()
                                .offset(2 as ::core::ffi::c_int as isize))
                        as isize,
                ) as *mut pixel;
            }
        } else if (*(*h).sps.as_mut_ptr()).i_chroma_format_idc != 0 {
            m.p_fref[4 as ::core::ffi::c_int as usize] = &mut *(*(*(*(*h)
                .mb
                .pic
                .p_fref
                .as_mut_ptr()
                .offset(0 as ::core::ffi::c_int as isize))
            .as_mut_ptr()
            .offset(i_ref as isize))
            .as_mut_ptr()
            .offset(4 as ::core::ffi::c_int as isize))
            .offset(
                (0 as ::core::ffi::c_int
                    + (0 as ::core::ffi::c_int >> (*h).mb.chroma_v_shift)
                        * *m.i_stride
                            .as_mut_ptr()
                            .offset(1 as ::core::ffi::c_int as isize)) as isize,
            ) as *mut pixel;
        }
        if (*h).param.analyse.i_me_method >= X264_ME_ESA {
            m.integral = &mut *(*(*(*h)
                .mb
                .pic
                .p_integral
                .as_mut_ptr()
                .offset(0 as ::core::ffi::c_int as isize))
            .as_mut_ptr()
            .offset(i_ref as isize))
            .offset(
                (0 as ::core::ffi::c_int
                    + 0 as ::core::ffi::c_int
                        * *m.i_stride
                            .as_mut_ptr()
                            .offset(0 as ::core::ffi::c_int as isize)) as isize,
            ) as *mut uint16_t;
        }
        m.weight = x264_zero.as_mut_ptr() as *const x264_weight_t;
        m.i_ref = i_ref;
        m.p_fref_w = &mut *(*(*h).mb.pic.p_fref_w.as_mut_ptr().offset(i_ref as isize)).offset(
            (0 as ::core::ffi::c_int
                + 0 as ::core::ffi::c_int
                    * *m.i_stride
                        .as_mut_ptr()
                        .offset(0 as ::core::ffi::c_int as isize)) as isize,
        ) as *mut pixel;
        m.weight = (*(*h).sh.weight.as_mut_ptr().offset(i_ref as isize)).as_mut_ptr();
        x264_10_mb_predict_mv_16x16(h, 0 as ::core::ffi::c_int, i_ref, m.mvp.as_mut_ptr());
        if (*h).mb.ref_blind_dupe == i_ref {
            (*(m.mv.as_mut_ptr() as *mut x264_union32_t)).i = (*((*(*(*a)
                .l0
                .mvc
                .as_mut_ptr()
                .offset(0 as ::core::ffi::c_int as isize))
            .as_mut_ptr()
            .offset(0 as ::core::ffi::c_int as isize))
            .as_mut_ptr()
                as *mut x264_union32_t))
                .i;
            x264_10_me_refine_qpel_refdupe(h, &mut m, p_halfpel_thresh);
        } else {
            x264_10_mb_predict_mv_ref16x16(
                h,
                0 as ::core::ffi::c_int,
                i_ref,
                mvc.as_mut_ptr() as *mut [int16_t; 2],
                &mut i_mvc,
            );
            x264_10_me_search_ref(
                h,
                &mut m,
                mvc.as_mut_ptr() as *mut [int16_t; 2],
                i_mvc,
                p_halfpel_thresh,
            );
        }
        (*((*(*(*(*h)
            .mb
            .mvr
            .as_mut_ptr()
            .offset(0 as ::core::ffi::c_int as isize))
        .as_mut_ptr()
        .offset(i_ref as isize))
        .offset((*h).mb.i_mb_xy as isize))
        .as_mut_ptr() as *mut x264_union32_t))
            .i = (*(m.mv.as_mut_ptr() as *mut x264_union32_t)).i;
        (*((*(*(*a).l0.mvc.as_mut_ptr().offset(i_ref as isize))
            .as_mut_ptr()
            .offset(0 as ::core::ffi::c_int as isize))
        .as_mut_ptr() as *mut x264_union32_t))
            .i = (*(m.mv.as_mut_ptr() as *mut x264_union32_t)).i;
        if i_ref == 0 as ::core::ffi::c_int
            && (*a).b_try_skip != 0
            && m.cost - m.cost_mv < 300 as ::core::ffi::c_int * (*a).i_lambda
            && abs(m.mv[0 as ::core::ffi::c_int as usize] as ::core::ffi::c_int
                - (*h).mb.cache.pskip_mv[0 as ::core::ffi::c_int as usize] as ::core::ffi::c_int)
                + abs(m.mv[1 as ::core::ffi::c_int as usize] as ::core::ffi::c_int
                    - (*h).mb.cache.pskip_mv[1 as ::core::ffi::c_int as usize]
                        as ::core::ffi::c_int)
                <= 1 as ::core::ffi::c_int
            && x264_10_macroblock_probe_skip(h, 0 as ::core::ffi::c_int) != 0
        {
            (*h).mb.i_type = P_SKIP as ::core::ffi::c_int;
            analyse_update_cache(h, a);
            if (*h).mb.cache.pskip_mv[1 as ::core::ffi::c_int as usize] as ::core::ffi::c_int
                <= (*h).mb.mv_max_spel[1 as ::core::ffi::c_int as usize]
                || (*h).i_thread_frames == 1 as ::core::ffi::c_int
            {
            } else {
                __assert_fail(
                    b"h->mb.cache.pskip_mv[1] <= h->mb.mv_max_spel[1] || h->i_thread_frames == 1\0"
                        as *const u8 as *const ::core::ffi::c_char,
                    b"encoder/analyse.c\0" as *const u8 as *const ::core::ffi::c_char,
                    1305 as ::core::ffi::c_uint,
                    ::core::mem::transmute::<[u8; 61], [::core::ffi::c_char; 61]>(
                        *b"void mb_analyse_inter_p16x16(x264_t *, x264_mb_analysis_t *)\0",
                    )
                    .as_ptr(),
                );
            }
            'c_105243: {
                if (*h).mb.cache.pskip_mv[1 as ::core::ffi::c_int as usize] as ::core::ffi::c_int
                    <= (*h).mb.mv_max_spel[1 as ::core::ffi::c_int as usize]
                    || (*h).i_thread_frames == 1 as ::core::ffi::c_int
                {
                } else {
                    __assert_fail(
                        b"h->mb.cache.pskip_mv[1] <= h->mb.mv_max_spel[1] || h->i_thread_frames == 1\0"
                            as *const u8 as *const ::core::ffi::c_char,
                        b"encoder/analyse.c\0" as *const u8
                            as *const ::core::ffi::c_char,
                        1305 as ::core::ffi::c_uint,
                        ::core::mem::transmute::<
                            [u8; 61],
                            [::core::ffi::c_char; 61],
                        >(
                                *b"void mb_analyse_inter_p16x16(x264_t *, x264_mb_analysis_t *)\0",
                            )
                            .as_ptr(),
                    );
                }
            };
            return;
        }
        m.cost += m.i_ref_cost;
        i_halfpel_thresh += m.i_ref_cost;
        if m.cost < (*a).l0.me16x16.cost {
            (*h).mc.memcpy_aligned.expect("non-null function pointer")(
                &mut (*a).l0.me16x16 as *mut x264_me_t as *mut ::core::ffi::c_void,
                &mut m as *mut x264_me_t as *const ::core::ffi::c_void,
                ::core::mem::size_of::<x264_me_t>() as size_t,
            );
        }
        i_ref += 1;
    }
    x264_macroblock_cache_ref(
        h,
        0 as ::core::ffi::c_int,
        0 as ::core::ffi::c_int,
        4 as ::core::ffi::c_int,
        4 as ::core::ffi::c_int,
        0 as ::core::ffi::c_int,
        (*a).l0.me16x16.i_ref as int8_t,
    );
    if (*a).l0.me16x16.mv[1 as ::core::ffi::c_int as usize] as ::core::ffi::c_int
        <= (*h).mb.mv_max_spel[1 as ::core::ffi::c_int as usize]
        || (*h).i_thread_frames == 1 as ::core::ffi::c_int
    {
    } else {
        __assert_fail(
            b"a->l0.me16x16.mv[1] <= h->mb.mv_max_spel[1] || h->i_thread_frames == 1\0" as *const u8
                as *const ::core::ffi::c_char,
            b"encoder/analyse.c\0" as *const u8 as *const ::core::ffi::c_char,
            1317 as ::core::ffi::c_uint,
            ::core::mem::transmute::<[u8; 61], [::core::ffi::c_char; 61]>(
                *b"void mb_analyse_inter_p16x16(x264_t *, x264_mb_analysis_t *)\0",
            )
            .as_ptr(),
        );
    }
    'c_105078: {
        if (*a).l0.me16x16.mv[1 as ::core::ffi::c_int as usize] as ::core::ffi::c_int
            <= (*h).mb.mv_max_spel[1 as ::core::ffi::c_int as usize]
            || (*h).i_thread_frames == 1 as ::core::ffi::c_int
        {
        } else {
            __assert_fail(
                b"a->l0.me16x16.mv[1] <= h->mb.mv_max_spel[1] || h->i_thread_frames == 1\0"
                    as *const u8 as *const ::core::ffi::c_char,
                b"encoder/analyse.c\0" as *const u8 as *const ::core::ffi::c_char,
                1317 as ::core::ffi::c_uint,
                ::core::mem::transmute::<[u8; 61], [::core::ffi::c_char; 61]>(
                    *b"void mb_analyse_inter_p16x16(x264_t *, x264_mb_analysis_t *)\0",
                )
                .as_ptr(),
            );
        }
    };
    (*h).mb.i_type = P_L0 as ::core::ffi::c_int;
    if (*a).i_mbrd != 0 {
        mb_init_fenc_cache(
            h,
            ((*a).i_mbrd >= 2 as ::core::ffi::c_int
                || (*h).param.analyse.inter & X264_ANALYSE_PSUB8x8 != 0)
                as ::core::ffi::c_int,
        );
        if (*a).l0.me16x16.i_ref == 0 as ::core::ffi::c_int
            && (*((*a).l0.me16x16.mv.as_mut_ptr() as *mut x264_union32_t)).i
                == (*((*h).mb.cache.pskip_mv.as_mut_ptr() as *mut x264_union32_t)).i
            && (*a).b_force_intra == 0
        {
            (*h).mb.i_partition = D_16x16 as ::core::ffi::c_int;
            x264_macroblock_cache_mv(
                h,
                0 as ::core::ffi::c_int,
                0 as ::core::ffi::c_int,
                4 as ::core::ffi::c_int,
                4 as ::core::ffi::c_int,
                0 as ::core::ffi::c_int,
                (*((*a).l0.me16x16.mv.as_mut_ptr() as *mut x264_union32_t)).i,
            );
            (*a).l0.i_rd16x16 = rd_cost_mb(h, (*a).i_lambda2);
            if (*h).mb.i_cbp_luma | (*h).mb.i_cbp_chroma == 0 {
                (*h).mb.i_type = P_SKIP as ::core::ffi::c_int;
            }
        }
    }
}
#[c2rust::src_loc = "1334:1"]
unsafe extern "C" fn mb_analyse_inter_p8x8_mixed_ref(
    mut h: *mut x264_t,
    mut a: *mut x264_mb_analysis_t,
) {
    let mut m: x264_me_t = x264_me_t {
        i_pixel: 0,
        p_cost_mv: 0 as *mut uint16_t,
        i_ref_cost: 0,
        i_ref: 0,
        weight: 0 as *const x264_weight_t,
        p_fref: [0 as *mut pixel; 12],
        p_fref_w: 0 as *mut pixel,
        p_fenc: [0 as *mut pixel; 3],
        integral: 0 as *mut uint16_t,
        i_stride: [0; 3],
        mvp: [0; 2],
        cost_mv: 0,
        cost: 0,
        mv: [0; 2],
    };
    let mut p_fenc: *mut *mut pixel = (*h).mb.pic.p_fenc.as_mut_ptr();
    let mut i_maxref: ::core::ffi::c_int =
        (*h).mb.pic.i_fref[0 as ::core::ffi::c_int as usize] - 1 as ::core::ffi::c_int;
    (*h).mb.i_partition = D_8x8 as ::core::ffi::c_int;
    if (*a).b_early_terminate != 0
        && (i_maxref > 0 as ::core::ffi::c_int
            && ((*a).l0.me16x16.i_ref == 0 as ::core::ffi::c_int
                || (*a).l0.me16x16.i_ref == (*h).mb.ref_blind_dupe)
            && (*h).mb.i_mb_type_top > 0 as ::core::ffi::c_int
            && (*h).mb.i_mb_type_left[0 as ::core::ffi::c_int as usize] > 0 as ::core::ffi::c_int)
    {
        i_maxref = 0 as ::core::ffi::c_int;
        let mut ref_0: ::core::ffi::c_int = (*h).mb.cache.ref_0[0 as ::core::ffi::c_int as usize]
            [(X264_SCAN8_0 + -(8 as ::core::ffi::c_int) - 1 as ::core::ffi::c_int) as usize]
            as ::core::ffi::c_int;
        if ref_0 > i_maxref && ref_0 != (*h).mb.ref_blind_dupe {
            i_maxref = ref_0;
        }
        let mut ref_1: ::core::ffi::c_int = (*h).mb.cache.ref_0[0 as ::core::ffi::c_int as usize]
            [(X264_SCAN8_0 + -(8 as ::core::ffi::c_int) + 0 as ::core::ffi::c_int) as usize]
            as ::core::ffi::c_int;
        if ref_1 > i_maxref && ref_1 != (*h).mb.ref_blind_dupe {
            i_maxref = ref_1;
        }
        let mut ref_2: ::core::ffi::c_int = (*h).mb.cache.ref_0[0 as ::core::ffi::c_int as usize]
            [(X264_SCAN8_0 + -(8 as ::core::ffi::c_int) + 2 as ::core::ffi::c_int) as usize]
            as ::core::ffi::c_int;
        if ref_2 > i_maxref && ref_2 != (*h).mb.ref_blind_dupe {
            i_maxref = ref_2;
        }
        let mut ref_3: ::core::ffi::c_int = (*h).mb.cache.ref_0[0 as ::core::ffi::c_int as usize]
            [(X264_SCAN8_0 + -(8 as ::core::ffi::c_int) + 4 as ::core::ffi::c_int) as usize]
            as ::core::ffi::c_int;
        if ref_3 > i_maxref && ref_3 != (*h).mb.ref_blind_dupe {
            i_maxref = ref_3;
        }
        let mut ref_4: ::core::ffi::c_int = (*h).mb.cache.ref_0[0 as ::core::ffi::c_int as usize]
            [(X264_SCAN8_0 + 0 as ::core::ffi::c_int - 1 as ::core::ffi::c_int) as usize]
            as ::core::ffi::c_int;
        if ref_4 > i_maxref && ref_4 != (*h).mb.ref_blind_dupe {
            i_maxref = ref_4;
        }
        let mut ref_5: ::core::ffi::c_int = (*h).mb.cache.ref_0[0 as ::core::ffi::c_int as usize]
            [(X264_SCAN8_0 + 2 as ::core::ffi::c_int * 8 as ::core::ffi::c_int
                - 1 as ::core::ffi::c_int) as usize]
            as ::core::ffi::c_int;
        if ref_5 > i_maxref && ref_5 != (*h).mb.ref_blind_dupe {
            i_maxref = ref_5;
        }
    }
    let mut i_ref: ::core::ffi::c_int = 0 as ::core::ffi::c_int;
    while i_ref <= i_maxref {
        (*((*(*(*a).l0.mvc.as_mut_ptr().offset(i_ref as isize))
            .as_mut_ptr()
            .offset(0 as ::core::ffi::c_int as isize))
        .as_mut_ptr() as *mut x264_union32_t))
            .i = (*((*(*(*(*h)
            .mb
            .mvr
            .as_mut_ptr()
            .offset(0 as ::core::ffi::c_int as isize))
        .as_mut_ptr()
        .offset(i_ref as isize))
        .offset((*h).mb.i_mb_xy as isize))
        .as_mut_ptr() as *mut x264_union32_t))
            .i;
        i_ref += 1;
    }
    let mut i: ::core::ffi::c_int = 0 as ::core::ffi::c_int;
    while i < 4 as ::core::ffi::c_int {
        let mut l0m: *mut x264_me_t =
            &mut *(*a).l0.me8x8.as_mut_ptr().offset(i as isize) as *mut x264_me_t;
        let mut x8: ::core::ffi::c_int = i & 1 as ::core::ffi::c_int;
        let mut y8: ::core::ffi::c_int = i >> 1 as ::core::ffi::c_int;
        m.i_pixel = PIXEL_8x8 as ::core::ffi::c_int;
        m.p_cost_mv = (*a).p_cost_mv;
        m.i_stride[0 as ::core::ffi::c_int as usize] =
            (*h).mb.pic.i_stride[0 as ::core::ffi::c_int as usize];
        m.i_stride[1 as ::core::ffi::c_int as usize] =
            (*h).mb.pic.i_stride[1 as ::core::ffi::c_int as usize];
        m.i_stride[2 as ::core::ffi::c_int as usize] =
            (*h).mb.pic.i_stride[2 as ::core::ffi::c_int as usize];
        m.p_fenc[0 as ::core::ffi::c_int as usize] = &mut *(*p_fenc
            .offset(0 as ::core::ffi::c_int as isize))
        .offset(
            (8 as ::core::ffi::c_int * x8 + 8 as ::core::ffi::c_int * y8 * FENC_STRIDE) as isize,
        ) as *mut pixel;
        if (*(*h).sps.as_mut_ptr()).i_chroma_format_idc != 0 {
            m.p_fenc[1 as ::core::ffi::c_int as usize] =
                &mut *(*p_fenc.offset(1 as ::core::ffi::c_int as isize)).offset(
                    ((8 as ::core::ffi::c_int * x8 >> (*h).mb.chroma_h_shift)
                        + (8 as ::core::ffi::c_int * y8 >> (*h).mb.chroma_v_shift) * FENC_STRIDE)
                        as isize,
                ) as *mut pixel;
            m.p_fenc[2 as ::core::ffi::c_int as usize] =
                &mut *(*p_fenc.offset(2 as ::core::ffi::c_int as isize)).offset(
                    ((8 as ::core::ffi::c_int * x8 >> (*h).mb.chroma_h_shift)
                        + (8 as ::core::ffi::c_int * y8 >> (*h).mb.chroma_v_shift) * FENC_STRIDE)
                        as isize,
                ) as *mut pixel;
        }
        (*l0m).cost = INT_MAX;
        let mut i_ref_0: ::core::ffi::c_int = 0 as ::core::ffi::c_int;
        while i_ref_0 <= i_maxref || i_ref_0 == (*h).mb.ref_blind_dupe {
            m.i_ref_cost = *(*a).p_cost_ref[0 as ::core::ffi::c_int as usize]
                .offset(i_ref_0 as isize) as ::core::ffi::c_int;
            m.p_fref[0 as ::core::ffi::c_int as usize] = &mut *(*(*(*(*h)
                .mb
                .pic
                .p_fref
                .as_mut_ptr()
                .offset(0 as ::core::ffi::c_int as isize))
            .as_mut_ptr()
            .offset(i_ref_0 as isize))
            .as_mut_ptr()
            .offset(0 as ::core::ffi::c_int as isize))
            .offset(
                (8 as ::core::ffi::c_int * x8
                    + 8 as ::core::ffi::c_int
                        * y8
                        * *m.i_stride
                            .as_mut_ptr()
                            .offset(0 as ::core::ffi::c_int as isize)) as isize,
            ) as *mut pixel;
            m.p_fref_w = m.p_fref[0 as ::core::ffi::c_int as usize];
            if (*h).param.analyse.i_subpel_refine != 0 {
                m.p_fref[1 as ::core::ffi::c_int as usize] = &mut *(*(*(*(*h)
                    .mb
                    .pic
                    .p_fref
                    .as_mut_ptr()
                    .offset(0 as ::core::ffi::c_int as isize))
                .as_mut_ptr()
                .offset(i_ref_0 as isize))
                .as_mut_ptr()
                .offset(1 as ::core::ffi::c_int as isize))
                .offset(
                    (8 as ::core::ffi::c_int * x8
                        + 8 as ::core::ffi::c_int
                            * y8
                            * *m.i_stride
                                .as_mut_ptr()
                                .offset(0 as ::core::ffi::c_int as isize))
                        as isize,
                ) as *mut pixel;
                m.p_fref[2 as ::core::ffi::c_int as usize] = &mut *(*(*(*(*h)
                    .mb
                    .pic
                    .p_fref
                    .as_mut_ptr()
                    .offset(0 as ::core::ffi::c_int as isize))
                .as_mut_ptr()
                .offset(i_ref_0 as isize))
                .as_mut_ptr()
                .offset(2 as ::core::ffi::c_int as isize))
                .offset(
                    (8 as ::core::ffi::c_int * x8
                        + 8 as ::core::ffi::c_int
                            * y8
                            * *m.i_stride
                                .as_mut_ptr()
                                .offset(0 as ::core::ffi::c_int as isize))
                        as isize,
                ) as *mut pixel;
                m.p_fref[3 as ::core::ffi::c_int as usize] = &mut *(*(*(*(*h)
                    .mb
                    .pic
                    .p_fref
                    .as_mut_ptr()
                    .offset(0 as ::core::ffi::c_int as isize))
                .as_mut_ptr()
                .offset(i_ref_0 as isize))
                .as_mut_ptr()
                .offset(3 as ::core::ffi::c_int as isize))
                .offset(
                    (8 as ::core::ffi::c_int * x8
                        + 8 as ::core::ffi::c_int
                            * y8
                            * *m.i_stride
                                .as_mut_ptr()
                                .offset(0 as ::core::ffi::c_int as isize))
                        as isize,
                ) as *mut pixel;
            }
            if (*(*h).sps.as_mut_ptr()).i_chroma_format_idc == CHROMA_444 as ::core::ffi::c_int {
                m.p_fref[4 as ::core::ffi::c_int as usize] = &mut *(*(*(*(*h)
                    .mb
                    .pic
                    .p_fref
                    .as_mut_ptr()
                    .offset(0 as ::core::ffi::c_int as isize))
                .as_mut_ptr()
                .offset(i_ref_0 as isize))
                .as_mut_ptr()
                .offset(4 as ::core::ffi::c_int as isize))
                .offset(
                    (8 as ::core::ffi::c_int * x8
                        + 8 as ::core::ffi::c_int
                            * y8
                            * *m.i_stride
                                .as_mut_ptr()
                                .offset(1 as ::core::ffi::c_int as isize))
                        as isize,
                ) as *mut pixel;
                m.p_fref[8 as ::core::ffi::c_int as usize] = &mut *(*(*(*(*h)
                    .mb
                    .pic
                    .p_fref
                    .as_mut_ptr()
                    .offset(0 as ::core::ffi::c_int as isize))
                .as_mut_ptr()
                .offset(i_ref_0 as isize))
                .as_mut_ptr()
                .offset(8 as ::core::ffi::c_int as isize))
                .offset(
                    (8 as ::core::ffi::c_int * x8
                        + 8 as ::core::ffi::c_int
                            * y8
                            * *m.i_stride
                                .as_mut_ptr()
                                .offset(2 as ::core::ffi::c_int as isize))
                        as isize,
                ) as *mut pixel;
                if (*h).param.analyse.i_subpel_refine != 0 {
                    m.p_fref[5 as ::core::ffi::c_int as usize] = &mut *(*(*(*(*h)
                        .mb
                        .pic
                        .p_fref
                        .as_mut_ptr()
                        .offset(0 as ::core::ffi::c_int as isize))
                    .as_mut_ptr()
                    .offset(i_ref_0 as isize))
                    .as_mut_ptr()
                    .offset(5 as ::core::ffi::c_int as isize))
                    .offset(
                        (8 as ::core::ffi::c_int * x8
                            + 8 as ::core::ffi::c_int
                                * y8
                                * *m.i_stride
                                    .as_mut_ptr()
                                    .offset(1 as ::core::ffi::c_int as isize))
                            as isize,
                    )
                        as *mut pixel;
                    m.p_fref[6 as ::core::ffi::c_int as usize] = &mut *(*(*(*(*h)
                        .mb
                        .pic
                        .p_fref
                        .as_mut_ptr()
                        .offset(0 as ::core::ffi::c_int as isize))
                    .as_mut_ptr()
                    .offset(i_ref_0 as isize))
                    .as_mut_ptr()
                    .offset(6 as ::core::ffi::c_int as isize))
                    .offset(
                        (8 as ::core::ffi::c_int * x8
                            + 8 as ::core::ffi::c_int
                                * y8
                                * *m.i_stride
                                    .as_mut_ptr()
                                    .offset(1 as ::core::ffi::c_int as isize))
                            as isize,
                    )
                        as *mut pixel;
                    m.p_fref[7 as ::core::ffi::c_int as usize] = &mut *(*(*(*(*h)
                        .mb
                        .pic
                        .p_fref
                        .as_mut_ptr()
                        .offset(0 as ::core::ffi::c_int as isize))
                    .as_mut_ptr()
                    .offset(i_ref_0 as isize))
                    .as_mut_ptr()
                    .offset(7 as ::core::ffi::c_int as isize))
                    .offset(
                        (8 as ::core::ffi::c_int * x8
                            + 8 as ::core::ffi::c_int
                                * y8
                                * *m.i_stride
                                    .as_mut_ptr()
                                    .offset(1 as ::core::ffi::c_int as isize))
                            as isize,
                    )
                        as *mut pixel;
                    m.p_fref[9 as ::core::ffi::c_int as usize] = &mut *(*(*(*(*h)
                        .mb
                        .pic
                        .p_fref
                        .as_mut_ptr()
                        .offset(0 as ::core::ffi::c_int as isize))
                    .as_mut_ptr()
                    .offset(i_ref_0 as isize))
                    .as_mut_ptr()
                    .offset(9 as ::core::ffi::c_int as isize))
                    .offset(
                        (8 as ::core::ffi::c_int * x8
                            + 8 as ::core::ffi::c_int
                                * y8
                                * *m.i_stride
                                    .as_mut_ptr()
                                    .offset(2 as ::core::ffi::c_int as isize))
                            as isize,
                    )
                        as *mut pixel;
                    m.p_fref[10 as ::core::ffi::c_int as usize] = &mut *(*(*(*(*h)
                        .mb
                        .pic
                        .p_fref
                        .as_mut_ptr()
                        .offset(0 as ::core::ffi::c_int as isize))
                    .as_mut_ptr()
                    .offset(i_ref_0 as isize))
                    .as_mut_ptr()
                    .offset(10 as ::core::ffi::c_int as isize))
                    .offset(
                        (8 as ::core::ffi::c_int * x8
                            + 8 as ::core::ffi::c_int
                                * y8
                                * *m.i_stride
                                    .as_mut_ptr()
                                    .offset(2 as ::core::ffi::c_int as isize))
                            as isize,
                    )
                        as *mut pixel;
                    m.p_fref[11 as ::core::ffi::c_int as usize] = &mut *(*(*(*(*h)
                        .mb
                        .pic
                        .p_fref
                        .as_mut_ptr()
                        .offset(0 as ::core::ffi::c_int as isize))
                    .as_mut_ptr()
                    .offset(i_ref_0 as isize))
                    .as_mut_ptr()
                    .offset(11 as ::core::ffi::c_int as isize))
                    .offset(
                        (8 as ::core::ffi::c_int * x8
                            + 8 as ::core::ffi::c_int
                                * y8
                                * *m.i_stride
                                    .as_mut_ptr()
                                    .offset(2 as ::core::ffi::c_int as isize))
                            as isize,
                    )
                        as *mut pixel;
                }
            } else if (*(*h).sps.as_mut_ptr()).i_chroma_format_idc != 0 {
                m.p_fref[4 as ::core::ffi::c_int as usize] = &mut *(*(*(*(*h)
                    .mb
                    .pic
                    .p_fref
                    .as_mut_ptr()
                    .offset(0 as ::core::ffi::c_int as isize))
                .as_mut_ptr()
                .offset(i_ref_0 as isize))
                .as_mut_ptr()
                .offset(4 as ::core::ffi::c_int as isize))
                .offset(
                    (8 as ::core::ffi::c_int * x8
                        + (8 as ::core::ffi::c_int * y8 >> (*h).mb.chroma_v_shift)
                            * *m.i_stride
                                .as_mut_ptr()
                                .offset(1 as ::core::ffi::c_int as isize))
                        as isize,
                ) as *mut pixel;
            }
            if (*h).param.analyse.i_me_method >= X264_ME_ESA {
                m.integral = &mut *(*(*(*h)
                    .mb
                    .pic
                    .p_integral
                    .as_mut_ptr()
                    .offset(0 as ::core::ffi::c_int as isize))
                .as_mut_ptr()
                .offset(i_ref_0 as isize))
                .offset(
                    (8 as ::core::ffi::c_int * x8
                        + 8 as ::core::ffi::c_int
                            * y8
                            * *m.i_stride
                                .as_mut_ptr()
                                .offset(0 as ::core::ffi::c_int as isize))
                        as isize,
                ) as *mut uint16_t;
            }
            m.weight = x264_zero.as_mut_ptr() as *const x264_weight_t;
            m.i_ref = i_ref_0;
            m.p_fref_w = &mut *(*(*h).mb.pic.p_fref_w.as_mut_ptr().offset(i_ref_0 as isize)).offset(
                (8 as ::core::ffi::c_int * x8
                    + 8 as ::core::ffi::c_int
                        * y8
                        * *m.i_stride
                            .as_mut_ptr()
                            .offset(0 as ::core::ffi::c_int as isize)) as isize,
            ) as *mut pixel;
            m.weight = (*(*h).sh.weight.as_mut_ptr().offset(i_ref_0 as isize)).as_mut_ptr();
            x264_macroblock_cache_ref(
                h,
                2 as ::core::ffi::c_int * x8,
                2 as ::core::ffi::c_int * y8,
                2 as ::core::ffi::c_int,
                2 as ::core::ffi::c_int,
                0 as ::core::ffi::c_int,
                i_ref_0 as int8_t,
            );
            x264_10_mb_predict_mv(
                h,
                0 as ::core::ffi::c_int,
                4 as ::core::ffi::c_int * i,
                2 as ::core::ffi::c_int,
                m.mvp.as_mut_ptr(),
            );
            if (*h).mb.ref_blind_dupe == i_ref_0 {
                (*(m.mv.as_mut_ptr() as *mut x264_union32_t)).i = (*((*(*(*a)
                    .l0
                    .mvc
                    .as_mut_ptr()
                    .offset(0 as ::core::ffi::c_int as isize))
                .as_mut_ptr()
                .offset((i + 1 as ::core::ffi::c_int) as isize))
                .as_mut_ptr()
                    as *mut x264_union32_t))
                    .i;
                x264_10_me_refine_qpel_refdupe(h, &mut m, 0 as *mut ::core::ffi::c_int);
            } else {
                x264_10_me_search_ref(
                    h,
                    &mut m,
                    (*(*a).l0.mvc.as_mut_ptr().offset(i_ref_0 as isize)).as_mut_ptr()
                        as *mut [int16_t; 2],
                    i + 1 as ::core::ffi::c_int,
                    0 as *mut ::core::ffi::c_int,
                );
            }
            m.cost += m.i_ref_cost;
            (*((*(*(*a).l0.mvc.as_mut_ptr().offset(i_ref_0 as isize))
                .as_mut_ptr()
                .offset((i + 1 as ::core::ffi::c_int) as isize))
            .as_mut_ptr() as *mut x264_union32_t))
                .i = (*(m.mv.as_mut_ptr() as *mut x264_union32_t)).i;
            if m.cost < (*l0m).cost {
                (*h).mc.memcpy_aligned.expect("non-null function pointer")(
                    l0m as *mut ::core::ffi::c_void,
                    &mut m as *mut x264_me_t as *const ::core::ffi::c_void,
                    ::core::mem::size_of::<x264_me_t>() as size_t,
                );
            }
            if i_ref_0 == i_maxref && i_maxref < (*h).mb.ref_blind_dupe {
                i_ref_0 = (*h).mb.ref_blind_dupe;
            } else {
                i_ref_0 += 1;
            }
        }
        x264_macroblock_cache_mv(
            h,
            2 as ::core::ffi::c_int * x8,
            2 as ::core::ffi::c_int * y8,
            2 as ::core::ffi::c_int,
            2 as ::core::ffi::c_int,
            0 as ::core::ffi::c_int,
            (*((*l0m).mv.as_mut_ptr() as *mut x264_union32_t)).i,
        );
        x264_macroblock_cache_ref(
            h,
            2 as ::core::ffi::c_int * x8,
            2 as ::core::ffi::c_int * y8,
            2 as ::core::ffi::c_int,
            2 as ::core::ffi::c_int,
            0 as ::core::ffi::c_int,
            (*l0m).i_ref as int8_t,
        );
        (*a).i_satd8x8[0 as ::core::ffi::c_int as usize][i as usize] =
            (*l0m).cost - ((*l0m).cost_mv + (*l0m).i_ref_cost);
        if (*h).param.b_cabac == 0 || (*h).param.analyse.inter & X264_ANALYSE_PSUB8x8 != 0 {
            (*l0m).cost += (*a).i_lambda
                * i_sub_mb_p_cost_table[D_L0_8x8 as ::core::ffi::c_int as usize]
                    as ::core::ffi::c_int;
        }
        i += 1;
    }
    (*a).l0.i_cost8x8 = (*a).l0.me8x8[0 as ::core::ffi::c_int as usize].cost
        + (*a).l0.me8x8[1 as ::core::ffi::c_int as usize].cost
        + (*a).l0.me8x8[2 as ::core::ffi::c_int as usize].cost
        + (*a).l0.me8x8[3 as ::core::ffi::c_int as usize].cost;
    if (*h).param.b_cabac == 0
        && (*a).l0.me8x8[0 as ::core::ffi::c_int as usize].i_ref
            | (*a).l0.me8x8[1 as ::core::ffi::c_int as usize].i_ref
            | (*a).l0.me8x8[2 as ::core::ffi::c_int as usize].i_ref
            | (*a).l0.me8x8[3 as ::core::ffi::c_int as usize].i_ref
            == 0
    {
        (*a).l0.i_cost8x8 -= *(*a).p_cost_ref[0 as ::core::ffi::c_int as usize]
            .offset(0 as ::core::ffi::c_int as isize)
            as ::core::ffi::c_int
            * 4 as ::core::ffi::c_int;
    }
    (*((*h).mb.i_sub_partition.as_mut_ptr() as *mut x264_union32_t)).i =
        (D_L0_8x8 as ::core::ffi::c_int * 0x1010101 as ::core::ffi::c_int) as uint32_t;
}
#[c2rust::src_loc = "1425:1"]
unsafe extern "C" fn mb_analyse_inter_p8x8(mut h: *mut x264_t, mut a: *mut x264_mb_analysis_t) {
    let i_ref: ::core::ffi::c_int = if (*h).mb.ref_blind_dupe == (*a).l0.me16x16.i_ref {
        0 as ::core::ffi::c_int
    } else {
        (*a).l0.me16x16.i_ref
    };
    let i_ref_cost: ::core::ffi::c_int = if (*h).param.b_cabac != 0 || i_ref != 0 {
        *(*a).p_cost_ref[0 as ::core::ffi::c_int as usize].offset(i_ref as isize)
            as ::core::ffi::c_int
    } else {
        0 as ::core::ffi::c_int
    };
    let mut p_fenc: *mut *mut pixel = (*h).mb.pic.p_fenc.as_mut_ptr();
    let mut i_mvc: ::core::ffi::c_int = 0;
    let mut mvc: *mut [int16_t; 2] =
        (*(*a).l0.mvc.as_mut_ptr().offset(i_ref as isize)).as_mut_ptr() as *mut [int16_t; 2];
    (*h).mb.i_partition = D_8x8 as ::core::ffi::c_int;
    i_mvc = 1 as ::core::ffi::c_int;
    (*((*mvc.offset(0 as ::core::ffi::c_int as isize)).as_mut_ptr() as *mut x264_union32_t)).i =
        (*((*a).l0.me16x16.mv.as_mut_ptr() as *mut x264_union32_t)).i;
    let mut i: ::core::ffi::c_int = 0 as ::core::ffi::c_int;
    while i < 4 as ::core::ffi::c_int {
        let mut m: *mut x264_me_t =
            &mut *(*a).l0.me8x8.as_mut_ptr().offset(i as isize) as *mut x264_me_t;
        let mut x8: ::core::ffi::c_int = i & 1 as ::core::ffi::c_int;
        let mut y8: ::core::ffi::c_int = i >> 1 as ::core::ffi::c_int;
        (*m).i_pixel = PIXEL_8x8 as ::core::ffi::c_int;
        (*m).i_ref_cost = i_ref_cost;
        (*m).p_cost_mv = (*a).p_cost_mv;
        (*m).i_stride[0 as ::core::ffi::c_int as usize] =
            (*h).mb.pic.i_stride[0 as ::core::ffi::c_int as usize];
        (*m).i_stride[1 as ::core::ffi::c_int as usize] =
            (*h).mb.pic.i_stride[1 as ::core::ffi::c_int as usize];
        (*m).i_stride[2 as ::core::ffi::c_int as usize] =
            (*h).mb.pic.i_stride[2 as ::core::ffi::c_int as usize];
        (*m).p_fenc[0 as ::core::ffi::c_int as usize] = &mut *(*p_fenc
            .offset(0 as ::core::ffi::c_int as isize))
        .offset(
            (8 as ::core::ffi::c_int * x8 + 8 as ::core::ffi::c_int * y8 * FENC_STRIDE) as isize,
        ) as *mut pixel;
        if (*(*h).sps.as_mut_ptr()).i_chroma_format_idc != 0 {
            (*m).p_fenc[1 as ::core::ffi::c_int as usize] =
                &mut *(*p_fenc.offset(1 as ::core::ffi::c_int as isize)).offset(
                    ((8 as ::core::ffi::c_int * x8 >> (*h).mb.chroma_h_shift)
                        + (8 as ::core::ffi::c_int * y8 >> (*h).mb.chroma_v_shift) * FENC_STRIDE)
                        as isize,
                ) as *mut pixel;
            (*m).p_fenc[2 as ::core::ffi::c_int as usize] =
                &mut *(*p_fenc.offset(2 as ::core::ffi::c_int as isize)).offset(
                    ((8 as ::core::ffi::c_int * x8 >> (*h).mb.chroma_h_shift)
                        + (8 as ::core::ffi::c_int * y8 >> (*h).mb.chroma_v_shift) * FENC_STRIDE)
                        as isize,
                ) as *mut pixel;
        }
        (*m).p_fref[0 as ::core::ffi::c_int as usize] = &mut *(*(*(*(*h)
            .mb
            .pic
            .p_fref
            .as_mut_ptr()
            .offset(0 as ::core::ffi::c_int as isize))
        .as_mut_ptr()
        .offset(i_ref as isize))
        .as_mut_ptr()
        .offset(0 as ::core::ffi::c_int as isize))
        .offset(
            (8 as ::core::ffi::c_int * x8
                + 8 as ::core::ffi::c_int
                    * y8
                    * *(*m)
                        .i_stride
                        .as_mut_ptr()
                        .offset(0 as ::core::ffi::c_int as isize)) as isize,
        ) as *mut pixel;
        (*m).p_fref_w = (*m).p_fref[0 as ::core::ffi::c_int as usize];
        if (*h).param.analyse.i_subpel_refine != 0 {
            (*m).p_fref[1 as ::core::ffi::c_int as usize] = &mut *(*(*(*(*h)
                .mb
                .pic
                .p_fref
                .as_mut_ptr()
                .offset(0 as ::core::ffi::c_int as isize))
            .as_mut_ptr()
            .offset(i_ref as isize))
            .as_mut_ptr()
            .offset(1 as ::core::ffi::c_int as isize))
            .offset(
                (8 as ::core::ffi::c_int * x8
                    + 8 as ::core::ffi::c_int
                        * y8
                        * *(*m)
                            .i_stride
                            .as_mut_ptr()
                            .offset(0 as ::core::ffi::c_int as isize)) as isize,
            ) as *mut pixel;
            (*m).p_fref[2 as ::core::ffi::c_int as usize] = &mut *(*(*(*(*h)
                .mb
                .pic
                .p_fref
                .as_mut_ptr()
                .offset(0 as ::core::ffi::c_int as isize))
            .as_mut_ptr()
            .offset(i_ref as isize))
            .as_mut_ptr()
            .offset(2 as ::core::ffi::c_int as isize))
            .offset(
                (8 as ::core::ffi::c_int * x8
                    + 8 as ::core::ffi::c_int
                        * y8
                        * *(*m)
                            .i_stride
                            .as_mut_ptr()
                            .offset(0 as ::core::ffi::c_int as isize)) as isize,
            ) as *mut pixel;
            (*m).p_fref[3 as ::core::ffi::c_int as usize] = &mut *(*(*(*(*h)
                .mb
                .pic
                .p_fref
                .as_mut_ptr()
                .offset(0 as ::core::ffi::c_int as isize))
            .as_mut_ptr()
            .offset(i_ref as isize))
            .as_mut_ptr()
            .offset(3 as ::core::ffi::c_int as isize))
            .offset(
                (8 as ::core::ffi::c_int * x8
                    + 8 as ::core::ffi::c_int
                        * y8
                        * *(*m)
                            .i_stride
                            .as_mut_ptr()
                            .offset(0 as ::core::ffi::c_int as isize)) as isize,
            ) as *mut pixel;
        }
        if (*(*h).sps.as_mut_ptr()).i_chroma_format_idc == CHROMA_444 as ::core::ffi::c_int {
            (*m).p_fref[4 as ::core::ffi::c_int as usize] = &mut *(*(*(*(*h)
                .mb
                .pic
                .p_fref
                .as_mut_ptr()
                .offset(0 as ::core::ffi::c_int as isize))
            .as_mut_ptr()
            .offset(i_ref as isize))
            .as_mut_ptr()
            .offset(4 as ::core::ffi::c_int as isize))
            .offset(
                (8 as ::core::ffi::c_int * x8
                    + 8 as ::core::ffi::c_int
                        * y8
                        * *(*m)
                            .i_stride
                            .as_mut_ptr()
                            .offset(1 as ::core::ffi::c_int as isize)) as isize,
            ) as *mut pixel;
            (*m).p_fref[8 as ::core::ffi::c_int as usize] = &mut *(*(*(*(*h)
                .mb
                .pic
                .p_fref
                .as_mut_ptr()
                .offset(0 as ::core::ffi::c_int as isize))
            .as_mut_ptr()
            .offset(i_ref as isize))
            .as_mut_ptr()
            .offset(8 as ::core::ffi::c_int as isize))
            .offset(
                (8 as ::core::ffi::c_int * x8
                    + 8 as ::core::ffi::c_int
                        * y8
                        * *(*m)
                            .i_stride
                            .as_mut_ptr()
                            .offset(2 as ::core::ffi::c_int as isize)) as isize,
            ) as *mut pixel;
            if (*h).param.analyse.i_subpel_refine != 0 {
                (*m).p_fref[5 as ::core::ffi::c_int as usize] = &mut *(*(*(*(*h)
                    .mb
                    .pic
                    .p_fref
                    .as_mut_ptr()
                    .offset(0 as ::core::ffi::c_int as isize))
                .as_mut_ptr()
                .offset(i_ref as isize))
                .as_mut_ptr()
                .offset(5 as ::core::ffi::c_int as isize))
                .offset(
                    (8 as ::core::ffi::c_int * x8
                        + 8 as ::core::ffi::c_int
                            * y8
                            * *(*m)
                                .i_stride
                                .as_mut_ptr()
                                .offset(1 as ::core::ffi::c_int as isize))
                        as isize,
                ) as *mut pixel;
                (*m).p_fref[6 as ::core::ffi::c_int as usize] = &mut *(*(*(*(*h)
                    .mb
                    .pic
                    .p_fref
                    .as_mut_ptr()
                    .offset(0 as ::core::ffi::c_int as isize))
                .as_mut_ptr()
                .offset(i_ref as isize))
                .as_mut_ptr()
                .offset(6 as ::core::ffi::c_int as isize))
                .offset(
                    (8 as ::core::ffi::c_int * x8
                        + 8 as ::core::ffi::c_int
                            * y8
                            * *(*m)
                                .i_stride
                                .as_mut_ptr()
                                .offset(1 as ::core::ffi::c_int as isize))
                        as isize,
                ) as *mut pixel;
                (*m).p_fref[7 as ::core::ffi::c_int as usize] = &mut *(*(*(*(*h)
                    .mb
                    .pic
                    .p_fref
                    .as_mut_ptr()
                    .offset(0 as ::core::ffi::c_int as isize))
                .as_mut_ptr()
                .offset(i_ref as isize))
                .as_mut_ptr()
                .offset(7 as ::core::ffi::c_int as isize))
                .offset(
                    (8 as ::core::ffi::c_int * x8
                        + 8 as ::core::ffi::c_int
                            * y8
                            * *(*m)
                                .i_stride
                                .as_mut_ptr()
                                .offset(1 as ::core::ffi::c_int as isize))
                        as isize,
                ) as *mut pixel;
                (*m).p_fref[9 as ::core::ffi::c_int as usize] = &mut *(*(*(*(*h)
                    .mb
                    .pic
                    .p_fref
                    .as_mut_ptr()
                    .offset(0 as ::core::ffi::c_int as isize))
                .as_mut_ptr()
                .offset(i_ref as isize))
                .as_mut_ptr()
                .offset(9 as ::core::ffi::c_int as isize))
                .offset(
                    (8 as ::core::ffi::c_int * x8
                        + 8 as ::core::ffi::c_int
                            * y8
                            * *(*m)
                                .i_stride
                                .as_mut_ptr()
                                .offset(2 as ::core::ffi::c_int as isize))
                        as isize,
                ) as *mut pixel;
                (*m).p_fref[10 as ::core::ffi::c_int as usize] = &mut *(*(*(*(*h)
                    .mb
                    .pic
                    .p_fref
                    .as_mut_ptr()
                    .offset(0 as ::core::ffi::c_int as isize))
                .as_mut_ptr()
                .offset(i_ref as isize))
                .as_mut_ptr()
                .offset(10 as ::core::ffi::c_int as isize))
                .offset(
                    (8 as ::core::ffi::c_int * x8
                        + 8 as ::core::ffi::c_int
                            * y8
                            * *(*m)
                                .i_stride
                                .as_mut_ptr()
                                .offset(2 as ::core::ffi::c_int as isize))
                        as isize,
                ) as *mut pixel;
                (*m).p_fref[11 as ::core::ffi::c_int as usize] = &mut *(*(*(*(*h)
                    .mb
                    .pic
                    .p_fref
                    .as_mut_ptr()
                    .offset(0 as ::core::ffi::c_int as isize))
                .as_mut_ptr()
                .offset(i_ref as isize))
                .as_mut_ptr()
                .offset(11 as ::core::ffi::c_int as isize))
                .offset(
                    (8 as ::core::ffi::c_int * x8
                        + 8 as ::core::ffi::c_int
                            * y8
                            * *(*m)
                                .i_stride
                                .as_mut_ptr()
                                .offset(2 as ::core::ffi::c_int as isize))
                        as isize,
                ) as *mut pixel;
            }
        } else if (*(*h).sps.as_mut_ptr()).i_chroma_format_idc != 0 {
            (*m).p_fref[4 as ::core::ffi::c_int as usize] = &mut *(*(*(*(*h)
                .mb
                .pic
                .p_fref
                .as_mut_ptr()
                .offset(0 as ::core::ffi::c_int as isize))
            .as_mut_ptr()
            .offset(i_ref as isize))
            .as_mut_ptr()
            .offset(4 as ::core::ffi::c_int as isize))
            .offset(
                (8 as ::core::ffi::c_int * x8
                    + (8 as ::core::ffi::c_int * y8 >> (*h).mb.chroma_v_shift)
                        * *(*m)
                            .i_stride
                            .as_mut_ptr()
                            .offset(1 as ::core::ffi::c_int as isize)) as isize,
            ) as *mut pixel;
        }
        if (*h).param.analyse.i_me_method >= X264_ME_ESA {
            (*m).integral = &mut *(*(*(*h)
                .mb
                .pic
                .p_integral
                .as_mut_ptr()
                .offset(0 as ::core::ffi::c_int as isize))
            .as_mut_ptr()
            .offset(i_ref as isize))
            .offset(
                (8 as ::core::ffi::c_int * x8
                    + 8 as ::core::ffi::c_int
                        * y8
                        * *(*m)
                            .i_stride
                            .as_mut_ptr()
                            .offset(0 as ::core::ffi::c_int as isize)) as isize,
            ) as *mut uint16_t;
        }
        (*m).weight = x264_zero.as_mut_ptr() as *const x264_weight_t;
        (*m).i_ref = i_ref;
        (*m).p_fref_w = &mut *(*(*h).mb.pic.p_fref_w.as_mut_ptr().offset(i_ref as isize)).offset(
            (8 as ::core::ffi::c_int * x8
                + 8 as ::core::ffi::c_int
                    * y8
                    * *(*m)
                        .i_stride
                        .as_mut_ptr()
                        .offset(0 as ::core::ffi::c_int as isize)) as isize,
        ) as *mut pixel;
        (*m).weight = (*(*h).sh.weight.as_mut_ptr().offset(i_ref as isize)).as_mut_ptr();
        x264_10_mb_predict_mv(
            h,
            0 as ::core::ffi::c_int,
            4 as ::core::ffi::c_int * i,
            2 as ::core::ffi::c_int,
            (*m).mvp.as_mut_ptr(),
        );
        x264_10_me_search_ref(h, m, mvc, i_mvc, 0 as *mut ::core::ffi::c_int);
        x264_macroblock_cache_mv(
            h,
            2 as ::core::ffi::c_int * x8,
            2 as ::core::ffi::c_int * y8,
            2 as ::core::ffi::c_int,
            2 as ::core::ffi::c_int,
            0 as ::core::ffi::c_int,
            (*((*m).mv.as_mut_ptr() as *mut x264_union32_t)).i,
        );
        (*((*mvc.offset(i_mvc as isize)).as_mut_ptr() as *mut x264_union32_t)).i =
            (*((*m).mv.as_mut_ptr() as *mut x264_union32_t)).i;
        i_mvc += 1;
        (*a).i_satd8x8[0 as ::core::ffi::c_int as usize][i as usize] = (*m).cost - (*m).cost_mv;
        (*m).cost += i_ref_cost;
        if (*h).param.b_cabac == 0 || (*h).param.analyse.inter & X264_ANALYSE_PSUB8x8 != 0 {
            (*m).cost += (*a).i_lambda
                * i_sub_mb_p_cost_table[D_L0_8x8 as ::core::ffi::c_int as usize]
                    as ::core::ffi::c_int;
        }
        i += 1;
    }
    (*a).l0.i_cost8x8 = (*a).l0.me8x8[0 as ::core::ffi::c_int as usize].cost
        + (*a).l0.me8x8[1 as ::core::ffi::c_int as usize].cost
        + (*a).l0.me8x8[2 as ::core::ffi::c_int as usize].cost
        + (*a).l0.me8x8[3 as ::core::ffi::c_int as usize].cost;
    if (*h).param.b_cabac != 0 {
        (*a).l0.i_cost8x8 -= i_ref_cost;
    }
    (*((*h).mb.i_sub_partition.as_mut_ptr() as *mut x264_union32_t)).i =
        (D_L0_8x8 as ::core::ffi::c_int * 0x1010101 as ::core::ffi::c_int) as uint32_t;
}
#[c2rust::src_loc = "1480:1"]
unsafe extern "C" fn mb_analyse_inter_p16x8(
    mut h: *mut x264_t,
    mut a: *mut x264_mb_analysis_t,
    mut i_best_satd: ::core::ffi::c_int,
) {
    let mut m: x264_me_t = x264_me_t {
        i_pixel: 0,
        p_cost_mv: 0 as *mut uint16_t,
        i_ref_cost: 0,
        i_ref: 0,
        weight: 0 as *const x264_weight_t,
        p_fref: [0 as *mut pixel; 12],
        p_fref_w: 0 as *mut pixel,
        p_fenc: [0 as *mut pixel; 3],
        integral: 0 as *mut uint16_t,
        i_stride: [0; 3],
        mvp: [0; 2],
        cost_mv: 0,
        cost: 0,
        mv: [0; 2],
    };
    let mut p_fenc: *mut *mut pixel = (*h).mb.pic.p_fenc.as_mut_ptr();
    let mut mvc: [[int16_t; 2]; 3] = [[0; 2]; 3];
    (*h).mb.i_partition = D_16x8 as ::core::ffi::c_int;
    let mut i: ::core::ffi::c_int = 0 as ::core::ffi::c_int;
    while i < 2 as ::core::ffi::c_int {
        let mut l0m: *mut x264_me_t =
            &mut *(*a).l0.me16x8.as_mut_ptr().offset(i as isize) as *mut x264_me_t;
        let minref: ::core::ffi::c_int = if (*a).l0.me8x8[(2 as ::core::ffi::c_int * i) as usize]
            .i_ref
            < (*a).l0.me8x8[(2 as ::core::ffi::c_int * i + 1 as ::core::ffi::c_int) as usize].i_ref
        {
            (*a).l0.me8x8[(2 as ::core::ffi::c_int * i) as usize].i_ref
        } else {
            (*a).l0.me8x8[(2 as ::core::ffi::c_int * i + 1 as ::core::ffi::c_int) as usize].i_ref
        };
        let maxref: ::core::ffi::c_int = if (*a).l0.me8x8[(2 as ::core::ffi::c_int * i) as usize]
            .i_ref
            > (*a).l0.me8x8[(2 as ::core::ffi::c_int * i + 1 as ::core::ffi::c_int) as usize].i_ref
        {
            (*a).l0.me8x8[(2 as ::core::ffi::c_int * i) as usize].i_ref
        } else {
            (*a).l0.me8x8[(2 as ::core::ffi::c_int * i + 1 as ::core::ffi::c_int) as usize].i_ref
        };
        let ref8: [::core::ffi::c_int; 2] = [minref, maxref];
        let i_ref8s: ::core::ffi::c_int =
            if ref8[0 as ::core::ffi::c_int as usize] == ref8[1 as ::core::ffi::c_int as usize] {
                1 as ::core::ffi::c_int
            } else {
                2 as ::core::ffi::c_int
            };
        m.i_pixel = PIXEL_16x8 as ::core::ffi::c_int;
        m.p_cost_mv = (*a).p_cost_mv;
        m.i_stride[0 as ::core::ffi::c_int as usize] =
            (*h).mb.pic.i_stride[0 as ::core::ffi::c_int as usize];
        m.i_stride[1 as ::core::ffi::c_int as usize] =
            (*h).mb.pic.i_stride[1 as ::core::ffi::c_int as usize];
        m.i_stride[2 as ::core::ffi::c_int as usize] =
            (*h).mb.pic.i_stride[2 as ::core::ffi::c_int as usize];
        m.p_fenc[0 as ::core::ffi::c_int as usize] = &mut *(*p_fenc
            .offset(0 as ::core::ffi::c_int as isize))
        .offset((0 as ::core::ffi::c_int + 8 as ::core::ffi::c_int * i * FENC_STRIDE) as isize)
            as *mut pixel;
        if (*(*h).sps.as_mut_ptr()).i_chroma_format_idc != 0 {
            m.p_fenc[1 as ::core::ffi::c_int as usize] =
                &mut *(*p_fenc.offset(1 as ::core::ffi::c_int as isize)).offset(
                    ((0 as ::core::ffi::c_int >> (*h).mb.chroma_h_shift)
                        + (8 as ::core::ffi::c_int * i >> (*h).mb.chroma_v_shift) * FENC_STRIDE)
                        as isize,
                ) as *mut pixel;
            m.p_fenc[2 as ::core::ffi::c_int as usize] =
                &mut *(*p_fenc.offset(2 as ::core::ffi::c_int as isize)).offset(
                    ((0 as ::core::ffi::c_int >> (*h).mb.chroma_h_shift)
                        + (8 as ::core::ffi::c_int * i >> (*h).mb.chroma_v_shift) * FENC_STRIDE)
                        as isize,
                ) as *mut pixel;
        }
        (*l0m).cost = INT_MAX;
        let mut j: ::core::ffi::c_int = 0 as ::core::ffi::c_int;
        while j < i_ref8s {
            let i_ref: ::core::ffi::c_int = ref8[j as usize];
            m.i_ref_cost = *(*a).p_cost_ref[0 as ::core::ffi::c_int as usize].offset(i_ref as isize)
                as ::core::ffi::c_int;
            (*((*mvc.as_mut_ptr().offset(0 as ::core::ffi::c_int as isize)).as_mut_ptr()
                as *mut x264_union32_t))
                .i = (*((*(*(*a).l0.mvc.as_mut_ptr().offset(i_ref as isize))
                .as_mut_ptr()
                .offset(0 as ::core::ffi::c_int as isize))
            .as_mut_ptr() as *mut x264_union32_t))
                .i;
            (*((*mvc.as_mut_ptr().offset(1 as ::core::ffi::c_int as isize)).as_mut_ptr()
                as *mut x264_union32_t))
                .i = (*((*(*(*a).l0.mvc.as_mut_ptr().offset(i_ref as isize))
                .as_mut_ptr()
                .offset((2 as ::core::ffi::c_int * i + 1 as ::core::ffi::c_int) as isize))
            .as_mut_ptr() as *mut x264_union32_t))
                .i;
            (*((*mvc.as_mut_ptr().offset(2 as ::core::ffi::c_int as isize)).as_mut_ptr()
                as *mut x264_union32_t))
                .i = (*((*(*(*a).l0.mvc.as_mut_ptr().offset(i_ref as isize))
                .as_mut_ptr()
                .offset((2 as ::core::ffi::c_int * i + 2 as ::core::ffi::c_int) as isize))
            .as_mut_ptr() as *mut x264_union32_t))
                .i;
            m.p_fref[0 as ::core::ffi::c_int as usize] = &mut *(*(*(*(*h)
                .mb
                .pic
                .p_fref
                .as_mut_ptr()
                .offset(0 as ::core::ffi::c_int as isize))
            .as_mut_ptr()
            .offset(i_ref as isize))
            .as_mut_ptr()
            .offset(0 as ::core::ffi::c_int as isize))
            .offset(
                (0 as ::core::ffi::c_int
                    + 8 as ::core::ffi::c_int
                        * i
                        * *m.i_stride
                            .as_mut_ptr()
                            .offset(0 as ::core::ffi::c_int as isize)) as isize,
            ) as *mut pixel;
            m.p_fref_w = m.p_fref[0 as ::core::ffi::c_int as usize];
            if (*h).param.analyse.i_subpel_refine != 0 {
                m.p_fref[1 as ::core::ffi::c_int as usize] = &mut *(*(*(*(*h)
                    .mb
                    .pic
                    .p_fref
                    .as_mut_ptr()
                    .offset(0 as ::core::ffi::c_int as isize))
                .as_mut_ptr()
                .offset(i_ref as isize))
                .as_mut_ptr()
                .offset(1 as ::core::ffi::c_int as isize))
                .offset(
                    (0 as ::core::ffi::c_int
                        + 8 as ::core::ffi::c_int
                            * i
                            * *m.i_stride
                                .as_mut_ptr()
                                .offset(0 as ::core::ffi::c_int as isize))
                        as isize,
                ) as *mut pixel;
                m.p_fref[2 as ::core::ffi::c_int as usize] = &mut *(*(*(*(*h)
                    .mb
                    .pic
                    .p_fref
                    .as_mut_ptr()
                    .offset(0 as ::core::ffi::c_int as isize))
                .as_mut_ptr()
                .offset(i_ref as isize))
                .as_mut_ptr()
                .offset(2 as ::core::ffi::c_int as isize))
                .offset(
                    (0 as ::core::ffi::c_int
                        + 8 as ::core::ffi::c_int
                            * i
                            * *m.i_stride
                                .as_mut_ptr()
                                .offset(0 as ::core::ffi::c_int as isize))
                        as isize,
                ) as *mut pixel;
                m.p_fref[3 as ::core::ffi::c_int as usize] = &mut *(*(*(*(*h)
                    .mb
                    .pic
                    .p_fref
                    .as_mut_ptr()
                    .offset(0 as ::core::ffi::c_int as isize))
                .as_mut_ptr()
                .offset(i_ref as isize))
                .as_mut_ptr()
                .offset(3 as ::core::ffi::c_int as isize))
                .offset(
                    (0 as ::core::ffi::c_int
                        + 8 as ::core::ffi::c_int
                            * i
                            * *m.i_stride
                                .as_mut_ptr()
                                .offset(0 as ::core::ffi::c_int as isize))
                        as isize,
                ) as *mut pixel;
            }
            if (*(*h).sps.as_mut_ptr()).i_chroma_format_idc == CHROMA_444 as ::core::ffi::c_int {
                m.p_fref[4 as ::core::ffi::c_int as usize] = &mut *(*(*(*(*h)
                    .mb
                    .pic
                    .p_fref
                    .as_mut_ptr()
                    .offset(0 as ::core::ffi::c_int as isize))
                .as_mut_ptr()
                .offset(i_ref as isize))
                .as_mut_ptr()
                .offset(4 as ::core::ffi::c_int as isize))
                .offset(
                    (0 as ::core::ffi::c_int
                        + 8 as ::core::ffi::c_int
                            * i
                            * *m.i_stride
                                .as_mut_ptr()
                                .offset(1 as ::core::ffi::c_int as isize))
                        as isize,
                ) as *mut pixel;
                m.p_fref[8 as ::core::ffi::c_int as usize] = &mut *(*(*(*(*h)
                    .mb
                    .pic
                    .p_fref
                    .as_mut_ptr()
                    .offset(0 as ::core::ffi::c_int as isize))
                .as_mut_ptr()
                .offset(i_ref as isize))
                .as_mut_ptr()
                .offset(8 as ::core::ffi::c_int as isize))
                .offset(
                    (0 as ::core::ffi::c_int
                        + 8 as ::core::ffi::c_int
                            * i
                            * *m.i_stride
                                .as_mut_ptr()
                                .offset(2 as ::core::ffi::c_int as isize))
                        as isize,
                ) as *mut pixel;
                if (*h).param.analyse.i_subpel_refine != 0 {
                    m.p_fref[5 as ::core::ffi::c_int as usize] = &mut *(*(*(*(*h)
                        .mb
                        .pic
                        .p_fref
                        .as_mut_ptr()
                        .offset(0 as ::core::ffi::c_int as isize))
                    .as_mut_ptr()
                    .offset(i_ref as isize))
                    .as_mut_ptr()
                    .offset(5 as ::core::ffi::c_int as isize))
                    .offset(
                        (0 as ::core::ffi::c_int
                            + 8 as ::core::ffi::c_int
                                * i
                                * *m.i_stride
                                    .as_mut_ptr()
                                    .offset(1 as ::core::ffi::c_int as isize))
                            as isize,
                    )
                        as *mut pixel;
                    m.p_fref[6 as ::core::ffi::c_int as usize] = &mut *(*(*(*(*h)
                        .mb
                        .pic
                        .p_fref
                        .as_mut_ptr()
                        .offset(0 as ::core::ffi::c_int as isize))
                    .as_mut_ptr()
                    .offset(i_ref as isize))
                    .as_mut_ptr()
                    .offset(6 as ::core::ffi::c_int as isize))
                    .offset(
                        (0 as ::core::ffi::c_int
                            + 8 as ::core::ffi::c_int
                                * i
                                * *m.i_stride
                                    .as_mut_ptr()
                                    .offset(1 as ::core::ffi::c_int as isize))
                            as isize,
                    )
                        as *mut pixel;
                    m.p_fref[7 as ::core::ffi::c_int as usize] = &mut *(*(*(*(*h)
                        .mb
                        .pic
                        .p_fref
                        .as_mut_ptr()
                        .offset(0 as ::core::ffi::c_int as isize))
                    .as_mut_ptr()
                    .offset(i_ref as isize))
                    .as_mut_ptr()
                    .offset(7 as ::core::ffi::c_int as isize))
                    .offset(
                        (0 as ::core::ffi::c_int
                            + 8 as ::core::ffi::c_int
                                * i
                                * *m.i_stride
                                    .as_mut_ptr()
                                    .offset(1 as ::core::ffi::c_int as isize))
                            as isize,
                    )
                        as *mut pixel;
                    m.p_fref[9 as ::core::ffi::c_int as usize] = &mut *(*(*(*(*h)
                        .mb
                        .pic
                        .p_fref
                        .as_mut_ptr()
                        .offset(0 as ::core::ffi::c_int as isize))
                    .as_mut_ptr()
                    .offset(i_ref as isize))
                    .as_mut_ptr()
                    .offset(9 as ::core::ffi::c_int as isize))
                    .offset(
                        (0 as ::core::ffi::c_int
                            + 8 as ::core::ffi::c_int
                                * i
                                * *m.i_stride
                                    .as_mut_ptr()
                                    .offset(2 as ::core::ffi::c_int as isize))
                            as isize,
                    )
                        as *mut pixel;
                    m.p_fref[10 as ::core::ffi::c_int as usize] = &mut *(*(*(*(*h)
                        .mb
                        .pic
                        .p_fref
                        .as_mut_ptr()
                        .offset(0 as ::core::ffi::c_int as isize))
                    .as_mut_ptr()
                    .offset(i_ref as isize))
                    .as_mut_ptr()
                    .offset(10 as ::core::ffi::c_int as isize))
                    .offset(
                        (0 as ::core::ffi::c_int
                            + 8 as ::core::ffi::c_int
                                * i
                                * *m.i_stride
                                    .as_mut_ptr()
                                    .offset(2 as ::core::ffi::c_int as isize))
                            as isize,
                    )
                        as *mut pixel;
                    m.p_fref[11 as ::core::ffi::c_int as usize] = &mut *(*(*(*(*h)
                        .mb
                        .pic
                        .p_fref
                        .as_mut_ptr()
                        .offset(0 as ::core::ffi::c_int as isize))
                    .as_mut_ptr()
                    .offset(i_ref as isize))
                    .as_mut_ptr()
                    .offset(11 as ::core::ffi::c_int as isize))
                    .offset(
                        (0 as ::core::ffi::c_int
                            + 8 as ::core::ffi::c_int
                                * i
                                * *m.i_stride
                                    .as_mut_ptr()
                                    .offset(2 as ::core::ffi::c_int as isize))
                            as isize,
                    )
                        as *mut pixel;
                }
            } else if (*(*h).sps.as_mut_ptr()).i_chroma_format_idc != 0 {
                m.p_fref[4 as ::core::ffi::c_int as usize] = &mut *(*(*(*(*h)
                    .mb
                    .pic
                    .p_fref
                    .as_mut_ptr()
                    .offset(0 as ::core::ffi::c_int as isize))
                .as_mut_ptr()
                .offset(i_ref as isize))
                .as_mut_ptr()
                .offset(4 as ::core::ffi::c_int as isize))
                .offset(
                    (0 as ::core::ffi::c_int
                        + (8 as ::core::ffi::c_int * i >> (*h).mb.chroma_v_shift)
                            * *m.i_stride
                                .as_mut_ptr()
                                .offset(1 as ::core::ffi::c_int as isize))
                        as isize,
                ) as *mut pixel;
            }
            if (*h).param.analyse.i_me_method >= X264_ME_ESA {
                m.integral = &mut *(*(*(*h)
                    .mb
                    .pic
                    .p_integral
                    .as_mut_ptr()
                    .offset(0 as ::core::ffi::c_int as isize))
                .as_mut_ptr()
                .offset(i_ref as isize))
                .offset(
                    (0 as ::core::ffi::c_int
                        + 8 as ::core::ffi::c_int
                            * i
                            * *m.i_stride
                                .as_mut_ptr()
                                .offset(0 as ::core::ffi::c_int as isize))
                        as isize,
                ) as *mut uint16_t;
            }
            m.weight = x264_zero.as_mut_ptr() as *const x264_weight_t;
            m.i_ref = i_ref;
            m.p_fref_w = &mut *(*(*h).mb.pic.p_fref_w.as_mut_ptr().offset(i_ref as isize)).offset(
                (0 as ::core::ffi::c_int
                    + 8 as ::core::ffi::c_int
                        * i
                        * *m.i_stride
                            .as_mut_ptr()
                            .offset(0 as ::core::ffi::c_int as isize)) as isize,
            ) as *mut pixel;
            m.weight = (*(*h).sh.weight.as_mut_ptr().offset(i_ref as isize)).as_mut_ptr();
            x264_macroblock_cache_ref(
                h,
                0 as ::core::ffi::c_int,
                2 as ::core::ffi::c_int * i,
                4 as ::core::ffi::c_int,
                2 as ::core::ffi::c_int,
                0 as ::core::ffi::c_int,
                i_ref as int8_t,
            );
            x264_10_mb_predict_mv(
                h,
                0 as ::core::ffi::c_int,
                8 as ::core::ffi::c_int * i,
                4 as ::core::ffi::c_int,
                m.mvp.as_mut_ptr(),
            );
            if (*h).mb.ref_blind_dupe == i_ref && ref8[0 as ::core::ffi::c_int as usize] == 0 {
                x264_10_me_refine_qpel_refdupe(h, &mut m, 0 as *mut ::core::ffi::c_int);
            } else {
                x264_10_me_search_ref(
                    h,
                    &mut m,
                    mvc.as_mut_ptr() as *mut [int16_t; 2],
                    3 as ::core::ffi::c_int,
                    0 as *mut ::core::ffi::c_int,
                );
            }
            m.cost += m.i_ref_cost;
            if m.cost < (*l0m).cost {
                (*h).mc.memcpy_aligned.expect("non-null function pointer")(
                    l0m as *mut ::core::ffi::c_void,
                    &mut m as *mut x264_me_t as *const ::core::ffi::c_void,
                    ::core::mem::size_of::<x264_me_t>() as size_t,
                );
            }
            j += 1;
        }
        if (*a).b_early_terminate != 0
            && (i == 0
                && (*l0m).cost + (*a).i_cost_est16x8[1 as ::core::ffi::c_int as usize]
                    > i_best_satd
                        * (4 as ::core::ffi::c_int + ((*a).i_mbrd != 0) as ::core::ffi::c_int)
                        / 4 as ::core::ffi::c_int)
        {
            (*a).l0.i_cost16x8 = COST_MAX;
            return;
        }
        x264_macroblock_cache_mv(
            h,
            0 as ::core::ffi::c_int,
            2 as ::core::ffi::c_int * i,
            4 as ::core::ffi::c_int,
            2 as ::core::ffi::c_int,
            0 as ::core::ffi::c_int,
            (*((*l0m).mv.as_mut_ptr() as *mut x264_union32_t)).i,
        );
        x264_macroblock_cache_ref(
            h,
            0 as ::core::ffi::c_int,
            2 as ::core::ffi::c_int * i,
            4 as ::core::ffi::c_int,
            2 as ::core::ffi::c_int,
            0 as ::core::ffi::c_int,
            (*l0m).i_ref as int8_t,
        );
        i += 1;
    }
    (*a).l0.i_cost16x8 = (*a).l0.me16x8[0 as ::core::ffi::c_int as usize].cost
        + (*a).l0.me16x8[1 as ::core::ffi::c_int as usize].cost;
}
#[c2rust::src_loc = "1546:1"]
unsafe extern "C" fn mb_analyse_inter_p8x16(
    mut h: *mut x264_t,
    mut a: *mut x264_mb_analysis_t,
    mut i_best_satd: ::core::ffi::c_int,
) {
    let mut m: x264_me_t = x264_me_t {
        i_pixel: 0,
        p_cost_mv: 0 as *mut uint16_t,
        i_ref_cost: 0,
        i_ref: 0,
        weight: 0 as *const x264_weight_t,
        p_fref: [0 as *mut pixel; 12],
        p_fref_w: 0 as *mut pixel,
        p_fenc: [0 as *mut pixel; 3],
        integral: 0 as *mut uint16_t,
        i_stride: [0; 3],
        mvp: [0; 2],
        cost_mv: 0,
        cost: 0,
        mv: [0; 2],
    };
    let mut p_fenc: *mut *mut pixel = (*h).mb.pic.p_fenc.as_mut_ptr();
    let mut mvc: [[int16_t; 2]; 3] = [[0; 2]; 3];
    (*h).mb.i_partition = D_8x16 as ::core::ffi::c_int;
    let mut i: ::core::ffi::c_int = 0 as ::core::ffi::c_int;
    while i < 2 as ::core::ffi::c_int {
        let mut l0m: *mut x264_me_t =
            &mut *(*a).l0.me8x16.as_mut_ptr().offset(i as isize) as *mut x264_me_t;
        let minref: ::core::ffi::c_int = if (*a).l0.me8x8[i as usize].i_ref
            < (*a).l0.me8x8[(i + 2 as ::core::ffi::c_int) as usize].i_ref
        {
            (*a).l0.me8x8[i as usize].i_ref
        } else {
            (*a).l0.me8x8[(i + 2 as ::core::ffi::c_int) as usize].i_ref
        };
        let maxref: ::core::ffi::c_int = if (*a).l0.me8x8[i as usize].i_ref
            > (*a).l0.me8x8[(i + 2 as ::core::ffi::c_int) as usize].i_ref
        {
            (*a).l0.me8x8[i as usize].i_ref
        } else {
            (*a).l0.me8x8[(i + 2 as ::core::ffi::c_int) as usize].i_ref
        };
        let ref8: [::core::ffi::c_int; 2] = [minref, maxref];
        let i_ref8s: ::core::ffi::c_int =
            if ref8[0 as ::core::ffi::c_int as usize] == ref8[1 as ::core::ffi::c_int as usize] {
                1 as ::core::ffi::c_int
            } else {
                2 as ::core::ffi::c_int
            };
        m.i_pixel = PIXEL_8x16 as ::core::ffi::c_int;
        m.p_cost_mv = (*a).p_cost_mv;
        m.i_stride[0 as ::core::ffi::c_int as usize] =
            (*h).mb.pic.i_stride[0 as ::core::ffi::c_int as usize];
        m.i_stride[1 as ::core::ffi::c_int as usize] =
            (*h).mb.pic.i_stride[1 as ::core::ffi::c_int as usize];
        m.i_stride[2 as ::core::ffi::c_int as usize] =
            (*h).mb.pic.i_stride[2 as ::core::ffi::c_int as usize];
        m.p_fenc[0 as ::core::ffi::c_int as usize] = &mut *(*p_fenc
            .offset(0 as ::core::ffi::c_int as isize))
        .offset((8 as ::core::ffi::c_int * i + 0 as ::core::ffi::c_int * FENC_STRIDE) as isize)
            as *mut pixel;
        if (*(*h).sps.as_mut_ptr()).i_chroma_format_idc != 0 {
            m.p_fenc[1 as ::core::ffi::c_int as usize] =
                &mut *(*p_fenc.offset(1 as ::core::ffi::c_int as isize)).offset(
                    ((8 as ::core::ffi::c_int * i >> (*h).mb.chroma_h_shift)
                        + (0 as ::core::ffi::c_int >> (*h).mb.chroma_v_shift) * FENC_STRIDE)
                        as isize,
                ) as *mut pixel;
            m.p_fenc[2 as ::core::ffi::c_int as usize] =
                &mut *(*p_fenc.offset(2 as ::core::ffi::c_int as isize)).offset(
                    ((8 as ::core::ffi::c_int * i >> (*h).mb.chroma_h_shift)
                        + (0 as ::core::ffi::c_int >> (*h).mb.chroma_v_shift) * FENC_STRIDE)
                        as isize,
                ) as *mut pixel;
        }
        (*l0m).cost = INT_MAX;
        let mut j: ::core::ffi::c_int = 0 as ::core::ffi::c_int;
        while j < i_ref8s {
            let i_ref: ::core::ffi::c_int = ref8[j as usize];
            m.i_ref_cost = *(*a).p_cost_ref[0 as ::core::ffi::c_int as usize].offset(i_ref as isize)
                as ::core::ffi::c_int;
            (*((*mvc.as_mut_ptr().offset(0 as ::core::ffi::c_int as isize)).as_mut_ptr()
                as *mut x264_union32_t))
                .i = (*((*(*(*a).l0.mvc.as_mut_ptr().offset(i_ref as isize))
                .as_mut_ptr()
                .offset(0 as ::core::ffi::c_int as isize))
            .as_mut_ptr() as *mut x264_union32_t))
                .i;
            (*((*mvc.as_mut_ptr().offset(1 as ::core::ffi::c_int as isize)).as_mut_ptr()
                as *mut x264_union32_t))
                .i = (*((*(*(*a).l0.mvc.as_mut_ptr().offset(i_ref as isize))
                .as_mut_ptr()
                .offset((i + 1 as ::core::ffi::c_int) as isize))
            .as_mut_ptr() as *mut x264_union32_t))
                .i;
            (*((*mvc.as_mut_ptr().offset(2 as ::core::ffi::c_int as isize)).as_mut_ptr()
                as *mut x264_union32_t))
                .i = (*((*(*(*a).l0.mvc.as_mut_ptr().offset(i_ref as isize))
                .as_mut_ptr()
                .offset((i + 3 as ::core::ffi::c_int) as isize))
            .as_mut_ptr() as *mut x264_union32_t))
                .i;
            m.p_fref[0 as ::core::ffi::c_int as usize] = &mut *(*(*(*(*h)
                .mb
                .pic
                .p_fref
                .as_mut_ptr()
                .offset(0 as ::core::ffi::c_int as isize))
            .as_mut_ptr()
            .offset(i_ref as isize))
            .as_mut_ptr()
            .offset(0 as ::core::ffi::c_int as isize))
            .offset(
                (8 as ::core::ffi::c_int * i
                    + 0 as ::core::ffi::c_int
                        * *m.i_stride
                            .as_mut_ptr()
                            .offset(0 as ::core::ffi::c_int as isize)) as isize,
            ) as *mut pixel;
            m.p_fref_w = m.p_fref[0 as ::core::ffi::c_int as usize];
            if (*h).param.analyse.i_subpel_refine != 0 {
                m.p_fref[1 as ::core::ffi::c_int as usize] = &mut *(*(*(*(*h)
                    .mb
                    .pic
                    .p_fref
                    .as_mut_ptr()
                    .offset(0 as ::core::ffi::c_int as isize))
                .as_mut_ptr()
                .offset(i_ref as isize))
                .as_mut_ptr()
                .offset(1 as ::core::ffi::c_int as isize))
                .offset(
                    (8 as ::core::ffi::c_int * i
                        + 0 as ::core::ffi::c_int
                            * *m.i_stride
                                .as_mut_ptr()
                                .offset(0 as ::core::ffi::c_int as isize))
                        as isize,
                ) as *mut pixel;
                m.p_fref[2 as ::core::ffi::c_int as usize] = &mut *(*(*(*(*h)
                    .mb
                    .pic
                    .p_fref
                    .as_mut_ptr()
                    .offset(0 as ::core::ffi::c_int as isize))
                .as_mut_ptr()
                .offset(i_ref as isize))
                .as_mut_ptr()
                .offset(2 as ::core::ffi::c_int as isize))
                .offset(
                    (8 as ::core::ffi::c_int * i
                        + 0 as ::core::ffi::c_int
                            * *m.i_stride
                                .as_mut_ptr()
                                .offset(0 as ::core::ffi::c_int as isize))
                        as isize,
                ) as *mut pixel;
                m.p_fref[3 as ::core::ffi::c_int as usize] = &mut *(*(*(*(*h)
                    .mb
                    .pic
                    .p_fref
                    .as_mut_ptr()
                    .offset(0 as ::core::ffi::c_int as isize))
                .as_mut_ptr()
                .offset(i_ref as isize))
                .as_mut_ptr()
                .offset(3 as ::core::ffi::c_int as isize))
                .offset(
                    (8 as ::core::ffi::c_int * i
                        + 0 as ::core::ffi::c_int
                            * *m.i_stride
                                .as_mut_ptr()
                                .offset(0 as ::core::ffi::c_int as isize))
                        as isize,
                ) as *mut pixel;
            }
            if (*(*h).sps.as_mut_ptr()).i_chroma_format_idc == CHROMA_444 as ::core::ffi::c_int {
                m.p_fref[4 as ::core::ffi::c_int as usize] = &mut *(*(*(*(*h)
                    .mb
                    .pic
                    .p_fref
                    .as_mut_ptr()
                    .offset(0 as ::core::ffi::c_int as isize))
                .as_mut_ptr()
                .offset(i_ref as isize))
                .as_mut_ptr()
                .offset(4 as ::core::ffi::c_int as isize))
                .offset(
                    (8 as ::core::ffi::c_int * i
                        + 0 as ::core::ffi::c_int
                            * *m.i_stride
                                .as_mut_ptr()
                                .offset(1 as ::core::ffi::c_int as isize))
                        as isize,
                ) as *mut pixel;
                m.p_fref[8 as ::core::ffi::c_int as usize] = &mut *(*(*(*(*h)
                    .mb
                    .pic
                    .p_fref
                    .as_mut_ptr()
                    .offset(0 as ::core::ffi::c_int as isize))
                .as_mut_ptr()
                .offset(i_ref as isize))
                .as_mut_ptr()
                .offset(8 as ::core::ffi::c_int as isize))
                .offset(
                    (8 as ::core::ffi::c_int * i
                        + 0 as ::core::ffi::c_int
                            * *m.i_stride
                                .as_mut_ptr()
                                .offset(2 as ::core::ffi::c_int as isize))
                        as isize,
                ) as *mut pixel;
                if (*h).param.analyse.i_subpel_refine != 0 {
                    m.p_fref[5 as ::core::ffi::c_int as usize] = &mut *(*(*(*(*h)
                        .mb
                        .pic
                        .p_fref
                        .as_mut_ptr()
                        .offset(0 as ::core::ffi::c_int as isize))
                    .as_mut_ptr()
                    .offset(i_ref as isize))
                    .as_mut_ptr()
                    .offset(5 as ::core::ffi::c_int as isize))
                    .offset(
                        (8 as ::core::ffi::c_int * i
                            + 0 as ::core::ffi::c_int
                                * *m.i_stride
                                    .as_mut_ptr()
                                    .offset(1 as ::core::ffi::c_int as isize))
                            as isize,
                    )
                        as *mut pixel;
                    m.p_fref[6 as ::core::ffi::c_int as usize] = &mut *(*(*(*(*h)
                        .mb
                        .pic
                        .p_fref
                        .as_mut_ptr()
                        .offset(0 as ::core::ffi::c_int as isize))
                    .as_mut_ptr()
                    .offset(i_ref as isize))
                    .as_mut_ptr()
                    .offset(6 as ::core::ffi::c_int as isize))
                    .offset(
                        (8 as ::core::ffi::c_int * i
                            + 0 as ::core::ffi::c_int
                                * *m.i_stride
                                    .as_mut_ptr()
                                    .offset(1 as ::core::ffi::c_int as isize))
                            as isize,
                    )
                        as *mut pixel;
                    m.p_fref[7 as ::core::ffi::c_int as usize] = &mut *(*(*(*(*h)
                        .mb
                        .pic
                        .p_fref
                        .as_mut_ptr()
                        .offset(0 as ::core::ffi::c_int as isize))
                    .as_mut_ptr()
                    .offset(i_ref as isize))
                    .as_mut_ptr()
                    .offset(7 as ::core::ffi::c_int as isize))
                    .offset(
                        (8 as ::core::ffi::c_int * i
                            + 0 as ::core::ffi::c_int
                                * *m.i_stride
                                    .as_mut_ptr()
                                    .offset(1 as ::core::ffi::c_int as isize))
                            as isize,
                    )
                        as *mut pixel;
                    m.p_fref[9 as ::core::ffi::c_int as usize] = &mut *(*(*(*(*h)
                        .mb
                        .pic
                        .p_fref
                        .as_mut_ptr()
                        .offset(0 as ::core::ffi::c_int as isize))
                    .as_mut_ptr()
                    .offset(i_ref as isize))
                    .as_mut_ptr()
                    .offset(9 as ::core::ffi::c_int as isize))
                    .offset(
                        (8 as ::core::ffi::c_int * i
                            + 0 as ::core::ffi::c_int
                                * *m.i_stride
                                    .as_mut_ptr()
                                    .offset(2 as ::core::ffi::c_int as isize))
                            as isize,
                    )
                        as *mut pixel;
                    m.p_fref[10 as ::core::ffi::c_int as usize] = &mut *(*(*(*(*h)
                        .mb
                        .pic
                        .p_fref
                        .as_mut_ptr()
                        .offset(0 as ::core::ffi::c_int as isize))
                    .as_mut_ptr()
                    .offset(i_ref as isize))
                    .as_mut_ptr()
                    .offset(10 as ::core::ffi::c_int as isize))
                    .offset(
                        (8 as ::core::ffi::c_int * i
                            + 0 as ::core::ffi::c_int
                                * *m.i_stride
                                    .as_mut_ptr()
                                    .offset(2 as ::core::ffi::c_int as isize))
                            as isize,
                    )
                        as *mut pixel;
                    m.p_fref[11 as ::core::ffi::c_int as usize] = &mut *(*(*(*(*h)
                        .mb
                        .pic
                        .p_fref
                        .as_mut_ptr()
                        .offset(0 as ::core::ffi::c_int as isize))
                    .as_mut_ptr()
                    .offset(i_ref as isize))
                    .as_mut_ptr()
                    .offset(11 as ::core::ffi::c_int as isize))
                    .offset(
                        (8 as ::core::ffi::c_int * i
                            + 0 as ::core::ffi::c_int
                                * *m.i_stride
                                    .as_mut_ptr()
                                    .offset(2 as ::core::ffi::c_int as isize))
                            as isize,
                    )
                        as *mut pixel;
                }
            } else if (*(*h).sps.as_mut_ptr()).i_chroma_format_idc != 0 {
                m.p_fref[4 as ::core::ffi::c_int as usize] = &mut *(*(*(*(*h)
                    .mb
                    .pic
                    .p_fref
                    .as_mut_ptr()
                    .offset(0 as ::core::ffi::c_int as isize))
                .as_mut_ptr()
                .offset(i_ref as isize))
                .as_mut_ptr()
                .offset(4 as ::core::ffi::c_int as isize))
                .offset(
                    (8 as ::core::ffi::c_int * i
                        + (0 as ::core::ffi::c_int >> (*h).mb.chroma_v_shift)
                            * *m.i_stride
                                .as_mut_ptr()
                                .offset(1 as ::core::ffi::c_int as isize))
                        as isize,
                ) as *mut pixel;
            }
            if (*h).param.analyse.i_me_method >= X264_ME_ESA {
                m.integral = &mut *(*(*(*h)
                    .mb
                    .pic
                    .p_integral
                    .as_mut_ptr()
                    .offset(0 as ::core::ffi::c_int as isize))
                .as_mut_ptr()
                .offset(i_ref as isize))
                .offset(
                    (8 as ::core::ffi::c_int * i
                        + 0 as ::core::ffi::c_int
                            * *m.i_stride
                                .as_mut_ptr()
                                .offset(0 as ::core::ffi::c_int as isize))
                        as isize,
                ) as *mut uint16_t;
            }
            m.weight = x264_zero.as_mut_ptr() as *const x264_weight_t;
            m.i_ref = i_ref;
            m.p_fref_w = &mut *(*(*h).mb.pic.p_fref_w.as_mut_ptr().offset(i_ref as isize)).offset(
                (8 as ::core::ffi::c_int * i
                    + 0 as ::core::ffi::c_int
                        * *m.i_stride
                            .as_mut_ptr()
                            .offset(0 as ::core::ffi::c_int as isize)) as isize,
            ) as *mut pixel;
            m.weight = (*(*h).sh.weight.as_mut_ptr().offset(i_ref as isize)).as_mut_ptr();
            x264_macroblock_cache_ref(
                h,
                2 as ::core::ffi::c_int * i,
                0 as ::core::ffi::c_int,
                2 as ::core::ffi::c_int,
                4 as ::core::ffi::c_int,
                0 as ::core::ffi::c_int,
                i_ref as int8_t,
            );
            x264_10_mb_predict_mv(
                h,
                0 as ::core::ffi::c_int,
                4 as ::core::ffi::c_int * i,
                2 as ::core::ffi::c_int,
                m.mvp.as_mut_ptr(),
            );
            if (*h).mb.ref_blind_dupe == i_ref && ref8[0 as ::core::ffi::c_int as usize] == 0 {
                x264_10_me_refine_qpel_refdupe(h, &mut m, 0 as *mut ::core::ffi::c_int);
            } else {
                x264_10_me_search_ref(
                    h,
                    &mut m,
                    mvc.as_mut_ptr() as *mut [int16_t; 2],
                    3 as ::core::ffi::c_int,
                    0 as *mut ::core::ffi::c_int,
                );
            }
            m.cost += m.i_ref_cost;
            if m.cost < (*l0m).cost {
                (*h).mc.memcpy_aligned.expect("non-null function pointer")(
                    l0m as *mut ::core::ffi::c_void,
                    &mut m as *mut x264_me_t as *const ::core::ffi::c_void,
                    ::core::mem::size_of::<x264_me_t>() as size_t,
                );
            }
            j += 1;
        }
        if (*a).b_early_terminate != 0
            && (i == 0
                && (*l0m).cost + (*a).i_cost_est8x16[1 as ::core::ffi::c_int as usize]
                    > i_best_satd
                        * (4 as ::core::ffi::c_int + ((*a).i_mbrd != 0) as ::core::ffi::c_int)
                        / 4 as ::core::ffi::c_int)
        {
            (*a).l0.i_cost8x16 = COST_MAX;
            return;
        }
        x264_macroblock_cache_mv(
            h,
            2 as ::core::ffi::c_int * i,
            0 as ::core::ffi::c_int,
            2 as ::core::ffi::c_int,
            4 as ::core::ffi::c_int,
            0 as ::core::ffi::c_int,
            (*((*l0m).mv.as_mut_ptr() as *mut x264_union32_t)).i,
        );
        x264_macroblock_cache_ref(
            h,
            2 as ::core::ffi::c_int * i,
            0 as ::core::ffi::c_int,
            2 as ::core::ffi::c_int,
            4 as ::core::ffi::c_int,
            0 as ::core::ffi::c_int,
            (*l0m).i_ref as int8_t,
        );
        i += 1;
    }
    (*a).l0.i_cost8x16 = (*a).l0.me8x16[0 as ::core::ffi::c_int as usize].cost
        + (*a).l0.me8x16[1 as ::core::ffi::c_int as usize].cost;
}
#[inline(always)]
#[c2rust::src_loc = "1611:1"]
unsafe extern "C" fn mb_analyse_inter_p4x4_chroma_internal(
    mut h: *mut x264_t,
    mut a: *mut x264_mb_analysis_t,
    mut p_fref: *mut *mut pixel,
    mut i8x8: ::core::ffi::c_int,
    mut size: ::core::ffi::c_int,
    mut chroma: ::core::ffi::c_int,
) -> ::core::ffi::c_int {
    let mut pix1: [pixel; 256] = [0; 256];
    let mut pix2: *mut pixel = pix1.as_mut_ptr().offset(8 as ::core::ffi::c_int as isize);
    let mut i_stride: ::core::ffi::c_int = (*h).mb.pic.i_stride[1 as ::core::ffi::c_int as usize];
    let mut chroma_h_shift: ::core::ffi::c_int =
        (chroma <= CHROMA_422 as ::core::ffi::c_int) as ::core::ffi::c_int;
    let mut chroma_v_shift: ::core::ffi::c_int =
        (chroma == CHROMA_420 as ::core::ffi::c_int) as ::core::ffi::c_int;
    let mut or: ::core::ffi::c_int = 8 as ::core::ffi::c_int * (i8x8 & 1 as ::core::ffi::c_int)
        + (4 as ::core::ffi::c_int >> chroma_v_shift) * (i8x8 & 2 as ::core::ffi::c_int) * i_stride;
    let mut i_ref: ::core::ffi::c_int = (*a).l0.me8x8[i8x8 as usize].i_ref;
    let mut mvy_offset: ::core::ffi::c_int =
        if chroma_v_shift != 0 && (*h).mb.b_interlaced & i_ref != 0 {
            ((*h).mb.i_mb_y & 1 as ::core::ffi::c_int) * 4 as ::core::ffi::c_int
                - 2 as ::core::ffi::c_int
        } else {
            0 as ::core::ffi::c_int
        };
    let mut weight: *mut x264_weight_t =
        (*(*h).sh.weight.as_mut_ptr().offset(i_ref as isize)).as_mut_ptr();
    if size == PIXEL_4x4 as ::core::ffi::c_int {
        let mut m: *mut x264_me_t =
            (*(*a).l0.me4x4.as_mut_ptr().offset(i8x8 as isize)).as_mut_ptr();
        if chroma == CHROMA_444 as ::core::ffi::c_int {
            let mut mvx: ::core::ffi::c_int = (*m.offset(0 as ::core::ffi::c_int as isize)).mv
                [0 as ::core::ffi::c_int as usize]
                as ::core::ffi::c_int
                + 4 as ::core::ffi::c_int * 2 as ::core::ffi::c_int * 0 as ::core::ffi::c_int;
            let mut mvy: ::core::ffi::c_int = (*m.offset(0 as ::core::ffi::c_int as isize)).mv
                [1 as ::core::ffi::c_int as usize]
                as ::core::ffi::c_int
                + 4 as ::core::ffi::c_int * 2 as ::core::ffi::c_int * 0 as ::core::ffi::c_int;
            (*h).mc.mc_luma.expect("non-null function pointer")(
                &mut *pix1.as_mut_ptr().offset(
                    (2 as ::core::ffi::c_int * 0 as ::core::ffi::c_int
                        + 2 as ::core::ffi::c_int
                            * 0 as ::core::ffi::c_int
                            * 16 as ::core::ffi::c_int) as isize,
                ),
                16 as intptr_t,
                &mut *(*(*(*h)
                    .mb
                    .pic
                    .p_fref
                    .as_mut_ptr()
                    .offset(0 as ::core::ffi::c_int as isize))
                .as_mut_ptr()
                .offset(i_ref as isize))
                .as_mut_ptr()
                .offset(4 as ::core::ffi::c_int as isize),
                i_stride as intptr_t,
                mvx,
                mvy,
                2 as ::core::ffi::c_int * 2 as ::core::ffi::c_int,
                2 as ::core::ffi::c_int * 2 as ::core::ffi::c_int,
                &mut *(*(*h).sh.weight.as_mut_ptr().offset(i_ref as isize))
                    .as_mut_ptr()
                    .offset(1 as ::core::ffi::c_int as isize),
            );
            (*h).mc.mc_luma.expect("non-null function pointer")(
                &mut *pix2.offset(
                    (2 as ::core::ffi::c_int * 0 as ::core::ffi::c_int
                        + 2 as ::core::ffi::c_int
                            * 0 as ::core::ffi::c_int
                            * 16 as ::core::ffi::c_int) as isize,
                ),
                16 as intptr_t,
                &mut *(*(*(*h)
                    .mb
                    .pic
                    .p_fref
                    .as_mut_ptr()
                    .offset(0 as ::core::ffi::c_int as isize))
                .as_mut_ptr()
                .offset(i_ref as isize))
                .as_mut_ptr()
                .offset(8 as ::core::ffi::c_int as isize),
                i_stride as intptr_t,
                mvx,
                mvy,
                2 as ::core::ffi::c_int * 2 as ::core::ffi::c_int,
                2 as ::core::ffi::c_int * 2 as ::core::ffi::c_int,
                &mut *(*(*h).sh.weight.as_mut_ptr().offset(i_ref as isize))
                    .as_mut_ptr()
                    .offset(2 as ::core::ffi::c_int as isize),
            );
        } else {
            let mut offset: ::core::ffi::c_int = 0 as ::core::ffi::c_int
                + (2 as ::core::ffi::c_int >> chroma_v_shift)
                    * 16 as ::core::ffi::c_int
                    * 0 as ::core::ffi::c_int;
            let mut chroma_height: ::core::ffi::c_int =
                (2 as ::core::ffi::c_int >> chroma_v_shift) * 2 as ::core::ffi::c_int;
            (*h).mc.mc_chroma.expect("non-null function pointer")(
                &mut *pix1.as_mut_ptr().offset(offset as isize),
                &mut *pix2.offset(offset as isize),
                16 as intptr_t,
                &mut *(*p_fref.offset(4 as ::core::ffi::c_int as isize)).offset(
                    (or + 2 as ::core::ffi::c_int * 0 as ::core::ffi::c_int
                        + (2 as ::core::ffi::c_int >> chroma_v_shift)
                            * 0 as ::core::ffi::c_int
                            * i_stride) as isize,
                ),
                i_stride as intptr_t,
                (*m.offset(0 as ::core::ffi::c_int as isize)).mv[0 as ::core::ffi::c_int as usize]
                    as ::core::ffi::c_int,
                (2 as ::core::ffi::c_int >> chroma_v_shift)
                    * ((*m.offset(0 as ::core::ffi::c_int as isize)).mv
                        [1 as ::core::ffi::c_int as usize]
                        as ::core::ffi::c_int
                        + mvy_offset),
                2 as ::core::ffi::c_int,
                chroma_height,
            );
            if !(*weight.offset(1 as ::core::ffi::c_int as isize))
                .weightfn
                .is_null()
            {
                (*(*weight.offset(1 as ::core::ffi::c_int as isize))
                    .weightfn
                    .offset((2 as ::core::ffi::c_int >> 2 as ::core::ffi::c_int) as isize))
                .expect("non-null function pointer")(
                    &mut *pix1.as_mut_ptr().offset(offset as isize),
                    16 as intptr_t,
                    &mut *pix1.as_mut_ptr().offset(offset as isize),
                    16 as intptr_t,
                    &mut *weight.offset(1 as ::core::ffi::c_int as isize),
                    chroma_height,
                );
            }
            if !(*weight.offset(2 as ::core::ffi::c_int as isize))
                .weightfn
                .is_null()
            {
                (*(*weight.offset(2 as ::core::ffi::c_int as isize))
                    .weightfn
                    .offset((2 as ::core::ffi::c_int >> 2 as ::core::ffi::c_int) as isize))
                .expect("non-null function pointer")(
                    &mut *pix2.offset(offset as isize),
                    16 as intptr_t,
                    &mut *pix2.offset(offset as isize),
                    16 as intptr_t,
                    &mut *weight.offset(2 as ::core::ffi::c_int as isize),
                    chroma_height,
                );
            }
        }
        if chroma == CHROMA_444 as ::core::ffi::c_int {
            let mut mvx_0: ::core::ffi::c_int = (*m.offset(1 as ::core::ffi::c_int as isize)).mv
                [0 as ::core::ffi::c_int as usize]
                as ::core::ffi::c_int
                + 4 as ::core::ffi::c_int * 2 as ::core::ffi::c_int * 2 as ::core::ffi::c_int;
            let mut mvy_0: ::core::ffi::c_int = (*m.offset(1 as ::core::ffi::c_int as isize)).mv
                [1 as ::core::ffi::c_int as usize]
                as ::core::ffi::c_int
                + 4 as ::core::ffi::c_int * 2 as ::core::ffi::c_int * 0 as ::core::ffi::c_int;
            (*h).mc.mc_luma.expect("non-null function pointer")(
                &mut *pix1.as_mut_ptr().offset(
                    (2 as ::core::ffi::c_int * 2 as ::core::ffi::c_int
                        + 2 as ::core::ffi::c_int
                            * 0 as ::core::ffi::c_int
                            * 16 as ::core::ffi::c_int) as isize,
                ),
                16 as intptr_t,
                &mut *(*(*(*h)
                    .mb
                    .pic
                    .p_fref
                    .as_mut_ptr()
                    .offset(0 as ::core::ffi::c_int as isize))
                .as_mut_ptr()
                .offset(i_ref as isize))
                .as_mut_ptr()
                .offset(4 as ::core::ffi::c_int as isize),
                i_stride as intptr_t,
                mvx_0,
                mvy_0,
                2 as ::core::ffi::c_int * 2 as ::core::ffi::c_int,
                2 as ::core::ffi::c_int * 2 as ::core::ffi::c_int,
                &mut *(*(*h).sh.weight.as_mut_ptr().offset(i_ref as isize))
                    .as_mut_ptr()
                    .offset(1 as ::core::ffi::c_int as isize),
            );
            (*h).mc.mc_luma.expect("non-null function pointer")(
                &mut *pix2.offset(
                    (2 as ::core::ffi::c_int * 2 as ::core::ffi::c_int
                        + 2 as ::core::ffi::c_int
                            * 0 as ::core::ffi::c_int
                            * 16 as ::core::ffi::c_int) as isize,
                ),
                16 as intptr_t,
                &mut *(*(*(*h)
                    .mb
                    .pic
                    .p_fref
                    .as_mut_ptr()
                    .offset(0 as ::core::ffi::c_int as isize))
                .as_mut_ptr()
                .offset(i_ref as isize))
                .as_mut_ptr()
                .offset(8 as ::core::ffi::c_int as isize),
                i_stride as intptr_t,
                mvx_0,
                mvy_0,
                2 as ::core::ffi::c_int * 2 as ::core::ffi::c_int,
                2 as ::core::ffi::c_int * 2 as ::core::ffi::c_int,
                &mut *(*(*h).sh.weight.as_mut_ptr().offset(i_ref as isize))
                    .as_mut_ptr()
                    .offset(2 as ::core::ffi::c_int as isize),
            );
        } else {
            let mut offset_0: ::core::ffi::c_int = 2 as ::core::ffi::c_int
                + (2 as ::core::ffi::c_int >> chroma_v_shift)
                    * 16 as ::core::ffi::c_int
                    * 0 as ::core::ffi::c_int;
            let mut chroma_height_0: ::core::ffi::c_int =
                (2 as ::core::ffi::c_int >> chroma_v_shift) * 2 as ::core::ffi::c_int;
            (*h).mc.mc_chroma.expect("non-null function pointer")(
                &mut *pix1.as_mut_ptr().offset(offset_0 as isize),
                &mut *pix2.offset(offset_0 as isize),
                16 as intptr_t,
                &mut *(*p_fref.offset(4 as ::core::ffi::c_int as isize)).offset(
                    (or + 2 as ::core::ffi::c_int * 2 as ::core::ffi::c_int
                        + (2 as ::core::ffi::c_int >> chroma_v_shift)
                            * 0 as ::core::ffi::c_int
                            * i_stride) as isize,
                ),
                i_stride as intptr_t,
                (*m.offset(1 as ::core::ffi::c_int as isize)).mv[0 as ::core::ffi::c_int as usize]
                    as ::core::ffi::c_int,
                (2 as ::core::ffi::c_int >> chroma_v_shift)
                    * ((*m.offset(1 as ::core::ffi::c_int as isize)).mv
                        [1 as ::core::ffi::c_int as usize]
                        as ::core::ffi::c_int
                        + mvy_offset),
                2 as ::core::ffi::c_int,
                chroma_height_0,
            );
            if !(*weight.offset(1 as ::core::ffi::c_int as isize))
                .weightfn
                .is_null()
            {
                (*(*weight.offset(1 as ::core::ffi::c_int as isize))
                    .weightfn
                    .offset((2 as ::core::ffi::c_int >> 2 as ::core::ffi::c_int) as isize))
                .expect("non-null function pointer")(
                    &mut *pix1.as_mut_ptr().offset(offset_0 as isize),
                    16 as intptr_t,
                    &mut *pix1.as_mut_ptr().offset(offset_0 as isize),
                    16 as intptr_t,
                    &mut *weight.offset(1 as ::core::ffi::c_int as isize),
                    chroma_height_0,
                );
            }
            if !(*weight.offset(2 as ::core::ffi::c_int as isize))
                .weightfn
                .is_null()
            {
                (*(*weight.offset(2 as ::core::ffi::c_int as isize))
                    .weightfn
                    .offset((2 as ::core::ffi::c_int >> 2 as ::core::ffi::c_int) as isize))
                .expect("non-null function pointer")(
                    &mut *pix2.offset(offset_0 as isize),
                    16 as intptr_t,
                    &mut *pix2.offset(offset_0 as isize),
                    16 as intptr_t,
                    &mut *weight.offset(2 as ::core::ffi::c_int as isize),
                    chroma_height_0,
                );
            }
        }
        if chroma == CHROMA_444 as ::core::ffi::c_int {
            let mut mvx_1: ::core::ffi::c_int = (*m.offset(2 as ::core::ffi::c_int as isize)).mv
                [0 as ::core::ffi::c_int as usize]
                as ::core::ffi::c_int
                + 4 as ::core::ffi::c_int * 2 as ::core::ffi::c_int * 0 as ::core::ffi::c_int;
            let mut mvy_1: ::core::ffi::c_int = (*m.offset(2 as ::core::ffi::c_int as isize)).mv
                [1 as ::core::ffi::c_int as usize]
                as ::core::ffi::c_int
                + 4 as ::core::ffi::c_int * 2 as ::core::ffi::c_int * 2 as ::core::ffi::c_int;
            (*h).mc.mc_luma.expect("non-null function pointer")(
                &mut *pix1.as_mut_ptr().offset(
                    (2 as ::core::ffi::c_int * 0 as ::core::ffi::c_int
                        + 2 as ::core::ffi::c_int
                            * 2 as ::core::ffi::c_int
                            * 16 as ::core::ffi::c_int) as isize,
                ),
                16 as intptr_t,
                &mut *(*(*(*h)
                    .mb
                    .pic
                    .p_fref
                    .as_mut_ptr()
                    .offset(0 as ::core::ffi::c_int as isize))
                .as_mut_ptr()
                .offset(i_ref as isize))
                .as_mut_ptr()
                .offset(4 as ::core::ffi::c_int as isize),
                i_stride as intptr_t,
                mvx_1,
                mvy_1,
                2 as ::core::ffi::c_int * 2 as ::core::ffi::c_int,
                2 as ::core::ffi::c_int * 2 as ::core::ffi::c_int,
                &mut *(*(*h).sh.weight.as_mut_ptr().offset(i_ref as isize))
                    .as_mut_ptr()
                    .offset(1 as ::core::ffi::c_int as isize),
            );
            (*h).mc.mc_luma.expect("non-null function pointer")(
                &mut *pix2.offset(
                    (2 as ::core::ffi::c_int * 0 as ::core::ffi::c_int
                        + 2 as ::core::ffi::c_int
                            * 2 as ::core::ffi::c_int
                            * 16 as ::core::ffi::c_int) as isize,
                ),
                16 as intptr_t,
                &mut *(*(*(*h)
                    .mb
                    .pic
                    .p_fref
                    .as_mut_ptr()
                    .offset(0 as ::core::ffi::c_int as isize))
                .as_mut_ptr()
                .offset(i_ref as isize))
                .as_mut_ptr()
                .offset(8 as ::core::ffi::c_int as isize),
                i_stride as intptr_t,
                mvx_1,
                mvy_1,
                2 as ::core::ffi::c_int * 2 as ::core::ffi::c_int,
                2 as ::core::ffi::c_int * 2 as ::core::ffi::c_int,
                &mut *(*(*h).sh.weight.as_mut_ptr().offset(i_ref as isize))
                    .as_mut_ptr()
                    .offset(2 as ::core::ffi::c_int as isize),
            );
        } else {
            let mut offset_1: ::core::ffi::c_int = 0 as ::core::ffi::c_int
                + (2 as ::core::ffi::c_int >> chroma_v_shift)
                    * 16 as ::core::ffi::c_int
                    * 2 as ::core::ffi::c_int;
            let mut chroma_height_1: ::core::ffi::c_int =
                (2 as ::core::ffi::c_int >> chroma_v_shift) * 2 as ::core::ffi::c_int;
            (*h).mc.mc_chroma.expect("non-null function pointer")(
                &mut *pix1.as_mut_ptr().offset(offset_1 as isize),
                &mut *pix2.offset(offset_1 as isize),
                16 as intptr_t,
                &mut *(*p_fref.offset(4 as ::core::ffi::c_int as isize)).offset(
                    (or + 2 as ::core::ffi::c_int * 0 as ::core::ffi::c_int
                        + (2 as ::core::ffi::c_int >> chroma_v_shift)
                            * 2 as ::core::ffi::c_int
                            * i_stride) as isize,
                ),
                i_stride as intptr_t,
                (*m.offset(2 as ::core::ffi::c_int as isize)).mv[0 as ::core::ffi::c_int as usize]
                    as ::core::ffi::c_int,
                (2 as ::core::ffi::c_int >> chroma_v_shift)
                    * ((*m.offset(2 as ::core::ffi::c_int as isize)).mv
                        [1 as ::core::ffi::c_int as usize]
                        as ::core::ffi::c_int
                        + mvy_offset),
                2 as ::core::ffi::c_int,
                chroma_height_1,
            );
            if !(*weight.offset(1 as ::core::ffi::c_int as isize))
                .weightfn
                .is_null()
            {
                (*(*weight.offset(1 as ::core::ffi::c_int as isize))
                    .weightfn
                    .offset((2 as ::core::ffi::c_int >> 2 as ::core::ffi::c_int) as isize))
                .expect("non-null function pointer")(
                    &mut *pix1.as_mut_ptr().offset(offset_1 as isize),
                    16 as intptr_t,
                    &mut *pix1.as_mut_ptr().offset(offset_1 as isize),
                    16 as intptr_t,
                    &mut *weight.offset(1 as ::core::ffi::c_int as isize),
                    chroma_height_1,
                );
            }
            if !(*weight.offset(2 as ::core::ffi::c_int as isize))
                .weightfn
                .is_null()
            {
                (*(*weight.offset(2 as ::core::ffi::c_int as isize))
                    .weightfn
                    .offset((2 as ::core::ffi::c_int >> 2 as ::core::ffi::c_int) as isize))
                .expect("non-null function pointer")(
                    &mut *pix2.offset(offset_1 as isize),
                    16 as intptr_t,
                    &mut *pix2.offset(offset_1 as isize),
                    16 as intptr_t,
                    &mut *weight.offset(2 as ::core::ffi::c_int as isize),
                    chroma_height_1,
                );
            }
        }
        if chroma == CHROMA_444 as ::core::ffi::c_int {
            let mut mvx_2: ::core::ffi::c_int = (*m.offset(3 as ::core::ffi::c_int as isize)).mv
                [0 as ::core::ffi::c_int as usize]
                as ::core::ffi::c_int
                + 4 as ::core::ffi::c_int * 2 as ::core::ffi::c_int * 2 as ::core::ffi::c_int;
            let mut mvy_2: ::core::ffi::c_int = (*m.offset(3 as ::core::ffi::c_int as isize)).mv
                [1 as ::core::ffi::c_int as usize]
                as ::core::ffi::c_int
                + 4 as ::core::ffi::c_int * 2 as ::core::ffi::c_int * 2 as ::core::ffi::c_int;
            (*h).mc.mc_luma.expect("non-null function pointer")(
                &mut *pix1.as_mut_ptr().offset(
                    (2 as ::core::ffi::c_int * 2 as ::core::ffi::c_int
                        + 2 as ::core::ffi::c_int
                            * 2 as ::core::ffi::c_int
                            * 16 as ::core::ffi::c_int) as isize,
                ),
                16 as intptr_t,
                &mut *(*(*(*h)
                    .mb
                    .pic
                    .p_fref
                    .as_mut_ptr()
                    .offset(0 as ::core::ffi::c_int as isize))
                .as_mut_ptr()
                .offset(i_ref as isize))
                .as_mut_ptr()
                .offset(4 as ::core::ffi::c_int as isize),
                i_stride as intptr_t,
                mvx_2,
                mvy_2,
                2 as ::core::ffi::c_int * 2 as ::core::ffi::c_int,
                2 as ::core::ffi::c_int * 2 as ::core::ffi::c_int,
                &mut *(*(*h).sh.weight.as_mut_ptr().offset(i_ref as isize))
                    .as_mut_ptr()
                    .offset(1 as ::core::ffi::c_int as isize),
            );
            (*h).mc.mc_luma.expect("non-null function pointer")(
                &mut *pix2.offset(
                    (2 as ::core::ffi::c_int * 2 as ::core::ffi::c_int
                        + 2 as ::core::ffi::c_int
                            * 2 as ::core::ffi::c_int
                            * 16 as ::core::ffi::c_int) as isize,
                ),
                16 as intptr_t,
                &mut *(*(*(*h)
                    .mb
                    .pic
                    .p_fref
                    .as_mut_ptr()
                    .offset(0 as ::core::ffi::c_int as isize))
                .as_mut_ptr()
                .offset(i_ref as isize))
                .as_mut_ptr()
                .offset(8 as ::core::ffi::c_int as isize),
                i_stride as intptr_t,
                mvx_2,
                mvy_2,
                2 as ::core::ffi::c_int * 2 as ::core::ffi::c_int,
                2 as ::core::ffi::c_int * 2 as ::core::ffi::c_int,
                &mut *(*(*h).sh.weight.as_mut_ptr().offset(i_ref as isize))
                    .as_mut_ptr()
                    .offset(2 as ::core::ffi::c_int as isize),
            );
        } else {
            let mut offset_2: ::core::ffi::c_int = 2 as ::core::ffi::c_int
                + (2 as ::core::ffi::c_int >> chroma_v_shift)
                    * 16 as ::core::ffi::c_int
                    * 2 as ::core::ffi::c_int;
            let mut chroma_height_2: ::core::ffi::c_int =
                (2 as ::core::ffi::c_int >> chroma_v_shift) * 2 as ::core::ffi::c_int;
            (*h).mc.mc_chroma.expect("non-null function pointer")(
                &mut *pix1.as_mut_ptr().offset(offset_2 as isize),
                &mut *pix2.offset(offset_2 as isize),
                16 as intptr_t,
                &mut *(*p_fref.offset(4 as ::core::ffi::c_int as isize)).offset(
                    (or + 2 as ::core::ffi::c_int * 2 as ::core::ffi::c_int
                        + (2 as ::core::ffi::c_int >> chroma_v_shift)
                            * 2 as ::core::ffi::c_int
                            * i_stride) as isize,
                ),
                i_stride as intptr_t,
                (*m.offset(3 as ::core::ffi::c_int as isize)).mv[0 as ::core::ffi::c_int as usize]
                    as ::core::ffi::c_int,
                (2 as ::core::ffi::c_int >> chroma_v_shift)
                    * ((*m.offset(3 as ::core::ffi::c_int as isize)).mv
                        [1 as ::core::ffi::c_int as usize]
                        as ::core::ffi::c_int
                        + mvy_offset),
                2 as ::core::ffi::c_int,
                chroma_height_2,
            );
            if !(*weight.offset(1 as ::core::ffi::c_int as isize))
                .weightfn
                .is_null()
            {
                (*(*weight.offset(1 as ::core::ffi::c_int as isize))
                    .weightfn
                    .offset((2 as ::core::ffi::c_int >> 2 as ::core::ffi::c_int) as isize))
                .expect("non-null function pointer")(
                    &mut *pix1.as_mut_ptr().offset(offset_2 as isize),
                    16 as intptr_t,
                    &mut *pix1.as_mut_ptr().offset(offset_2 as isize),
                    16 as intptr_t,
                    &mut *weight.offset(1 as ::core::ffi::c_int as isize),
                    chroma_height_2,
                );
            }
            if !(*weight.offset(2 as ::core::ffi::c_int as isize))
                .weightfn
                .is_null()
            {
                (*(*weight.offset(2 as ::core::ffi::c_int as isize))
                    .weightfn
                    .offset((2 as ::core::ffi::c_int >> 2 as ::core::ffi::c_int) as isize))
                .expect("non-null function pointer")(
                    &mut *pix2.offset(offset_2 as isize),
                    16 as intptr_t,
                    &mut *pix2.offset(offset_2 as isize),
                    16 as intptr_t,
                    &mut *weight.offset(2 as ::core::ffi::c_int as isize),
                    chroma_height_2,
                );
            }
        }
    } else if size == PIXEL_8x4 as ::core::ffi::c_int {
        let mut m_0: *mut x264_me_t =
            (*(*a).l0.me8x4.as_mut_ptr().offset(i8x8 as isize)).as_mut_ptr();
        if chroma == CHROMA_444 as ::core::ffi::c_int {
            let mut mvx_3: ::core::ffi::c_int = (*m_0.offset(0 as ::core::ffi::c_int as isize)).mv
                [0 as ::core::ffi::c_int as usize]
                as ::core::ffi::c_int
                + 4 as ::core::ffi::c_int * 2 as ::core::ffi::c_int * 0 as ::core::ffi::c_int;
            let mut mvy_3: ::core::ffi::c_int = (*m_0.offset(0 as ::core::ffi::c_int as isize)).mv
                [1 as ::core::ffi::c_int as usize]
                as ::core::ffi::c_int
                + 4 as ::core::ffi::c_int * 2 as ::core::ffi::c_int * 0 as ::core::ffi::c_int;
            (*h).mc.mc_luma.expect("non-null function pointer")(
                &mut *pix1.as_mut_ptr().offset(
                    (2 as ::core::ffi::c_int * 0 as ::core::ffi::c_int
                        + 2 as ::core::ffi::c_int
                            * 0 as ::core::ffi::c_int
                            * 16 as ::core::ffi::c_int) as isize,
                ),
                16 as intptr_t,
                &mut *(*(*(*h)
                    .mb
                    .pic
                    .p_fref
                    .as_mut_ptr()
                    .offset(0 as ::core::ffi::c_int as isize))
                .as_mut_ptr()
                .offset(i_ref as isize))
                .as_mut_ptr()
                .offset(4 as ::core::ffi::c_int as isize),
                i_stride as intptr_t,
                mvx_3,
                mvy_3,
                2 as ::core::ffi::c_int * 4 as ::core::ffi::c_int,
                2 as ::core::ffi::c_int * 2 as ::core::ffi::c_int,
                &mut *(*(*h).sh.weight.as_mut_ptr().offset(i_ref as isize))
                    .as_mut_ptr()
                    .offset(1 as ::core::ffi::c_int as isize),
            );
            (*h).mc.mc_luma.expect("non-null function pointer")(
                &mut *pix2.offset(
                    (2 as ::core::ffi::c_int * 0 as ::core::ffi::c_int
                        + 2 as ::core::ffi::c_int
                            * 0 as ::core::ffi::c_int
                            * 16 as ::core::ffi::c_int) as isize,
                ),
                16 as intptr_t,
                &mut *(*(*(*h)
                    .mb
                    .pic
                    .p_fref
                    .as_mut_ptr()
                    .offset(0 as ::core::ffi::c_int as isize))
                .as_mut_ptr()
                .offset(i_ref as isize))
                .as_mut_ptr()
                .offset(8 as ::core::ffi::c_int as isize),
                i_stride as intptr_t,
                mvx_3,
                mvy_3,
                2 as ::core::ffi::c_int * 4 as ::core::ffi::c_int,
                2 as ::core::ffi::c_int * 2 as ::core::ffi::c_int,
                &mut *(*(*h).sh.weight.as_mut_ptr().offset(i_ref as isize))
                    .as_mut_ptr()
                    .offset(2 as ::core::ffi::c_int as isize),
            );
        } else {
            let mut offset_3: ::core::ffi::c_int = 0 as ::core::ffi::c_int
                + (2 as ::core::ffi::c_int >> chroma_v_shift)
                    * 16 as ::core::ffi::c_int
                    * 0 as ::core::ffi::c_int;
            let mut chroma_height_3: ::core::ffi::c_int =
                (2 as ::core::ffi::c_int >> chroma_v_shift) * 2 as ::core::ffi::c_int;
            (*h).mc.mc_chroma.expect("non-null function pointer")(
                &mut *pix1.as_mut_ptr().offset(offset_3 as isize),
                &mut *pix2.offset(offset_3 as isize),
                16 as intptr_t,
                &mut *(*p_fref.offset(4 as ::core::ffi::c_int as isize)).offset(
                    (or + 2 as ::core::ffi::c_int * 0 as ::core::ffi::c_int
                        + (2 as ::core::ffi::c_int >> chroma_v_shift)
                            * 0 as ::core::ffi::c_int
                            * i_stride) as isize,
                ),
                i_stride as intptr_t,
                (*m_0.offset(0 as ::core::ffi::c_int as isize)).mv[0 as ::core::ffi::c_int as usize]
                    as ::core::ffi::c_int,
                (2 as ::core::ffi::c_int >> chroma_v_shift)
                    * ((*m_0.offset(0 as ::core::ffi::c_int as isize)).mv
                        [1 as ::core::ffi::c_int as usize]
                        as ::core::ffi::c_int
                        + mvy_offset),
                4 as ::core::ffi::c_int,
                chroma_height_3,
            );
            if !(*weight.offset(1 as ::core::ffi::c_int as isize))
                .weightfn
                .is_null()
            {
                (*(*weight.offset(1 as ::core::ffi::c_int as isize))
                    .weightfn
                    .offset((4 as ::core::ffi::c_int >> 2 as ::core::ffi::c_int) as isize))
                .expect("non-null function pointer")(
                    &mut *pix1.as_mut_ptr().offset(offset_3 as isize),
                    16 as intptr_t,
                    &mut *pix1.as_mut_ptr().offset(offset_3 as isize),
                    16 as intptr_t,
                    &mut *weight.offset(1 as ::core::ffi::c_int as isize),
                    chroma_height_3,
                );
            }
            if !(*weight.offset(2 as ::core::ffi::c_int as isize))
                .weightfn
                .is_null()
            {
                (*(*weight.offset(2 as ::core::ffi::c_int as isize))
                    .weightfn
                    .offset((4 as ::core::ffi::c_int >> 2 as ::core::ffi::c_int) as isize))
                .expect("non-null function pointer")(
                    &mut *pix2.offset(offset_3 as isize),
                    16 as intptr_t,
                    &mut *pix2.offset(offset_3 as isize),
                    16 as intptr_t,
                    &mut *weight.offset(2 as ::core::ffi::c_int as isize),
                    chroma_height_3,
                );
            }
        }
        if chroma == CHROMA_444 as ::core::ffi::c_int {
            let mut mvx_4: ::core::ffi::c_int = (*m_0.offset(1 as ::core::ffi::c_int as isize)).mv
                [0 as ::core::ffi::c_int as usize]
                as ::core::ffi::c_int
                + 4 as ::core::ffi::c_int * 2 as ::core::ffi::c_int * 0 as ::core::ffi::c_int;
            let mut mvy_4: ::core::ffi::c_int = (*m_0.offset(1 as ::core::ffi::c_int as isize)).mv
                [1 as ::core::ffi::c_int as usize]
                as ::core::ffi::c_int
                + 4 as ::core::ffi::c_int * 2 as ::core::ffi::c_int * 2 as ::core::ffi::c_int;
            (*h).mc.mc_luma.expect("non-null function pointer")(
                &mut *pix1.as_mut_ptr().offset(
                    (2 as ::core::ffi::c_int * 0 as ::core::ffi::c_int
                        + 2 as ::core::ffi::c_int
                            * 2 as ::core::ffi::c_int
                            * 16 as ::core::ffi::c_int) as isize,
                ),
                16 as intptr_t,
                &mut *(*(*(*h)
                    .mb
                    .pic
                    .p_fref
                    .as_mut_ptr()
                    .offset(0 as ::core::ffi::c_int as isize))
                .as_mut_ptr()
                .offset(i_ref as isize))
                .as_mut_ptr()
                .offset(4 as ::core::ffi::c_int as isize),
                i_stride as intptr_t,
                mvx_4,
                mvy_4,
                2 as ::core::ffi::c_int * 4 as ::core::ffi::c_int,
                2 as ::core::ffi::c_int * 2 as ::core::ffi::c_int,
                &mut *(*(*h).sh.weight.as_mut_ptr().offset(i_ref as isize))
                    .as_mut_ptr()
                    .offset(1 as ::core::ffi::c_int as isize),
            );
            (*h).mc.mc_luma.expect("non-null function pointer")(
                &mut *pix2.offset(
                    (2 as ::core::ffi::c_int * 0 as ::core::ffi::c_int
                        + 2 as ::core::ffi::c_int
                            * 2 as ::core::ffi::c_int
                            * 16 as ::core::ffi::c_int) as isize,
                ),
                16 as intptr_t,
                &mut *(*(*(*h)
                    .mb
                    .pic
                    .p_fref
                    .as_mut_ptr()
                    .offset(0 as ::core::ffi::c_int as isize))
                .as_mut_ptr()
                .offset(i_ref as isize))
                .as_mut_ptr()
                .offset(8 as ::core::ffi::c_int as isize),
                i_stride as intptr_t,
                mvx_4,
                mvy_4,
                2 as ::core::ffi::c_int * 4 as ::core::ffi::c_int,
                2 as ::core::ffi::c_int * 2 as ::core::ffi::c_int,
                &mut *(*(*h).sh.weight.as_mut_ptr().offset(i_ref as isize))
                    .as_mut_ptr()
                    .offset(2 as ::core::ffi::c_int as isize),
            );
        } else {
            let mut offset_4: ::core::ffi::c_int = 0 as ::core::ffi::c_int
                + (2 as ::core::ffi::c_int >> chroma_v_shift)
                    * 16 as ::core::ffi::c_int
                    * 2 as ::core::ffi::c_int;
            let mut chroma_height_4: ::core::ffi::c_int =
                (2 as ::core::ffi::c_int >> chroma_v_shift) * 2 as ::core::ffi::c_int;
            (*h).mc.mc_chroma.expect("non-null function pointer")(
                &mut *pix1.as_mut_ptr().offset(offset_4 as isize),
                &mut *pix2.offset(offset_4 as isize),
                16 as intptr_t,
                &mut *(*p_fref.offset(4 as ::core::ffi::c_int as isize)).offset(
                    (or + 2 as ::core::ffi::c_int * 0 as ::core::ffi::c_int
                        + (2 as ::core::ffi::c_int >> chroma_v_shift)
                            * 2 as ::core::ffi::c_int
                            * i_stride) as isize,
                ),
                i_stride as intptr_t,
                (*m_0.offset(1 as ::core::ffi::c_int as isize)).mv[0 as ::core::ffi::c_int as usize]
                    as ::core::ffi::c_int,
                (2 as ::core::ffi::c_int >> chroma_v_shift)
                    * ((*m_0.offset(1 as ::core::ffi::c_int as isize)).mv
                        [1 as ::core::ffi::c_int as usize]
                        as ::core::ffi::c_int
                        + mvy_offset),
                4 as ::core::ffi::c_int,
                chroma_height_4,
            );
            if !(*weight.offset(1 as ::core::ffi::c_int as isize))
                .weightfn
                .is_null()
            {
                (*(*weight.offset(1 as ::core::ffi::c_int as isize))
                    .weightfn
                    .offset((4 as ::core::ffi::c_int >> 2 as ::core::ffi::c_int) as isize))
                .expect("non-null function pointer")(
                    &mut *pix1.as_mut_ptr().offset(offset_4 as isize),
                    16 as intptr_t,
                    &mut *pix1.as_mut_ptr().offset(offset_4 as isize),
                    16 as intptr_t,
                    &mut *weight.offset(1 as ::core::ffi::c_int as isize),
                    chroma_height_4,
                );
            }
            if !(*weight.offset(2 as ::core::ffi::c_int as isize))
                .weightfn
                .is_null()
            {
                (*(*weight.offset(2 as ::core::ffi::c_int as isize))
                    .weightfn
                    .offset((4 as ::core::ffi::c_int >> 2 as ::core::ffi::c_int) as isize))
                .expect("non-null function pointer")(
                    &mut *pix2.offset(offset_4 as isize),
                    16 as intptr_t,
                    &mut *pix2.offset(offset_4 as isize),
                    16 as intptr_t,
                    &mut *weight.offset(2 as ::core::ffi::c_int as isize),
                    chroma_height_4,
                );
            }
        }
    } else {
        let mut m_1: *mut x264_me_t =
            (*(*a).l0.me4x8.as_mut_ptr().offset(i8x8 as isize)).as_mut_ptr();
        if chroma == CHROMA_444 as ::core::ffi::c_int {
            let mut mvx_5: ::core::ffi::c_int = (*m_1.offset(0 as ::core::ffi::c_int as isize)).mv
                [0 as ::core::ffi::c_int as usize]
                as ::core::ffi::c_int
                + 4 as ::core::ffi::c_int * 2 as ::core::ffi::c_int * 0 as ::core::ffi::c_int;
            let mut mvy_5: ::core::ffi::c_int = (*m_1.offset(0 as ::core::ffi::c_int as isize)).mv
                [1 as ::core::ffi::c_int as usize]
                as ::core::ffi::c_int
                + 4 as ::core::ffi::c_int * 2 as ::core::ffi::c_int * 0 as ::core::ffi::c_int;
            (*h).mc.mc_luma.expect("non-null function pointer")(
                &mut *pix1.as_mut_ptr().offset(
                    (2 as ::core::ffi::c_int * 0 as ::core::ffi::c_int
                        + 2 as ::core::ffi::c_int
                            * 0 as ::core::ffi::c_int
                            * 16 as ::core::ffi::c_int) as isize,
                ),
                16 as intptr_t,
                &mut *(*(*(*h)
                    .mb
                    .pic
                    .p_fref
                    .as_mut_ptr()
                    .offset(0 as ::core::ffi::c_int as isize))
                .as_mut_ptr()
                .offset(i_ref as isize))
                .as_mut_ptr()
                .offset(4 as ::core::ffi::c_int as isize),
                i_stride as intptr_t,
                mvx_5,
                mvy_5,
                2 as ::core::ffi::c_int * 2 as ::core::ffi::c_int,
                2 as ::core::ffi::c_int * 4 as ::core::ffi::c_int,
                &mut *(*(*h).sh.weight.as_mut_ptr().offset(i_ref as isize))
                    .as_mut_ptr()
                    .offset(1 as ::core::ffi::c_int as isize),
            );
            (*h).mc.mc_luma.expect("non-null function pointer")(
                &mut *pix2.offset(
                    (2 as ::core::ffi::c_int * 0 as ::core::ffi::c_int
                        + 2 as ::core::ffi::c_int
                            * 0 as ::core::ffi::c_int
                            * 16 as ::core::ffi::c_int) as isize,
                ),
                16 as intptr_t,
                &mut *(*(*(*h)
                    .mb
                    .pic
                    .p_fref
                    .as_mut_ptr()
                    .offset(0 as ::core::ffi::c_int as isize))
                .as_mut_ptr()
                .offset(i_ref as isize))
                .as_mut_ptr()
                .offset(8 as ::core::ffi::c_int as isize),
                i_stride as intptr_t,
                mvx_5,
                mvy_5,
                2 as ::core::ffi::c_int * 2 as ::core::ffi::c_int,
                2 as ::core::ffi::c_int * 4 as ::core::ffi::c_int,
                &mut *(*(*h).sh.weight.as_mut_ptr().offset(i_ref as isize))
                    .as_mut_ptr()
                    .offset(2 as ::core::ffi::c_int as isize),
            );
        } else {
            let mut offset_5: ::core::ffi::c_int = 0 as ::core::ffi::c_int
                + (2 as ::core::ffi::c_int >> chroma_v_shift)
                    * 16 as ::core::ffi::c_int
                    * 0 as ::core::ffi::c_int;
            let mut chroma_height_5: ::core::ffi::c_int =
                (2 as ::core::ffi::c_int >> chroma_v_shift) * 4 as ::core::ffi::c_int;
            (*h).mc.mc_chroma.expect("non-null function pointer")(
                &mut *pix1.as_mut_ptr().offset(offset_5 as isize),
                &mut *pix2.offset(offset_5 as isize),
                16 as intptr_t,
                &mut *(*p_fref.offset(4 as ::core::ffi::c_int as isize)).offset(
                    (or + 2 as ::core::ffi::c_int * 0 as ::core::ffi::c_int
                        + (2 as ::core::ffi::c_int >> chroma_v_shift)
                            * 0 as ::core::ffi::c_int
                            * i_stride) as isize,
                ),
                i_stride as intptr_t,
                (*m_1.offset(0 as ::core::ffi::c_int as isize)).mv[0 as ::core::ffi::c_int as usize]
                    as ::core::ffi::c_int,
                (2 as ::core::ffi::c_int >> chroma_v_shift)
                    * ((*m_1.offset(0 as ::core::ffi::c_int as isize)).mv
                        [1 as ::core::ffi::c_int as usize]
                        as ::core::ffi::c_int
                        + mvy_offset),
                2 as ::core::ffi::c_int,
                chroma_height_5,
            );
            if !(*weight.offset(1 as ::core::ffi::c_int as isize))
                .weightfn
                .is_null()
            {
                (*(*weight.offset(1 as ::core::ffi::c_int as isize))
                    .weightfn
                    .offset((2 as ::core::ffi::c_int >> 2 as ::core::ffi::c_int) as isize))
                .expect("non-null function pointer")(
                    &mut *pix1.as_mut_ptr().offset(offset_5 as isize),
                    16 as intptr_t,
                    &mut *pix1.as_mut_ptr().offset(offset_5 as isize),
                    16 as intptr_t,
                    &mut *weight.offset(1 as ::core::ffi::c_int as isize),
                    chroma_height_5,
                );
            }
            if !(*weight.offset(2 as ::core::ffi::c_int as isize))
                .weightfn
                .is_null()
            {
                (*(*weight.offset(2 as ::core::ffi::c_int as isize))
                    .weightfn
                    .offset((2 as ::core::ffi::c_int >> 2 as ::core::ffi::c_int) as isize))
                .expect("non-null function pointer")(
                    &mut *pix2.offset(offset_5 as isize),
                    16 as intptr_t,
                    &mut *pix2.offset(offset_5 as isize),
                    16 as intptr_t,
                    &mut *weight.offset(2 as ::core::ffi::c_int as isize),
                    chroma_height_5,
                );
            }
        }
        if chroma == CHROMA_444 as ::core::ffi::c_int {
            let mut mvx_6: ::core::ffi::c_int = (*m_1.offset(1 as ::core::ffi::c_int as isize)).mv
                [0 as ::core::ffi::c_int as usize]
                as ::core::ffi::c_int
                + 4 as ::core::ffi::c_int * 2 as ::core::ffi::c_int * 2 as ::core::ffi::c_int;
            let mut mvy_6: ::core::ffi::c_int = (*m_1.offset(1 as ::core::ffi::c_int as isize)).mv
                [1 as ::core::ffi::c_int as usize]
                as ::core::ffi::c_int
                + 4 as ::core::ffi::c_int * 2 as ::core::ffi::c_int * 0 as ::core::ffi::c_int;
            (*h).mc.mc_luma.expect("non-null function pointer")(
                &mut *pix1.as_mut_ptr().offset(
                    (2 as ::core::ffi::c_int * 2 as ::core::ffi::c_int
                        + 2 as ::core::ffi::c_int
                            * 0 as ::core::ffi::c_int
                            * 16 as ::core::ffi::c_int) as isize,
                ),
                16 as intptr_t,
                &mut *(*(*(*h)
                    .mb
                    .pic
                    .p_fref
                    .as_mut_ptr()
                    .offset(0 as ::core::ffi::c_int as isize))
                .as_mut_ptr()
                .offset(i_ref as isize))
                .as_mut_ptr()
                .offset(4 as ::core::ffi::c_int as isize),
                i_stride as intptr_t,
                mvx_6,
                mvy_6,
                2 as ::core::ffi::c_int * 2 as ::core::ffi::c_int,
                2 as ::core::ffi::c_int * 4 as ::core::ffi::c_int,
                &mut *(*(*h).sh.weight.as_mut_ptr().offset(i_ref as isize))
                    .as_mut_ptr()
                    .offset(1 as ::core::ffi::c_int as isize),
            );
            (*h).mc.mc_luma.expect("non-null function pointer")(
                &mut *pix2.offset(
                    (2 as ::core::ffi::c_int * 2 as ::core::ffi::c_int
                        + 2 as ::core::ffi::c_int
                            * 0 as ::core::ffi::c_int
                            * 16 as ::core::ffi::c_int) as isize,
                ),
                16 as intptr_t,
                &mut *(*(*(*h)
                    .mb
                    .pic
                    .p_fref
                    .as_mut_ptr()
                    .offset(0 as ::core::ffi::c_int as isize))
                .as_mut_ptr()
                .offset(i_ref as isize))
                .as_mut_ptr()
                .offset(8 as ::core::ffi::c_int as isize),
                i_stride as intptr_t,
                mvx_6,
                mvy_6,
                2 as ::core::ffi::c_int * 2 as ::core::ffi::c_int,
                2 as ::core::ffi::c_int * 4 as ::core::ffi::c_int,
                &mut *(*(*h).sh.weight.as_mut_ptr().offset(i_ref as isize))
                    .as_mut_ptr()
                    .offset(2 as ::core::ffi::c_int as isize),
            );
        } else {
            let mut offset_6: ::core::ffi::c_int = 2 as ::core::ffi::c_int
                + (2 as ::core::ffi::c_int >> chroma_v_shift)
                    * 16 as ::core::ffi::c_int
                    * 0 as ::core::ffi::c_int;
            let mut chroma_height_6: ::core::ffi::c_int =
                (2 as ::core::ffi::c_int >> chroma_v_shift) * 4 as ::core::ffi::c_int;
            (*h).mc.mc_chroma.expect("non-null function pointer")(
                &mut *pix1.as_mut_ptr().offset(offset_6 as isize),
                &mut *pix2.offset(offset_6 as isize),
                16 as intptr_t,
                &mut *(*p_fref.offset(4 as ::core::ffi::c_int as isize)).offset(
                    (or + 2 as ::core::ffi::c_int * 2 as ::core::ffi::c_int
                        + (2 as ::core::ffi::c_int >> chroma_v_shift)
                            * 0 as ::core::ffi::c_int
                            * i_stride) as isize,
                ),
                i_stride as intptr_t,
                (*m_1.offset(1 as ::core::ffi::c_int as isize)).mv[0 as ::core::ffi::c_int as usize]
                    as ::core::ffi::c_int,
                (2 as ::core::ffi::c_int >> chroma_v_shift)
                    * ((*m_1.offset(1 as ::core::ffi::c_int as isize)).mv
                        [1 as ::core::ffi::c_int as usize]
                        as ::core::ffi::c_int
                        + mvy_offset),
                2 as ::core::ffi::c_int,
                chroma_height_6,
            );
            if !(*weight.offset(1 as ::core::ffi::c_int as isize))
                .weightfn
                .is_null()
            {
                (*(*weight.offset(1 as ::core::ffi::c_int as isize))
                    .weightfn
                    .offset((2 as ::core::ffi::c_int >> 2 as ::core::ffi::c_int) as isize))
                .expect("non-null function pointer")(
                    &mut *pix1.as_mut_ptr().offset(offset_6 as isize),
                    16 as intptr_t,
                    &mut *pix1.as_mut_ptr().offset(offset_6 as isize),
                    16 as intptr_t,
                    &mut *weight.offset(1 as ::core::ffi::c_int as isize),
                    chroma_height_6,
                );
            }
            if !(*weight.offset(2 as ::core::ffi::c_int as isize))
                .weightfn
                .is_null()
            {
                (*(*weight.offset(2 as ::core::ffi::c_int as isize))
                    .weightfn
                    .offset((2 as ::core::ffi::c_int >> 2 as ::core::ffi::c_int) as isize))
                .expect("non-null function pointer")(
                    &mut *pix2.offset(offset_6 as isize),
                    16 as intptr_t,
                    &mut *pix2.offset(offset_6 as isize),
                    16 as intptr_t,
                    &mut *weight.offset(2 as ::core::ffi::c_int as isize),
                    chroma_height_6,
                );
            }
        }
    }
    let mut oe: ::core::ffi::c_int = (8 as ::core::ffi::c_int >> chroma_h_shift)
        * (i8x8 & 1 as ::core::ffi::c_int)
        + (4 as ::core::ffi::c_int >> chroma_v_shift)
            * (i8x8 & 2 as ::core::ffi::c_int)
            * FENC_STRIDE;
    let mut chromapix: ::core::ffi::c_int = if chroma == CHROMA_444 as ::core::ffi::c_int {
        PIXEL_8x8 as ::core::ffi::c_int
    } else if chroma == CHROMA_422 as ::core::ffi::c_int {
        PIXEL_4x8 as ::core::ffi::c_int
    } else {
        PIXEL_4x4 as ::core::ffi::c_int
    };
    return (*h).pixf.mbcmp[chromapix as usize].expect("non-null function pointer")(
        &mut *(*(*h)
            .mb
            .pic
            .p_fenc
            .as_mut_ptr()
            .offset(1 as ::core::ffi::c_int as isize))
        .offset(oe as isize),
        FENC_STRIDE as intptr_t,
        pix1.as_mut_ptr(),
        16 as intptr_t,
    ) + (*h).pixf.mbcmp[chromapix as usize].expect("non-null function pointer")(
        &mut *(*(*h)
            .mb
            .pic
            .p_fenc
            .as_mut_ptr()
            .offset(2 as ::core::ffi::c_int as isize))
        .offset(oe as isize),
        FENC_STRIDE as intptr_t,
        pix2,
        16 as intptr_t,
    );
}
#[c2rust::src_loc = "1675:1"]
unsafe extern "C" fn mb_analyse_inter_p4x4_chroma(
    mut h: *mut x264_t,
    mut a: *mut x264_mb_analysis_t,
    mut p_fref: *mut *mut pixel,
    mut i8x8: ::core::ffi::c_int,
    mut size: ::core::ffi::c_int,
) -> ::core::ffi::c_int {
    if (*(*h).sps.as_mut_ptr()).i_chroma_format_idc == CHROMA_444 as ::core::ffi::c_int {
        return mb_analyse_inter_p4x4_chroma_internal(
            h,
            a,
            p_fref,
            i8x8,
            size,
            CHROMA_444 as ::core::ffi::c_int,
        );
    } else if (*(*h).sps.as_mut_ptr()).i_chroma_format_idc == CHROMA_422 as ::core::ffi::c_int {
        return mb_analyse_inter_p4x4_chroma_internal(
            h,
            a,
            p_fref,
            i8x8,
            size,
            CHROMA_422 as ::core::ffi::c_int,
        );
    } else {
        return mb_analyse_inter_p4x4_chroma_internal(
            h,
            a,
            p_fref,
            i8x8,
            size,
            CHROMA_420 as ::core::ffi::c_int,
        );
    };
}
#[c2rust::src_loc = "1685:1"]
unsafe extern "C" fn mb_analyse_inter_p4x4(
    mut h: *mut x264_t,
    mut a: *mut x264_mb_analysis_t,
    mut i8x8: ::core::ffi::c_int,
) {
    let mut p_fref: *mut *mut pixel = (*(*(*h)
        .mb
        .pic
        .p_fref
        .as_mut_ptr()
        .offset(0 as ::core::ffi::c_int as isize))
    .as_mut_ptr()
    .offset((*(*a).l0.me8x8.as_mut_ptr().offset(i8x8 as isize)).i_ref as isize))
    .as_mut_ptr();
    let mut p_fenc: *mut *mut pixel = (*h).mb.pic.p_fenc.as_mut_ptr();
    let i_ref: ::core::ffi::c_int = (*a).l0.me8x8[i8x8 as usize].i_ref;
    (*h).mb.i_partition = D_8x8 as ::core::ffi::c_int;
    let mut i4x4: ::core::ffi::c_int = 0 as ::core::ffi::c_int;
    while i4x4 < 4 as ::core::ffi::c_int {
        let idx: ::core::ffi::c_int = 4 as ::core::ffi::c_int * i8x8 + i4x4;
        let x4: ::core::ffi::c_int = block_idx_x[idx as usize] as ::core::ffi::c_int;
        let y4: ::core::ffi::c_int = block_idx_y[idx as usize] as ::core::ffi::c_int;
        let i_mvc: ::core::ffi::c_int = (i4x4 == 0 as ::core::ffi::c_int) as ::core::ffi::c_int;
        let mut m: *mut x264_me_t = &mut *(*(*a).l0.me4x4.as_mut_ptr().offset(i8x8 as isize))
            .as_mut_ptr()
            .offset(i4x4 as isize) as *mut x264_me_t;
        (*m).i_pixel = PIXEL_4x4 as ::core::ffi::c_int;
        (*m).p_cost_mv = (*a).p_cost_mv;
        (*m).i_stride[0 as ::core::ffi::c_int as usize] =
            (*h).mb.pic.i_stride[0 as ::core::ffi::c_int as usize];
        (*m).i_stride[1 as ::core::ffi::c_int as usize] =
            (*h).mb.pic.i_stride[1 as ::core::ffi::c_int as usize];
        (*m).i_stride[2 as ::core::ffi::c_int as usize] =
            (*h).mb.pic.i_stride[2 as ::core::ffi::c_int as usize];
        (*m).p_fenc[0 as ::core::ffi::c_int as usize] = &mut *(*p_fenc
            .offset(0 as ::core::ffi::c_int as isize))
        .offset(
            (4 as ::core::ffi::c_int * x4 + 4 as ::core::ffi::c_int * y4 * FENC_STRIDE) as isize,
        ) as *mut pixel;
        if (*(*h).sps.as_mut_ptr()).i_chroma_format_idc != 0 {
            (*m).p_fenc[1 as ::core::ffi::c_int as usize] =
                &mut *(*p_fenc.offset(1 as ::core::ffi::c_int as isize)).offset(
                    ((4 as ::core::ffi::c_int * x4 >> (*h).mb.chroma_h_shift)
                        + (4 as ::core::ffi::c_int * y4 >> (*h).mb.chroma_v_shift) * FENC_STRIDE)
                        as isize,
                ) as *mut pixel;
            (*m).p_fenc[2 as ::core::ffi::c_int as usize] =
                &mut *(*p_fenc.offset(2 as ::core::ffi::c_int as isize)).offset(
                    ((4 as ::core::ffi::c_int * x4 >> (*h).mb.chroma_h_shift)
                        + (4 as ::core::ffi::c_int * y4 >> (*h).mb.chroma_v_shift) * FENC_STRIDE)
                        as isize,
                ) as *mut pixel;
        }
        (*m).p_fref[0 as ::core::ffi::c_int as usize] =
            &mut *(*p_fref.offset(0 as ::core::ffi::c_int as isize)).offset(
                (4 as ::core::ffi::c_int * x4
                    + 4 as ::core::ffi::c_int
                        * y4
                        * *(*m)
                            .i_stride
                            .as_mut_ptr()
                            .offset(0 as ::core::ffi::c_int as isize)) as isize,
            ) as *mut pixel;
        (*m).p_fref_w = (*m).p_fref[0 as ::core::ffi::c_int as usize];
        if (*h).param.analyse.i_subpel_refine != 0 {
            (*m).p_fref[1 as ::core::ffi::c_int as usize] = &mut *(*p_fref
                .offset(1 as ::core::ffi::c_int as isize))
            .offset(
                (4 as ::core::ffi::c_int * x4
                    + 4 as ::core::ffi::c_int
                        * y4
                        * *(*m)
                            .i_stride
                            .as_mut_ptr()
                            .offset(0 as ::core::ffi::c_int as isize)) as isize,
            ) as *mut pixel;
            (*m).p_fref[2 as ::core::ffi::c_int as usize] = &mut *(*p_fref
                .offset(2 as ::core::ffi::c_int as isize))
            .offset(
                (4 as ::core::ffi::c_int * x4
                    + 4 as ::core::ffi::c_int
                        * y4
                        * *(*m)
                            .i_stride
                            .as_mut_ptr()
                            .offset(0 as ::core::ffi::c_int as isize)) as isize,
            ) as *mut pixel;
            (*m).p_fref[3 as ::core::ffi::c_int as usize] = &mut *(*p_fref
                .offset(3 as ::core::ffi::c_int as isize))
            .offset(
                (4 as ::core::ffi::c_int * x4
                    + 4 as ::core::ffi::c_int
                        * y4
                        * *(*m)
                            .i_stride
                            .as_mut_ptr()
                            .offset(0 as ::core::ffi::c_int as isize)) as isize,
            ) as *mut pixel;
        }
        if (*(*h).sps.as_mut_ptr()).i_chroma_format_idc == CHROMA_444 as ::core::ffi::c_int {
            (*m).p_fref[4 as ::core::ffi::c_int as usize] = &mut *(*p_fref
                .offset(4 as ::core::ffi::c_int as isize))
            .offset(
                (4 as ::core::ffi::c_int * x4
                    + 4 as ::core::ffi::c_int
                        * y4
                        * *(*m)
                            .i_stride
                            .as_mut_ptr()
                            .offset(1 as ::core::ffi::c_int as isize)) as isize,
            ) as *mut pixel;
            (*m).p_fref[8 as ::core::ffi::c_int as usize] = &mut *(*p_fref
                .offset(8 as ::core::ffi::c_int as isize))
            .offset(
                (4 as ::core::ffi::c_int * x4
                    + 4 as ::core::ffi::c_int
                        * y4
                        * *(*m)
                            .i_stride
                            .as_mut_ptr()
                            .offset(2 as ::core::ffi::c_int as isize)) as isize,
            ) as *mut pixel;
            if (*h).param.analyse.i_subpel_refine != 0 {
                (*m).p_fref[5 as ::core::ffi::c_int as usize] =
                    &mut *(*p_fref.offset(5 as ::core::ffi::c_int as isize)).offset(
                        (4 as ::core::ffi::c_int * x4
                            + 4 as ::core::ffi::c_int
                                * y4
                                * *(*m)
                                    .i_stride
                                    .as_mut_ptr()
                                    .offset(1 as ::core::ffi::c_int as isize))
                            as isize,
                    ) as *mut pixel;
                (*m).p_fref[6 as ::core::ffi::c_int as usize] =
                    &mut *(*p_fref.offset(6 as ::core::ffi::c_int as isize)).offset(
                        (4 as ::core::ffi::c_int * x4
                            + 4 as ::core::ffi::c_int
                                * y4
                                * *(*m)
                                    .i_stride
                                    .as_mut_ptr()
                                    .offset(1 as ::core::ffi::c_int as isize))
                            as isize,
                    ) as *mut pixel;
                (*m).p_fref[7 as ::core::ffi::c_int as usize] =
                    &mut *(*p_fref.offset(7 as ::core::ffi::c_int as isize)).offset(
                        (4 as ::core::ffi::c_int * x4
                            + 4 as ::core::ffi::c_int
                                * y4
                                * *(*m)
                                    .i_stride
                                    .as_mut_ptr()
                                    .offset(1 as ::core::ffi::c_int as isize))
                            as isize,
                    ) as *mut pixel;
                (*m).p_fref[9 as ::core::ffi::c_int as usize] =
                    &mut *(*p_fref.offset(9 as ::core::ffi::c_int as isize)).offset(
                        (4 as ::core::ffi::c_int * x4
                            + 4 as ::core::ffi::c_int
                                * y4
                                * *(*m)
                                    .i_stride
                                    .as_mut_ptr()
                                    .offset(2 as ::core::ffi::c_int as isize))
                            as isize,
                    ) as *mut pixel;
                (*m).p_fref[10 as ::core::ffi::c_int as usize] =
                    &mut *(*p_fref.offset(10 as ::core::ffi::c_int as isize)).offset(
                        (4 as ::core::ffi::c_int * x4
                            + 4 as ::core::ffi::c_int
                                * y4
                                * *(*m)
                                    .i_stride
                                    .as_mut_ptr()
                                    .offset(2 as ::core::ffi::c_int as isize))
                            as isize,
                    ) as *mut pixel;
                (*m).p_fref[11 as ::core::ffi::c_int as usize] =
                    &mut *(*p_fref.offset(11 as ::core::ffi::c_int as isize)).offset(
                        (4 as ::core::ffi::c_int * x4
                            + 4 as ::core::ffi::c_int
                                * y4
                                * *(*m)
                                    .i_stride
                                    .as_mut_ptr()
                                    .offset(2 as ::core::ffi::c_int as isize))
                            as isize,
                    ) as *mut pixel;
            }
        } else if (*(*h).sps.as_mut_ptr()).i_chroma_format_idc != 0 {
            (*m).p_fref[4 as ::core::ffi::c_int as usize] = &mut *(*p_fref
                .offset(4 as ::core::ffi::c_int as isize))
            .offset(
                (4 as ::core::ffi::c_int * x4
                    + (4 as ::core::ffi::c_int * y4 >> (*h).mb.chroma_v_shift)
                        * *(*m)
                            .i_stride
                            .as_mut_ptr()
                            .offset(1 as ::core::ffi::c_int as isize)) as isize,
            ) as *mut pixel;
        }
        if (*h).param.analyse.i_me_method >= X264_ME_ESA {
            (*m).integral = &mut *(*(*(*h)
                .mb
                .pic
                .p_integral
                .as_mut_ptr()
                .offset(0 as ::core::ffi::c_int as isize))
            .as_mut_ptr()
            .offset(i_ref as isize))
            .offset(
                (4 as ::core::ffi::c_int * x4
                    + 4 as ::core::ffi::c_int
                        * y4
                        * *(*m)
                            .i_stride
                            .as_mut_ptr()
                            .offset(0 as ::core::ffi::c_int as isize)) as isize,
            ) as *mut uint16_t;
        }
        (*m).weight = x264_zero.as_mut_ptr() as *const x264_weight_t;
        (*m).i_ref = i_ref;
        (*m).p_fref_w = &mut *(*(*h).mb.pic.p_fref_w.as_mut_ptr().offset(i_ref as isize)).offset(
            (4 as ::core::ffi::c_int * x4
                + 4 as ::core::ffi::c_int
                    * y4
                    * *(*m)
                        .i_stride
                        .as_mut_ptr()
                        .offset(0 as ::core::ffi::c_int as isize)) as isize,
        ) as *mut pixel;
        (*m).weight = (*(*h).sh.weight.as_mut_ptr().offset(i_ref as isize)).as_mut_ptr();
        x264_10_mb_predict_mv(
            h,
            0 as ::core::ffi::c_int,
            idx,
            1 as ::core::ffi::c_int,
            (*m).mvp.as_mut_ptr(),
        );
        x264_10_me_search_ref(
            h,
            m,
            &mut (*(*a).l0.me8x8.as_mut_ptr().offset(i8x8 as isize)).mv,
            i_mvc,
            0 as *mut ::core::ffi::c_int,
        );
        x264_macroblock_cache_mv(
            h,
            x4,
            y4,
            1 as ::core::ffi::c_int,
            1 as ::core::ffi::c_int,
            0 as ::core::ffi::c_int,
            (*((*m).mv.as_mut_ptr() as *mut x264_union32_t)).i,
        );
        i4x4 += 1;
    }
    (*a).l0.i_cost4x4[i8x8 as usize] = (*a).l0.me4x4[i8x8 as usize]
        [0 as ::core::ffi::c_int as usize]
        .cost
        + (*a).l0.me4x4[i8x8 as usize][1 as ::core::ffi::c_int as usize].cost
        + (*a).l0.me4x4[i8x8 as usize][2 as ::core::ffi::c_int as usize].cost
        + (*a).l0.me4x4[i8x8 as usize][3 as ::core::ffi::c_int as usize].cost
        + *(*a).p_cost_ref[0 as ::core::ffi::c_int as usize].offset(i_ref as isize)
            as ::core::ffi::c_int
        + (*a).i_lambda
            * i_sub_mb_p_cost_table[D_L0_4x4 as ::core::ffi::c_int as usize] as ::core::ffi::c_int;
    if (*h).mb.b_chroma_me != 0
        && !((*(*h).sps.as_mut_ptr()).i_chroma_format_idc == CHROMA_444 as ::core::ffi::c_int)
    {
        (*a).l0.i_cost4x4[i8x8 as usize] +=
            mb_analyse_inter_p4x4_chroma(h, a, p_fref, i8x8, PIXEL_4x4 as ::core::ffi::c_int);
    }
}
#[c2rust::src_loc = "1724:1"]
unsafe extern "C" fn mb_analyse_inter_p8x4(
    mut h: *mut x264_t,
    mut a: *mut x264_mb_analysis_t,
    mut i8x8: ::core::ffi::c_int,
) {
    let mut p_fref: *mut *mut pixel = (*(*(*h)
        .mb
        .pic
        .p_fref
        .as_mut_ptr()
        .offset(0 as ::core::ffi::c_int as isize))
    .as_mut_ptr()
    .offset((*(*a).l0.me8x8.as_mut_ptr().offset(i8x8 as isize)).i_ref as isize))
    .as_mut_ptr();
    let mut p_fenc: *mut *mut pixel = (*h).mb.pic.p_fenc.as_mut_ptr();
    let i_ref: ::core::ffi::c_int = (*a).l0.me8x8[i8x8 as usize].i_ref;
    (*h).mb.i_partition = D_8x8 as ::core::ffi::c_int;
    let mut i8x4: ::core::ffi::c_int = 0 as ::core::ffi::c_int;
    while i8x4 < 2 as ::core::ffi::c_int {
        let idx: ::core::ffi::c_int =
            4 as ::core::ffi::c_int * i8x8 + 2 as ::core::ffi::c_int * i8x4;
        let x4: ::core::ffi::c_int = block_idx_x[idx as usize] as ::core::ffi::c_int;
        let y4: ::core::ffi::c_int = block_idx_y[idx as usize] as ::core::ffi::c_int;
        let i_mvc: ::core::ffi::c_int = (i8x4 == 0 as ::core::ffi::c_int) as ::core::ffi::c_int;
        let mut m: *mut x264_me_t = &mut *(*(*a).l0.me8x4.as_mut_ptr().offset(i8x8 as isize))
            .as_mut_ptr()
            .offset(i8x4 as isize) as *mut x264_me_t;
        (*m).i_pixel = PIXEL_8x4 as ::core::ffi::c_int;
        (*m).p_cost_mv = (*a).p_cost_mv;
        (*m).i_stride[0 as ::core::ffi::c_int as usize] =
            (*h).mb.pic.i_stride[0 as ::core::ffi::c_int as usize];
        (*m).i_stride[1 as ::core::ffi::c_int as usize] =
            (*h).mb.pic.i_stride[1 as ::core::ffi::c_int as usize];
        (*m).i_stride[2 as ::core::ffi::c_int as usize] =
            (*h).mb.pic.i_stride[2 as ::core::ffi::c_int as usize];
        (*m).p_fenc[0 as ::core::ffi::c_int as usize] = &mut *(*p_fenc
            .offset(0 as ::core::ffi::c_int as isize))
        .offset(
            (4 as ::core::ffi::c_int * x4 + 4 as ::core::ffi::c_int * y4 * FENC_STRIDE) as isize,
        ) as *mut pixel;
        if (*(*h).sps.as_mut_ptr()).i_chroma_format_idc != 0 {
            (*m).p_fenc[1 as ::core::ffi::c_int as usize] =
                &mut *(*p_fenc.offset(1 as ::core::ffi::c_int as isize)).offset(
                    ((4 as ::core::ffi::c_int * x4 >> (*h).mb.chroma_h_shift)
                        + (4 as ::core::ffi::c_int * y4 >> (*h).mb.chroma_v_shift) * FENC_STRIDE)
                        as isize,
                ) as *mut pixel;
            (*m).p_fenc[2 as ::core::ffi::c_int as usize] =
                &mut *(*p_fenc.offset(2 as ::core::ffi::c_int as isize)).offset(
                    ((4 as ::core::ffi::c_int * x4 >> (*h).mb.chroma_h_shift)
                        + (4 as ::core::ffi::c_int * y4 >> (*h).mb.chroma_v_shift) * FENC_STRIDE)
                        as isize,
                ) as *mut pixel;
        }
        (*m).p_fref[0 as ::core::ffi::c_int as usize] =
            &mut *(*p_fref.offset(0 as ::core::ffi::c_int as isize)).offset(
                (4 as ::core::ffi::c_int * x4
                    + 4 as ::core::ffi::c_int
                        * y4
                        * *(*m)
                            .i_stride
                            .as_mut_ptr()
                            .offset(0 as ::core::ffi::c_int as isize)) as isize,
            ) as *mut pixel;
        (*m).p_fref_w = (*m).p_fref[0 as ::core::ffi::c_int as usize];
        if (*h).param.analyse.i_subpel_refine != 0 {
            (*m).p_fref[1 as ::core::ffi::c_int as usize] = &mut *(*p_fref
                .offset(1 as ::core::ffi::c_int as isize))
            .offset(
                (4 as ::core::ffi::c_int * x4
                    + 4 as ::core::ffi::c_int
                        * y4
                        * *(*m)
                            .i_stride
                            .as_mut_ptr()
                            .offset(0 as ::core::ffi::c_int as isize)) as isize,
            ) as *mut pixel;
            (*m).p_fref[2 as ::core::ffi::c_int as usize] = &mut *(*p_fref
                .offset(2 as ::core::ffi::c_int as isize))
            .offset(
                (4 as ::core::ffi::c_int * x4
                    + 4 as ::core::ffi::c_int
                        * y4
                        * *(*m)
                            .i_stride
                            .as_mut_ptr()
                            .offset(0 as ::core::ffi::c_int as isize)) as isize,
            ) as *mut pixel;
            (*m).p_fref[3 as ::core::ffi::c_int as usize] = &mut *(*p_fref
                .offset(3 as ::core::ffi::c_int as isize))
            .offset(
                (4 as ::core::ffi::c_int * x4
                    + 4 as ::core::ffi::c_int
                        * y4
                        * *(*m)
                            .i_stride
                            .as_mut_ptr()
                            .offset(0 as ::core::ffi::c_int as isize)) as isize,
            ) as *mut pixel;
        }
        if (*(*h).sps.as_mut_ptr()).i_chroma_format_idc == CHROMA_444 as ::core::ffi::c_int {
            (*m).p_fref[4 as ::core::ffi::c_int as usize] = &mut *(*p_fref
                .offset(4 as ::core::ffi::c_int as isize))
            .offset(
                (4 as ::core::ffi::c_int * x4
                    + 4 as ::core::ffi::c_int
                        * y4
                        * *(*m)
                            .i_stride
                            .as_mut_ptr()
                            .offset(1 as ::core::ffi::c_int as isize)) as isize,
            ) as *mut pixel;
            (*m).p_fref[8 as ::core::ffi::c_int as usize] = &mut *(*p_fref
                .offset(8 as ::core::ffi::c_int as isize))
            .offset(
                (4 as ::core::ffi::c_int * x4
                    + 4 as ::core::ffi::c_int
                        * y4
                        * *(*m)
                            .i_stride
                            .as_mut_ptr()
                            .offset(2 as ::core::ffi::c_int as isize)) as isize,
            ) as *mut pixel;
            if (*h).param.analyse.i_subpel_refine != 0 {
                (*m).p_fref[5 as ::core::ffi::c_int as usize] =
                    &mut *(*p_fref.offset(5 as ::core::ffi::c_int as isize)).offset(
                        (4 as ::core::ffi::c_int * x4
                            + 4 as ::core::ffi::c_int
                                * y4
                                * *(*m)
                                    .i_stride
                                    .as_mut_ptr()
                                    .offset(1 as ::core::ffi::c_int as isize))
                            as isize,
                    ) as *mut pixel;
                (*m).p_fref[6 as ::core::ffi::c_int as usize] =
                    &mut *(*p_fref.offset(6 as ::core::ffi::c_int as isize)).offset(
                        (4 as ::core::ffi::c_int * x4
                            + 4 as ::core::ffi::c_int
                                * y4
                                * *(*m)
                                    .i_stride
                                    .as_mut_ptr()
                                    .offset(1 as ::core::ffi::c_int as isize))
                            as isize,
                    ) as *mut pixel;
                (*m).p_fref[7 as ::core::ffi::c_int as usize] =
                    &mut *(*p_fref.offset(7 as ::core::ffi::c_int as isize)).offset(
                        (4 as ::core::ffi::c_int * x4
                            + 4 as ::core::ffi::c_int
                                * y4
                                * *(*m)
                                    .i_stride
                                    .as_mut_ptr()
                                    .offset(1 as ::core::ffi::c_int as isize))
                            as isize,
                    ) as *mut pixel;
                (*m).p_fref[9 as ::core::ffi::c_int as usize] =
                    &mut *(*p_fref.offset(9 as ::core::ffi::c_int as isize)).offset(
                        (4 as ::core::ffi::c_int * x4
                            + 4 as ::core::ffi::c_int
                                * y4
                                * *(*m)
                                    .i_stride
                                    .as_mut_ptr()
                                    .offset(2 as ::core::ffi::c_int as isize))
                            as isize,
                    ) as *mut pixel;
                (*m).p_fref[10 as ::core::ffi::c_int as usize] =
                    &mut *(*p_fref.offset(10 as ::core::ffi::c_int as isize)).offset(
                        (4 as ::core::ffi::c_int * x4
                            + 4 as ::core::ffi::c_int
                                * y4
                                * *(*m)
                                    .i_stride
                                    .as_mut_ptr()
                                    .offset(2 as ::core::ffi::c_int as isize))
                            as isize,
                    ) as *mut pixel;
                (*m).p_fref[11 as ::core::ffi::c_int as usize] =
                    &mut *(*p_fref.offset(11 as ::core::ffi::c_int as isize)).offset(
                        (4 as ::core::ffi::c_int * x4
                            + 4 as ::core::ffi::c_int
                                * y4
                                * *(*m)
                                    .i_stride
                                    .as_mut_ptr()
                                    .offset(2 as ::core::ffi::c_int as isize))
                            as isize,
                    ) as *mut pixel;
            }
        } else if (*(*h).sps.as_mut_ptr()).i_chroma_format_idc != 0 {
            (*m).p_fref[4 as ::core::ffi::c_int as usize] = &mut *(*p_fref
                .offset(4 as ::core::ffi::c_int as isize))
            .offset(
                (4 as ::core::ffi::c_int * x4
                    + (4 as ::core::ffi::c_int * y4 >> (*h).mb.chroma_v_shift)
                        * *(*m)
                            .i_stride
                            .as_mut_ptr()
                            .offset(1 as ::core::ffi::c_int as isize)) as isize,
            ) as *mut pixel;
        }
        if (*h).param.analyse.i_me_method >= X264_ME_ESA {
            (*m).integral = &mut *(*(*(*h)
                .mb
                .pic
                .p_integral
                .as_mut_ptr()
                .offset(0 as ::core::ffi::c_int as isize))
            .as_mut_ptr()
            .offset(i_ref as isize))
            .offset(
                (4 as ::core::ffi::c_int * x4
                    + 4 as ::core::ffi::c_int
                        * y4
                        * *(*m)
                            .i_stride
                            .as_mut_ptr()
                            .offset(0 as ::core::ffi::c_int as isize)) as isize,
            ) as *mut uint16_t;
        }
        (*m).weight = x264_zero.as_mut_ptr() as *const x264_weight_t;
        (*m).i_ref = i_ref;
        (*m).p_fref_w = &mut *(*(*h).mb.pic.p_fref_w.as_mut_ptr().offset(i_ref as isize)).offset(
            (4 as ::core::ffi::c_int * x4
                + 4 as ::core::ffi::c_int
                    * y4
                    * *(*m)
                        .i_stride
                        .as_mut_ptr()
                        .offset(0 as ::core::ffi::c_int as isize)) as isize,
        ) as *mut pixel;
        (*m).weight = (*(*h).sh.weight.as_mut_ptr().offset(i_ref as isize)).as_mut_ptr();
        x264_10_mb_predict_mv(
            h,
            0 as ::core::ffi::c_int,
            idx,
            2 as ::core::ffi::c_int,
            (*m).mvp.as_mut_ptr(),
        );
        x264_10_me_search_ref(
            h,
            m,
            &mut (*(*(*a).l0.me4x4.as_mut_ptr().offset(i8x8 as isize))
                .as_mut_ptr()
                .offset(0 as ::core::ffi::c_int as isize))
            .mv,
            i_mvc,
            0 as *mut ::core::ffi::c_int,
        );
        x264_macroblock_cache_mv(
            h,
            x4,
            y4,
            2 as ::core::ffi::c_int,
            1 as ::core::ffi::c_int,
            0 as ::core::ffi::c_int,
            (*((*m).mv.as_mut_ptr() as *mut x264_union32_t)).i,
        );
        i8x4 += 1;
    }
    (*a).l0.i_cost8x4[i8x8 as usize] = (*a).l0.me8x4[i8x8 as usize]
        [0 as ::core::ffi::c_int as usize]
        .cost
        + (*a).l0.me8x4[i8x8 as usize][1 as ::core::ffi::c_int as usize].cost
        + *(*a).p_cost_ref[0 as ::core::ffi::c_int as usize].offset(i_ref as isize)
            as ::core::ffi::c_int
        + (*a).i_lambda
            * i_sub_mb_p_cost_table[D_L0_8x4 as ::core::ffi::c_int as usize] as ::core::ffi::c_int;
    if (*h).mb.b_chroma_me != 0
        && !((*(*h).sps.as_mut_ptr()).i_chroma_format_idc == CHROMA_444 as ::core::ffi::c_int)
    {
        (*a).l0.i_cost8x4[i8x8 as usize] +=
            mb_analyse_inter_p4x4_chroma(h, a, p_fref, i8x8, PIXEL_8x4 as ::core::ffi::c_int);
    }
}
#[c2rust::src_loc = "1760:1"]
unsafe extern "C" fn mb_analyse_inter_p4x8(
    mut h: *mut x264_t,
    mut a: *mut x264_mb_analysis_t,
    mut i8x8: ::core::ffi::c_int,
) {
    let mut p_fref: *mut *mut pixel = (*(*(*h)
        .mb
        .pic
        .p_fref
        .as_mut_ptr()
        .offset(0 as ::core::ffi::c_int as isize))
    .as_mut_ptr()
    .offset((*(*a).l0.me8x8.as_mut_ptr().offset(i8x8 as isize)).i_ref as isize))
    .as_mut_ptr();
    let mut p_fenc: *mut *mut pixel = (*h).mb.pic.p_fenc.as_mut_ptr();
    let i_ref: ::core::ffi::c_int = (*a).l0.me8x8[i8x8 as usize].i_ref;
    (*h).mb.i_partition = D_8x8 as ::core::ffi::c_int;
    let mut i4x8: ::core::ffi::c_int = 0 as ::core::ffi::c_int;
    while i4x8 < 2 as ::core::ffi::c_int {
        let idx: ::core::ffi::c_int = 4 as ::core::ffi::c_int * i8x8 + i4x8;
        let x4: ::core::ffi::c_int = block_idx_x[idx as usize] as ::core::ffi::c_int;
        let y4: ::core::ffi::c_int = block_idx_y[idx as usize] as ::core::ffi::c_int;
        let i_mvc: ::core::ffi::c_int = (i4x8 == 0 as ::core::ffi::c_int) as ::core::ffi::c_int;
        let mut m: *mut x264_me_t = &mut *(*(*a).l0.me4x8.as_mut_ptr().offset(i8x8 as isize))
            .as_mut_ptr()
            .offset(i4x8 as isize) as *mut x264_me_t;
        (*m).i_pixel = PIXEL_4x8 as ::core::ffi::c_int;
        (*m).p_cost_mv = (*a).p_cost_mv;
        (*m).i_stride[0 as ::core::ffi::c_int as usize] =
            (*h).mb.pic.i_stride[0 as ::core::ffi::c_int as usize];
        (*m).i_stride[1 as ::core::ffi::c_int as usize] =
            (*h).mb.pic.i_stride[1 as ::core::ffi::c_int as usize];
        (*m).i_stride[2 as ::core::ffi::c_int as usize] =
            (*h).mb.pic.i_stride[2 as ::core::ffi::c_int as usize];
        (*m).p_fenc[0 as ::core::ffi::c_int as usize] = &mut *(*p_fenc
            .offset(0 as ::core::ffi::c_int as isize))
        .offset(
            (4 as ::core::ffi::c_int * x4 + 4 as ::core::ffi::c_int * y4 * FENC_STRIDE) as isize,
        ) as *mut pixel;
        if (*(*h).sps.as_mut_ptr()).i_chroma_format_idc != 0 {
            (*m).p_fenc[1 as ::core::ffi::c_int as usize] =
                &mut *(*p_fenc.offset(1 as ::core::ffi::c_int as isize)).offset(
                    ((4 as ::core::ffi::c_int * x4 >> (*h).mb.chroma_h_shift)
                        + (4 as ::core::ffi::c_int * y4 >> (*h).mb.chroma_v_shift) * FENC_STRIDE)
                        as isize,
                ) as *mut pixel;
            (*m).p_fenc[2 as ::core::ffi::c_int as usize] =
                &mut *(*p_fenc.offset(2 as ::core::ffi::c_int as isize)).offset(
                    ((4 as ::core::ffi::c_int * x4 >> (*h).mb.chroma_h_shift)
                        + (4 as ::core::ffi::c_int * y4 >> (*h).mb.chroma_v_shift) * FENC_STRIDE)
                        as isize,
                ) as *mut pixel;
        }
        (*m).p_fref[0 as ::core::ffi::c_int as usize] =
            &mut *(*p_fref.offset(0 as ::core::ffi::c_int as isize)).offset(
                (4 as ::core::ffi::c_int * x4
                    + 4 as ::core::ffi::c_int
                        * y4
                        * *(*m)
                            .i_stride
                            .as_mut_ptr()
                            .offset(0 as ::core::ffi::c_int as isize)) as isize,
            ) as *mut pixel;
        (*m).p_fref_w = (*m).p_fref[0 as ::core::ffi::c_int as usize];
        if (*h).param.analyse.i_subpel_refine != 0 {
            (*m).p_fref[1 as ::core::ffi::c_int as usize] = &mut *(*p_fref
                .offset(1 as ::core::ffi::c_int as isize))
            .offset(
                (4 as ::core::ffi::c_int * x4
                    + 4 as ::core::ffi::c_int
                        * y4
                        * *(*m)
                            .i_stride
                            .as_mut_ptr()
                            .offset(0 as ::core::ffi::c_int as isize)) as isize,
            ) as *mut pixel;
            (*m).p_fref[2 as ::core::ffi::c_int as usize] = &mut *(*p_fref
                .offset(2 as ::core::ffi::c_int as isize))
            .offset(
                (4 as ::core::ffi::c_int * x4
                    + 4 as ::core::ffi::c_int
                        * y4
                        * *(*m)
                            .i_stride
                            .as_mut_ptr()
                            .offset(0 as ::core::ffi::c_int as isize)) as isize,
            ) as *mut pixel;
            (*m).p_fref[3 as ::core::ffi::c_int as usize] = &mut *(*p_fref
                .offset(3 as ::core::ffi::c_int as isize))
            .offset(
                (4 as ::core::ffi::c_int * x4
                    + 4 as ::core::ffi::c_int
                        * y4
                        * *(*m)
                            .i_stride
                            .as_mut_ptr()
                            .offset(0 as ::core::ffi::c_int as isize)) as isize,
            ) as *mut pixel;
        }
        if (*(*h).sps.as_mut_ptr()).i_chroma_format_idc == CHROMA_444 as ::core::ffi::c_int {
            (*m).p_fref[4 as ::core::ffi::c_int as usize] = &mut *(*p_fref
                .offset(4 as ::core::ffi::c_int as isize))
            .offset(
                (4 as ::core::ffi::c_int * x4
                    + 4 as ::core::ffi::c_int
                        * y4
                        * *(*m)
                            .i_stride
                            .as_mut_ptr()
                            .offset(1 as ::core::ffi::c_int as isize)) as isize,
            ) as *mut pixel;
            (*m).p_fref[8 as ::core::ffi::c_int as usize] = &mut *(*p_fref
                .offset(8 as ::core::ffi::c_int as isize))
            .offset(
                (4 as ::core::ffi::c_int * x4
                    + 4 as ::core::ffi::c_int
                        * y4
                        * *(*m)
                            .i_stride
                            .as_mut_ptr()
                            .offset(2 as ::core::ffi::c_int as isize)) as isize,
            ) as *mut pixel;
            if (*h).param.analyse.i_subpel_refine != 0 {
                (*m).p_fref[5 as ::core::ffi::c_int as usize] =
                    &mut *(*p_fref.offset(5 as ::core::ffi::c_int as isize)).offset(
                        (4 as ::core::ffi::c_int * x4
                            + 4 as ::core::ffi::c_int
                                * y4
                                * *(*m)
                                    .i_stride
                                    .as_mut_ptr()
                                    .offset(1 as ::core::ffi::c_int as isize))
                            as isize,
                    ) as *mut pixel;
                (*m).p_fref[6 as ::core::ffi::c_int as usize] =
                    &mut *(*p_fref.offset(6 as ::core::ffi::c_int as isize)).offset(
                        (4 as ::core::ffi::c_int * x4
                            + 4 as ::core::ffi::c_int
                                * y4
                                * *(*m)
                                    .i_stride
                                    .as_mut_ptr()
                                    .offset(1 as ::core::ffi::c_int as isize))
                            as isize,
                    ) as *mut pixel;
                (*m).p_fref[7 as ::core::ffi::c_int as usize] =
                    &mut *(*p_fref.offset(7 as ::core::ffi::c_int as isize)).offset(
                        (4 as ::core::ffi::c_int * x4
                            + 4 as ::core::ffi::c_int
                                * y4
                                * *(*m)
                                    .i_stride
                                    .as_mut_ptr()
                                    .offset(1 as ::core::ffi::c_int as isize))
                            as isize,
                    ) as *mut pixel;
                (*m).p_fref[9 as ::core::ffi::c_int as usize] =
                    &mut *(*p_fref.offset(9 as ::core::ffi::c_int as isize)).offset(
                        (4 as ::core::ffi::c_int * x4
                            + 4 as ::core::ffi::c_int
                                * y4
                                * *(*m)
                                    .i_stride
                                    .as_mut_ptr()
                                    .offset(2 as ::core::ffi::c_int as isize))
                            as isize,
                    ) as *mut pixel;
                (*m).p_fref[10 as ::core::ffi::c_int as usize] =
                    &mut *(*p_fref.offset(10 as ::core::ffi::c_int as isize)).offset(
                        (4 as ::core::ffi::c_int * x4
                            + 4 as ::core::ffi::c_int
                                * y4
                                * *(*m)
                                    .i_stride
                                    .as_mut_ptr()
                                    .offset(2 as ::core::ffi::c_int as isize))
                            as isize,
                    ) as *mut pixel;
                (*m).p_fref[11 as ::core::ffi::c_int as usize] =
                    &mut *(*p_fref.offset(11 as ::core::ffi::c_int as isize)).offset(
                        (4 as ::core::ffi::c_int * x4
                            + 4 as ::core::ffi::c_int
                                * y4
                                * *(*m)
                                    .i_stride
                                    .as_mut_ptr()
                                    .offset(2 as ::core::ffi::c_int as isize))
                            as isize,
                    ) as *mut pixel;
            }
        } else if (*(*h).sps.as_mut_ptr()).i_chroma_format_idc != 0 {
            (*m).p_fref[4 as ::core::ffi::c_int as usize] = &mut *(*p_fref
                .offset(4 as ::core::ffi::c_int as isize))
            .offset(
                (4 as ::core::ffi::c_int * x4
                    + (4 as ::core::ffi::c_int * y4 >> (*h).mb.chroma_v_shift)
                        * *(*m)
                            .i_stride
                            .as_mut_ptr()
                            .offset(1 as ::core::ffi::c_int as isize)) as isize,
            ) as *mut pixel;
        }
        if (*h).param.analyse.i_me_method >= X264_ME_ESA {
            (*m).integral = &mut *(*(*(*h)
                .mb
                .pic
                .p_integral
                .as_mut_ptr()
                .offset(0 as ::core::ffi::c_int as isize))
            .as_mut_ptr()
            .offset(i_ref as isize))
            .offset(
                (4 as ::core::ffi::c_int * x4
                    + 4 as ::core::ffi::c_int
                        * y4
                        * *(*m)
                            .i_stride
                            .as_mut_ptr()
                            .offset(0 as ::core::ffi::c_int as isize)) as isize,
            ) as *mut uint16_t;
        }
        (*m).weight = x264_zero.as_mut_ptr() as *const x264_weight_t;
        (*m).i_ref = i_ref;
        (*m).p_fref_w = &mut *(*(*h).mb.pic.p_fref_w.as_mut_ptr().offset(i_ref as isize)).offset(
            (4 as ::core::ffi::c_int * x4
                + 4 as ::core::ffi::c_int
                    * y4
                    * *(*m)
                        .i_stride
                        .as_mut_ptr()
                        .offset(0 as ::core::ffi::c_int as isize)) as isize,
        ) as *mut pixel;
        (*m).weight = (*(*h).sh.weight.as_mut_ptr().offset(i_ref as isize)).as_mut_ptr();
        x264_10_mb_predict_mv(
            h,
            0 as ::core::ffi::c_int,
            idx,
            1 as ::core::ffi::c_int,
            (*m).mvp.as_mut_ptr(),
        );
        x264_10_me_search_ref(
            h,
            m,
            &mut (*(*(*a).l0.me4x4.as_mut_ptr().offset(i8x8 as isize))
                .as_mut_ptr()
                .offset(0 as ::core::ffi::c_int as isize))
            .mv,
            i_mvc,
            0 as *mut ::core::ffi::c_int,
        );
        x264_macroblock_cache_mv(
            h,
            x4,
            y4,
            1 as ::core::ffi::c_int,
            2 as ::core::ffi::c_int,
            0 as ::core::ffi::c_int,
            (*((*m).mv.as_mut_ptr() as *mut x264_union32_t)).i,
        );
        i4x8 += 1;
    }
    (*a).l0.i_cost4x8[i8x8 as usize] = (*a).l0.me4x8[i8x8 as usize]
        [0 as ::core::ffi::c_int as usize]
        .cost
        + (*a).l0.me4x8[i8x8 as usize][1 as ::core::ffi::c_int as usize].cost
        + *(*a).p_cost_ref[0 as ::core::ffi::c_int as usize].offset(i_ref as isize)
            as ::core::ffi::c_int
        + (*a).i_lambda
            * i_sub_mb_p_cost_table[D_L0_4x8 as ::core::ffi::c_int as usize] as ::core::ffi::c_int;
    if (*h).mb.b_chroma_me != 0
        && !((*(*h).sps.as_mut_ptr()).i_chroma_format_idc == CHROMA_444 as ::core::ffi::c_int)
    {
        (*a).l0.i_cost4x8[i8x8 as usize] +=
            mb_analyse_inter_p4x4_chroma(h, a, p_fref, i8x8, PIXEL_4x8 as ::core::ffi::c_int);
    }
}
#[inline(always)]
#[c2rust::src_loc = "1796:1"]
unsafe extern "C" fn analyse_bi_chroma(
    mut h: *mut x264_t,
    mut a: *mut x264_mb_analysis_t,
    mut idx: ::core::ffi::c_int,
    mut i_pixel: ::core::ffi::c_int,
) -> ::core::ffi::c_int {
    let mut pix: [[pixel; 256]; 4] = [[0; 256]; 4];
    let mut bi: [[pixel; 256]; 2] = [[0; 256]; 2];
    let mut i_chroma_cost: ::core::ffi::c_int = 0 as ::core::ffi::c_int;
    let mut chromapix: ::core::ffi::c_int =
        (*h).luma2chroma_pixel[i_pixel as usize] as ::core::ffi::c_int;
    if i_pixel == PIXEL_16x16 as ::core::ffi::c_int {
        if (*(*h).sps.as_mut_ptr()).i_chroma_format_idc == CHROMA_444 as ::core::ffi::c_int {
            (*h).mc.mc_luma.expect("non-null function pointer")(
                (*pix.as_mut_ptr().offset(0 as ::core::ffi::c_int as isize)).as_mut_ptr(),
                16 as intptr_t,
                &mut *(*a)
                    .l0
                    .bi16x16
                    .p_fref
                    .as_mut_ptr()
                    .offset(4 as ::core::ffi::c_int as isize),
                (*a).l0.bi16x16.i_stride[1 as ::core::ffi::c_int as usize] as intptr_t,
                (*a).l0.bi16x16.mv[0 as ::core::ffi::c_int as usize] as ::core::ffi::c_int,
                (*a).l0.bi16x16.mv[1 as ::core::ffi::c_int as usize] as ::core::ffi::c_int,
                16 as ::core::ffi::c_int,
                16 as ::core::ffi::c_int,
                x264_zero.as_mut_ptr() as *const x264_weight_t,
            );
            (*h).mc.mc_luma.expect("non-null function pointer")(
                (*pix.as_mut_ptr().offset(1 as ::core::ffi::c_int as isize)).as_mut_ptr(),
                16 as intptr_t,
                &mut *(*a)
                    .l0
                    .bi16x16
                    .p_fref
                    .as_mut_ptr()
                    .offset(8 as ::core::ffi::c_int as isize),
                (*a).l0.bi16x16.i_stride[2 as ::core::ffi::c_int as usize] as intptr_t,
                (*a).l0.bi16x16.mv[0 as ::core::ffi::c_int as usize] as ::core::ffi::c_int,
                (*a).l0.bi16x16.mv[1 as ::core::ffi::c_int as usize] as ::core::ffi::c_int,
                16 as ::core::ffi::c_int,
                16 as ::core::ffi::c_int,
                x264_zero.as_mut_ptr() as *const x264_weight_t,
            );
            (*h).mc.mc_luma.expect("non-null function pointer")(
                (*pix.as_mut_ptr().offset(2 as ::core::ffi::c_int as isize)).as_mut_ptr(),
                16 as intptr_t,
                &mut *(*a)
                    .l1
                    .bi16x16
                    .p_fref
                    .as_mut_ptr()
                    .offset(4 as ::core::ffi::c_int as isize),
                (*a).l1.bi16x16.i_stride[1 as ::core::ffi::c_int as usize] as intptr_t,
                (*a).l1.bi16x16.mv[0 as ::core::ffi::c_int as usize] as ::core::ffi::c_int,
                (*a).l1.bi16x16.mv[1 as ::core::ffi::c_int as usize] as ::core::ffi::c_int,
                16 as ::core::ffi::c_int,
                16 as ::core::ffi::c_int,
                x264_zero.as_mut_ptr() as *const x264_weight_t,
            );
            (*h).mc.mc_luma.expect("non-null function pointer")(
                (*pix.as_mut_ptr().offset(3 as ::core::ffi::c_int as isize)).as_mut_ptr(),
                16 as intptr_t,
                &mut *(*a)
                    .l1
                    .bi16x16
                    .p_fref
                    .as_mut_ptr()
                    .offset(8 as ::core::ffi::c_int as isize),
                (*a).l1.bi16x16.i_stride[2 as ::core::ffi::c_int as usize] as intptr_t,
                (*a).l1.bi16x16.mv[0 as ::core::ffi::c_int as usize] as ::core::ffi::c_int,
                (*a).l1.bi16x16.mv[1 as ::core::ffi::c_int as usize] as ::core::ffi::c_int,
                16 as ::core::ffi::c_int,
                16 as ::core::ffi::c_int,
                x264_zero.as_mut_ptr() as *const x264_weight_t,
            );
        } else {
            let mut v_shift: ::core::ffi::c_int = (*h).mb.chroma_v_shift;
            let mut l0_mvy_offset: ::core::ffi::c_int =
                if v_shift & (*h).mb.b_interlaced & (*a).l0.bi16x16.i_ref != 0 {
                    ((*h).mb.i_mb_y & 1 as ::core::ffi::c_int) * 4 as ::core::ffi::c_int
                        - 2 as ::core::ffi::c_int
                } else {
                    0 as ::core::ffi::c_int
                };
            let mut l1_mvy_offset: ::core::ffi::c_int =
                if v_shift & (*h).mb.b_interlaced & (*a).l1.bi16x16.i_ref != 0 {
                    ((*h).mb.i_mb_y & 1 as ::core::ffi::c_int) * 4 as ::core::ffi::c_int
                        - 2 as ::core::ffi::c_int
                } else {
                    0 as ::core::ffi::c_int
                };
            (*h).mc.mc_chroma.expect("non-null function pointer")(
                (*pix.as_mut_ptr().offset(0 as ::core::ffi::c_int as isize)).as_mut_ptr(),
                (*pix.as_mut_ptr().offset(1 as ::core::ffi::c_int as isize)).as_mut_ptr(),
                16 as intptr_t,
                (*a).l0.bi16x16.p_fref[4 as ::core::ffi::c_int as usize],
                (*a).l0.bi16x16.i_stride[1 as ::core::ffi::c_int as usize] as intptr_t,
                (*a).l0.bi16x16.mv[0 as ::core::ffi::c_int as usize] as ::core::ffi::c_int,
                2 as ::core::ffi::c_int
                    * ((*a).l0.bi16x16.mv[1 as ::core::ffi::c_int as usize] as ::core::ffi::c_int
                        + l0_mvy_offset)
                    >> v_shift,
                16 as ::core::ffi::c_int >> 1 as ::core::ffi::c_int,
                16 as ::core::ffi::c_int >> v_shift,
            );
            (*h).mc.mc_chroma.expect("non-null function pointer")(
                (*pix.as_mut_ptr().offset(2 as ::core::ffi::c_int as isize)).as_mut_ptr(),
                (*pix.as_mut_ptr().offset(3 as ::core::ffi::c_int as isize)).as_mut_ptr(),
                16 as intptr_t,
                (*a).l1.bi16x16.p_fref[4 as ::core::ffi::c_int as usize],
                (*a).l1.bi16x16.i_stride[1 as ::core::ffi::c_int as usize] as intptr_t,
                (*a).l1.bi16x16.mv[0 as ::core::ffi::c_int as usize] as ::core::ffi::c_int,
                2 as ::core::ffi::c_int
                    * ((*a).l1.bi16x16.mv[1 as ::core::ffi::c_int as usize] as ::core::ffi::c_int
                        + l1_mvy_offset)
                    >> v_shift,
                16 as ::core::ffi::c_int >> 1 as ::core::ffi::c_int,
                16 as ::core::ffi::c_int >> v_shift,
            );
        }
        (*h).mc.avg[chromapix as usize].expect("non-null function pointer")(
            (*bi.as_mut_ptr().offset(0 as ::core::ffi::c_int as isize)).as_mut_ptr(),
            16 as intptr_t,
            (*pix.as_mut_ptr().offset(0 as ::core::ffi::c_int as isize)).as_mut_ptr(),
            16 as intptr_t,
            (*pix.as_mut_ptr().offset(2 as ::core::ffi::c_int as isize)).as_mut_ptr(),
            16 as intptr_t,
            (*(*h).mb.bipred_weight.offset((*a).l0.bi16x16.i_ref as isize))
                [(*a).l1.bi16x16.i_ref as usize] as ::core::ffi::c_int,
        );
        (*h).mc.avg[chromapix as usize].expect("non-null function pointer")(
            (*bi.as_mut_ptr().offset(1 as ::core::ffi::c_int as isize)).as_mut_ptr(),
            16 as intptr_t,
            (*pix.as_mut_ptr().offset(1 as ::core::ffi::c_int as isize)).as_mut_ptr(),
            16 as intptr_t,
            (*pix.as_mut_ptr().offset(3 as ::core::ffi::c_int as isize)).as_mut_ptr(),
            16 as intptr_t,
            (*(*h).mb.bipred_weight.offset((*a).l0.bi16x16.i_ref as isize))
                [(*a).l1.bi16x16.i_ref as usize] as ::core::ffi::c_int,
        );
        i_chroma_cost = (*h).pixf.mbcmp[chromapix as usize].expect("non-null function pointer")(
            (*a).l0.bi16x16.p_fenc[1 as ::core::ffi::c_int as usize],
            FENC_STRIDE as intptr_t,
            (*bi.as_mut_ptr().offset(0 as ::core::ffi::c_int as isize)).as_mut_ptr(),
            16 as intptr_t,
        ) + (*h).pixf.mbcmp[chromapix as usize].expect("non-null function pointer")(
            (*a).l0.bi16x16.p_fenc[2 as ::core::ffi::c_int as usize],
            FENC_STRIDE as intptr_t,
            (*bi.as_mut_ptr().offset(1 as ::core::ffi::c_int as isize)).as_mut_ptr(),
            16 as intptr_t,
        );
    } else if i_pixel == PIXEL_16x8 as ::core::ffi::c_int {
        if (*(*h).sps.as_mut_ptr()).i_chroma_format_idc == CHROMA_444 as ::core::ffi::c_int {
            (*h).mc.mc_luma.expect("non-null function pointer")(
                (*pix.as_mut_ptr().offset(0 as ::core::ffi::c_int as isize)).as_mut_ptr(),
                16 as intptr_t,
                &mut *(*(*a).l0.me16x8.as_mut_ptr().offset(idx as isize))
                    .p_fref
                    .as_mut_ptr()
                    .offset(4 as ::core::ffi::c_int as isize),
                (*a).l0.me16x8[idx as usize].i_stride[1 as ::core::ffi::c_int as usize] as intptr_t,
                (*a).l0.me16x8[idx as usize].mv[0 as ::core::ffi::c_int as usize]
                    as ::core::ffi::c_int,
                (*a).l0.me16x8[idx as usize].mv[1 as ::core::ffi::c_int as usize]
                    as ::core::ffi::c_int,
                16 as ::core::ffi::c_int,
                8 as ::core::ffi::c_int,
                x264_zero.as_mut_ptr() as *const x264_weight_t,
            );
            (*h).mc.mc_luma.expect("non-null function pointer")(
                (*pix.as_mut_ptr().offset(1 as ::core::ffi::c_int as isize)).as_mut_ptr(),
                16 as intptr_t,
                &mut *(*(*a).l0.me16x8.as_mut_ptr().offset(idx as isize))
                    .p_fref
                    .as_mut_ptr()
                    .offset(8 as ::core::ffi::c_int as isize),
                (*a).l0.me16x8[idx as usize].i_stride[2 as ::core::ffi::c_int as usize] as intptr_t,
                (*a).l0.me16x8[idx as usize].mv[0 as ::core::ffi::c_int as usize]
                    as ::core::ffi::c_int,
                (*a).l0.me16x8[idx as usize].mv[1 as ::core::ffi::c_int as usize]
                    as ::core::ffi::c_int,
                16 as ::core::ffi::c_int,
                8 as ::core::ffi::c_int,
                x264_zero.as_mut_ptr() as *const x264_weight_t,
            );
            (*h).mc.mc_luma.expect("non-null function pointer")(
                (*pix.as_mut_ptr().offset(2 as ::core::ffi::c_int as isize)).as_mut_ptr(),
                16 as intptr_t,
                &mut *(*(*a).l1.me16x8.as_mut_ptr().offset(idx as isize))
                    .p_fref
                    .as_mut_ptr()
                    .offset(4 as ::core::ffi::c_int as isize),
                (*a).l1.me16x8[idx as usize].i_stride[1 as ::core::ffi::c_int as usize] as intptr_t,
                (*a).l1.me16x8[idx as usize].mv[0 as ::core::ffi::c_int as usize]
                    as ::core::ffi::c_int,
                (*a).l1.me16x8[idx as usize].mv[1 as ::core::ffi::c_int as usize]
                    as ::core::ffi::c_int,
                16 as ::core::ffi::c_int,
                8 as ::core::ffi::c_int,
                x264_zero.as_mut_ptr() as *const x264_weight_t,
            );
            (*h).mc.mc_luma.expect("non-null function pointer")(
                (*pix.as_mut_ptr().offset(3 as ::core::ffi::c_int as isize)).as_mut_ptr(),
                16 as intptr_t,
                &mut *(*(*a).l1.me16x8.as_mut_ptr().offset(idx as isize))
                    .p_fref
                    .as_mut_ptr()
                    .offset(8 as ::core::ffi::c_int as isize),
                (*a).l1.me16x8[idx as usize].i_stride[2 as ::core::ffi::c_int as usize] as intptr_t,
                (*a).l1.me16x8[idx as usize].mv[0 as ::core::ffi::c_int as usize]
                    as ::core::ffi::c_int,
                (*a).l1.me16x8[idx as usize].mv[1 as ::core::ffi::c_int as usize]
                    as ::core::ffi::c_int,
                16 as ::core::ffi::c_int,
                8 as ::core::ffi::c_int,
                x264_zero.as_mut_ptr() as *const x264_weight_t,
            );
        } else {
            let mut v_shift_0: ::core::ffi::c_int = (*h).mb.chroma_v_shift;
            let mut l0_mvy_offset_0: ::core::ffi::c_int =
                if v_shift_0 & (*h).mb.b_interlaced & (*a).l0.me16x8[idx as usize].i_ref != 0 {
                    ((*h).mb.i_mb_y & 1 as ::core::ffi::c_int) * 4 as ::core::ffi::c_int
                        - 2 as ::core::ffi::c_int
                } else {
                    0 as ::core::ffi::c_int
                };
            let mut l1_mvy_offset_0: ::core::ffi::c_int =
                if v_shift_0 & (*h).mb.b_interlaced & (*a).l1.me16x8[idx as usize].i_ref != 0 {
                    ((*h).mb.i_mb_y & 1 as ::core::ffi::c_int) * 4 as ::core::ffi::c_int
                        - 2 as ::core::ffi::c_int
                } else {
                    0 as ::core::ffi::c_int
                };
            (*h).mc.mc_chroma.expect("non-null function pointer")(
                (*pix.as_mut_ptr().offset(0 as ::core::ffi::c_int as isize)).as_mut_ptr(),
                (*pix.as_mut_ptr().offset(1 as ::core::ffi::c_int as isize)).as_mut_ptr(),
                16 as intptr_t,
                (*a).l0.me16x8[idx as usize].p_fref[4 as ::core::ffi::c_int as usize],
                (*a).l0.me16x8[idx as usize].i_stride[1 as ::core::ffi::c_int as usize] as intptr_t,
                (*a).l0.me16x8[idx as usize].mv[0 as ::core::ffi::c_int as usize]
                    as ::core::ffi::c_int,
                2 as ::core::ffi::c_int
                    * ((*a).l0.me16x8[idx as usize].mv[1 as ::core::ffi::c_int as usize]
                        as ::core::ffi::c_int
                        + l0_mvy_offset_0)
                    >> v_shift_0,
                16 as ::core::ffi::c_int >> 1 as ::core::ffi::c_int,
                8 as ::core::ffi::c_int >> v_shift_0,
            );
            (*h).mc.mc_chroma.expect("non-null function pointer")(
                (*pix.as_mut_ptr().offset(2 as ::core::ffi::c_int as isize)).as_mut_ptr(),
                (*pix.as_mut_ptr().offset(3 as ::core::ffi::c_int as isize)).as_mut_ptr(),
                16 as intptr_t,
                (*a).l1.me16x8[idx as usize].p_fref[4 as ::core::ffi::c_int as usize],
                (*a).l1.me16x8[idx as usize].i_stride[1 as ::core::ffi::c_int as usize] as intptr_t,
                (*a).l1.me16x8[idx as usize].mv[0 as ::core::ffi::c_int as usize]
                    as ::core::ffi::c_int,
                2 as ::core::ffi::c_int
                    * ((*a).l1.me16x8[idx as usize].mv[1 as ::core::ffi::c_int as usize]
                        as ::core::ffi::c_int
                        + l1_mvy_offset_0)
                    >> v_shift_0,
                16 as ::core::ffi::c_int >> 1 as ::core::ffi::c_int,
                8 as ::core::ffi::c_int >> v_shift_0,
            );
        }
        (*h).mc.avg[chromapix as usize].expect("non-null function pointer")(
            (*bi.as_mut_ptr().offset(0 as ::core::ffi::c_int as isize)).as_mut_ptr(),
            16 as intptr_t,
            (*pix.as_mut_ptr().offset(0 as ::core::ffi::c_int as isize)).as_mut_ptr(),
            16 as intptr_t,
            (*pix.as_mut_ptr().offset(2 as ::core::ffi::c_int as isize)).as_mut_ptr(),
            16 as intptr_t,
            (*(*h)
                .mb
                .bipred_weight
                .offset((*a).l0.me16x8[idx as usize].i_ref as isize))
                [(*a).l1.me16x8[idx as usize].i_ref as usize] as ::core::ffi::c_int,
        );
        (*h).mc.avg[chromapix as usize].expect("non-null function pointer")(
            (*bi.as_mut_ptr().offset(1 as ::core::ffi::c_int as isize)).as_mut_ptr(),
            16 as intptr_t,
            (*pix.as_mut_ptr().offset(1 as ::core::ffi::c_int as isize)).as_mut_ptr(),
            16 as intptr_t,
            (*pix.as_mut_ptr().offset(3 as ::core::ffi::c_int as isize)).as_mut_ptr(),
            16 as intptr_t,
            (*(*h)
                .mb
                .bipred_weight
                .offset((*a).l0.me16x8[idx as usize].i_ref as isize))
                [(*a).l1.me16x8[idx as usize].i_ref as usize] as ::core::ffi::c_int,
        );
        i_chroma_cost = (*h).pixf.mbcmp[chromapix as usize].expect("non-null function pointer")(
            (*a).l0.me16x8[idx as usize].p_fenc[1 as ::core::ffi::c_int as usize],
            FENC_STRIDE as intptr_t,
            (*bi.as_mut_ptr().offset(0 as ::core::ffi::c_int as isize)).as_mut_ptr(),
            16 as intptr_t,
        ) + (*h).pixf.mbcmp[chromapix as usize].expect("non-null function pointer")(
            (*a).l0.me16x8[idx as usize].p_fenc[2 as ::core::ffi::c_int as usize],
            FENC_STRIDE as intptr_t,
            (*bi.as_mut_ptr().offset(1 as ::core::ffi::c_int as isize)).as_mut_ptr(),
            16 as intptr_t,
        );
    } else if i_pixel == PIXEL_8x16 as ::core::ffi::c_int {
        if (*(*h).sps.as_mut_ptr()).i_chroma_format_idc == CHROMA_444 as ::core::ffi::c_int {
            (*h).mc.mc_luma.expect("non-null function pointer")(
                (*pix.as_mut_ptr().offset(0 as ::core::ffi::c_int as isize)).as_mut_ptr(),
                16 as intptr_t,
                &mut *(*(*a).l0.me8x16.as_mut_ptr().offset(idx as isize))
                    .p_fref
                    .as_mut_ptr()
                    .offset(4 as ::core::ffi::c_int as isize),
                (*a).l0.me8x16[idx as usize].i_stride[1 as ::core::ffi::c_int as usize] as intptr_t,
                (*a).l0.me8x16[idx as usize].mv[0 as ::core::ffi::c_int as usize]
                    as ::core::ffi::c_int,
                (*a).l0.me8x16[idx as usize].mv[1 as ::core::ffi::c_int as usize]
                    as ::core::ffi::c_int,
                8 as ::core::ffi::c_int,
                16 as ::core::ffi::c_int,
                x264_zero.as_mut_ptr() as *const x264_weight_t,
            );
            (*h).mc.mc_luma.expect("non-null function pointer")(
                (*pix.as_mut_ptr().offset(1 as ::core::ffi::c_int as isize)).as_mut_ptr(),
                16 as intptr_t,
                &mut *(*(*a).l0.me8x16.as_mut_ptr().offset(idx as isize))
                    .p_fref
                    .as_mut_ptr()
                    .offset(8 as ::core::ffi::c_int as isize),
                (*a).l0.me8x16[idx as usize].i_stride[2 as ::core::ffi::c_int as usize] as intptr_t,
                (*a).l0.me8x16[idx as usize].mv[0 as ::core::ffi::c_int as usize]
                    as ::core::ffi::c_int,
                (*a).l0.me8x16[idx as usize].mv[1 as ::core::ffi::c_int as usize]
                    as ::core::ffi::c_int,
                8 as ::core::ffi::c_int,
                16 as ::core::ffi::c_int,
                x264_zero.as_mut_ptr() as *const x264_weight_t,
            );
            (*h).mc.mc_luma.expect("non-null function pointer")(
                (*pix.as_mut_ptr().offset(2 as ::core::ffi::c_int as isize)).as_mut_ptr(),
                16 as intptr_t,
                &mut *(*(*a).l1.me8x16.as_mut_ptr().offset(idx as isize))
                    .p_fref
                    .as_mut_ptr()
                    .offset(4 as ::core::ffi::c_int as isize),
                (*a).l1.me8x16[idx as usize].i_stride[1 as ::core::ffi::c_int as usize] as intptr_t,
                (*a).l1.me8x16[idx as usize].mv[0 as ::core::ffi::c_int as usize]
                    as ::core::ffi::c_int,
                (*a).l1.me8x16[idx as usize].mv[1 as ::core::ffi::c_int as usize]
                    as ::core::ffi::c_int,
                8 as ::core::ffi::c_int,
                16 as ::core::ffi::c_int,
                x264_zero.as_mut_ptr() as *const x264_weight_t,
            );
            (*h).mc.mc_luma.expect("non-null function pointer")(
                (*pix.as_mut_ptr().offset(3 as ::core::ffi::c_int as isize)).as_mut_ptr(),
                16 as intptr_t,
                &mut *(*(*a).l1.me8x16.as_mut_ptr().offset(idx as isize))
                    .p_fref
                    .as_mut_ptr()
                    .offset(8 as ::core::ffi::c_int as isize),
                (*a).l1.me8x16[idx as usize].i_stride[2 as ::core::ffi::c_int as usize] as intptr_t,
                (*a).l1.me8x16[idx as usize].mv[0 as ::core::ffi::c_int as usize]
                    as ::core::ffi::c_int,
                (*a).l1.me8x16[idx as usize].mv[1 as ::core::ffi::c_int as usize]
                    as ::core::ffi::c_int,
                8 as ::core::ffi::c_int,
                16 as ::core::ffi::c_int,
                x264_zero.as_mut_ptr() as *const x264_weight_t,
            );
        } else {
            let mut v_shift_1: ::core::ffi::c_int = (*h).mb.chroma_v_shift;
            let mut l0_mvy_offset_1: ::core::ffi::c_int =
                if v_shift_1 & (*h).mb.b_interlaced & (*a).l0.me8x16[idx as usize].i_ref != 0 {
                    ((*h).mb.i_mb_y & 1 as ::core::ffi::c_int) * 4 as ::core::ffi::c_int
                        - 2 as ::core::ffi::c_int
                } else {
                    0 as ::core::ffi::c_int
                };
            let mut l1_mvy_offset_1: ::core::ffi::c_int =
                if v_shift_1 & (*h).mb.b_interlaced & (*a).l1.me8x16[idx as usize].i_ref != 0 {
                    ((*h).mb.i_mb_y & 1 as ::core::ffi::c_int) * 4 as ::core::ffi::c_int
                        - 2 as ::core::ffi::c_int
                } else {
                    0 as ::core::ffi::c_int
                };
            (*h).mc.mc_chroma.expect("non-null function pointer")(
                (*pix.as_mut_ptr().offset(0 as ::core::ffi::c_int as isize)).as_mut_ptr(),
                (*pix.as_mut_ptr().offset(1 as ::core::ffi::c_int as isize)).as_mut_ptr(),
                16 as intptr_t,
                (*a).l0.me8x16[idx as usize].p_fref[4 as ::core::ffi::c_int as usize],
                (*a).l0.me8x16[idx as usize].i_stride[1 as ::core::ffi::c_int as usize] as intptr_t,
                (*a).l0.me8x16[idx as usize].mv[0 as ::core::ffi::c_int as usize]
                    as ::core::ffi::c_int,
                2 as ::core::ffi::c_int
                    * ((*a).l0.me8x16[idx as usize].mv[1 as ::core::ffi::c_int as usize]
                        as ::core::ffi::c_int
                        + l0_mvy_offset_1)
                    >> v_shift_1,
                8 as ::core::ffi::c_int >> 1 as ::core::ffi::c_int,
                16 as ::core::ffi::c_int >> v_shift_1,
            );
            (*h).mc.mc_chroma.expect("non-null function pointer")(
                (*pix.as_mut_ptr().offset(2 as ::core::ffi::c_int as isize)).as_mut_ptr(),
                (*pix.as_mut_ptr().offset(3 as ::core::ffi::c_int as isize)).as_mut_ptr(),
                16 as intptr_t,
                (*a).l1.me8x16[idx as usize].p_fref[4 as ::core::ffi::c_int as usize],
                (*a).l1.me8x16[idx as usize].i_stride[1 as ::core::ffi::c_int as usize] as intptr_t,
                (*a).l1.me8x16[idx as usize].mv[0 as ::core::ffi::c_int as usize]
                    as ::core::ffi::c_int,
                2 as ::core::ffi::c_int
                    * ((*a).l1.me8x16[idx as usize].mv[1 as ::core::ffi::c_int as usize]
                        as ::core::ffi::c_int
                        + l1_mvy_offset_1)
                    >> v_shift_1,
                8 as ::core::ffi::c_int >> 1 as ::core::ffi::c_int,
                16 as ::core::ffi::c_int >> v_shift_1,
            );
        }
        (*h).mc.avg[chromapix as usize].expect("non-null function pointer")(
            (*bi.as_mut_ptr().offset(0 as ::core::ffi::c_int as isize)).as_mut_ptr(),
            16 as intptr_t,
            (*pix.as_mut_ptr().offset(0 as ::core::ffi::c_int as isize)).as_mut_ptr(),
            16 as intptr_t,
            (*pix.as_mut_ptr().offset(2 as ::core::ffi::c_int as isize)).as_mut_ptr(),
            16 as intptr_t,
            (*(*h)
                .mb
                .bipred_weight
                .offset((*a).l0.me8x16[idx as usize].i_ref as isize))
                [(*a).l1.me8x16[idx as usize].i_ref as usize] as ::core::ffi::c_int,
        );
        (*h).mc.avg[chromapix as usize].expect("non-null function pointer")(
            (*bi.as_mut_ptr().offset(1 as ::core::ffi::c_int as isize)).as_mut_ptr(),
            16 as intptr_t,
            (*pix.as_mut_ptr().offset(1 as ::core::ffi::c_int as isize)).as_mut_ptr(),
            16 as intptr_t,
            (*pix.as_mut_ptr().offset(3 as ::core::ffi::c_int as isize)).as_mut_ptr(),
            16 as intptr_t,
            (*(*h)
                .mb
                .bipred_weight
                .offset((*a).l0.me8x16[idx as usize].i_ref as isize))
                [(*a).l1.me8x16[idx as usize].i_ref as usize] as ::core::ffi::c_int,
        );
        i_chroma_cost = (*h).pixf.mbcmp[chromapix as usize].expect("non-null function pointer")(
            (*a).l0.me8x16[idx as usize].p_fenc[1 as ::core::ffi::c_int as usize],
            FENC_STRIDE as intptr_t,
            (*bi.as_mut_ptr().offset(0 as ::core::ffi::c_int as isize)).as_mut_ptr(),
            16 as intptr_t,
        ) + (*h).pixf.mbcmp[chromapix as usize].expect("non-null function pointer")(
            (*a).l0.me8x16[idx as usize].p_fenc[2 as ::core::ffi::c_int as usize],
            FENC_STRIDE as intptr_t,
            (*bi.as_mut_ptr().offset(1 as ::core::ffi::c_int as isize)).as_mut_ptr(),
            16 as intptr_t,
        );
    } else {
        if (*(*h).sps.as_mut_ptr()).i_chroma_format_idc == CHROMA_444 as ::core::ffi::c_int {
            (*h).mc.mc_luma.expect("non-null function pointer")(
                (*pix.as_mut_ptr().offset(0 as ::core::ffi::c_int as isize)).as_mut_ptr(),
                16 as intptr_t,
                &mut *(*(*a).l0.me8x8.as_mut_ptr().offset(idx as isize))
                    .p_fref
                    .as_mut_ptr()
                    .offset(4 as ::core::ffi::c_int as isize),
                (*a).l0.me8x8[idx as usize].i_stride[1 as ::core::ffi::c_int as usize] as intptr_t,
                (*a).l0.me8x8[idx as usize].mv[0 as ::core::ffi::c_int as usize]
                    as ::core::ffi::c_int,
                (*a).l0.me8x8[idx as usize].mv[1 as ::core::ffi::c_int as usize]
                    as ::core::ffi::c_int,
                8 as ::core::ffi::c_int,
                8 as ::core::ffi::c_int,
                x264_zero.as_mut_ptr() as *const x264_weight_t,
            );
            (*h).mc.mc_luma.expect("non-null function pointer")(
                (*pix.as_mut_ptr().offset(1 as ::core::ffi::c_int as isize)).as_mut_ptr(),
                16 as intptr_t,
                &mut *(*(*a).l0.me8x8.as_mut_ptr().offset(idx as isize))
                    .p_fref
                    .as_mut_ptr()
                    .offset(8 as ::core::ffi::c_int as isize),
                (*a).l0.me8x8[idx as usize].i_stride[2 as ::core::ffi::c_int as usize] as intptr_t,
                (*a).l0.me8x8[idx as usize].mv[0 as ::core::ffi::c_int as usize]
                    as ::core::ffi::c_int,
                (*a).l0.me8x8[idx as usize].mv[1 as ::core::ffi::c_int as usize]
                    as ::core::ffi::c_int,
                8 as ::core::ffi::c_int,
                8 as ::core::ffi::c_int,
                x264_zero.as_mut_ptr() as *const x264_weight_t,
            );
            (*h).mc.mc_luma.expect("non-null function pointer")(
                (*pix.as_mut_ptr().offset(2 as ::core::ffi::c_int as isize)).as_mut_ptr(),
                16 as intptr_t,
                &mut *(*(*a).l1.me8x8.as_mut_ptr().offset(idx as isize))
                    .p_fref
                    .as_mut_ptr()
                    .offset(4 as ::core::ffi::c_int as isize),
                (*a).l1.me8x8[idx as usize].i_stride[1 as ::core::ffi::c_int as usize] as intptr_t,
                (*a).l1.me8x8[idx as usize].mv[0 as ::core::ffi::c_int as usize]
                    as ::core::ffi::c_int,
                (*a).l1.me8x8[idx as usize].mv[1 as ::core::ffi::c_int as usize]
                    as ::core::ffi::c_int,
                8 as ::core::ffi::c_int,
                8 as ::core::ffi::c_int,
                x264_zero.as_mut_ptr() as *const x264_weight_t,
            );
            (*h).mc.mc_luma.expect("non-null function pointer")(
                (*pix.as_mut_ptr().offset(3 as ::core::ffi::c_int as isize)).as_mut_ptr(),
                16 as intptr_t,
                &mut *(*(*a).l1.me8x8.as_mut_ptr().offset(idx as isize))
                    .p_fref
                    .as_mut_ptr()
                    .offset(8 as ::core::ffi::c_int as isize),
                (*a).l1.me8x8[idx as usize].i_stride[2 as ::core::ffi::c_int as usize] as intptr_t,
                (*a).l1.me8x8[idx as usize].mv[0 as ::core::ffi::c_int as usize]
                    as ::core::ffi::c_int,
                (*a).l1.me8x8[idx as usize].mv[1 as ::core::ffi::c_int as usize]
                    as ::core::ffi::c_int,
                8 as ::core::ffi::c_int,
                8 as ::core::ffi::c_int,
                x264_zero.as_mut_ptr() as *const x264_weight_t,
            );
        } else {
            let mut v_shift_2: ::core::ffi::c_int = (*h).mb.chroma_v_shift;
            let mut l0_mvy_offset_2: ::core::ffi::c_int =
                if v_shift_2 & (*h).mb.b_interlaced & (*a).l0.me8x8[idx as usize].i_ref != 0 {
                    ((*h).mb.i_mb_y & 1 as ::core::ffi::c_int) * 4 as ::core::ffi::c_int
                        - 2 as ::core::ffi::c_int
                } else {
                    0 as ::core::ffi::c_int
                };
            let mut l1_mvy_offset_2: ::core::ffi::c_int =
                if v_shift_2 & (*h).mb.b_interlaced & (*a).l1.me8x8[idx as usize].i_ref != 0 {
                    ((*h).mb.i_mb_y & 1 as ::core::ffi::c_int) * 4 as ::core::ffi::c_int
                        - 2 as ::core::ffi::c_int
                } else {
                    0 as ::core::ffi::c_int
                };
            (*h).mc.mc_chroma.expect("non-null function pointer")(
                (*pix.as_mut_ptr().offset(0 as ::core::ffi::c_int as isize)).as_mut_ptr(),
                (*pix.as_mut_ptr().offset(1 as ::core::ffi::c_int as isize)).as_mut_ptr(),
                16 as intptr_t,
                (*a).l0.me8x8[idx as usize].p_fref[4 as ::core::ffi::c_int as usize],
                (*a).l0.me8x8[idx as usize].i_stride[1 as ::core::ffi::c_int as usize] as intptr_t,
                (*a).l0.me8x8[idx as usize].mv[0 as ::core::ffi::c_int as usize]
                    as ::core::ffi::c_int,
                2 as ::core::ffi::c_int
                    * ((*a).l0.me8x8[idx as usize].mv[1 as ::core::ffi::c_int as usize]
                        as ::core::ffi::c_int
                        + l0_mvy_offset_2)
                    >> v_shift_2,
                8 as ::core::ffi::c_int >> 1 as ::core::ffi::c_int,
                8 as ::core::ffi::c_int >> v_shift_2,
            );
            (*h).mc.mc_chroma.expect("non-null function pointer")(
                (*pix.as_mut_ptr().offset(2 as ::core::ffi::c_int as isize)).as_mut_ptr(),
                (*pix.as_mut_ptr().offset(3 as ::core::ffi::c_int as isize)).as_mut_ptr(),
                16 as intptr_t,
                (*a).l1.me8x8[idx as usize].p_fref[4 as ::core::ffi::c_int as usize],
                (*a).l1.me8x8[idx as usize].i_stride[1 as ::core::ffi::c_int as usize] as intptr_t,
                (*a).l1.me8x8[idx as usize].mv[0 as ::core::ffi::c_int as usize]
                    as ::core::ffi::c_int,
                2 as ::core::ffi::c_int
                    * ((*a).l1.me8x8[idx as usize].mv[1 as ::core::ffi::c_int as usize]
                        as ::core::ffi::c_int
                        + l1_mvy_offset_2)
                    >> v_shift_2,
                8 as ::core::ffi::c_int >> 1 as ::core::ffi::c_int,
                8 as ::core::ffi::c_int >> v_shift_2,
            );
        }
        (*h).mc.avg[chromapix as usize].expect("non-null function pointer")(
            (*bi.as_mut_ptr().offset(0 as ::core::ffi::c_int as isize)).as_mut_ptr(),
            16 as intptr_t,
            (*pix.as_mut_ptr().offset(0 as ::core::ffi::c_int as isize)).as_mut_ptr(),
            16 as intptr_t,
            (*pix.as_mut_ptr().offset(2 as ::core::ffi::c_int as isize)).as_mut_ptr(),
            16 as intptr_t,
            (*(*h)
                .mb
                .bipred_weight
                .offset((*a).l0.me8x8[idx as usize].i_ref as isize))
                [(*a).l1.me8x8[idx as usize].i_ref as usize] as ::core::ffi::c_int,
        );
        (*h).mc.avg[chromapix as usize].expect("non-null function pointer")(
            (*bi.as_mut_ptr().offset(1 as ::core::ffi::c_int as isize)).as_mut_ptr(),
            16 as intptr_t,
            (*pix.as_mut_ptr().offset(1 as ::core::ffi::c_int as isize)).as_mut_ptr(),
            16 as intptr_t,
            (*pix.as_mut_ptr().offset(3 as ::core::ffi::c_int as isize)).as_mut_ptr(),
            16 as intptr_t,
            (*(*h)
                .mb
                .bipred_weight
                .offset((*a).l0.me8x8[idx as usize].i_ref as isize))
                [(*a).l1.me8x8[idx as usize].i_ref as usize] as ::core::ffi::c_int,
        );
        i_chroma_cost = (*h).pixf.mbcmp[chromapix as usize].expect("non-null function pointer")(
            (*a).l0.me8x8[idx as usize].p_fenc[1 as ::core::ffi::c_int as usize],
            FENC_STRIDE as intptr_t,
            (*bi.as_mut_ptr().offset(0 as ::core::ffi::c_int as isize)).as_mut_ptr(),
            16 as intptr_t,
        ) + (*h).pixf.mbcmp[chromapix as usize].expect("non-null function pointer")(
            (*a).l0.me8x8[idx as usize].p_fenc[2 as ::core::ffi::c_int as usize],
            FENC_STRIDE as intptr_t,
            (*bi.as_mut_ptr().offset(1 as ::core::ffi::c_int as isize)).as_mut_ptr(),
            16 as intptr_t,
        );
    }
    return i_chroma_cost;
}
#[c2rust::src_loc = "1844:1"]
unsafe extern "C" fn mb_analyse_inter_direct(mut h: *mut x264_t, mut a: *mut x264_mb_analysis_t) {
    let mut p_fenc: *mut pixel = (*h).mb.pic.p_fenc[0 as ::core::ffi::c_int as usize];
    let mut p_fdec: *mut pixel = (*h).mb.pic.p_fdec[0 as ::core::ffi::c_int as usize];
    (*a).i_cost16x16direct = (*a).i_lambda
        * i_mb_b_cost_table[B_DIRECT as ::core::ffi::c_int as usize] as ::core::ffi::c_int;
    if (*h).param.analyse.inter & X264_ANALYSE_BSUB16x16 != 0 {
        let mut chromapix: ::core::ffi::c_int =
            (*h).luma2chroma_pixel[PIXEL_8x8 as ::core::ffi::c_int as usize] as ::core::ffi::c_int;
        let mut i: ::core::ffi::c_int = 0 as ::core::ffi::c_int;
        while i < 4 as ::core::ffi::c_int {
            let x: ::core::ffi::c_int = (i & 1 as ::core::ffi::c_int) * 8 as ::core::ffi::c_int;
            let y: ::core::ffi::c_int = (i >> 1 as ::core::ffi::c_int) * 8 as ::core::ffi::c_int;
            (*a).i_cost8x8direct[i as usize] = (*h).pixf.mbcmp
                [PIXEL_8x8 as ::core::ffi::c_int as usize]
                .expect("non-null function pointer")(
                &mut *p_fenc.offset((x + y * FENC_STRIDE) as isize),
                FENC_STRIDE as intptr_t,
                &mut *p_fdec.offset((x + y * FDEC_STRIDE) as isize),
                FDEC_STRIDE as intptr_t,
            );
            if (*h).mb.b_chroma_me != 0 {
                let mut fenc_offset: ::core::ffi::c_int =
                    (x >> (*h).mb.chroma_h_shift) + (y >> (*h).mb.chroma_v_shift) * FENC_STRIDE;
                let mut fdec_offset: ::core::ffi::c_int =
                    (x >> (*h).mb.chroma_h_shift) + (y >> (*h).mb.chroma_v_shift) * FDEC_STRIDE;
                (*a).i_cost8x8direct[i as usize] +=
                    (*h).pixf.mbcmp[chromapix as usize].expect("non-null function pointer")(
                        &mut *(*(*h)
                            .mb
                            .pic
                            .p_fenc
                            .as_mut_ptr()
                            .offset(1 as ::core::ffi::c_int as isize))
                        .offset(fenc_offset as isize),
                        FENC_STRIDE as intptr_t,
                        &mut *(*(*h)
                            .mb
                            .pic
                            .p_fdec
                            .as_mut_ptr()
                            .offset(1 as ::core::ffi::c_int as isize))
                        .offset(fdec_offset as isize),
                        FDEC_STRIDE as intptr_t,
                    ) + (*h).pixf.mbcmp[chromapix as usize].expect("non-null function pointer")(
                        &mut *(*(*h)
                            .mb
                            .pic
                            .p_fenc
                            .as_mut_ptr()
                            .offset(2 as ::core::ffi::c_int as isize))
                        .offset(fenc_offset as isize),
                        FENC_STRIDE as intptr_t,
                        &mut *(*(*h)
                            .mb
                            .pic
                            .p_fdec
                            .as_mut_ptr()
                            .offset(2 as ::core::ffi::c_int as isize))
                        .offset(fdec_offset as isize),
                        FDEC_STRIDE as intptr_t,
                    );
            }
            (*a).i_cost16x16direct += (*a).i_cost8x8direct[i as usize];
            (*a).i_cost8x8direct[i as usize] += (*a).i_lambda
                * i_sub_mb_b_cost_table[D_DIRECT_8x8 as ::core::ffi::c_int as usize]
                    as ::core::ffi::c_int;
            i += 1;
        }
    } else {
        (*a).i_cost16x16direct += (*h).pixf.mbcmp[PIXEL_16x16 as ::core::ffi::c_int as usize]
            .expect("non-null function pointer")(
            p_fenc,
            FENC_STRIDE as intptr_t,
            p_fdec,
            FDEC_STRIDE as intptr_t,
        );
        if (*h).mb.b_chroma_me != 0 {
            let mut chromapix_0: ::core::ffi::c_int = (*h).luma2chroma_pixel
                [PIXEL_16x16 as ::core::ffi::c_int as usize]
                as ::core::ffi::c_int;
            (*a).i_cost16x16direct +=
                (*h).pixf.mbcmp[chromapix_0 as usize].expect("non-null function pointer")(
                    (*h).mb.pic.p_fenc[1 as ::core::ffi::c_int as usize],
                    FENC_STRIDE as intptr_t,
                    (*h).mb.pic.p_fdec[1 as ::core::ffi::c_int as usize],
                    FDEC_STRIDE as intptr_t,
                ) + (*h).pixf.mbcmp[chromapix_0 as usize].expect("non-null function pointer")(
                    (*h).mb.pic.p_fenc[2 as ::core::ffi::c_int as usize],
                    FENC_STRIDE as intptr_t,
                    (*h).mb.pic.p_fdec[2 as ::core::ffi::c_int as usize],
                    FDEC_STRIDE as intptr_t,
                );
        }
    };
}
#[c2rust::src_loc = "1890:1"]
unsafe extern "C" fn mb_analyse_inter_b16x16(mut h: *mut x264_t, mut a: *mut x264_mb_analysis_t) {
    let mut pix0: [pixel; 256] = [0; 256];
    let mut pix1: [pixel; 256] = [0; 256];
    let mut src0: *mut pixel = 0 as *mut pixel;
    let mut src1: *mut pixel = 0 as *mut pixel;
    let mut stride0: intptr_t = 16 as intptr_t;
    let mut stride1: intptr_t = 16 as intptr_t;
    let mut i_ref: ::core::ffi::c_int = 0;
    let mut i_mvc: ::core::ffi::c_int = 0;
    let mut mvc: [[int16_t; 2]; 9] = [[0; 2]; 9];
    let mut try_skip: ::core::ffi::c_int = (*a).b_try_skip;
    let mut list1_skipped: ::core::ffi::c_int = 0 as ::core::ffi::c_int;
    let mut i_halfpel_thresh: [::core::ffi::c_int; 2] = [INT_MAX, INT_MAX];
    let mut p_halfpel_thresh: [*mut ::core::ffi::c_int; 2] = [
        if (*a).b_early_terminate != 0
            && (*h).mb.pic.i_fref[0 as ::core::ffi::c_int as usize] > 1 as ::core::ffi::c_int
        {
            &mut *i_halfpel_thresh
                .as_mut_ptr()
                .offset(0 as ::core::ffi::c_int as isize) as *mut ::core::ffi::c_int
        } else {
            0 as *mut ::core::ffi::c_int
        },
        if (*a).b_early_terminate != 0
            && (*h).mb.pic.i_fref[1 as ::core::ffi::c_int as usize] > 1 as ::core::ffi::c_int
        {
            &mut *i_halfpel_thresh
                .as_mut_ptr()
                .offset(1 as ::core::ffi::c_int as isize) as *mut ::core::ffi::c_int
        } else {
            0 as *mut ::core::ffi::c_int
        },
    ];
    let mut m: x264_me_t = x264_me_t {
        i_pixel: 0,
        p_cost_mv: 0 as *mut uint16_t,
        i_ref_cost: 0,
        i_ref: 0,
        weight: 0 as *const x264_weight_t,
        p_fref: [0 as *mut pixel; 12],
        p_fref_w: 0 as *mut pixel,
        p_fenc: [0 as *mut pixel; 3],
        integral: 0 as *mut uint16_t,
        i_stride: [0; 3],
        mvp: [0; 2],
        cost_mv: 0,
        cost: 0,
        mv: [0; 2],
    };
    m.i_pixel = PIXEL_16x16 as ::core::ffi::c_int;
    m.p_cost_mv = (*a).p_cost_mv;
    m.i_stride[0 as ::core::ffi::c_int as usize] =
        (*h).mb.pic.i_stride[0 as ::core::ffi::c_int as usize];
    m.i_stride[1 as ::core::ffi::c_int as usize] =
        (*h).mb.pic.i_stride[1 as ::core::ffi::c_int as usize];
    m.i_stride[2 as ::core::ffi::c_int as usize] =
        (*h).mb.pic.i_stride[2 as ::core::ffi::c_int as usize];
    m.p_fenc[0 as ::core::ffi::c_int as usize] = &mut *(*(*h)
        .mb
        .pic
        .p_fenc
        .as_mut_ptr()
        .offset(0 as ::core::ffi::c_int as isize))
    .offset((0 as ::core::ffi::c_int + 0 as ::core::ffi::c_int * FENC_STRIDE) as isize)
        as *mut pixel;
    if (*(*h).sps.as_mut_ptr()).i_chroma_format_idc != 0 {
        m.p_fenc[1 as ::core::ffi::c_int as usize] = &mut *(*(*h)
            .mb
            .pic
            .p_fenc
            .as_mut_ptr()
            .offset(1 as ::core::ffi::c_int as isize))
        .offset(
            ((0 as ::core::ffi::c_int >> (*h).mb.chroma_h_shift)
                + (0 as ::core::ffi::c_int >> (*h).mb.chroma_v_shift) * FENC_STRIDE)
                as isize,
        ) as *mut pixel;
        m.p_fenc[2 as ::core::ffi::c_int as usize] = &mut *(*(*h)
            .mb
            .pic
            .p_fenc
            .as_mut_ptr()
            .offset(2 as ::core::ffi::c_int as isize))
        .offset(
            ((0 as ::core::ffi::c_int >> (*h).mb.chroma_h_shift)
                + (0 as ::core::ffi::c_int >> (*h).mb.chroma_v_shift) * FENC_STRIDE)
                as isize,
        ) as *mut pixel;
    }
    (*a).l0.me16x16.cost = INT_MAX;
    (*a).l1.me16x16.cost = INT_MAX;
    let mut l: ::core::ffi::c_int = 1 as ::core::ffi::c_int;
    while l >= 0 as ::core::ffi::c_int {
        let mut lX: *mut x264_mb_analysis_list_t = if l != 0 { &mut (*a).l1 } else { &mut (*a).l0 };
        i_ref = if list1_skipped != 0 && l == 1 as ::core::ffi::c_int {
            1 as ::core::ffi::c_int
        } else {
            0 as ::core::ffi::c_int
        };
        while i_ref < (*h).mb.pic.i_fref[l as usize] {
            if try_skip != 0 && l == 1 as ::core::ffi::c_int && i_ref > 0 as ::core::ffi::c_int {
                list1_skipped = 1 as ::core::ffi::c_int;
                break;
            } else {
                m.i_ref_cost =
                    *(*a).p_cost_ref[l as usize].offset(i_ref as isize) as ::core::ffi::c_int;
                m.p_fref[0 as ::core::ffi::c_int as usize] =
                    &mut *(*(*(*(*h).mb.pic.p_fref.as_mut_ptr().offset(l as isize))
                        .as_mut_ptr()
                        .offset(i_ref as isize))
                    .as_mut_ptr()
                    .offset(0 as ::core::ffi::c_int as isize))
                    .offset(
                        (0 as ::core::ffi::c_int
                            + 0 as ::core::ffi::c_int
                                * *m.i_stride
                                    .as_mut_ptr()
                                    .offset(0 as ::core::ffi::c_int as isize))
                            as isize,
                    ) as *mut pixel;
                m.p_fref_w = m.p_fref[0 as ::core::ffi::c_int as usize];
                if (*h).param.analyse.i_subpel_refine != 0 {
                    m.p_fref[1 as ::core::ffi::c_int as usize] =
                        &mut *(*(*(*(*h).mb.pic.p_fref.as_mut_ptr().offset(l as isize))
                            .as_mut_ptr()
                            .offset(i_ref as isize))
                        .as_mut_ptr()
                        .offset(1 as ::core::ffi::c_int as isize))
                        .offset(
                            (0 as ::core::ffi::c_int
                                + 0 as ::core::ffi::c_int
                                    * *m.i_stride
                                        .as_mut_ptr()
                                        .offset(0 as ::core::ffi::c_int as isize))
                                as isize,
                        ) as *mut pixel;
                    m.p_fref[2 as ::core::ffi::c_int as usize] =
                        &mut *(*(*(*(*h).mb.pic.p_fref.as_mut_ptr().offset(l as isize))
                            .as_mut_ptr()
                            .offset(i_ref as isize))
                        .as_mut_ptr()
                        .offset(2 as ::core::ffi::c_int as isize))
                        .offset(
                            (0 as ::core::ffi::c_int
                                + 0 as ::core::ffi::c_int
                                    * *m.i_stride
                                        .as_mut_ptr()
                                        .offset(0 as ::core::ffi::c_int as isize))
                                as isize,
                        ) as *mut pixel;
                    m.p_fref[3 as ::core::ffi::c_int as usize] =
                        &mut *(*(*(*(*h).mb.pic.p_fref.as_mut_ptr().offset(l as isize))
                            .as_mut_ptr()
                            .offset(i_ref as isize))
                        .as_mut_ptr()
                        .offset(3 as ::core::ffi::c_int as isize))
                        .offset(
                            (0 as ::core::ffi::c_int
                                + 0 as ::core::ffi::c_int
                                    * *m.i_stride
                                        .as_mut_ptr()
                                        .offset(0 as ::core::ffi::c_int as isize))
                                as isize,
                        ) as *mut pixel;
                }
                if (*(*h).sps.as_mut_ptr()).i_chroma_format_idc == CHROMA_444 as ::core::ffi::c_int
                {
                    m.p_fref[4 as ::core::ffi::c_int as usize] =
                        &mut *(*(*(*(*h).mb.pic.p_fref.as_mut_ptr().offset(l as isize))
                            .as_mut_ptr()
                            .offset(i_ref as isize))
                        .as_mut_ptr()
                        .offset(4 as ::core::ffi::c_int as isize))
                        .offset(
                            (0 as ::core::ffi::c_int
                                + 0 as ::core::ffi::c_int
                                    * *m.i_stride
                                        .as_mut_ptr()
                                        .offset(1 as ::core::ffi::c_int as isize))
                                as isize,
                        ) as *mut pixel;
                    m.p_fref[8 as ::core::ffi::c_int as usize] =
                        &mut *(*(*(*(*h).mb.pic.p_fref.as_mut_ptr().offset(l as isize))
                            .as_mut_ptr()
                            .offset(i_ref as isize))
                        .as_mut_ptr()
                        .offset(8 as ::core::ffi::c_int as isize))
                        .offset(
                            (0 as ::core::ffi::c_int
                                + 0 as ::core::ffi::c_int
                                    * *m.i_stride
                                        .as_mut_ptr()
                                        .offset(2 as ::core::ffi::c_int as isize))
                                as isize,
                        ) as *mut pixel;
                    if (*h).param.analyse.i_subpel_refine != 0 {
                        m.p_fref[5 as ::core::ffi::c_int as usize] =
                            &mut *(*(*(*(*h).mb.pic.p_fref.as_mut_ptr().offset(l as isize))
                                .as_mut_ptr()
                                .offset(i_ref as isize))
                            .as_mut_ptr()
                            .offset(5 as ::core::ffi::c_int as isize))
                            .offset(
                                (0 as ::core::ffi::c_int
                                    + 0 as ::core::ffi::c_int
                                        * *m.i_stride
                                            .as_mut_ptr()
                                            .offset(1 as ::core::ffi::c_int as isize))
                                    as isize,
                            ) as *mut pixel;
                        m.p_fref[6 as ::core::ffi::c_int as usize] =
                            &mut *(*(*(*(*h).mb.pic.p_fref.as_mut_ptr().offset(l as isize))
                                .as_mut_ptr()
                                .offset(i_ref as isize))
                            .as_mut_ptr()
                            .offset(6 as ::core::ffi::c_int as isize))
                            .offset(
                                (0 as ::core::ffi::c_int
                                    + 0 as ::core::ffi::c_int
                                        * *m.i_stride
                                            .as_mut_ptr()
                                            .offset(1 as ::core::ffi::c_int as isize))
                                    as isize,
                            ) as *mut pixel;
                        m.p_fref[7 as ::core::ffi::c_int as usize] =
                            &mut *(*(*(*(*h).mb.pic.p_fref.as_mut_ptr().offset(l as isize))
                                .as_mut_ptr()
                                .offset(i_ref as isize))
                            .as_mut_ptr()
                            .offset(7 as ::core::ffi::c_int as isize))
                            .offset(
                                (0 as ::core::ffi::c_int
                                    + 0 as ::core::ffi::c_int
                                        * *m.i_stride
                                            .as_mut_ptr()
                                            .offset(1 as ::core::ffi::c_int as isize))
                                    as isize,
                            ) as *mut pixel;
                        m.p_fref[9 as ::core::ffi::c_int as usize] =
                            &mut *(*(*(*(*h).mb.pic.p_fref.as_mut_ptr().offset(l as isize))
                                .as_mut_ptr()
                                .offset(i_ref as isize))
                            .as_mut_ptr()
                            .offset(9 as ::core::ffi::c_int as isize))
                            .offset(
                                (0 as ::core::ffi::c_int
                                    + 0 as ::core::ffi::c_int
                                        * *m.i_stride
                                            .as_mut_ptr()
                                            .offset(2 as ::core::ffi::c_int as isize))
                                    as isize,
                            ) as *mut pixel;
                        m.p_fref[10 as ::core::ffi::c_int as usize] =
                            &mut *(*(*(*(*h).mb.pic.p_fref.as_mut_ptr().offset(l as isize))
                                .as_mut_ptr()
                                .offset(i_ref as isize))
                            .as_mut_ptr()
                            .offset(10 as ::core::ffi::c_int as isize))
                            .offset(
                                (0 as ::core::ffi::c_int
                                    + 0 as ::core::ffi::c_int
                                        * *m.i_stride
                                            .as_mut_ptr()
                                            .offset(2 as ::core::ffi::c_int as isize))
                                    as isize,
                            ) as *mut pixel;
                        m.p_fref[11 as ::core::ffi::c_int as usize] =
                            &mut *(*(*(*(*h).mb.pic.p_fref.as_mut_ptr().offset(l as isize))
                                .as_mut_ptr()
                                .offset(i_ref as isize))
                            .as_mut_ptr()
                            .offset(11 as ::core::ffi::c_int as isize))
                            .offset(
                                (0 as ::core::ffi::c_int
                                    + 0 as ::core::ffi::c_int
                                        * *m.i_stride
                                            .as_mut_ptr()
                                            .offset(2 as ::core::ffi::c_int as isize))
                                    as isize,
                            ) as *mut pixel;
                    }
                } else if (*(*h).sps.as_mut_ptr()).i_chroma_format_idc != 0 {
                    m.p_fref[4 as ::core::ffi::c_int as usize] =
                        &mut *(*(*(*(*h).mb.pic.p_fref.as_mut_ptr().offset(l as isize))
                            .as_mut_ptr()
                            .offset(i_ref as isize))
                        .as_mut_ptr()
                        .offset(4 as ::core::ffi::c_int as isize))
                        .offset(
                            (0 as ::core::ffi::c_int
                                + (0 as ::core::ffi::c_int >> (*h).mb.chroma_v_shift)
                                    * *m.i_stride
                                        .as_mut_ptr()
                                        .offset(1 as ::core::ffi::c_int as isize))
                                as isize,
                        ) as *mut pixel;
                }
                if (*h).param.analyse.i_me_method >= X264_ME_ESA {
                    m.integral = &mut *(*(*(*h).mb.pic.p_integral.as_mut_ptr().offset(l as isize))
                        .as_mut_ptr()
                        .offset(i_ref as isize))
                    .offset(
                        (0 as ::core::ffi::c_int
                            + 0 as ::core::ffi::c_int
                                * *m.i_stride
                                    .as_mut_ptr()
                                    .offset(0 as ::core::ffi::c_int as isize))
                            as isize,
                    ) as *mut uint16_t;
                }
                m.weight = x264_zero.as_mut_ptr() as *const x264_weight_t;
                m.i_ref = i_ref;
                x264_10_mb_predict_mv_16x16(h, l, i_ref, m.mvp.as_mut_ptr());
                x264_10_mb_predict_mv_ref16x16(
                    h,
                    l,
                    i_ref,
                    mvc.as_mut_ptr() as *mut [int16_t; 2],
                    &mut i_mvc,
                );
                x264_10_me_search_ref(
                    h,
                    &mut m,
                    mvc.as_mut_ptr() as *mut [int16_t; 2],
                    i_mvc,
                    p_halfpel_thresh[l as usize],
                );
                m.cost += m.i_ref_cost;
                if m.cost < (*lX).me16x16.cost {
                    (*h).mc.memcpy_aligned.expect("non-null function pointer")(
                        &mut (*lX).me16x16 as *mut x264_me_t as *mut ::core::ffi::c_void,
                        &mut m as *mut x264_me_t as *const ::core::ffi::c_void,
                        ::core::mem::size_of::<x264_me_t>() as size_t,
                    );
                }
                (*((*(*(*lX).mvc.as_mut_ptr().offset(i_ref as isize))
                    .as_mut_ptr()
                    .offset(0 as ::core::ffi::c_int as isize))
                .as_mut_ptr() as *mut x264_union32_t))
                    .i = (*(m.mv.as_mut_ptr() as *mut x264_union32_t)).i;
                (*((*(*(*(*h).mb.mvr.as_mut_ptr().offset(l as isize))
                    .as_mut_ptr()
                    .offset(i_ref as isize))
                .offset((*h).mb.i_mb_xy as isize))
                .as_mut_ptr() as *mut x264_union32_t))
                    .i = (*(m.mv.as_mut_ptr() as *mut x264_union32_t)).i;
                if i_ref == 0 as ::core::ffi::c_int && try_skip != 0 {
                    if abs(
                        (*lX).me16x16.mv[0 as ::core::ffi::c_int as usize] as ::core::ffi::c_int
                            - (*h).mb.cache.direct_mv[l as usize][0 as ::core::ffi::c_int as usize]
                                [0 as ::core::ffi::c_int as usize]
                                as ::core::ffi::c_int,
                    ) + abs((*lX).me16x16.mv[1 as ::core::ffi::c_int as usize]
                        as ::core::ffi::c_int
                        - (*h).mb.cache.direct_mv[l as usize][0 as ::core::ffi::c_int as usize]
                            [1 as ::core::ffi::c_int as usize]
                            as ::core::ffi::c_int)
                        > 1 as ::core::ffi::c_int
                    {
                        try_skip = 0 as ::core::ffi::c_int;
                    } else if l == 0 {
                        (*h).mb.i_type = B_SKIP as ::core::ffi::c_int;
                        analyse_update_cache(h, a);
                        return;
                    }
                }
                i_ref += 1;
            }
        }
        if list1_skipped != 0
            && l == 1 as ::core::ffi::c_int
            && i_ref == (*h).mb.pic.i_fref[1 as ::core::ffi::c_int as usize]
        {
            break;
        }
        if list1_skipped != 0 && l == 0 as ::core::ffi::c_int {
            l = 1 as ::core::ffi::c_int;
        } else {
            l -= 1;
        }
    }
    (*h).mc.memcpy_aligned.expect("non-null function pointer")(
        &mut (*a).l0.bi16x16 as *mut x264_me_t as *mut ::core::ffi::c_void,
        &mut (*a).l0.me16x16 as *mut x264_me_t as *const ::core::ffi::c_void,
        ::core::mem::size_of::<x264_me_t>() as size_t,
    );
    (*h).mc.memcpy_aligned.expect("non-null function pointer")(
        &mut (*a).l1.bi16x16 as *mut x264_me_t as *mut ::core::ffi::c_void,
        &mut (*a).l1.me16x16 as *mut x264_me_t as *const ::core::ffi::c_void,
        ::core::mem::size_of::<x264_me_t>() as size_t,
    );
    let mut ref_costs: ::core::ffi::c_int = *(*a).p_cost_ref[0 as ::core::ffi::c_int as usize]
        .offset((*a).l0.bi16x16.i_ref as isize)
        as ::core::ffi::c_int
        + *(*a).p_cost_ref[1 as ::core::ffi::c_int as usize].offset((*a).l1.bi16x16.i_ref as isize)
            as ::core::ffi::c_int;
    src0 = (*h).mc.get_ref.expect("non-null function pointer")(
        pix0.as_mut_ptr(),
        &mut stride0,
        (*(*(*h)
            .mb
            .pic
            .p_fref
            .as_mut_ptr()
            .offset(0 as ::core::ffi::c_int as isize))
        .as_mut_ptr()
        .offset((*a).l0.bi16x16.i_ref as isize))
        .as_mut_ptr(),
        (*h).mb.pic.i_stride[0 as ::core::ffi::c_int as usize] as intptr_t,
        (*a).l0.bi16x16.mv[0 as ::core::ffi::c_int as usize] as ::core::ffi::c_int,
        (*a).l0.bi16x16.mv[1 as ::core::ffi::c_int as usize] as ::core::ffi::c_int,
        16 as ::core::ffi::c_int,
        16 as ::core::ffi::c_int,
        x264_zero.as_mut_ptr() as *const x264_weight_t,
    );
    src1 = (*h).mc.get_ref.expect("non-null function pointer")(
        pix1.as_mut_ptr(),
        &mut stride1,
        (*(*(*h)
            .mb
            .pic
            .p_fref
            .as_mut_ptr()
            .offset(1 as ::core::ffi::c_int as isize))
        .as_mut_ptr()
        .offset((*a).l1.bi16x16.i_ref as isize))
        .as_mut_ptr(),
        (*h).mb.pic.i_stride[0 as ::core::ffi::c_int as usize] as intptr_t,
        (*a).l1.bi16x16.mv[0 as ::core::ffi::c_int as usize] as ::core::ffi::c_int,
        (*a).l1.bi16x16.mv[1 as ::core::ffi::c_int as usize] as ::core::ffi::c_int,
        16 as ::core::ffi::c_int,
        16 as ::core::ffi::c_int,
        x264_zero.as_mut_ptr() as *const x264_weight_t,
    );
    (*h).mc.avg[PIXEL_16x16 as ::core::ffi::c_int as usize].expect("non-null function pointer")(
        pix0.as_mut_ptr(),
        16 as intptr_t,
        src0,
        stride0,
        src1,
        stride1,
        (*(*h).mb.bipred_weight.offset((*a).l0.bi16x16.i_ref as isize))
            [(*a).l1.bi16x16.i_ref as usize] as ::core::ffi::c_int,
    );
    (*a).i_cost16x16bi = (*h).pixf.mbcmp[PIXEL_16x16 as ::core::ffi::c_int as usize]
        .expect("non-null function pointer")(
        (*h).mb.pic.p_fenc[0 as ::core::ffi::c_int as usize],
        FENC_STRIDE as intptr_t,
        pix0.as_mut_ptr(),
        16 as intptr_t,
    ) + ref_costs
        + (*a).l0.bi16x16.cost_mv
        + (*a).l1.bi16x16.cost_mv;
    if (*h).mb.b_chroma_me != 0 {
        (*a).i_cost16x16bi += analyse_bi_chroma(
            h,
            a,
            0 as ::core::ffi::c_int,
            PIXEL_16x16 as ::core::ffi::c_int,
        );
    }
    if (*((*a).l0.bi16x16.mv.as_mut_ptr() as *mut x264_union32_t)).i
        | (*((*a).l1.bi16x16.mv.as_mut_ptr() as *mut x264_union32_t)).i
        != 0
    {
        let mut l0_mv_cost: ::core::ffi::c_int = *(*a).l0.bi16x16.p_cost_mv.offset(
            -((*a).l0.bi16x16.mvp[0 as ::core::ffi::c_int as usize] as ::core::ffi::c_int) as isize,
        ) as ::core::ffi::c_int
            + *(*a).l0.bi16x16.p_cost_mv.offset(
                -((*a).l0.bi16x16.mvp[1 as ::core::ffi::c_int as usize] as ::core::ffi::c_int)
                    as isize,
            ) as ::core::ffi::c_int;
        let mut l1_mv_cost: ::core::ffi::c_int = *(*a).l1.bi16x16.p_cost_mv.offset(
            -((*a).l1.bi16x16.mvp[0 as ::core::ffi::c_int as usize] as ::core::ffi::c_int) as isize,
        ) as ::core::ffi::c_int
            + *(*a).l1.bi16x16.p_cost_mv.offset(
                -((*a).l1.bi16x16.mvp[1 as ::core::ffi::c_int as usize] as ::core::ffi::c_int)
                    as isize,
            ) as ::core::ffi::c_int;
        (*h).mc.avg[PIXEL_16x16 as ::core::ffi::c_int as usize].expect("non-null function pointer")(
            pix0.as_mut_ptr(),
            16 as intptr_t,
            (*h).mb.pic.p_fref[0 as ::core::ffi::c_int as usize][(*a).l0.bi16x16.i_ref as usize]
                [0 as ::core::ffi::c_int as usize],
            (*h).mb.pic.i_stride[0 as ::core::ffi::c_int as usize] as intptr_t,
            (*h).mb.pic.p_fref[1 as ::core::ffi::c_int as usize][(*a).l1.bi16x16.i_ref as usize]
                [0 as ::core::ffi::c_int as usize],
            (*h).mb.pic.i_stride[0 as ::core::ffi::c_int as usize] as intptr_t,
            (*(*h).mb.bipred_weight.offset((*a).l0.bi16x16.i_ref as isize))
                [(*a).l1.bi16x16.i_ref as usize] as ::core::ffi::c_int,
        );
        let mut cost00: ::core::ffi::c_int = (*h).pixf.mbcmp
            [PIXEL_16x16 as ::core::ffi::c_int as usize]
            .expect("non-null function pointer")(
            (*h).mb.pic.p_fenc[0 as ::core::ffi::c_int as usize],
            FENC_STRIDE as intptr_t,
            pix0.as_mut_ptr(),
            16 as intptr_t,
        ) + ref_costs
            + l0_mv_cost
            + l1_mv_cost;
        if (*h).mb.b_chroma_me != 0 && cost00 < (*a).i_cost16x16bi {
            let mut bi: [pixel; 256] = [0; 256];
            if (*(*h).sps.as_mut_ptr()).i_chroma_format_idc == CHROMA_444 as ::core::ffi::c_int {
                (*h).mc.avg[PIXEL_16x16 as ::core::ffi::c_int as usize]
                    .expect("non-null function pointer")(
                    bi.as_mut_ptr(),
                    FENC_STRIDE as intptr_t,
                    (*h).mb.pic.p_fref[0 as ::core::ffi::c_int as usize]
                        [(*a).l0.bi16x16.i_ref as usize][4 as ::core::ffi::c_int as usize],
                    (*h).mb.pic.i_stride[1 as ::core::ffi::c_int as usize] as intptr_t,
                    (*h).mb.pic.p_fref[1 as ::core::ffi::c_int as usize]
                        [(*a).l1.bi16x16.i_ref as usize][4 as ::core::ffi::c_int as usize],
                    (*h).mb.pic.i_stride[1 as ::core::ffi::c_int as usize] as intptr_t,
                    (*(*h).mb.bipred_weight.offset((*a).l0.bi16x16.i_ref as isize))
                        [(*a).l1.bi16x16.i_ref as usize] as ::core::ffi::c_int,
                );
                cost00 += (*h).pixf.mbcmp[PIXEL_16x16 as ::core::ffi::c_int as usize]
                    .expect("non-null function pointer")(
                    (*h).mb.pic.p_fenc[1 as ::core::ffi::c_int as usize],
                    FENC_STRIDE as intptr_t,
                    bi.as_mut_ptr(),
                    FENC_STRIDE as intptr_t,
                );
                (*h).mc.avg[PIXEL_16x16 as ::core::ffi::c_int as usize]
                    .expect("non-null function pointer")(
                    bi.as_mut_ptr(),
                    FENC_STRIDE as intptr_t,
                    (*h).mb.pic.p_fref[0 as ::core::ffi::c_int as usize]
                        [(*a).l0.bi16x16.i_ref as usize][8 as ::core::ffi::c_int as usize],
                    (*h).mb.pic.i_stride[2 as ::core::ffi::c_int as usize] as intptr_t,
                    (*h).mb.pic.p_fref[1 as ::core::ffi::c_int as usize]
                        [(*a).l1.bi16x16.i_ref as usize][8 as ::core::ffi::c_int as usize],
                    (*h).mb.pic.i_stride[2 as ::core::ffi::c_int as usize] as intptr_t,
                    (*(*h).mb.bipred_weight.offset((*a).l0.bi16x16.i_ref as isize))
                        [(*a).l1.bi16x16.i_ref as usize] as ::core::ffi::c_int,
                );
                cost00 += (*h).pixf.mbcmp[PIXEL_16x16 as ::core::ffi::c_int as usize]
                    .expect("non-null function pointer")(
                    (*h).mb.pic.p_fenc[2 as ::core::ffi::c_int as usize],
                    FENC_STRIDE as intptr_t,
                    bi.as_mut_ptr(),
                    FENC_STRIDE as intptr_t,
                );
            } else {
                let mut pixuv: [[pixel; 256]; 2] = [[0; 256]; 2];
                let mut chromapix: ::core::ffi::c_int = (*h).luma2chroma_pixel
                    [PIXEL_16x16 as ::core::ffi::c_int as usize]
                    as ::core::ffi::c_int;
                let mut v_shift: ::core::ffi::c_int = (*h).mb.chroma_v_shift;
                if v_shift & (*h).mb.b_interlaced & (*a).l0.bi16x16.i_ref != 0 {
                    let mut l0_mvy_offset: ::core::ffi::c_int =
                        ((*h).mb.i_mb_y & 1 as ::core::ffi::c_int) * 4 as ::core::ffi::c_int
                            - 2 as ::core::ffi::c_int;
                    (*h).mc.mc_chroma.expect("non-null function pointer")(
                        (*pixuv.as_mut_ptr().offset(0 as ::core::ffi::c_int as isize)).as_mut_ptr(),
                        (*pixuv.as_mut_ptr().offset(0 as ::core::ffi::c_int as isize))
                            .as_mut_ptr()
                            .offset(8 as ::core::ffi::c_int as isize),
                        FENC_STRIDE as intptr_t,
                        (*h).mb.pic.p_fref[0 as ::core::ffi::c_int as usize]
                            [(*a).l0.bi16x16.i_ref as usize]
                            [4 as ::core::ffi::c_int as usize],
                        (*h).mb.pic.i_stride[1 as ::core::ffi::c_int as usize] as intptr_t,
                        0 as ::core::ffi::c_int,
                        0 as ::core::ffi::c_int + l0_mvy_offset,
                        8 as ::core::ffi::c_int,
                        8 as ::core::ffi::c_int,
                    );
                } else {
                    (*h).mc
                        .load_deinterleave_chroma_fenc
                        .expect("non-null function pointer")(
                        (*pixuv.as_mut_ptr().offset(0 as ::core::ffi::c_int as isize)).as_mut_ptr(),
                        (*h).mb.pic.p_fref[0 as ::core::ffi::c_int as usize]
                            [(*a).l0.bi16x16.i_ref as usize]
                            [4 as ::core::ffi::c_int as usize],
                        (*h).mb.pic.i_stride[1 as ::core::ffi::c_int as usize] as intptr_t,
                        16 as ::core::ffi::c_int >> v_shift,
                    );
                }
                if v_shift & (*h).mb.b_interlaced & (*a).l1.bi16x16.i_ref != 0 {
                    let mut l1_mvy_offset: ::core::ffi::c_int =
                        ((*h).mb.i_mb_y & 1 as ::core::ffi::c_int) * 4 as ::core::ffi::c_int
                            - 2 as ::core::ffi::c_int;
                    (*h).mc.mc_chroma.expect("non-null function pointer")(
                        (*pixuv.as_mut_ptr().offset(1 as ::core::ffi::c_int as isize)).as_mut_ptr(),
                        (*pixuv.as_mut_ptr().offset(1 as ::core::ffi::c_int as isize))
                            .as_mut_ptr()
                            .offset(8 as ::core::ffi::c_int as isize),
                        FENC_STRIDE as intptr_t,
                        (*h).mb.pic.p_fref[1 as ::core::ffi::c_int as usize]
                            [(*a).l1.bi16x16.i_ref as usize]
                            [4 as ::core::ffi::c_int as usize],
                        (*h).mb.pic.i_stride[1 as ::core::ffi::c_int as usize] as intptr_t,
                        0 as ::core::ffi::c_int,
                        0 as ::core::ffi::c_int + l1_mvy_offset,
                        8 as ::core::ffi::c_int,
                        8 as ::core::ffi::c_int,
                    );
                } else {
                    (*h).mc
                        .load_deinterleave_chroma_fenc
                        .expect("non-null function pointer")(
                        (*pixuv.as_mut_ptr().offset(1 as ::core::ffi::c_int as isize)).as_mut_ptr(),
                        (*h).mb.pic.p_fref[1 as ::core::ffi::c_int as usize]
                            [(*a).l1.bi16x16.i_ref as usize]
                            [4 as ::core::ffi::c_int as usize],
                        (*h).mb.pic.i_stride[1 as ::core::ffi::c_int as usize] as intptr_t,
                        16 as ::core::ffi::c_int >> v_shift,
                    );
                }
                (*h).mc.avg[chromapix as usize].expect("non-null function pointer")(
                    bi.as_mut_ptr(),
                    FENC_STRIDE as intptr_t,
                    (*pixuv.as_mut_ptr().offset(0 as ::core::ffi::c_int as isize)).as_mut_ptr(),
                    FENC_STRIDE as intptr_t,
                    (*pixuv.as_mut_ptr().offset(1 as ::core::ffi::c_int as isize)).as_mut_ptr(),
                    FENC_STRIDE as intptr_t,
                    (*(*h).mb.bipred_weight.offset((*a).l0.bi16x16.i_ref as isize))
                        [(*a).l1.bi16x16.i_ref as usize] as ::core::ffi::c_int,
                );
                (*h).mc.avg[chromapix as usize].expect("non-null function pointer")(
                    bi.as_mut_ptr().offset(8 as ::core::ffi::c_int as isize),
                    FENC_STRIDE as intptr_t,
                    (*pixuv.as_mut_ptr().offset(0 as ::core::ffi::c_int as isize))
                        .as_mut_ptr()
                        .offset(8 as ::core::ffi::c_int as isize),
                    FENC_STRIDE as intptr_t,
                    (*pixuv.as_mut_ptr().offset(1 as ::core::ffi::c_int as isize))
                        .as_mut_ptr()
                        .offset(8 as ::core::ffi::c_int as isize),
                    FENC_STRIDE as intptr_t,
                    (*(*h).mb.bipred_weight.offset((*a).l0.bi16x16.i_ref as isize))
                        [(*a).l1.bi16x16.i_ref as usize] as ::core::ffi::c_int,
                );
                cost00 += (*h).pixf.mbcmp[chromapix as usize].expect("non-null function pointer")(
                    (*h).mb.pic.p_fenc[1 as ::core::ffi::c_int as usize],
                    FENC_STRIDE as intptr_t,
                    bi.as_mut_ptr(),
                    FENC_STRIDE as intptr_t,
                ) + (*h).pixf.mbcmp[chromapix as usize]
                    .expect("non-null function pointer")(
                    (*h).mb.pic.p_fenc[2 as ::core::ffi::c_int as usize],
                    FENC_STRIDE as intptr_t,
                    bi.as_mut_ptr().offset(8 as ::core::ffi::c_int as isize),
                    FENC_STRIDE as intptr_t,
                );
            }
        }
        if cost00 < (*a).i_cost16x16bi {
            (*((*a).l0.bi16x16.mv.as_mut_ptr() as *mut x264_union32_t)).i = 0 as uint32_t;
            (*((*a).l1.bi16x16.mv.as_mut_ptr() as *mut x264_union32_t)).i = 0 as uint32_t;
            (*a).l0.bi16x16.cost_mv = l0_mv_cost;
            (*a).l1.bi16x16.cost_mv = l1_mv_cost;
            (*a).i_cost16x16bi = cost00;
        }
    }
    (*a).i_cost16x16bi += (*a).i_lambda
        * i_mb_b_cost_table[B_BI_BI as ::core::ffi::c_int as usize] as ::core::ffi::c_int;
    (*a).l0.me16x16.cost += (*a).i_lambda
        * i_mb_b_cost_table[B_L0_L0 as ::core::ffi::c_int as usize] as ::core::ffi::c_int;
    (*a).l1.me16x16.cost += (*a).i_lambda
        * i_mb_b_cost_table[B_L1_L1 as ::core::ffi::c_int as usize] as ::core::ffi::c_int;
}
#[inline]
#[c2rust::src_loc = "2076:1"]
unsafe extern "C" fn mb_cache_mv_p8x8(
    mut h: *mut x264_t,
    mut a: *mut x264_mb_analysis_t,
    mut i: ::core::ffi::c_int,
) {
    let mut x: ::core::ffi::c_int = 2 as ::core::ffi::c_int * (i & 1 as ::core::ffi::c_int);
    let mut y: ::core::ffi::c_int = i & 2 as ::core::ffi::c_int;
    match (*h).mb.i_sub_partition[i as usize] as ::core::ffi::c_int {
        3 => {
            x264_macroblock_cache_mv(
                h,
                x,
                y,
                2 as ::core::ffi::c_int,
                2 as ::core::ffi::c_int,
                0 as ::core::ffi::c_int,
                (*((*(*a).l0.me8x8.as_mut_ptr().offset(i as isize))
                    .mv
                    .as_mut_ptr() as *mut x264_union32_t))
                    .i,
            );
        }
        1 => {
            x264_macroblock_cache_mv(
                h,
                x,
                y + 0 as ::core::ffi::c_int,
                2 as ::core::ffi::c_int,
                1 as ::core::ffi::c_int,
                0 as ::core::ffi::c_int,
                (*((*(*(*a).l0.me8x4.as_mut_ptr().offset(i as isize))
                    .as_mut_ptr()
                    .offset(0 as ::core::ffi::c_int as isize))
                .mv
                .as_mut_ptr() as *mut x264_union32_t))
                    .i,
            );
            x264_macroblock_cache_mv(
                h,
                x,
                y + 1 as ::core::ffi::c_int,
                2 as ::core::ffi::c_int,
                1 as ::core::ffi::c_int,
                0 as ::core::ffi::c_int,
                (*((*(*(*a).l0.me8x4.as_mut_ptr().offset(i as isize))
                    .as_mut_ptr()
                    .offset(1 as ::core::ffi::c_int as isize))
                .mv
                .as_mut_ptr() as *mut x264_union32_t))
                    .i,
            );
        }
        2 => {
            x264_macroblock_cache_mv(
                h,
                x + 0 as ::core::ffi::c_int,
                y,
                1 as ::core::ffi::c_int,
                2 as ::core::ffi::c_int,
                0 as ::core::ffi::c_int,
                (*((*(*(*a).l0.me4x8.as_mut_ptr().offset(i as isize))
                    .as_mut_ptr()
                    .offset(0 as ::core::ffi::c_int as isize))
                .mv
                .as_mut_ptr() as *mut x264_union32_t))
                    .i,
            );
            x264_macroblock_cache_mv(
                h,
                x + 1 as ::core::ffi::c_int,
                y,
                1 as ::core::ffi::c_int,
                2 as ::core::ffi::c_int,
                0 as ::core::ffi::c_int,
                (*((*(*(*a).l0.me4x8.as_mut_ptr().offset(i as isize))
                    .as_mut_ptr()
                    .offset(1 as ::core::ffi::c_int as isize))
                .mv
                .as_mut_ptr() as *mut x264_union32_t))
                    .i,
            );
        }
        0 => {
            x264_macroblock_cache_mv(
                h,
                x + 0 as ::core::ffi::c_int,
                y + 0 as ::core::ffi::c_int,
                1 as ::core::ffi::c_int,
                1 as ::core::ffi::c_int,
                0 as ::core::ffi::c_int,
                (*((*(*(*a).l0.me4x4.as_mut_ptr().offset(i as isize))
                    .as_mut_ptr()
                    .offset(0 as ::core::ffi::c_int as isize))
                .mv
                .as_mut_ptr() as *mut x264_union32_t))
                    .i,
            );
            x264_macroblock_cache_mv(
                h,
                x + 1 as ::core::ffi::c_int,
                y + 0 as ::core::ffi::c_int,
                1 as ::core::ffi::c_int,
                1 as ::core::ffi::c_int,
                0 as ::core::ffi::c_int,
                (*((*(*(*a).l0.me4x4.as_mut_ptr().offset(i as isize))
                    .as_mut_ptr()
                    .offset(1 as ::core::ffi::c_int as isize))
                .mv
                .as_mut_ptr() as *mut x264_union32_t))
                    .i,
            );
            x264_macroblock_cache_mv(
                h,
                x + 0 as ::core::ffi::c_int,
                y + 1 as ::core::ffi::c_int,
                1 as ::core::ffi::c_int,
                1 as ::core::ffi::c_int,
                0 as ::core::ffi::c_int,
                (*((*(*(*a).l0.me4x4.as_mut_ptr().offset(i as isize))
                    .as_mut_ptr()
                    .offset(2 as ::core::ffi::c_int as isize))
                .mv
                .as_mut_ptr() as *mut x264_union32_t))
                    .i,
            );
            x264_macroblock_cache_mv(
                h,
                x + 1 as ::core::ffi::c_int,
                y + 1 as ::core::ffi::c_int,
                1 as ::core::ffi::c_int,
                1 as ::core::ffi::c_int,
                0 as ::core::ffi::c_int,
                (*((*(*(*a).l0.me4x4.as_mut_ptr().offset(i as isize))
                    .as_mut_ptr()
                    .offset(3 as ::core::ffi::c_int as isize))
                .mv
                .as_mut_ptr() as *mut x264_union32_t))
                    .i,
            );
        }
        _ => {
            x264_10_log(
                h,
                X264_LOG_ERROR,
                b"internal error\n\0" as *const u8 as *const ::core::ffi::c_char,
            );
        }
    };
}
#[c2rust::src_loc = "2106:1"]
unsafe extern "C" fn mb_load_mv_direct8x8(mut h: *mut x264_t, mut idx: ::core::ffi::c_int) {
    let mut x: ::core::ffi::c_int = 2 as ::core::ffi::c_int * (idx & 1 as ::core::ffi::c_int);
    let mut y: ::core::ffi::c_int = idx & 2 as ::core::ffi::c_int;
    x264_macroblock_cache_ref(
        h,
        x,
        y,
        2 as ::core::ffi::c_int,
        2 as ::core::ffi::c_int,
        0 as ::core::ffi::c_int,
        (*h).mb.cache.direct_ref[0 as ::core::ffi::c_int as usize][idx as usize],
    );
    x264_macroblock_cache_ref(
        h,
        x,
        y,
        2 as ::core::ffi::c_int,
        2 as ::core::ffi::c_int,
        1 as ::core::ffi::c_int,
        (*h).mb.cache.direct_ref[1 as ::core::ffi::c_int as usize][idx as usize],
    );
    x264_macroblock_cache_mv(
        h,
        x,
        y,
        2 as ::core::ffi::c_int,
        2 as ::core::ffi::c_int,
        0 as ::core::ffi::c_int,
        (*((*(*(*h)
            .mb
            .cache
            .direct_mv
            .as_mut_ptr()
            .offset(0 as ::core::ffi::c_int as isize))
        .as_mut_ptr()
        .offset(idx as isize))
        .as_mut_ptr() as *mut x264_union32_t))
            .i,
    );
    x264_macroblock_cache_mv(
        h,
        x,
        y,
        2 as ::core::ffi::c_int,
        2 as ::core::ffi::c_int,
        1 as ::core::ffi::c_int,
        (*((*(*(*h)
            .mb
            .cache
            .direct_mv
            .as_mut_ptr()
            .offset(1 as ::core::ffi::c_int as isize))
        .as_mut_ptr()
        .offset(idx as isize))
        .as_mut_ptr() as *mut x264_union32_t))
            .i,
    );
}
#[inline]
#[c2rust::src_loc = "2142:1"]
unsafe extern "C" fn mb_cache_mv_b8x8(
    mut h: *mut x264_t,
    mut a: *mut x264_mb_analysis_t,
    mut i: ::core::ffi::c_int,
    mut b_mvd: ::core::ffi::c_int,
) {
    let mut x: ::core::ffi::c_int = 2 as ::core::ffi::c_int * (i & 1 as ::core::ffi::c_int);
    let mut y: ::core::ffi::c_int = i & 2 as ::core::ffi::c_int;
    if (*h).mb.i_sub_partition[i as usize] as ::core::ffi::c_int
        == D_DIRECT_8x8 as ::core::ffi::c_int
    {
        mb_load_mv_direct8x8(h, i);
        if b_mvd != 0 {
            x264_macroblock_cache_mvd(
                h,
                x,
                y,
                2 as ::core::ffi::c_int,
                2 as ::core::ffi::c_int,
                0 as ::core::ffi::c_int,
                0 as uint16_t,
            );
            x264_macroblock_cache_mvd(
                h,
                x,
                y,
                2 as ::core::ffi::c_int,
                2 as ::core::ffi::c_int,
                1 as ::core::ffi::c_int,
                0 as uint16_t,
            );
            x264_macroblock_cache_skip(
                h,
                x,
                y,
                2 as ::core::ffi::c_int,
                2 as ::core::ffi::c_int,
                1 as ::core::ffi::c_int,
            );
        }
    } else {
        if x264_mb_partition_listX_table[0 as ::core::ffi::c_int as usize]
            [(*h).mb.i_sub_partition[i as usize] as usize]
            != 0
        {
            x264_macroblock_cache_ref(
                h,
                x,
                y,
                2 as ::core::ffi::c_int,
                2 as ::core::ffi::c_int,
                0 as ::core::ffi::c_int,
                (*a).l0.me8x8[i as usize].i_ref as int8_t,
            );
            x264_macroblock_cache_mv(
                h,
                x,
                y,
                2 as ::core::ffi::c_int,
                2 as ::core::ffi::c_int,
                0 as ::core::ffi::c_int,
                (*((*(*a).l0.me8x8.as_mut_ptr().offset(i as isize))
                    .mv
                    .as_mut_ptr() as *mut x264_union32_t))
                    .i,
            );
        } else {
            x264_macroblock_cache_ref(
                h,
                x,
                y,
                2 as ::core::ffi::c_int,
                2 as ::core::ffi::c_int,
                0 as ::core::ffi::c_int,
                -(1 as ::core::ffi::c_int) as int8_t,
            );
            x264_macroblock_cache_mv(
                h,
                x,
                y,
                2 as ::core::ffi::c_int,
                2 as ::core::ffi::c_int,
                0 as ::core::ffi::c_int,
                0 as uint32_t,
            );
            if b_mvd != 0 {
                x264_macroblock_cache_mvd(
                    h,
                    x,
                    y,
                    2 as ::core::ffi::c_int,
                    2 as ::core::ffi::c_int,
                    0 as ::core::ffi::c_int,
                    0 as uint16_t,
                );
            }
        }
        if x264_mb_partition_listX_table[1 as ::core::ffi::c_int as usize]
            [(*h).mb.i_sub_partition[i as usize] as usize]
            != 0
        {
            x264_macroblock_cache_ref(
                h,
                x,
                y,
                2 as ::core::ffi::c_int,
                2 as ::core::ffi::c_int,
                1 as ::core::ffi::c_int,
                (*a).l1.me8x8[i as usize].i_ref as int8_t,
            );
            x264_macroblock_cache_mv(
                h,
                x,
                y,
                2 as ::core::ffi::c_int,
                2 as ::core::ffi::c_int,
                1 as ::core::ffi::c_int,
                (*((*(*a).l1.me8x8.as_mut_ptr().offset(i as isize))
                    .mv
                    .as_mut_ptr() as *mut x264_union32_t))
                    .i,
            );
        } else {
            x264_macroblock_cache_ref(
                h,
                x,
                y,
                2 as ::core::ffi::c_int,
                2 as ::core::ffi::c_int,
                1 as ::core::ffi::c_int,
                -(1 as ::core::ffi::c_int) as int8_t,
            );
            x264_macroblock_cache_mv(
                h,
                x,
                y,
                2 as ::core::ffi::c_int,
                2 as ::core::ffi::c_int,
                1 as ::core::ffi::c_int,
                0 as uint32_t,
            );
            if b_mvd != 0 {
                x264_macroblock_cache_mvd(
                    h,
                    x,
                    y,
                    2 as ::core::ffi::c_int,
                    2 as ::core::ffi::c_int,
                    1 as ::core::ffi::c_int,
                    0 as uint16_t,
                );
            }
        }
    };
}
#[inline]
#[c2rust::src_loc = "2161:1"]
unsafe extern "C" fn mb_cache_mv_b16x8(
    mut h: *mut x264_t,
    mut a: *mut x264_mb_analysis_t,
    mut i: ::core::ffi::c_int,
    mut b_mvd: ::core::ffi::c_int,
) {
    if x264_mb_partition_listX_table[0 as ::core::ffi::c_int as usize]
        [(*a).i_mb_partition16x8[i as usize] as usize]
        != 0
    {
        x264_macroblock_cache_ref(
            h,
            0 as ::core::ffi::c_int,
            2 as ::core::ffi::c_int * i,
            4 as ::core::ffi::c_int,
            2 as ::core::ffi::c_int,
            0 as ::core::ffi::c_int,
            (*a).l0.me16x8[i as usize].i_ref as int8_t,
        );
        x264_macroblock_cache_mv(
            h,
            0 as ::core::ffi::c_int,
            2 as ::core::ffi::c_int * i,
            4 as ::core::ffi::c_int,
            2 as ::core::ffi::c_int,
            0 as ::core::ffi::c_int,
            (*((*(*a).l0.me16x8.as_mut_ptr().offset(i as isize))
                .mv
                .as_mut_ptr() as *mut x264_union32_t))
                .i,
        );
    } else {
        x264_macroblock_cache_ref(
            h,
            0 as ::core::ffi::c_int,
            2 as ::core::ffi::c_int * i,
            4 as ::core::ffi::c_int,
            2 as ::core::ffi::c_int,
            0 as ::core::ffi::c_int,
            -(1 as ::core::ffi::c_int) as int8_t,
        );
        x264_macroblock_cache_mv(
            h,
            0 as ::core::ffi::c_int,
            2 as ::core::ffi::c_int * i,
            4 as ::core::ffi::c_int,
            2 as ::core::ffi::c_int,
            0 as ::core::ffi::c_int,
            0 as uint32_t,
        );
        if b_mvd != 0 {
            x264_macroblock_cache_mvd(
                h,
                0 as ::core::ffi::c_int,
                2 as ::core::ffi::c_int * i,
                4 as ::core::ffi::c_int,
                2 as ::core::ffi::c_int,
                0 as ::core::ffi::c_int,
                0 as uint16_t,
            );
        }
    }
    if x264_mb_partition_listX_table[1 as ::core::ffi::c_int as usize]
        [(*a).i_mb_partition16x8[i as usize] as usize]
        != 0
    {
        x264_macroblock_cache_ref(
            h,
            0 as ::core::ffi::c_int,
            2 as ::core::ffi::c_int * i,
            4 as ::core::ffi::c_int,
            2 as ::core::ffi::c_int,
            1 as ::core::ffi::c_int,
            (*a).l1.me16x8[i as usize].i_ref as int8_t,
        );
        x264_macroblock_cache_mv(
            h,
            0 as ::core::ffi::c_int,
            2 as ::core::ffi::c_int * i,
            4 as ::core::ffi::c_int,
            2 as ::core::ffi::c_int,
            1 as ::core::ffi::c_int,
            (*((*(*a).l1.me16x8.as_mut_ptr().offset(i as isize))
                .mv
                .as_mut_ptr() as *mut x264_union32_t))
                .i,
        );
    } else {
        x264_macroblock_cache_ref(
            h,
            0 as ::core::ffi::c_int,
            2 as ::core::ffi::c_int * i,
            4 as ::core::ffi::c_int,
            2 as ::core::ffi::c_int,
            1 as ::core::ffi::c_int,
            -(1 as ::core::ffi::c_int) as int8_t,
        );
        x264_macroblock_cache_mv(
            h,
            0 as ::core::ffi::c_int,
            2 as ::core::ffi::c_int * i,
            4 as ::core::ffi::c_int,
            2 as ::core::ffi::c_int,
            1 as ::core::ffi::c_int,
            0 as uint32_t,
        );
        if b_mvd != 0 {
            x264_macroblock_cache_mvd(
                h,
                0 as ::core::ffi::c_int,
                2 as ::core::ffi::c_int * i,
                4 as ::core::ffi::c_int,
                2 as ::core::ffi::c_int,
                1 as ::core::ffi::c_int,
                0 as uint16_t,
            );
        }
    };
}
#[inline]
#[c2rust::src_loc = "2165:1"]
unsafe extern "C" fn mb_cache_mv_b8x16(
    mut h: *mut x264_t,
    mut a: *mut x264_mb_analysis_t,
    mut i: ::core::ffi::c_int,
    mut b_mvd: ::core::ffi::c_int,
) {
    if x264_mb_partition_listX_table[0 as ::core::ffi::c_int as usize]
        [(*a).i_mb_partition8x16[i as usize] as usize]
        != 0
    {
        x264_macroblock_cache_ref(
            h,
            2 as ::core::ffi::c_int * i,
            0 as ::core::ffi::c_int,
            2 as ::core::ffi::c_int,
            4 as ::core::ffi::c_int,
            0 as ::core::ffi::c_int,
            (*a).l0.me8x16[i as usize].i_ref as int8_t,
        );
        x264_macroblock_cache_mv(
            h,
            2 as ::core::ffi::c_int * i,
            0 as ::core::ffi::c_int,
            2 as ::core::ffi::c_int,
            4 as ::core::ffi::c_int,
            0 as ::core::ffi::c_int,
            (*((*(*a).l0.me8x16.as_mut_ptr().offset(i as isize))
                .mv
                .as_mut_ptr() as *mut x264_union32_t))
                .i,
        );
    } else {
        x264_macroblock_cache_ref(
            h,
            2 as ::core::ffi::c_int * i,
            0 as ::core::ffi::c_int,
            2 as ::core::ffi::c_int,
            4 as ::core::ffi::c_int,
            0 as ::core::ffi::c_int,
            -(1 as ::core::ffi::c_int) as int8_t,
        );
        x264_macroblock_cache_mv(
            h,
            2 as ::core::ffi::c_int * i,
            0 as ::core::ffi::c_int,
            2 as ::core::ffi::c_int,
            4 as ::core::ffi::c_int,
            0 as ::core::ffi::c_int,
            0 as uint32_t,
        );
        if b_mvd != 0 {
            x264_macroblock_cache_mvd(
                h,
                2 as ::core::ffi::c_int * i,
                0 as ::core::ffi::c_int,
                2 as ::core::ffi::c_int,
                4 as ::core::ffi::c_int,
                0 as ::core::ffi::c_int,
                0 as uint16_t,
            );
        }
    }
    if x264_mb_partition_listX_table[1 as ::core::ffi::c_int as usize]
        [(*a).i_mb_partition8x16[i as usize] as usize]
        != 0
    {
        x264_macroblock_cache_ref(
            h,
            2 as ::core::ffi::c_int * i,
            0 as ::core::ffi::c_int,
            2 as ::core::ffi::c_int,
            4 as ::core::ffi::c_int,
            1 as ::core::ffi::c_int,
            (*a).l1.me8x16[i as usize].i_ref as int8_t,
        );
        x264_macroblock_cache_mv(
            h,
            2 as ::core::ffi::c_int * i,
            0 as ::core::ffi::c_int,
            2 as ::core::ffi::c_int,
            4 as ::core::ffi::c_int,
            1 as ::core::ffi::c_int,
            (*((*(*a).l1.me8x16.as_mut_ptr().offset(i as isize))
                .mv
                .as_mut_ptr() as *mut x264_union32_t))
                .i,
        );
    } else {
        x264_macroblock_cache_ref(
            h,
            2 as ::core::ffi::c_int * i,
            0 as ::core::ffi::c_int,
            2 as ::core::ffi::c_int,
            4 as ::core::ffi::c_int,
            1 as ::core::ffi::c_int,
            -(1 as ::core::ffi::c_int) as int8_t,
        );
        x264_macroblock_cache_mv(
            h,
            2 as ::core::ffi::c_int * i,
            0 as ::core::ffi::c_int,
            2 as ::core::ffi::c_int,
            4 as ::core::ffi::c_int,
            1 as ::core::ffi::c_int,
            0 as uint32_t,
        );
        if b_mvd != 0 {
            x264_macroblock_cache_mvd(
                h,
                2 as ::core::ffi::c_int * i,
                0 as ::core::ffi::c_int,
                2 as ::core::ffi::c_int,
                4 as ::core::ffi::c_int,
                1 as ::core::ffi::c_int,
                0 as uint16_t,
            );
        }
    };
}
#[c2rust::src_loc = "2171:1"]
unsafe extern "C" fn mb_analyse_inter_b8x8_mixed_ref(
    mut h: *mut x264_t,
    mut a: *mut x264_mb_analysis_t,
) {
    let mut pix: [[pixel; 64]; 2] = [[0; 64]; 2];
    let mut i_maxref: [::core::ffi::c_int; 2] = [
        (*h).mb.pic.i_fref[0 as ::core::ffi::c_int as usize] - 1 as ::core::ffi::c_int,
        (*h).mb.pic.i_fref[1 as ::core::ffi::c_int as usize] - 1 as ::core::ffi::c_int,
    ];
    let mut l: ::core::ffi::c_int = 0 as ::core::ffi::c_int;
    while l < 2 as ::core::ffi::c_int {
        let mut lX: *mut x264_mb_analysis_list_t = if l != 0 { &mut (*a).l1 } else { &mut (*a).l0 };
        if i_maxref[l as usize] > 0 as ::core::ffi::c_int
            && (*lX).me16x16.i_ref == 0 as ::core::ffi::c_int
            && (*h).mb.i_mb_type_top > 0 as ::core::ffi::c_int
            && (*h).mb.i_mb_type_left[0 as ::core::ffi::c_int as usize] > 0 as ::core::ffi::c_int
        {
            i_maxref[l as usize] = 0 as ::core::ffi::c_int;
            let mut ref_0: ::core::ffi::c_int = (*h).mb.cache.ref_0[l as usize]
                [(X264_SCAN8_0 + -(8 as ::core::ffi::c_int) - 1 as ::core::ffi::c_int) as usize]
                as ::core::ffi::c_int;
            if ref_0 > i_maxref[l as usize] {
                i_maxref[l as usize] = ref_0;
            }
            let mut ref_1: ::core::ffi::c_int = (*h).mb.cache.ref_0[l as usize]
                [(X264_SCAN8_0 + -(8 as ::core::ffi::c_int) + 0 as ::core::ffi::c_int) as usize]
                as ::core::ffi::c_int;
            if ref_1 > i_maxref[l as usize] {
                i_maxref[l as usize] = ref_1;
            }
            let mut ref_2: ::core::ffi::c_int = (*h).mb.cache.ref_0[l as usize]
                [(X264_SCAN8_0 + -(8 as ::core::ffi::c_int) + 2 as ::core::ffi::c_int) as usize]
                as ::core::ffi::c_int;
            if ref_2 > i_maxref[l as usize] {
                i_maxref[l as usize] = ref_2;
            }
            let mut ref_3: ::core::ffi::c_int = (*h).mb.cache.ref_0[l as usize]
                [(X264_SCAN8_0 + -(8 as ::core::ffi::c_int) + 4 as ::core::ffi::c_int) as usize]
                as ::core::ffi::c_int;
            if ref_3 > i_maxref[l as usize] {
                i_maxref[l as usize] = ref_3;
            }
            let mut ref_4: ::core::ffi::c_int = (*h).mb.cache.ref_0[l as usize]
                [(X264_SCAN8_0 + 0 as ::core::ffi::c_int - 1 as ::core::ffi::c_int) as usize]
                as ::core::ffi::c_int;
            if ref_4 > i_maxref[l as usize] {
                i_maxref[l as usize] = ref_4;
            }
            let mut ref_5: ::core::ffi::c_int = (*h).mb.cache.ref_0[l as usize][(X264_SCAN8_0
                + 2 as ::core::ffi::c_int * 8 as ::core::ffi::c_int
                - 1 as ::core::ffi::c_int)
                as usize] as ::core::ffi::c_int;
            if ref_5 > i_maxref[l as usize] {
                i_maxref[l as usize] = ref_5;
            }
        }
        l += 1;
    }
    (*h).mb.i_partition = D_8x8 as ::core::ffi::c_int;
    (*a).i_cost8x8bi = 0 as ::core::ffi::c_int;
    let mut i: ::core::ffi::c_int = 0 as ::core::ffi::c_int;
    while i < 4 as ::core::ffi::c_int {
        let mut x8: ::core::ffi::c_int = i & 1 as ::core::ffi::c_int;
        let mut y8: ::core::ffi::c_int = i >> 1 as ::core::ffi::c_int;
        let mut i_part_cost: ::core::ffi::c_int = 0;
        let mut i_part_cost_bi: ::core::ffi::c_int = 0;
        let mut stride: [intptr_t; 2] = [
            8 as ::core::ffi::c_int as intptr_t,
            8 as ::core::ffi::c_int as intptr_t,
        ];
        let mut src: [*mut pixel; 2] = [0 as *mut pixel; 2];
        let mut m: x264_me_t = x264_me_t {
            i_pixel: 0,
            p_cost_mv: 0 as *mut uint16_t,
            i_ref_cost: 0,
            i_ref: 0,
            weight: 0 as *const x264_weight_t,
            p_fref: [0 as *mut pixel; 12],
            p_fref_w: 0 as *mut pixel,
            p_fenc: [0 as *mut pixel; 3],
            integral: 0 as *mut uint16_t,
            i_stride: [0; 3],
            mvp: [0; 2],
            cost_mv: 0,
            cost: 0,
            mv: [0; 2],
        };
        m.i_pixel = PIXEL_8x8 as ::core::ffi::c_int;
        m.p_cost_mv = (*a).p_cost_mv;
        m.i_stride[0 as ::core::ffi::c_int as usize] =
            (*h).mb.pic.i_stride[0 as ::core::ffi::c_int as usize];
        m.i_stride[1 as ::core::ffi::c_int as usize] =
            (*h).mb.pic.i_stride[1 as ::core::ffi::c_int as usize];
        m.i_stride[2 as ::core::ffi::c_int as usize] =
            (*h).mb.pic.i_stride[2 as ::core::ffi::c_int as usize];
        m.p_fenc[0 as ::core::ffi::c_int as usize] = &mut *(*(*h)
            .mb
            .pic
            .p_fenc
            .as_mut_ptr()
            .offset(0 as ::core::ffi::c_int as isize))
        .offset(
            (8 as ::core::ffi::c_int * x8 + 8 as ::core::ffi::c_int * y8 * FENC_STRIDE) as isize,
        ) as *mut pixel;
        if (*(*h).sps.as_mut_ptr()).i_chroma_format_idc != 0 {
            m.p_fenc[1 as ::core::ffi::c_int as usize] = &mut *(*(*h)
                .mb
                .pic
                .p_fenc
                .as_mut_ptr()
                .offset(1 as ::core::ffi::c_int as isize))
            .offset(
                ((8 as ::core::ffi::c_int * x8 >> (*h).mb.chroma_h_shift)
                    + (8 as ::core::ffi::c_int * y8 >> (*h).mb.chroma_v_shift) * FENC_STRIDE)
                    as isize,
            ) as *mut pixel;
            m.p_fenc[2 as ::core::ffi::c_int as usize] = &mut *(*(*h)
                .mb
                .pic
                .p_fenc
                .as_mut_ptr()
                .offset(2 as ::core::ffi::c_int as isize))
            .offset(
                ((8 as ::core::ffi::c_int * x8 >> (*h).mb.chroma_h_shift)
                    + (8 as ::core::ffi::c_int * y8 >> (*h).mb.chroma_v_shift) * FENC_STRIDE)
                    as isize,
            ) as *mut pixel;
        }
        let mut l_0: ::core::ffi::c_int = 0 as ::core::ffi::c_int;
        while l_0 < 2 as ::core::ffi::c_int {
            let mut lX_0: *mut x264_mb_analysis_list_t =
                if l_0 != 0 { &mut (*a).l1 } else { &mut (*a).l0 };
            (*lX_0).me8x8[i as usize].cost = INT_MAX;
            let mut i_ref: ::core::ffi::c_int = 0 as ::core::ffi::c_int;
            while i_ref <= i_maxref[l_0 as usize] {
                m.i_ref_cost =
                    *(*a).p_cost_ref[l_0 as usize].offset(i_ref as isize) as ::core::ffi::c_int;
                m.p_fref[0 as ::core::ffi::c_int as usize] =
                    &mut *(*(*(*(*h).mb.pic.p_fref.as_mut_ptr().offset(l_0 as isize))
                        .as_mut_ptr()
                        .offset(i_ref as isize))
                    .as_mut_ptr()
                    .offset(0 as ::core::ffi::c_int as isize))
                    .offset(
                        (8 as ::core::ffi::c_int * x8
                            + 8 as ::core::ffi::c_int
                                * y8
                                * *m.i_stride
                                    .as_mut_ptr()
                                    .offset(0 as ::core::ffi::c_int as isize))
                            as isize,
                    ) as *mut pixel;
                m.p_fref_w = m.p_fref[0 as ::core::ffi::c_int as usize];
                if (*h).param.analyse.i_subpel_refine != 0 {
                    m.p_fref[1 as ::core::ffi::c_int as usize] =
                        &mut *(*(*(*(*h).mb.pic.p_fref.as_mut_ptr().offset(l_0 as isize))
                            .as_mut_ptr()
                            .offset(i_ref as isize))
                        .as_mut_ptr()
                        .offset(1 as ::core::ffi::c_int as isize))
                        .offset(
                            (8 as ::core::ffi::c_int * x8
                                + 8 as ::core::ffi::c_int
                                    * y8
                                    * *m.i_stride
                                        .as_mut_ptr()
                                        .offset(0 as ::core::ffi::c_int as isize))
                                as isize,
                        ) as *mut pixel;
                    m.p_fref[2 as ::core::ffi::c_int as usize] =
                        &mut *(*(*(*(*h).mb.pic.p_fref.as_mut_ptr().offset(l_0 as isize))
                            .as_mut_ptr()
                            .offset(i_ref as isize))
                        .as_mut_ptr()
                        .offset(2 as ::core::ffi::c_int as isize))
                        .offset(
                            (8 as ::core::ffi::c_int * x8
                                + 8 as ::core::ffi::c_int
                                    * y8
                                    * *m.i_stride
                                        .as_mut_ptr()
                                        .offset(0 as ::core::ffi::c_int as isize))
                                as isize,
                        ) as *mut pixel;
                    m.p_fref[3 as ::core::ffi::c_int as usize] =
                        &mut *(*(*(*(*h).mb.pic.p_fref.as_mut_ptr().offset(l_0 as isize))
                            .as_mut_ptr()
                            .offset(i_ref as isize))
                        .as_mut_ptr()
                        .offset(3 as ::core::ffi::c_int as isize))
                        .offset(
                            (8 as ::core::ffi::c_int * x8
                                + 8 as ::core::ffi::c_int
                                    * y8
                                    * *m.i_stride
                                        .as_mut_ptr()
                                        .offset(0 as ::core::ffi::c_int as isize))
                                as isize,
                        ) as *mut pixel;
                }
                if (*(*h).sps.as_mut_ptr()).i_chroma_format_idc == CHROMA_444 as ::core::ffi::c_int
                {
                    m.p_fref[4 as ::core::ffi::c_int as usize] =
                        &mut *(*(*(*(*h).mb.pic.p_fref.as_mut_ptr().offset(l_0 as isize))
                            .as_mut_ptr()
                            .offset(i_ref as isize))
                        .as_mut_ptr()
                        .offset(4 as ::core::ffi::c_int as isize))
                        .offset(
                            (8 as ::core::ffi::c_int * x8
                                + 8 as ::core::ffi::c_int
                                    * y8
                                    * *m.i_stride
                                        .as_mut_ptr()
                                        .offset(1 as ::core::ffi::c_int as isize))
                                as isize,
                        ) as *mut pixel;
                    m.p_fref[8 as ::core::ffi::c_int as usize] =
                        &mut *(*(*(*(*h).mb.pic.p_fref.as_mut_ptr().offset(l_0 as isize))
                            .as_mut_ptr()
                            .offset(i_ref as isize))
                        .as_mut_ptr()
                        .offset(8 as ::core::ffi::c_int as isize))
                        .offset(
                            (8 as ::core::ffi::c_int * x8
                                + 8 as ::core::ffi::c_int
                                    * y8
                                    * *m.i_stride
                                        .as_mut_ptr()
                                        .offset(2 as ::core::ffi::c_int as isize))
                                as isize,
                        ) as *mut pixel;
                    if (*h).param.analyse.i_subpel_refine != 0 {
                        m.p_fref[5 as ::core::ffi::c_int as usize] =
                            &mut *(*(*(*(*h).mb.pic.p_fref.as_mut_ptr().offset(l_0 as isize))
                                .as_mut_ptr()
                                .offset(i_ref as isize))
                            .as_mut_ptr()
                            .offset(5 as ::core::ffi::c_int as isize))
                            .offset(
                                (8 as ::core::ffi::c_int * x8
                                    + 8 as ::core::ffi::c_int
                                        * y8
                                        * *m.i_stride
                                            .as_mut_ptr()
                                            .offset(1 as ::core::ffi::c_int as isize))
                                    as isize,
                            ) as *mut pixel;
                        m.p_fref[6 as ::core::ffi::c_int as usize] =
                            &mut *(*(*(*(*h).mb.pic.p_fref.as_mut_ptr().offset(l_0 as isize))
                                .as_mut_ptr()
                                .offset(i_ref as isize))
                            .as_mut_ptr()
                            .offset(6 as ::core::ffi::c_int as isize))
                            .offset(
                                (8 as ::core::ffi::c_int * x8
                                    + 8 as ::core::ffi::c_int
                                        * y8
                                        * *m.i_stride
                                            .as_mut_ptr()
                                            .offset(1 as ::core::ffi::c_int as isize))
                                    as isize,
                            ) as *mut pixel;
                        m.p_fref[7 as ::core::ffi::c_int as usize] =
                            &mut *(*(*(*(*h).mb.pic.p_fref.as_mut_ptr().offset(l_0 as isize))
                                .as_mut_ptr()
                                .offset(i_ref as isize))
                            .as_mut_ptr()
                            .offset(7 as ::core::ffi::c_int as isize))
                            .offset(
                                (8 as ::core::ffi::c_int * x8
                                    + 8 as ::core::ffi::c_int
                                        * y8
                                        * *m.i_stride
                                            .as_mut_ptr()
                                            .offset(1 as ::core::ffi::c_int as isize))
                                    as isize,
                            ) as *mut pixel;
                        m.p_fref[9 as ::core::ffi::c_int as usize] =
                            &mut *(*(*(*(*h).mb.pic.p_fref.as_mut_ptr().offset(l_0 as isize))
                                .as_mut_ptr()
                                .offset(i_ref as isize))
                            .as_mut_ptr()
                            .offset(9 as ::core::ffi::c_int as isize))
                            .offset(
                                (8 as ::core::ffi::c_int * x8
                                    + 8 as ::core::ffi::c_int
                                        * y8
                                        * *m.i_stride
                                            .as_mut_ptr()
                                            .offset(2 as ::core::ffi::c_int as isize))
                                    as isize,
                            ) as *mut pixel;
                        m.p_fref[10 as ::core::ffi::c_int as usize] =
                            &mut *(*(*(*(*h).mb.pic.p_fref.as_mut_ptr().offset(l_0 as isize))
                                .as_mut_ptr()
                                .offset(i_ref as isize))
                            .as_mut_ptr()
                            .offset(10 as ::core::ffi::c_int as isize))
                            .offset(
                                (8 as ::core::ffi::c_int * x8
                                    + 8 as ::core::ffi::c_int
                                        * y8
                                        * *m.i_stride
                                            .as_mut_ptr()
                                            .offset(2 as ::core::ffi::c_int as isize))
                                    as isize,
                            ) as *mut pixel;
                        m.p_fref[11 as ::core::ffi::c_int as usize] =
                            &mut *(*(*(*(*h).mb.pic.p_fref.as_mut_ptr().offset(l_0 as isize))
                                .as_mut_ptr()
                                .offset(i_ref as isize))
                            .as_mut_ptr()
                            .offset(11 as ::core::ffi::c_int as isize))
                            .offset(
                                (8 as ::core::ffi::c_int * x8
                                    + 8 as ::core::ffi::c_int
                                        * y8
                                        * *m.i_stride
                                            .as_mut_ptr()
                                            .offset(2 as ::core::ffi::c_int as isize))
                                    as isize,
                            ) as *mut pixel;
                    }
                } else if (*(*h).sps.as_mut_ptr()).i_chroma_format_idc != 0 {
                    m.p_fref[4 as ::core::ffi::c_int as usize] =
                        &mut *(*(*(*(*h).mb.pic.p_fref.as_mut_ptr().offset(l_0 as isize))
                            .as_mut_ptr()
                            .offset(i_ref as isize))
                        .as_mut_ptr()
                        .offset(4 as ::core::ffi::c_int as isize))
                        .offset(
                            (8 as ::core::ffi::c_int * x8
                                + (8 as ::core::ffi::c_int * y8 >> (*h).mb.chroma_v_shift)
                                    * *m.i_stride
                                        .as_mut_ptr()
                                        .offset(1 as ::core::ffi::c_int as isize))
                                as isize,
                        ) as *mut pixel;
                }
                if (*h).param.analyse.i_me_method >= X264_ME_ESA {
                    m.integral =
                        &mut *(*(*(*h).mb.pic.p_integral.as_mut_ptr().offset(l_0 as isize))
                            .as_mut_ptr()
                            .offset(i_ref as isize))
                        .offset(
                            (8 as ::core::ffi::c_int * x8
                                + 8 as ::core::ffi::c_int
                                    * y8
                                    * *m.i_stride
                                        .as_mut_ptr()
                                        .offset(0 as ::core::ffi::c_int as isize))
                                as isize,
                        ) as *mut uint16_t;
                }
                m.weight = x264_zero.as_mut_ptr() as *const x264_weight_t;
                m.i_ref = i_ref;
                x264_macroblock_cache_ref(
                    h,
                    x8 * 2 as ::core::ffi::c_int,
                    y8 * 2 as ::core::ffi::c_int,
                    2 as ::core::ffi::c_int,
                    2 as ::core::ffi::c_int,
                    l_0,
                    i_ref as int8_t,
                );
                x264_10_mb_predict_mv(
                    h,
                    l_0,
                    4 as ::core::ffi::c_int * i,
                    2 as ::core::ffi::c_int,
                    m.mvp.as_mut_ptr(),
                );
                x264_10_me_search_ref(
                    h,
                    &mut m,
                    (*(*lX_0).mvc.as_mut_ptr().offset(i_ref as isize)).as_mut_ptr()
                        as *mut [int16_t; 2],
                    i + 1 as ::core::ffi::c_int,
                    0 as *mut ::core::ffi::c_int,
                );
                m.cost += m.i_ref_cost;
                if m.cost < (*lX_0).me8x8[i as usize].cost {
                    (*h).mc.memcpy_aligned.expect("non-null function pointer")(
                        &mut *(*lX_0).me8x8.as_mut_ptr().offset(i as isize) as *mut x264_me_t
                            as *mut ::core::ffi::c_void,
                        &mut m as *mut x264_me_t as *const ::core::ffi::c_void,
                        ::core::mem::size_of::<x264_me_t>() as size_t,
                    );
                    (*a).i_satd8x8[l_0 as usize][i as usize] = m.cost - (m.cost_mv + m.i_ref_cost);
                }
                (*((*(*(*lX_0).mvc.as_mut_ptr().offset(i_ref as isize))
                    .as_mut_ptr()
                    .offset((i + 1 as ::core::ffi::c_int) as isize))
                .as_mut_ptr() as *mut x264_union32_t))
                    .i = (*(m.mv.as_mut_ptr() as *mut x264_union32_t)).i;
                i_ref += 1;
            }
            l_0 += 1;
        }
        src[0 as ::core::ffi::c_int as usize] = (*h).mc.get_ref.expect("non-null function pointer")(
            (*pix.as_mut_ptr().offset(0 as ::core::ffi::c_int as isize)).as_mut_ptr(),
            &mut *stride.as_mut_ptr().offset(0 as ::core::ffi::c_int as isize),
            (*(*a).l0.me8x8.as_mut_ptr().offset(i as isize))
                .p_fref
                .as_mut_ptr(),
            (*a).l0.me8x8[i as usize].i_stride[0 as ::core::ffi::c_int as usize] as intptr_t,
            (*a).l0.me8x8[i as usize].mv[0 as ::core::ffi::c_int as usize] as ::core::ffi::c_int,
            (*a).l0.me8x8[i as usize].mv[1 as ::core::ffi::c_int as usize] as ::core::ffi::c_int,
            8 as ::core::ffi::c_int,
            8 as ::core::ffi::c_int,
            x264_zero.as_mut_ptr() as *const x264_weight_t,
        );
        src[1 as ::core::ffi::c_int as usize] = (*h).mc.get_ref.expect("non-null function pointer")(
            (*pix.as_mut_ptr().offset(1 as ::core::ffi::c_int as isize)).as_mut_ptr(),
            &mut *stride.as_mut_ptr().offset(1 as ::core::ffi::c_int as isize),
            (*(*a).l1.me8x8.as_mut_ptr().offset(i as isize))
                .p_fref
                .as_mut_ptr(),
            (*a).l1.me8x8[i as usize].i_stride[0 as ::core::ffi::c_int as usize] as intptr_t,
            (*a).l1.me8x8[i as usize].mv[0 as ::core::ffi::c_int as usize] as ::core::ffi::c_int,
            (*a).l1.me8x8[i as usize].mv[1 as ::core::ffi::c_int as usize] as ::core::ffi::c_int,
            8 as ::core::ffi::c_int,
            8 as ::core::ffi::c_int,
            x264_zero.as_mut_ptr() as *const x264_weight_t,
        );
        (*h).mc.avg[PIXEL_8x8 as ::core::ffi::c_int as usize].expect("non-null function pointer")(
            (*pix.as_mut_ptr().offset(0 as ::core::ffi::c_int as isize)).as_mut_ptr(),
            8 as intptr_t,
            src[0 as ::core::ffi::c_int as usize],
            stride[0 as ::core::ffi::c_int as usize],
            src[1 as ::core::ffi::c_int as usize],
            stride[1 as ::core::ffi::c_int as usize],
            (*(*h)
                .mb
                .bipred_weight
                .offset((*a).l0.me8x8[i as usize].i_ref as isize))
                [(*a).l1.me8x8[i as usize].i_ref as usize] as ::core::ffi::c_int,
        );
        (*a).i_satd8x8[2 as ::core::ffi::c_int as usize][i as usize] = (*h).pixf.mbcmp
            [PIXEL_8x8 as ::core::ffi::c_int as usize]
            .expect("non-null function pointer")(
            (*a).l0.me8x8[i as usize].p_fenc[0 as ::core::ffi::c_int as usize],
            FENC_STRIDE as intptr_t,
            (*pix.as_mut_ptr().offset(0 as ::core::ffi::c_int as isize)).as_mut_ptr(),
            8 as intptr_t,
        );
        i_part_cost_bi = (*a).i_satd8x8[2 as ::core::ffi::c_int as usize][i as usize]
            + (*a).l0.me8x8[i as usize].cost_mv
            + (*a).l1.me8x8[i as usize].cost_mv
            + (*a).l0.me8x8[i as usize].i_ref_cost
            + (*a).l1.me8x8[i as usize].i_ref_cost
            + (*a).i_lambda
                * i_sub_mb_b_cost_table[D_BI_8x8 as ::core::ffi::c_int as usize]
                    as ::core::ffi::c_int;
        if (*h).mb.b_chroma_me != 0 {
            let mut i_chroma_cost: ::core::ffi::c_int =
                analyse_bi_chroma(h, a, i, PIXEL_8x8 as ::core::ffi::c_int);
            i_part_cost_bi += i_chroma_cost;
            (*a).i_satd8x8[2 as ::core::ffi::c_int as usize][i as usize] += i_chroma_cost;
        }
        (*a).l0.me8x8[i as usize].cost += (*a).i_lambda
            * i_sub_mb_b_cost_table[D_L0_8x8 as ::core::ffi::c_int as usize] as ::core::ffi::c_int;
        (*a).l1.me8x8[i as usize].cost += (*a).i_lambda
            * i_sub_mb_b_cost_table[D_L1_8x8 as ::core::ffi::c_int as usize] as ::core::ffi::c_int;
        i_part_cost = (*a).l0.me8x8[i as usize].cost;
        (*h).mb.i_sub_partition[i as usize] = D_L0_8x8 as ::core::ffi::c_int as uint8_t;
        if (*a).l1.me8x8[i as usize].cost < i_part_cost {
            i_part_cost = (*a).l1.me8x8[i as usize].cost;
            (*h).mb.i_sub_partition[i as usize] = D_L1_8x8 as ::core::ffi::c_int as uint8_t;
        }
        if i_part_cost_bi < i_part_cost {
            i_part_cost = i_part_cost_bi;
            (*h).mb.i_sub_partition[i as usize] = D_BI_8x8 as ::core::ffi::c_int as uint8_t;
        }
        if (*a).i_cost8x8direct[i as usize] < i_part_cost {
            i_part_cost = (*a).i_cost8x8direct[i as usize];
            (*h).mb.i_sub_partition[i as usize] = D_DIRECT_8x8 as ::core::ffi::c_int as uint8_t;
        }
        (*a).i_cost8x8bi += i_part_cost;
        mb_cache_mv_b8x8(h, a, i, 0 as ::core::ffi::c_int);
        i += 1;
    }
    (*a).i_cost8x8bi += (*a).i_lambda
        * i_mb_b_cost_table[B_8x8 as ::core::ffi::c_int as usize] as ::core::ffi::c_int;
}
#[c2rust::src_loc = "2283:1"]
unsafe extern "C" fn mb_analyse_inter_b8x8(mut h: *mut x264_t, mut a: *mut x264_mb_analysis_t) {
    let mut p_fref: [*mut *mut pixel; 2] = [
        (*(*(*h)
            .mb
            .pic
            .p_fref
            .as_mut_ptr()
            .offset(0 as ::core::ffi::c_int as isize))
        .as_mut_ptr()
        .offset((*a).l0.me16x16.i_ref as isize))
        .as_mut_ptr(),
        (*(*(*h)
            .mb
            .pic
            .p_fref
            .as_mut_ptr()
            .offset(1 as ::core::ffi::c_int as isize))
        .as_mut_ptr()
        .offset((*a).l1.me16x16.i_ref as isize))
        .as_mut_ptr(),
    ];
    let mut pix: [[pixel; 64]; 2] = [[0; 64]; 2];
    (*h).mb.i_partition = D_8x8 as ::core::ffi::c_int;
    (*a).i_cost8x8bi = 0 as ::core::ffi::c_int;
    let mut i: ::core::ffi::c_int = 0 as ::core::ffi::c_int;
    while i < 4 as ::core::ffi::c_int {
        let mut x8: ::core::ffi::c_int = i & 1 as ::core::ffi::c_int;
        let mut y8: ::core::ffi::c_int = i >> 1 as ::core::ffi::c_int;
        let mut i_part_cost: ::core::ffi::c_int = 0;
        let mut i_part_cost_bi: ::core::ffi::c_int = 0 as ::core::ffi::c_int;
        let mut stride: [intptr_t; 2] = [
            8 as ::core::ffi::c_int as intptr_t,
            8 as ::core::ffi::c_int as intptr_t,
        ];
        let mut src: [*mut pixel; 2] = [0 as *mut pixel; 2];
        let mut l: ::core::ffi::c_int = 0 as ::core::ffi::c_int;
        while l < 2 as ::core::ffi::c_int {
            let mut lX: *mut x264_mb_analysis_list_t =
                if l != 0 { &mut (*a).l1 } else { &mut (*a).l0 };
            let mut m: *mut x264_me_t =
                &mut *(*lX).me8x8.as_mut_ptr().offset(i as isize) as *mut x264_me_t;
            (*m).i_pixel = PIXEL_8x8 as ::core::ffi::c_int;
            (*m).p_cost_mv = (*a).p_cost_mv;
            (*m).i_stride[0 as ::core::ffi::c_int as usize] =
                (*h).mb.pic.i_stride[0 as ::core::ffi::c_int as usize];
            (*m).i_stride[1 as ::core::ffi::c_int as usize] =
                (*h).mb.pic.i_stride[1 as ::core::ffi::c_int as usize];
            (*m).i_stride[2 as ::core::ffi::c_int as usize] =
                (*h).mb.pic.i_stride[2 as ::core::ffi::c_int as usize];
            (*m).p_fenc[0 as ::core::ffi::c_int as usize] = &mut *(*(*h)
                .mb
                .pic
                .p_fenc
                .as_mut_ptr()
                .offset(0 as ::core::ffi::c_int as isize))
            .offset(
                (8 as ::core::ffi::c_int * x8 + 8 as ::core::ffi::c_int * y8 * FENC_STRIDE)
                    as isize,
            ) as *mut pixel;
            if (*(*h).sps.as_mut_ptr()).i_chroma_format_idc != 0 {
                (*m).p_fenc[1 as ::core::ffi::c_int as usize] = &mut *(*(*h)
                    .mb
                    .pic
                    .p_fenc
                    .as_mut_ptr()
                    .offset(1 as ::core::ffi::c_int as isize))
                .offset(
                    ((8 as ::core::ffi::c_int * x8 >> (*h).mb.chroma_h_shift)
                        + (8 as ::core::ffi::c_int * y8 >> (*h).mb.chroma_v_shift) * FENC_STRIDE)
                        as isize,
                ) as *mut pixel;
                (*m).p_fenc[2 as ::core::ffi::c_int as usize] = &mut *(*(*h)
                    .mb
                    .pic
                    .p_fenc
                    .as_mut_ptr()
                    .offset(2 as ::core::ffi::c_int as isize))
                .offset(
                    ((8 as ::core::ffi::c_int * x8 >> (*h).mb.chroma_h_shift)
                        + (8 as ::core::ffi::c_int * y8 >> (*h).mb.chroma_v_shift) * FENC_STRIDE)
                        as isize,
                ) as *mut pixel;
            }
            (*m).i_ref_cost = *(*a).p_cost_ref[l as usize].offset((*lX).me16x16.i_ref as isize)
                as ::core::ffi::c_int;
            (*m).i_ref = (*lX).me16x16.i_ref;
            (*m).p_fref[0 as ::core::ffi::c_int as usize] = &mut *(*(*p_fref
                .as_mut_ptr()
                .offset(l as isize))
            .offset(0 as ::core::ffi::c_int as isize))
            .offset(
                (8 as ::core::ffi::c_int * x8
                    + 8 as ::core::ffi::c_int
                        * y8
                        * *(*m)
                            .i_stride
                            .as_mut_ptr()
                            .offset(0 as ::core::ffi::c_int as isize)) as isize,
            ) as *mut pixel;
            (*m).p_fref_w = (*m).p_fref[0 as ::core::ffi::c_int as usize];
            if (*h).param.analyse.i_subpel_refine != 0 {
                (*m).p_fref[1 as ::core::ffi::c_int as usize] =
                    &mut *(*(*p_fref.as_mut_ptr().offset(l as isize))
                        .offset(1 as ::core::ffi::c_int as isize))
                    .offset(
                        (8 as ::core::ffi::c_int * x8
                            + 8 as ::core::ffi::c_int
                                * y8
                                * *(*m)
                                    .i_stride
                                    .as_mut_ptr()
                                    .offset(0 as ::core::ffi::c_int as isize))
                            as isize,
                    ) as *mut pixel;
                (*m).p_fref[2 as ::core::ffi::c_int as usize] =
                    &mut *(*(*p_fref.as_mut_ptr().offset(l as isize))
                        .offset(2 as ::core::ffi::c_int as isize))
                    .offset(
                        (8 as ::core::ffi::c_int * x8
                            + 8 as ::core::ffi::c_int
                                * y8
                                * *(*m)
                                    .i_stride
                                    .as_mut_ptr()
                                    .offset(0 as ::core::ffi::c_int as isize))
                            as isize,
                    ) as *mut pixel;
                (*m).p_fref[3 as ::core::ffi::c_int as usize] =
                    &mut *(*(*p_fref.as_mut_ptr().offset(l as isize))
                        .offset(3 as ::core::ffi::c_int as isize))
                    .offset(
                        (8 as ::core::ffi::c_int * x8
                            + 8 as ::core::ffi::c_int
                                * y8
                                * *(*m)
                                    .i_stride
                                    .as_mut_ptr()
                                    .offset(0 as ::core::ffi::c_int as isize))
                            as isize,
                    ) as *mut pixel;
            }
            if (*(*h).sps.as_mut_ptr()).i_chroma_format_idc == CHROMA_444 as ::core::ffi::c_int {
                (*m).p_fref[4 as ::core::ffi::c_int as usize] =
                    &mut *(*(*p_fref.as_mut_ptr().offset(l as isize))
                        .offset(4 as ::core::ffi::c_int as isize))
                    .offset(
                        (8 as ::core::ffi::c_int * x8
                            + 8 as ::core::ffi::c_int
                                * y8
                                * *(*m)
                                    .i_stride
                                    .as_mut_ptr()
                                    .offset(1 as ::core::ffi::c_int as isize))
                            as isize,
                    ) as *mut pixel;
                (*m).p_fref[8 as ::core::ffi::c_int as usize] =
                    &mut *(*(*p_fref.as_mut_ptr().offset(l as isize))
                        .offset(8 as ::core::ffi::c_int as isize))
                    .offset(
                        (8 as ::core::ffi::c_int * x8
                            + 8 as ::core::ffi::c_int
                                * y8
                                * *(*m)
                                    .i_stride
                                    .as_mut_ptr()
                                    .offset(2 as ::core::ffi::c_int as isize))
                            as isize,
                    ) as *mut pixel;
                if (*h).param.analyse.i_subpel_refine != 0 {
                    (*m).p_fref[5 as ::core::ffi::c_int as usize] =
                        &mut *(*(*p_fref.as_mut_ptr().offset(l as isize))
                            .offset(5 as ::core::ffi::c_int as isize))
                        .offset(
                            (8 as ::core::ffi::c_int * x8
                                + 8 as ::core::ffi::c_int
                                    * y8
                                    * *(*m)
                                        .i_stride
                                        .as_mut_ptr()
                                        .offset(1 as ::core::ffi::c_int as isize))
                                as isize,
                        ) as *mut pixel;
                    (*m).p_fref[6 as ::core::ffi::c_int as usize] =
                        &mut *(*(*p_fref.as_mut_ptr().offset(l as isize))
                            .offset(6 as ::core::ffi::c_int as isize))
                        .offset(
                            (8 as ::core::ffi::c_int * x8
                                + 8 as ::core::ffi::c_int
                                    * y8
                                    * *(*m)
                                        .i_stride
                                        .as_mut_ptr()
                                        .offset(1 as ::core::ffi::c_int as isize))
                                as isize,
                        ) as *mut pixel;
                    (*m).p_fref[7 as ::core::ffi::c_int as usize] =
                        &mut *(*(*p_fref.as_mut_ptr().offset(l as isize))
                            .offset(7 as ::core::ffi::c_int as isize))
                        .offset(
                            (8 as ::core::ffi::c_int * x8
                                + 8 as ::core::ffi::c_int
                                    * y8
                                    * *(*m)
                                        .i_stride
                                        .as_mut_ptr()
                                        .offset(1 as ::core::ffi::c_int as isize))
                                as isize,
                        ) as *mut pixel;
                    (*m).p_fref[9 as ::core::ffi::c_int as usize] =
                        &mut *(*(*p_fref.as_mut_ptr().offset(l as isize))
                            .offset(9 as ::core::ffi::c_int as isize))
                        .offset(
                            (8 as ::core::ffi::c_int * x8
                                + 8 as ::core::ffi::c_int
                                    * y8
                                    * *(*m)
                                        .i_stride
                                        .as_mut_ptr()
                                        .offset(2 as ::core::ffi::c_int as isize))
                                as isize,
                        ) as *mut pixel;
                    (*m).p_fref[10 as ::core::ffi::c_int as usize] =
                        &mut *(*(*p_fref.as_mut_ptr().offset(l as isize))
                            .offset(10 as ::core::ffi::c_int as isize))
                        .offset(
                            (8 as ::core::ffi::c_int * x8
                                + 8 as ::core::ffi::c_int
                                    * y8
                                    * *(*m)
                                        .i_stride
                                        .as_mut_ptr()
                                        .offset(2 as ::core::ffi::c_int as isize))
                                as isize,
                        ) as *mut pixel;
                    (*m).p_fref[11 as ::core::ffi::c_int as usize] =
                        &mut *(*(*p_fref.as_mut_ptr().offset(l as isize))
                            .offset(11 as ::core::ffi::c_int as isize))
                        .offset(
                            (8 as ::core::ffi::c_int * x8
                                + 8 as ::core::ffi::c_int
                                    * y8
                                    * *(*m)
                                        .i_stride
                                        .as_mut_ptr()
                                        .offset(2 as ::core::ffi::c_int as isize))
                                as isize,
                        ) as *mut pixel;
                }
            } else if (*(*h).sps.as_mut_ptr()).i_chroma_format_idc != 0 {
                (*m).p_fref[4 as ::core::ffi::c_int as usize] =
                    &mut *(*(*p_fref.as_mut_ptr().offset(l as isize))
                        .offset(4 as ::core::ffi::c_int as isize))
                    .offset(
                        (8 as ::core::ffi::c_int * x8
                            + (8 as ::core::ffi::c_int * y8 >> (*h).mb.chroma_v_shift)
                                * *(*m)
                                    .i_stride
                                    .as_mut_ptr()
                                    .offset(1 as ::core::ffi::c_int as isize))
                            as isize,
                    ) as *mut pixel;
            }
            if (*h).param.analyse.i_me_method >= X264_ME_ESA {
                (*m).integral = &mut *(*(*(*h).mb.pic.p_integral.as_mut_ptr().offset(l as isize))
                    .as_mut_ptr()
                    .offset((*lX).me16x16.i_ref as isize))
                .offset(
                    (8 as ::core::ffi::c_int * x8
                        + 8 as ::core::ffi::c_int
                            * y8
                            * *(*m)
                                .i_stride
                                .as_mut_ptr()
                                .offset(0 as ::core::ffi::c_int as isize))
                        as isize,
                ) as *mut uint16_t;
            }
            (*m).weight = x264_zero.as_mut_ptr() as *const x264_weight_t;
            (*m).i_ref = (*lX).me16x16.i_ref;
            x264_macroblock_cache_ref(
                h,
                x8 * 2 as ::core::ffi::c_int,
                y8 * 2 as ::core::ffi::c_int,
                2 as ::core::ffi::c_int,
                2 as ::core::ffi::c_int,
                l,
                (*lX).me16x16.i_ref as int8_t,
            );
            x264_10_mb_predict_mv(
                h,
                l,
                4 as ::core::ffi::c_int * i,
                2 as ::core::ffi::c_int,
                (*m).mvp.as_mut_ptr(),
            );
            x264_10_me_search_ref(
                h,
                m,
                &mut (*lX).me16x16.mv,
                1 as ::core::ffi::c_int,
                0 as *mut ::core::ffi::c_int,
            );
            (*a).i_satd8x8[l as usize][i as usize] = (*m).cost - (*m).cost_mv;
            (*m).cost += (*m).i_ref_cost;
            x264_macroblock_cache_mv(
                h,
                2 as ::core::ffi::c_int * x8,
                2 as ::core::ffi::c_int * y8,
                2 as ::core::ffi::c_int,
                2 as ::core::ffi::c_int,
                l,
                (*((*m).mv.as_mut_ptr() as *mut x264_union32_t)).i,
            );
            (*((*(*(*lX).mvc.as_mut_ptr().offset((*lX).me16x16.i_ref as isize))
                .as_mut_ptr()
                .offset((i + 1 as ::core::ffi::c_int) as isize))
            .as_mut_ptr() as *mut x264_union32_t))
                .i = (*((*m).mv.as_mut_ptr() as *mut x264_union32_t)).i;
            src[l as usize] = (*h).mc.get_ref.expect("non-null function pointer")(
                (*pix.as_mut_ptr().offset(l as isize)).as_mut_ptr(),
                &mut *stride.as_mut_ptr().offset(l as isize),
                (*m).p_fref.as_mut_ptr(),
                (*m).i_stride[0 as ::core::ffi::c_int as usize] as intptr_t,
                (*m).mv[0 as ::core::ffi::c_int as usize] as ::core::ffi::c_int,
                (*m).mv[1 as ::core::ffi::c_int as usize] as ::core::ffi::c_int,
                8 as ::core::ffi::c_int,
                8 as ::core::ffi::c_int,
                x264_zero.as_mut_ptr() as *const x264_weight_t,
            );
            i_part_cost_bi += (*m).cost_mv + (*m).i_ref_cost;
            l += 1;
        }
        (*h).mc.avg[PIXEL_8x8 as ::core::ffi::c_int as usize].expect("non-null function pointer")(
            (*pix.as_mut_ptr().offset(0 as ::core::ffi::c_int as isize)).as_mut_ptr(),
            8 as intptr_t,
            src[0 as ::core::ffi::c_int as usize],
            stride[0 as ::core::ffi::c_int as usize],
            src[1 as ::core::ffi::c_int as usize],
            stride[1 as ::core::ffi::c_int as usize],
            (*(*h).mb.bipred_weight.offset((*a).l0.me16x16.i_ref as isize))
                [(*a).l1.me16x16.i_ref as usize] as ::core::ffi::c_int,
        );
        (*a).i_satd8x8[2 as ::core::ffi::c_int as usize][i as usize] = (*h).pixf.mbcmp
            [PIXEL_8x8 as ::core::ffi::c_int as usize]
            .expect("non-null function pointer")(
            (*a).l0.me8x8[i as usize].p_fenc[0 as ::core::ffi::c_int as usize],
            FENC_STRIDE as intptr_t,
            (*pix.as_mut_ptr().offset(0 as ::core::ffi::c_int as isize)).as_mut_ptr(),
            8 as intptr_t,
        );
        i_part_cost_bi += (*a).i_satd8x8[2 as ::core::ffi::c_int as usize][i as usize]
            + (*a).i_lambda
                * i_sub_mb_b_cost_table[D_BI_8x8 as ::core::ffi::c_int as usize]
                    as ::core::ffi::c_int;
        (*a).l0.me8x8[i as usize].cost += (*a).i_lambda
            * i_sub_mb_b_cost_table[D_L0_8x8 as ::core::ffi::c_int as usize] as ::core::ffi::c_int;
        (*a).l1.me8x8[i as usize].cost += (*a).i_lambda
            * i_sub_mb_b_cost_table[D_L1_8x8 as ::core::ffi::c_int as usize] as ::core::ffi::c_int;
        if (*h).mb.b_chroma_me != 0 {
            let mut i_chroma_cost: ::core::ffi::c_int =
                analyse_bi_chroma(h, a, i, PIXEL_8x8 as ::core::ffi::c_int);
            i_part_cost_bi += i_chroma_cost;
            (*a).i_satd8x8[2 as ::core::ffi::c_int as usize][i as usize] += i_chroma_cost;
        }
        i_part_cost = (*a).l0.me8x8[i as usize].cost;
        (*h).mb.i_sub_partition[i as usize] = D_L0_8x8 as ::core::ffi::c_int as uint8_t;
        if (*a).l1.me8x8[i as usize].cost < i_part_cost {
            i_part_cost = (*a).l1.me8x8[i as usize].cost;
            (*h).mb.i_sub_partition[i as usize] = D_L1_8x8 as ::core::ffi::c_int as uint8_t;
        }
        if i_part_cost_bi < i_part_cost {
            i_part_cost = i_part_cost_bi;
            (*h).mb.i_sub_partition[i as usize] = D_BI_8x8 as ::core::ffi::c_int as uint8_t;
        }
        if (*a).i_cost8x8direct[i as usize] < i_part_cost {
            i_part_cost = (*a).i_cost8x8direct[i as usize];
            (*h).mb.i_sub_partition[i as usize] = D_DIRECT_8x8 as ::core::ffi::c_int as uint8_t;
        }
        (*a).i_cost8x8bi += i_part_cost;
        mb_cache_mv_b8x8(h, a, i, 0 as ::core::ffi::c_int);
        i += 1;
    }
    (*a).i_cost8x8bi += (*a).i_lambda
        * i_mb_b_cost_table[B_8x8 as ::core::ffi::c_int as usize] as ::core::ffi::c_int;
}
#[c2rust::src_loc = "2360:1"]
unsafe extern "C" fn mb_analyse_inter_b16x8(
    mut h: *mut x264_t,
    mut a: *mut x264_mb_analysis_t,
    mut i_best_satd: ::core::ffi::c_int,
) {
    let mut pix: [[pixel; 128]; 2] = [[0; 128]; 2];
    let mut mvc: [[int16_t; 2]; 3] = [[0; 2]; 3];
    (*h).mb.i_partition = D_16x8 as ::core::ffi::c_int;
    (*a).i_cost16x8bi = 0 as ::core::ffi::c_int;
    let mut i: ::core::ffi::c_int = 0 as ::core::ffi::c_int;
    while i < 2 as ::core::ffi::c_int {
        let mut i_part_cost: ::core::ffi::c_int = 0;
        let mut i_part_cost_bi: ::core::ffi::c_int = 0 as ::core::ffi::c_int;
        let mut stride: [intptr_t; 2] = [
            16 as ::core::ffi::c_int as intptr_t,
            16 as ::core::ffi::c_int as intptr_t,
        ];
        let mut src: [*mut pixel; 2] = [0 as *mut pixel; 2];
        let mut m: x264_me_t = x264_me_t {
            i_pixel: 0,
            p_cost_mv: 0 as *mut uint16_t,
            i_ref_cost: 0,
            i_ref: 0,
            weight: 0 as *const x264_weight_t,
            p_fref: [0 as *mut pixel; 12],
            p_fref_w: 0 as *mut pixel,
            p_fenc: [0 as *mut pixel; 3],
            integral: 0 as *mut uint16_t,
            i_stride: [0; 3],
            mvp: [0; 2],
            cost_mv: 0,
            cost: 0,
            mv: [0; 2],
        };
        m.i_pixel = PIXEL_16x8 as ::core::ffi::c_int;
        m.p_cost_mv = (*a).p_cost_mv;
        m.i_stride[0 as ::core::ffi::c_int as usize] =
            (*h).mb.pic.i_stride[0 as ::core::ffi::c_int as usize];
        m.i_stride[1 as ::core::ffi::c_int as usize] =
            (*h).mb.pic.i_stride[1 as ::core::ffi::c_int as usize];
        m.i_stride[2 as ::core::ffi::c_int as usize] =
            (*h).mb.pic.i_stride[2 as ::core::ffi::c_int as usize];
        m.p_fenc[0 as ::core::ffi::c_int as usize] = &mut *(*(*h)
            .mb
            .pic
            .p_fenc
            .as_mut_ptr()
            .offset(0 as ::core::ffi::c_int as isize))
        .offset((0 as ::core::ffi::c_int + 8 as ::core::ffi::c_int * i * FENC_STRIDE) as isize)
            as *mut pixel;
        if (*(*h).sps.as_mut_ptr()).i_chroma_format_idc != 0 {
            m.p_fenc[1 as ::core::ffi::c_int as usize] = &mut *(*(*h)
                .mb
                .pic
                .p_fenc
                .as_mut_ptr()
                .offset(1 as ::core::ffi::c_int as isize))
            .offset(
                ((0 as ::core::ffi::c_int >> (*h).mb.chroma_h_shift)
                    + (8 as ::core::ffi::c_int * i >> (*h).mb.chroma_v_shift) * FENC_STRIDE)
                    as isize,
            ) as *mut pixel;
            m.p_fenc[2 as ::core::ffi::c_int as usize] = &mut *(*(*h)
                .mb
                .pic
                .p_fenc
                .as_mut_ptr()
                .offset(2 as ::core::ffi::c_int as isize))
            .offset(
                ((0 as ::core::ffi::c_int >> (*h).mb.chroma_h_shift)
                    + (8 as ::core::ffi::c_int * i >> (*h).mb.chroma_v_shift) * FENC_STRIDE)
                    as isize,
            ) as *mut pixel;
        }
        let mut l: ::core::ffi::c_int = 0 as ::core::ffi::c_int;
        while l < 2 as ::core::ffi::c_int {
            let mut lX: *mut x264_mb_analysis_list_t =
                if l != 0 { &mut (*a).l1 } else { &mut (*a).l0 };
            let mut ref8: [::core::ffi::c_int; 2] = [
                (*lX).me8x8[(2 as ::core::ffi::c_int * i) as usize].i_ref,
                (*lX).me8x8[(2 as ::core::ffi::c_int * i + 1 as ::core::ffi::c_int) as usize].i_ref,
            ];
            let mut i_ref8s: ::core::ffi::c_int = if ref8[0 as ::core::ffi::c_int as usize]
                == ref8[1 as ::core::ffi::c_int as usize]
            {
                1 as ::core::ffi::c_int
            } else {
                2 as ::core::ffi::c_int
            };
            (*lX).me16x8[i as usize].cost = INT_MAX;
            let mut j: ::core::ffi::c_int = 0 as ::core::ffi::c_int;
            while j < i_ref8s {
                let mut i_ref: ::core::ffi::c_int = ref8[j as usize];
                m.i_ref_cost =
                    *(*a).p_cost_ref[l as usize].offset(i_ref as isize) as ::core::ffi::c_int;
                m.p_fref[0 as ::core::ffi::c_int as usize] =
                    &mut *(*(*(*(*h).mb.pic.p_fref.as_mut_ptr().offset(l as isize))
                        .as_mut_ptr()
                        .offset(i_ref as isize))
                    .as_mut_ptr()
                    .offset(0 as ::core::ffi::c_int as isize))
                    .offset(
                        (0 as ::core::ffi::c_int
                            + 8 as ::core::ffi::c_int
                                * i
                                * *m.i_stride
                                    .as_mut_ptr()
                                    .offset(0 as ::core::ffi::c_int as isize))
                            as isize,
                    ) as *mut pixel;
                m.p_fref_w = m.p_fref[0 as ::core::ffi::c_int as usize];
                if (*h).param.analyse.i_subpel_refine != 0 {
                    m.p_fref[1 as ::core::ffi::c_int as usize] =
                        &mut *(*(*(*(*h).mb.pic.p_fref.as_mut_ptr().offset(l as isize))
                            .as_mut_ptr()
                            .offset(i_ref as isize))
                        .as_mut_ptr()
                        .offset(1 as ::core::ffi::c_int as isize))
                        .offset(
                            (0 as ::core::ffi::c_int
                                + 8 as ::core::ffi::c_int
                                    * i
                                    * *m.i_stride
                                        .as_mut_ptr()
                                        .offset(0 as ::core::ffi::c_int as isize))
                                as isize,
                        ) as *mut pixel;
                    m.p_fref[2 as ::core::ffi::c_int as usize] =
                        &mut *(*(*(*(*h).mb.pic.p_fref.as_mut_ptr().offset(l as isize))
                            .as_mut_ptr()
                            .offset(i_ref as isize))
                        .as_mut_ptr()
                        .offset(2 as ::core::ffi::c_int as isize))
                        .offset(
                            (0 as ::core::ffi::c_int
                                + 8 as ::core::ffi::c_int
                                    * i
                                    * *m.i_stride
                                        .as_mut_ptr()
                                        .offset(0 as ::core::ffi::c_int as isize))
                                as isize,
                        ) as *mut pixel;
                    m.p_fref[3 as ::core::ffi::c_int as usize] =
                        &mut *(*(*(*(*h).mb.pic.p_fref.as_mut_ptr().offset(l as isize))
                            .as_mut_ptr()
                            .offset(i_ref as isize))
                        .as_mut_ptr()
                        .offset(3 as ::core::ffi::c_int as isize))
                        .offset(
                            (0 as ::core::ffi::c_int
                                + 8 as ::core::ffi::c_int
                                    * i
                                    * *m.i_stride
                                        .as_mut_ptr()
                                        .offset(0 as ::core::ffi::c_int as isize))
                                as isize,
                        ) as *mut pixel;
                }
                if (*(*h).sps.as_mut_ptr()).i_chroma_format_idc == CHROMA_444 as ::core::ffi::c_int
                {
                    m.p_fref[4 as ::core::ffi::c_int as usize] =
                        &mut *(*(*(*(*h).mb.pic.p_fref.as_mut_ptr().offset(l as isize))
                            .as_mut_ptr()
                            .offset(i_ref as isize))
                        .as_mut_ptr()
                        .offset(4 as ::core::ffi::c_int as isize))
                        .offset(
                            (0 as ::core::ffi::c_int
                                + 8 as ::core::ffi::c_int
                                    * i
                                    * *m.i_stride
                                        .as_mut_ptr()
                                        .offset(1 as ::core::ffi::c_int as isize))
                                as isize,
                        ) as *mut pixel;
                    m.p_fref[8 as ::core::ffi::c_int as usize] =
                        &mut *(*(*(*(*h).mb.pic.p_fref.as_mut_ptr().offset(l as isize))
                            .as_mut_ptr()
                            .offset(i_ref as isize))
                        .as_mut_ptr()
                        .offset(8 as ::core::ffi::c_int as isize))
                        .offset(
                            (0 as ::core::ffi::c_int
                                + 8 as ::core::ffi::c_int
                                    * i
                                    * *m.i_stride
                                        .as_mut_ptr()
                                        .offset(2 as ::core::ffi::c_int as isize))
                                as isize,
                        ) as *mut pixel;
                    if (*h).param.analyse.i_subpel_refine != 0 {
                        m.p_fref[5 as ::core::ffi::c_int as usize] =
                            &mut *(*(*(*(*h).mb.pic.p_fref.as_mut_ptr().offset(l as isize))
                                .as_mut_ptr()
                                .offset(i_ref as isize))
                            .as_mut_ptr()
                            .offset(5 as ::core::ffi::c_int as isize))
                            .offset(
                                (0 as ::core::ffi::c_int
                                    + 8 as ::core::ffi::c_int
                                        * i
                                        * *m.i_stride
                                            .as_mut_ptr()
                                            .offset(1 as ::core::ffi::c_int as isize))
                                    as isize,
                            ) as *mut pixel;
                        m.p_fref[6 as ::core::ffi::c_int as usize] =
                            &mut *(*(*(*(*h).mb.pic.p_fref.as_mut_ptr().offset(l as isize))
                                .as_mut_ptr()
                                .offset(i_ref as isize))
                            .as_mut_ptr()
                            .offset(6 as ::core::ffi::c_int as isize))
                            .offset(
                                (0 as ::core::ffi::c_int
                                    + 8 as ::core::ffi::c_int
                                        * i
                                        * *m.i_stride
                                            .as_mut_ptr()
                                            .offset(1 as ::core::ffi::c_int as isize))
                                    as isize,
                            ) as *mut pixel;
                        m.p_fref[7 as ::core::ffi::c_int as usize] =
                            &mut *(*(*(*(*h).mb.pic.p_fref.as_mut_ptr().offset(l as isize))
                                .as_mut_ptr()
                                .offset(i_ref as isize))
                            .as_mut_ptr()
                            .offset(7 as ::core::ffi::c_int as isize))
                            .offset(
                                (0 as ::core::ffi::c_int
                                    + 8 as ::core::ffi::c_int
                                        * i
                                        * *m.i_stride
                                            .as_mut_ptr()
                                            .offset(1 as ::core::ffi::c_int as isize))
                                    as isize,
                            ) as *mut pixel;
                        m.p_fref[9 as ::core::ffi::c_int as usize] =
                            &mut *(*(*(*(*h).mb.pic.p_fref.as_mut_ptr().offset(l as isize))
                                .as_mut_ptr()
                                .offset(i_ref as isize))
                            .as_mut_ptr()
                            .offset(9 as ::core::ffi::c_int as isize))
                            .offset(
                                (0 as ::core::ffi::c_int
                                    + 8 as ::core::ffi::c_int
                                        * i
                                        * *m.i_stride
                                            .as_mut_ptr()
                                            .offset(2 as ::core::ffi::c_int as isize))
                                    as isize,
                            ) as *mut pixel;
                        m.p_fref[10 as ::core::ffi::c_int as usize] =
                            &mut *(*(*(*(*h).mb.pic.p_fref.as_mut_ptr().offset(l as isize))
                                .as_mut_ptr()
                                .offset(i_ref as isize))
                            .as_mut_ptr()
                            .offset(10 as ::core::ffi::c_int as isize))
                            .offset(
                                (0 as ::core::ffi::c_int
                                    + 8 as ::core::ffi::c_int
                                        * i
                                        * *m.i_stride
                                            .as_mut_ptr()
                                            .offset(2 as ::core::ffi::c_int as isize))
                                    as isize,
                            ) as *mut pixel;
                        m.p_fref[11 as ::core::ffi::c_int as usize] =
                            &mut *(*(*(*(*h).mb.pic.p_fref.as_mut_ptr().offset(l as isize))
                                .as_mut_ptr()
                                .offset(i_ref as isize))
                            .as_mut_ptr()
                            .offset(11 as ::core::ffi::c_int as isize))
                            .offset(
                                (0 as ::core::ffi::c_int
                                    + 8 as ::core::ffi::c_int
                                        * i
                                        * *m.i_stride
                                            .as_mut_ptr()
                                            .offset(2 as ::core::ffi::c_int as isize))
                                    as isize,
                            ) as *mut pixel;
                    }
                } else if (*(*h).sps.as_mut_ptr()).i_chroma_format_idc != 0 {
                    m.p_fref[4 as ::core::ffi::c_int as usize] =
                        &mut *(*(*(*(*h).mb.pic.p_fref.as_mut_ptr().offset(l as isize))
                            .as_mut_ptr()
                            .offset(i_ref as isize))
                        .as_mut_ptr()
                        .offset(4 as ::core::ffi::c_int as isize))
                        .offset(
                            (0 as ::core::ffi::c_int
                                + (8 as ::core::ffi::c_int * i >> (*h).mb.chroma_v_shift)
                                    * *m.i_stride
                                        .as_mut_ptr()
                                        .offset(1 as ::core::ffi::c_int as isize))
                                as isize,
                        ) as *mut pixel;
                }
                if (*h).param.analyse.i_me_method >= X264_ME_ESA {
                    m.integral = &mut *(*(*(*h).mb.pic.p_integral.as_mut_ptr().offset(l as isize))
                        .as_mut_ptr()
                        .offset(i_ref as isize))
                    .offset(
                        (0 as ::core::ffi::c_int
                            + 8 as ::core::ffi::c_int
                                * i
                                * *m.i_stride
                                    .as_mut_ptr()
                                    .offset(0 as ::core::ffi::c_int as isize))
                            as isize,
                    ) as *mut uint16_t;
                }
                m.weight = x264_zero.as_mut_ptr() as *const x264_weight_t;
                m.i_ref = i_ref;
                (*((*mvc.as_mut_ptr().offset(0 as ::core::ffi::c_int as isize)).as_mut_ptr()
                    as *mut x264_union32_t))
                    .i = (*((*(*(*lX).mvc.as_mut_ptr().offset(i_ref as isize))
                    .as_mut_ptr()
                    .offset(0 as ::core::ffi::c_int as isize))
                .as_mut_ptr() as *mut x264_union32_t))
                    .i;
                (*((*mvc.as_mut_ptr().offset(1 as ::core::ffi::c_int as isize)).as_mut_ptr()
                    as *mut x264_union32_t))
                    .i = (*((*(*(*lX).mvc.as_mut_ptr().offset(i_ref as isize))
                    .as_mut_ptr()
                    .offset((2 as ::core::ffi::c_int * i + 1 as ::core::ffi::c_int) as isize))
                .as_mut_ptr() as *mut x264_union32_t))
                    .i;
                (*((*mvc.as_mut_ptr().offset(2 as ::core::ffi::c_int as isize)).as_mut_ptr()
                    as *mut x264_union32_t))
                    .i = (*((*(*(*lX).mvc.as_mut_ptr().offset(i_ref as isize))
                    .as_mut_ptr()
                    .offset((2 as ::core::ffi::c_int * i + 2 as ::core::ffi::c_int) as isize))
                .as_mut_ptr() as *mut x264_union32_t))
                    .i;
                x264_macroblock_cache_ref(
                    h,
                    0 as ::core::ffi::c_int,
                    2 as ::core::ffi::c_int * i,
                    4 as ::core::ffi::c_int,
                    2 as ::core::ffi::c_int,
                    l,
                    i_ref as int8_t,
                );
                x264_10_mb_predict_mv(
                    h,
                    l,
                    8 as ::core::ffi::c_int * i,
                    4 as ::core::ffi::c_int,
                    m.mvp.as_mut_ptr(),
                );
                x264_10_me_search_ref(
                    h,
                    &mut m,
                    mvc.as_mut_ptr() as *mut [int16_t; 2],
                    3 as ::core::ffi::c_int,
                    0 as *mut ::core::ffi::c_int,
                );
                m.cost += m.i_ref_cost;
                if m.cost < (*lX).me16x8[i as usize].cost {
                    (*h).mc.memcpy_aligned.expect("non-null function pointer")(
                        &mut *(*lX).me16x8.as_mut_ptr().offset(i as isize) as *mut x264_me_t
                            as *mut ::core::ffi::c_void,
                        &mut m as *mut x264_me_t as *const ::core::ffi::c_void,
                        ::core::mem::size_of::<x264_me_t>() as size_t,
                    );
                }
                j += 1;
            }
            l += 1;
        }
        src[0 as ::core::ffi::c_int as usize] = (*h).mc.get_ref.expect("non-null function pointer")(
            (*pix.as_mut_ptr().offset(0 as ::core::ffi::c_int as isize)).as_mut_ptr(),
            &mut *stride.as_mut_ptr().offset(0 as ::core::ffi::c_int as isize),
            (*(*a).l0.me16x8.as_mut_ptr().offset(i as isize))
                .p_fref
                .as_mut_ptr(),
            (*a).l0.me16x8[i as usize].i_stride[0 as ::core::ffi::c_int as usize] as intptr_t,
            (*a).l0.me16x8[i as usize].mv[0 as ::core::ffi::c_int as usize] as ::core::ffi::c_int,
            (*a).l0.me16x8[i as usize].mv[1 as ::core::ffi::c_int as usize] as ::core::ffi::c_int,
            16 as ::core::ffi::c_int,
            8 as ::core::ffi::c_int,
            x264_zero.as_mut_ptr() as *const x264_weight_t,
        );
        src[1 as ::core::ffi::c_int as usize] = (*h).mc.get_ref.expect("non-null function pointer")(
            (*pix.as_mut_ptr().offset(1 as ::core::ffi::c_int as isize)).as_mut_ptr(),
            &mut *stride.as_mut_ptr().offset(1 as ::core::ffi::c_int as isize),
            (*(*a).l1.me16x8.as_mut_ptr().offset(i as isize))
                .p_fref
                .as_mut_ptr(),
            (*a).l1.me16x8[i as usize].i_stride[0 as ::core::ffi::c_int as usize] as intptr_t,
            (*a).l1.me16x8[i as usize].mv[0 as ::core::ffi::c_int as usize] as ::core::ffi::c_int,
            (*a).l1.me16x8[i as usize].mv[1 as ::core::ffi::c_int as usize] as ::core::ffi::c_int,
            16 as ::core::ffi::c_int,
            8 as ::core::ffi::c_int,
            x264_zero.as_mut_ptr() as *const x264_weight_t,
        );
        (*h).mc.avg[PIXEL_16x8 as ::core::ffi::c_int as usize].expect("non-null function pointer")(
            (*pix.as_mut_ptr().offset(0 as ::core::ffi::c_int as isize)).as_mut_ptr(),
            16 as intptr_t,
            src[0 as ::core::ffi::c_int as usize],
            stride[0 as ::core::ffi::c_int as usize],
            src[1 as ::core::ffi::c_int as usize],
            stride[1 as ::core::ffi::c_int as usize],
            (*(*h)
                .mb
                .bipred_weight
                .offset((*a).l0.me16x8[i as usize].i_ref as isize))
                [(*a).l1.me16x8[i as usize].i_ref as usize] as ::core::ffi::c_int,
        );
        i_part_cost_bi = (*h).pixf.mbcmp[PIXEL_16x8 as ::core::ffi::c_int as usize]
            .expect("non-null function pointer")(
            (*a).l0.me16x8[i as usize].p_fenc[0 as ::core::ffi::c_int as usize],
            FENC_STRIDE as intptr_t,
            (*pix.as_mut_ptr().offset(0 as ::core::ffi::c_int as isize)).as_mut_ptr(),
            16 as intptr_t,
        ) + (*a).l0.me16x8[i as usize].cost_mv
            + (*a).l1.me16x8[i as usize].cost_mv
            + (*a).l0.me16x8[i as usize].i_ref_cost
            + (*a).l1.me16x8[i as usize].i_ref_cost;
        if (*h).mb.b_chroma_me != 0 {
            i_part_cost_bi += analyse_bi_chroma(h, a, i, PIXEL_16x8 as ::core::ffi::c_int);
        }
        i_part_cost = (*a).l0.me16x8[i as usize].cost;
        (*a).i_mb_partition16x8[i as usize] = D_L0_8x8 as ::core::ffi::c_int;
        if (*a).l1.me16x8[i as usize].cost < i_part_cost {
            i_part_cost = (*a).l1.me16x8[i as usize].cost;
            (*a).i_mb_partition16x8[i as usize] = D_L1_8x8 as ::core::ffi::c_int;
        }
        if (i_part_cost_bi + (*a).i_lambda * 1 as ::core::ffi::c_int) < i_part_cost {
            i_part_cost = i_part_cost_bi;
            (*a).i_mb_partition16x8[i as usize] = D_BI_8x8 as ::core::ffi::c_int;
        }
        (*a).i_cost16x8bi += i_part_cost;
        if (*a).b_early_terminate != 0
            && (i == 0
                && i_part_cost + (*a).i_cost_est16x8[1 as ::core::ffi::c_int as usize]
                    > i_best_satd
                        * (16 as ::core::ffi::c_int
                            + (((*a).i_mbrd != 0) as ::core::ffi::c_int
                                + ((*h).mb.i_psy_rd != 0) as ::core::ffi::c_int))
                        / 16 as ::core::ffi::c_int)
        {
            (*a).i_cost16x8bi = COST_MAX;
            return;
        }
        mb_cache_mv_b16x8(h, a, i, 0 as ::core::ffi::c_int);
        i += 1;
    }
    (*a).i_mb_type16x8 = B_L0_L0 as ::core::ffi::c_int
        + ((*a).i_mb_partition16x8[0 as ::core::ffi::c_int as usize] >> 2 as ::core::ffi::c_int)
            * 3 as ::core::ffi::c_int
        + ((*a).i_mb_partition16x8[1 as ::core::ffi::c_int as usize] >> 2 as ::core::ffi::c_int);
    (*a).i_cost16x8bi +=
        (*a).i_lambda * i_mb_b16x8_cost_table[(*a).i_mb_type16x8 as usize] as ::core::ffi::c_int;
}
#[c2rust::src_loc = "2454:1"]
unsafe extern "C" fn mb_analyse_inter_b8x16(
    mut h: *mut x264_t,
    mut a: *mut x264_mb_analysis_t,
    mut i_best_satd: ::core::ffi::c_int,
) {
    let mut pix: [[pixel; 128]; 2] = [[0; 128]; 2];
    let mut mvc: [[int16_t; 2]; 3] = [[0; 2]; 3];
    (*h).mb.i_partition = D_8x16 as ::core::ffi::c_int;
    (*a).i_cost8x16bi = 0 as ::core::ffi::c_int;
    let mut i: ::core::ffi::c_int = 0 as ::core::ffi::c_int;
    while i < 2 as ::core::ffi::c_int {
        let mut i_part_cost: ::core::ffi::c_int = 0;
        let mut i_part_cost_bi: ::core::ffi::c_int = 0 as ::core::ffi::c_int;
        let mut stride: [intptr_t; 2] = [
            8 as ::core::ffi::c_int as intptr_t,
            8 as ::core::ffi::c_int as intptr_t,
        ];
        let mut src: [*mut pixel; 2] = [0 as *mut pixel; 2];
        let mut m: x264_me_t = x264_me_t {
            i_pixel: 0,
            p_cost_mv: 0 as *mut uint16_t,
            i_ref_cost: 0,
            i_ref: 0,
            weight: 0 as *const x264_weight_t,
            p_fref: [0 as *mut pixel; 12],
            p_fref_w: 0 as *mut pixel,
            p_fenc: [0 as *mut pixel; 3],
            integral: 0 as *mut uint16_t,
            i_stride: [0; 3],
            mvp: [0; 2],
            cost_mv: 0,
            cost: 0,
            mv: [0; 2],
        };
        m.i_pixel = PIXEL_8x16 as ::core::ffi::c_int;
        m.p_cost_mv = (*a).p_cost_mv;
        m.i_stride[0 as ::core::ffi::c_int as usize] =
            (*h).mb.pic.i_stride[0 as ::core::ffi::c_int as usize];
        m.i_stride[1 as ::core::ffi::c_int as usize] =
            (*h).mb.pic.i_stride[1 as ::core::ffi::c_int as usize];
        m.i_stride[2 as ::core::ffi::c_int as usize] =
            (*h).mb.pic.i_stride[2 as ::core::ffi::c_int as usize];
        m.p_fenc[0 as ::core::ffi::c_int as usize] = &mut *(*(*h)
            .mb
            .pic
            .p_fenc
            .as_mut_ptr()
            .offset(0 as ::core::ffi::c_int as isize))
        .offset((8 as ::core::ffi::c_int * i + 0 as ::core::ffi::c_int * FENC_STRIDE) as isize)
            as *mut pixel;
        if (*(*h).sps.as_mut_ptr()).i_chroma_format_idc != 0 {
            m.p_fenc[1 as ::core::ffi::c_int as usize] = &mut *(*(*h)
                .mb
                .pic
                .p_fenc
                .as_mut_ptr()
                .offset(1 as ::core::ffi::c_int as isize))
            .offset(
                ((8 as ::core::ffi::c_int * i >> (*h).mb.chroma_h_shift)
                    + (0 as ::core::ffi::c_int >> (*h).mb.chroma_v_shift) * FENC_STRIDE)
                    as isize,
            ) as *mut pixel;
            m.p_fenc[2 as ::core::ffi::c_int as usize] = &mut *(*(*h)
                .mb
                .pic
                .p_fenc
                .as_mut_ptr()
                .offset(2 as ::core::ffi::c_int as isize))
            .offset(
                ((8 as ::core::ffi::c_int * i >> (*h).mb.chroma_h_shift)
                    + (0 as ::core::ffi::c_int >> (*h).mb.chroma_v_shift) * FENC_STRIDE)
                    as isize,
            ) as *mut pixel;
        }
        let mut l: ::core::ffi::c_int = 0 as ::core::ffi::c_int;
        while l < 2 as ::core::ffi::c_int {
            let mut lX: *mut x264_mb_analysis_list_t =
                if l != 0 { &mut (*a).l1 } else { &mut (*a).l0 };
            let mut ref8: [::core::ffi::c_int; 2] = [
                (*lX).me8x8[i as usize].i_ref,
                (*lX).me8x8[(i + 2 as ::core::ffi::c_int) as usize].i_ref,
            ];
            let mut i_ref8s: ::core::ffi::c_int = if ref8[0 as ::core::ffi::c_int as usize]
                == ref8[1 as ::core::ffi::c_int as usize]
            {
                1 as ::core::ffi::c_int
            } else {
                2 as ::core::ffi::c_int
            };
            (*lX).me8x16[i as usize].cost = INT_MAX;
            let mut j: ::core::ffi::c_int = 0 as ::core::ffi::c_int;
            while j < i_ref8s {
                let mut i_ref: ::core::ffi::c_int = ref8[j as usize];
                m.i_ref_cost =
                    *(*a).p_cost_ref[l as usize].offset(i_ref as isize) as ::core::ffi::c_int;
                m.p_fref[0 as ::core::ffi::c_int as usize] =
                    &mut *(*(*(*(*h).mb.pic.p_fref.as_mut_ptr().offset(l as isize))
                        .as_mut_ptr()
                        .offset(i_ref as isize))
                    .as_mut_ptr()
                    .offset(0 as ::core::ffi::c_int as isize))
                    .offset(
                        (8 as ::core::ffi::c_int * i
                            + 0 as ::core::ffi::c_int
                                * *m.i_stride
                                    .as_mut_ptr()
                                    .offset(0 as ::core::ffi::c_int as isize))
                            as isize,
                    ) as *mut pixel;
                m.p_fref_w = m.p_fref[0 as ::core::ffi::c_int as usize];
                if (*h).param.analyse.i_subpel_refine != 0 {
                    m.p_fref[1 as ::core::ffi::c_int as usize] =
                        &mut *(*(*(*(*h).mb.pic.p_fref.as_mut_ptr().offset(l as isize))
                            .as_mut_ptr()
                            .offset(i_ref as isize))
                        .as_mut_ptr()
                        .offset(1 as ::core::ffi::c_int as isize))
                        .offset(
                            (8 as ::core::ffi::c_int * i
                                + 0 as ::core::ffi::c_int
                                    * *m.i_stride
                                        .as_mut_ptr()
                                        .offset(0 as ::core::ffi::c_int as isize))
                                as isize,
                        ) as *mut pixel;
                    m.p_fref[2 as ::core::ffi::c_int as usize] =
                        &mut *(*(*(*(*h).mb.pic.p_fref.as_mut_ptr().offset(l as isize))
                            .as_mut_ptr()
                            .offset(i_ref as isize))
                        .as_mut_ptr()
                        .offset(2 as ::core::ffi::c_int as isize))
                        .offset(
                            (8 as ::core::ffi::c_int * i
                                + 0 as ::core::ffi::c_int
                                    * *m.i_stride
                                        .as_mut_ptr()
                                        .offset(0 as ::core::ffi::c_int as isize))
                                as isize,
                        ) as *mut pixel;
                    m.p_fref[3 as ::core::ffi::c_int as usize] =
                        &mut *(*(*(*(*h).mb.pic.p_fref.as_mut_ptr().offset(l as isize))
                            .as_mut_ptr()
                            .offset(i_ref as isize))
                        .as_mut_ptr()
                        .offset(3 as ::core::ffi::c_int as isize))
                        .offset(
                            (8 as ::core::ffi::c_int * i
                                + 0 as ::core::ffi::c_int
                                    * *m.i_stride
                                        .as_mut_ptr()
                                        .offset(0 as ::core::ffi::c_int as isize))
                                as isize,
                        ) as *mut pixel;
                }
                if (*(*h).sps.as_mut_ptr()).i_chroma_format_idc == CHROMA_444 as ::core::ffi::c_int
                {
                    m.p_fref[4 as ::core::ffi::c_int as usize] =
                        &mut *(*(*(*(*h).mb.pic.p_fref.as_mut_ptr().offset(l as isize))
                            .as_mut_ptr()
                            .offset(i_ref as isize))
                        .as_mut_ptr()
                        .offset(4 as ::core::ffi::c_int as isize))
                        .offset(
                            (8 as ::core::ffi::c_int * i
                                + 0 as ::core::ffi::c_int
                                    * *m.i_stride
                                        .as_mut_ptr()
                                        .offset(1 as ::core::ffi::c_int as isize))
                                as isize,
                        ) as *mut pixel;
                    m.p_fref[8 as ::core::ffi::c_int as usize] =
                        &mut *(*(*(*(*h).mb.pic.p_fref.as_mut_ptr().offset(l as isize))
                            .as_mut_ptr()
                            .offset(i_ref as isize))
                        .as_mut_ptr()
                        .offset(8 as ::core::ffi::c_int as isize))
                        .offset(
                            (8 as ::core::ffi::c_int * i
                                + 0 as ::core::ffi::c_int
                                    * *m.i_stride
                                        .as_mut_ptr()
                                        .offset(2 as ::core::ffi::c_int as isize))
                                as isize,
                        ) as *mut pixel;
                    if (*h).param.analyse.i_subpel_refine != 0 {
                        m.p_fref[5 as ::core::ffi::c_int as usize] =
                            &mut *(*(*(*(*h).mb.pic.p_fref.as_mut_ptr().offset(l as isize))
                                .as_mut_ptr()
                                .offset(i_ref as isize))
                            .as_mut_ptr()
                            .offset(5 as ::core::ffi::c_int as isize))
                            .offset(
                                (8 as ::core::ffi::c_int * i
                                    + 0 as ::core::ffi::c_int
                                        * *m.i_stride
                                            .as_mut_ptr()
                                            .offset(1 as ::core::ffi::c_int as isize))
                                    as isize,
                            ) as *mut pixel;
                        m.p_fref[6 as ::core::ffi::c_int as usize] =
                            &mut *(*(*(*(*h).mb.pic.p_fref.as_mut_ptr().offset(l as isize))
                                .as_mut_ptr()
                                .offset(i_ref as isize))
                            .as_mut_ptr()
                            .offset(6 as ::core::ffi::c_int as isize))
                            .offset(
                                (8 as ::core::ffi::c_int * i
                                    + 0 as ::core::ffi::c_int
                                        * *m.i_stride
                                            .as_mut_ptr()
                                            .offset(1 as ::core::ffi::c_int as isize))
                                    as isize,
                            ) as *mut pixel;
                        m.p_fref[7 as ::core::ffi::c_int as usize] =
                            &mut *(*(*(*(*h).mb.pic.p_fref.as_mut_ptr().offset(l as isize))
                                .as_mut_ptr()
                                .offset(i_ref as isize))
                            .as_mut_ptr()
                            .offset(7 as ::core::ffi::c_int as isize))
                            .offset(
                                (8 as ::core::ffi::c_int * i
                                    + 0 as ::core::ffi::c_int
                                        * *m.i_stride
                                            .as_mut_ptr()
                                            .offset(1 as ::core::ffi::c_int as isize))
                                    as isize,
                            ) as *mut pixel;
                        m.p_fref[9 as ::core::ffi::c_int as usize] =
                            &mut *(*(*(*(*h).mb.pic.p_fref.as_mut_ptr().offset(l as isize))
                                .as_mut_ptr()
                                .offset(i_ref as isize))
                            .as_mut_ptr()
                            .offset(9 as ::core::ffi::c_int as isize))
                            .offset(
                                (8 as ::core::ffi::c_int * i
                                    + 0 as ::core::ffi::c_int
                                        * *m.i_stride
                                            .as_mut_ptr()
                                            .offset(2 as ::core::ffi::c_int as isize))
                                    as isize,
                            ) as *mut pixel;
                        m.p_fref[10 as ::core::ffi::c_int as usize] =
                            &mut *(*(*(*(*h).mb.pic.p_fref.as_mut_ptr().offset(l as isize))
                                .as_mut_ptr()
                                .offset(i_ref as isize))
                            .as_mut_ptr()
                            .offset(10 as ::core::ffi::c_int as isize))
                            .offset(
                                (8 as ::core::ffi::c_int * i
                                    + 0 as ::core::ffi::c_int
                                        * *m.i_stride
                                            .as_mut_ptr()
                                            .offset(2 as ::core::ffi::c_int as isize))
                                    as isize,
                            ) as *mut pixel;
                        m.p_fref[11 as ::core::ffi::c_int as usize] =
                            &mut *(*(*(*(*h).mb.pic.p_fref.as_mut_ptr().offset(l as isize))
                                .as_mut_ptr()
                                .offset(i_ref as isize))
                            .as_mut_ptr()
                            .offset(11 as ::core::ffi::c_int as isize))
                            .offset(
                                (8 as ::core::ffi::c_int * i
                                    + 0 as ::core::ffi::c_int
                                        * *m.i_stride
                                            .as_mut_ptr()
                                            .offset(2 as ::core::ffi::c_int as isize))
                                    as isize,
                            ) as *mut pixel;
                    }
                } else if (*(*h).sps.as_mut_ptr()).i_chroma_format_idc != 0 {
                    m.p_fref[4 as ::core::ffi::c_int as usize] =
                        &mut *(*(*(*(*h).mb.pic.p_fref.as_mut_ptr().offset(l as isize))
                            .as_mut_ptr()
                            .offset(i_ref as isize))
                        .as_mut_ptr()
                        .offset(4 as ::core::ffi::c_int as isize))
                        .offset(
                            (8 as ::core::ffi::c_int * i
                                + (0 as ::core::ffi::c_int >> (*h).mb.chroma_v_shift)
                                    * *m.i_stride
                                        .as_mut_ptr()
                                        .offset(1 as ::core::ffi::c_int as isize))
                                as isize,
                        ) as *mut pixel;
                }
                if (*h).param.analyse.i_me_method >= X264_ME_ESA {
                    m.integral = &mut *(*(*(*h).mb.pic.p_integral.as_mut_ptr().offset(l as isize))
                        .as_mut_ptr()
                        .offset(i_ref as isize))
                    .offset(
                        (8 as ::core::ffi::c_int * i
                            + 0 as ::core::ffi::c_int
                                * *m.i_stride
                                    .as_mut_ptr()
                                    .offset(0 as ::core::ffi::c_int as isize))
                            as isize,
                    ) as *mut uint16_t;
                }
                m.weight = x264_zero.as_mut_ptr() as *const x264_weight_t;
                m.i_ref = i_ref;
                (*((*mvc.as_mut_ptr().offset(0 as ::core::ffi::c_int as isize)).as_mut_ptr()
                    as *mut x264_union32_t))
                    .i = (*((*(*(*lX).mvc.as_mut_ptr().offset(i_ref as isize))
                    .as_mut_ptr()
                    .offset(0 as ::core::ffi::c_int as isize))
                .as_mut_ptr() as *mut x264_union32_t))
                    .i;
                (*((*mvc.as_mut_ptr().offset(1 as ::core::ffi::c_int as isize)).as_mut_ptr()
                    as *mut x264_union32_t))
                    .i = (*((*(*(*lX).mvc.as_mut_ptr().offset(i_ref as isize))
                    .as_mut_ptr()
                    .offset((i + 1 as ::core::ffi::c_int) as isize))
                .as_mut_ptr() as *mut x264_union32_t))
                    .i;
                (*((*mvc.as_mut_ptr().offset(2 as ::core::ffi::c_int as isize)).as_mut_ptr()
                    as *mut x264_union32_t))
                    .i = (*((*(*(*lX).mvc.as_mut_ptr().offset(i_ref as isize))
                    .as_mut_ptr()
                    .offset((i + 3 as ::core::ffi::c_int) as isize))
                .as_mut_ptr() as *mut x264_union32_t))
                    .i;
                x264_macroblock_cache_ref(
                    h,
                    2 as ::core::ffi::c_int * i,
                    0 as ::core::ffi::c_int,
                    2 as ::core::ffi::c_int,
                    4 as ::core::ffi::c_int,
                    l,
                    i_ref as int8_t,
                );
                x264_10_mb_predict_mv(
                    h,
                    l,
                    4 as ::core::ffi::c_int * i,
                    2 as ::core::ffi::c_int,
                    m.mvp.as_mut_ptr(),
                );
                x264_10_me_search_ref(
                    h,
                    &mut m,
                    mvc.as_mut_ptr() as *mut [int16_t; 2],
                    3 as ::core::ffi::c_int,
                    0 as *mut ::core::ffi::c_int,
                );
                m.cost += m.i_ref_cost;
                if m.cost < (*lX).me8x16[i as usize].cost {
                    (*h).mc.memcpy_aligned.expect("non-null function pointer")(
                        &mut *(*lX).me8x16.as_mut_ptr().offset(i as isize) as *mut x264_me_t
                            as *mut ::core::ffi::c_void,
                        &mut m as *mut x264_me_t as *const ::core::ffi::c_void,
                        ::core::mem::size_of::<x264_me_t>() as size_t,
                    );
                }
                j += 1;
            }
            l += 1;
        }
        src[0 as ::core::ffi::c_int as usize] = (*h).mc.get_ref.expect("non-null function pointer")(
            (*pix.as_mut_ptr().offset(0 as ::core::ffi::c_int as isize)).as_mut_ptr(),
            &mut *stride.as_mut_ptr().offset(0 as ::core::ffi::c_int as isize),
            (*(*a).l0.me8x16.as_mut_ptr().offset(i as isize))
                .p_fref
                .as_mut_ptr(),
            (*a).l0.me8x16[i as usize].i_stride[0 as ::core::ffi::c_int as usize] as intptr_t,
            (*a).l0.me8x16[i as usize].mv[0 as ::core::ffi::c_int as usize] as ::core::ffi::c_int,
            (*a).l0.me8x16[i as usize].mv[1 as ::core::ffi::c_int as usize] as ::core::ffi::c_int,
            8 as ::core::ffi::c_int,
            16 as ::core::ffi::c_int,
            x264_zero.as_mut_ptr() as *const x264_weight_t,
        );
        src[1 as ::core::ffi::c_int as usize] = (*h).mc.get_ref.expect("non-null function pointer")(
            (*pix.as_mut_ptr().offset(1 as ::core::ffi::c_int as isize)).as_mut_ptr(),
            &mut *stride.as_mut_ptr().offset(1 as ::core::ffi::c_int as isize),
            (*(*a).l1.me8x16.as_mut_ptr().offset(i as isize))
                .p_fref
                .as_mut_ptr(),
            (*a).l1.me8x16[i as usize].i_stride[0 as ::core::ffi::c_int as usize] as intptr_t,
            (*a).l1.me8x16[i as usize].mv[0 as ::core::ffi::c_int as usize] as ::core::ffi::c_int,
            (*a).l1.me8x16[i as usize].mv[1 as ::core::ffi::c_int as usize] as ::core::ffi::c_int,
            8 as ::core::ffi::c_int,
            16 as ::core::ffi::c_int,
            x264_zero.as_mut_ptr() as *const x264_weight_t,
        );
        (*h).mc.avg[PIXEL_8x16 as ::core::ffi::c_int as usize].expect("non-null function pointer")(
            (*pix.as_mut_ptr().offset(0 as ::core::ffi::c_int as isize)).as_mut_ptr(),
            8 as intptr_t,
            src[0 as ::core::ffi::c_int as usize],
            stride[0 as ::core::ffi::c_int as usize],
            src[1 as ::core::ffi::c_int as usize],
            stride[1 as ::core::ffi::c_int as usize],
            (*(*h)
                .mb
                .bipred_weight
                .offset((*a).l0.me8x16[i as usize].i_ref as isize))
                [(*a).l1.me8x16[i as usize].i_ref as usize] as ::core::ffi::c_int,
        );
        i_part_cost_bi = (*h).pixf.mbcmp[PIXEL_8x16 as ::core::ffi::c_int as usize]
            .expect("non-null function pointer")(
            (*a).l0.me8x16[i as usize].p_fenc[0 as ::core::ffi::c_int as usize],
            FENC_STRIDE as intptr_t,
            (*pix.as_mut_ptr().offset(0 as ::core::ffi::c_int as isize)).as_mut_ptr(),
            8 as intptr_t,
        ) + (*a).l0.me8x16[i as usize].cost_mv
            + (*a).l1.me8x16[i as usize].cost_mv
            + (*a).l0.me8x16[i as usize].i_ref_cost
            + (*a).l1.me8x16[i as usize].i_ref_cost;
        if (*h).mb.b_chroma_me != 0 {
            i_part_cost_bi += analyse_bi_chroma(h, a, i, PIXEL_8x16 as ::core::ffi::c_int);
        }
        i_part_cost = (*a).l0.me8x16[i as usize].cost;
        (*a).i_mb_partition8x16[i as usize] = D_L0_8x8 as ::core::ffi::c_int;
        if (*a).l1.me8x16[i as usize].cost < i_part_cost {
            i_part_cost = (*a).l1.me8x16[i as usize].cost;
            (*a).i_mb_partition8x16[i as usize] = D_L1_8x8 as ::core::ffi::c_int;
        }
        if (i_part_cost_bi + (*a).i_lambda * 1 as ::core::ffi::c_int) < i_part_cost {
            i_part_cost = i_part_cost_bi;
            (*a).i_mb_partition8x16[i as usize] = D_BI_8x8 as ::core::ffi::c_int;
        }
        (*a).i_cost8x16bi += i_part_cost;
        if (*a).b_early_terminate != 0
            && (i == 0
                && i_part_cost + (*a).i_cost_est8x16[1 as ::core::ffi::c_int as usize]
                    > i_best_satd
                        * (16 as ::core::ffi::c_int
                            + (((*a).i_mbrd != 0) as ::core::ffi::c_int
                                + ((*h).mb.i_psy_rd != 0) as ::core::ffi::c_int))
                        / 16 as ::core::ffi::c_int)
        {
            (*a).i_cost8x16bi = COST_MAX;
            return;
        }
        mb_cache_mv_b8x16(h, a, i, 0 as ::core::ffi::c_int);
        i += 1;
    }
    (*a).i_mb_type8x16 = B_L0_L0 as ::core::ffi::c_int
        + ((*a).i_mb_partition8x16[0 as ::core::ffi::c_int as usize] >> 2 as ::core::ffi::c_int)
            * 3 as ::core::ffi::c_int
        + ((*a).i_mb_partition8x16[1 as ::core::ffi::c_int as usize] >> 2 as ::core::ffi::c_int);
    (*a).i_cost8x16bi +=
        (*a).i_lambda * i_mb_b16x8_cost_table[(*a).i_mb_type8x16 as usize] as ::core::ffi::c_int;
}
#[c2rust::src_loc = "2547:1"]
unsafe extern "C" fn mb_analyse_p_rd(
    mut h: *mut x264_t,
    mut a: *mut x264_mb_analysis_t,
    mut i_satd: ::core::ffi::c_int,
) {
    let mut thresh: ::core::ffi::c_int = if (*a).b_early_terminate != 0 {
        i_satd * 5 as ::core::ffi::c_int / 4 as ::core::ffi::c_int + 1 as ::core::ffi::c_int
    } else {
        COST_MAX
    };
    (*h).mb.i_type = P_L0 as ::core::ffi::c_int;
    if (*a).l0.i_rd16x16 == COST_MAX
        && ((*a).b_early_terminate == 0
            || (*a).l0.me16x16.cost <= i_satd * 3 as ::core::ffi::c_int / 2 as ::core::ffi::c_int)
    {
        (*h).mb.i_partition = D_16x16 as ::core::ffi::c_int;
        analyse_update_cache(h, a);
        (*a).l0.i_rd16x16 = rd_cost_mb(h, (*a).i_lambda2);
    }
    if (*a).l0.i_cost16x8 < thresh {
        (*h).mb.i_partition = D_16x8 as ::core::ffi::c_int;
        analyse_update_cache(h, a);
        (*a).l0.i_cost16x8 = rd_cost_mb(h, (*a).i_lambda2);
    } else {
        (*a).l0.i_cost16x8 = COST_MAX;
    }
    if (*a).l0.i_cost8x16 < thresh {
        (*h).mb.i_partition = D_8x16 as ::core::ffi::c_int;
        analyse_update_cache(h, a);
        (*a).l0.i_cost8x16 = rd_cost_mb(h, (*a).i_lambda2);
    } else {
        (*a).l0.i_cost8x16 = COST_MAX;
    }
    if (*a).l0.i_cost8x8 < thresh {
        (*h).mb.i_type = P_8x8 as ::core::ffi::c_int;
        (*h).mb.i_partition = D_8x8 as ::core::ffi::c_int;
        if (*h).param.analyse.inter & X264_ANALYSE_PSUB8x8 != 0 {
            x264_macroblock_cache_ref(
                h,
                0 as ::core::ffi::c_int,
                0 as ::core::ffi::c_int,
                2 as ::core::ffi::c_int,
                2 as ::core::ffi::c_int,
                0 as ::core::ffi::c_int,
                (*a).l0.me8x8[0 as ::core::ffi::c_int as usize].i_ref as int8_t,
            );
            x264_macroblock_cache_ref(
                h,
                2 as ::core::ffi::c_int,
                0 as ::core::ffi::c_int,
                2 as ::core::ffi::c_int,
                2 as ::core::ffi::c_int,
                0 as ::core::ffi::c_int,
                (*a).l0.me8x8[1 as ::core::ffi::c_int as usize].i_ref as int8_t,
            );
            x264_macroblock_cache_ref(
                h,
                0 as ::core::ffi::c_int,
                2 as ::core::ffi::c_int,
                2 as ::core::ffi::c_int,
                2 as ::core::ffi::c_int,
                0 as ::core::ffi::c_int,
                (*a).l0.me8x8[2 as ::core::ffi::c_int as usize].i_ref as int8_t,
            );
            x264_macroblock_cache_ref(
                h,
                2 as ::core::ffi::c_int,
                2 as ::core::ffi::c_int,
                2 as ::core::ffi::c_int,
                2 as ::core::ffi::c_int,
                0 as ::core::ffi::c_int,
                (*a).l0.me8x8[3 as ::core::ffi::c_int as usize].i_ref as int8_t,
            );
            let mut i: ::core::ffi::c_int = 0 as ::core::ffi::c_int;
            while i < 4 as ::core::ffi::c_int {
                let mut costs: [::core::ffi::c_int; 4] = [
                    (*a).l0.i_cost4x4[i as usize],
                    (*a).l0.i_cost8x4[i as usize],
                    (*a).l0.i_cost4x8[i as usize],
                    (*a).l0.me8x8[i as usize].cost,
                ];
                let mut sub8x8_thresh: ::core::ffi::c_int = if (*a).b_early_terminate != 0 {
                    (if costs[0 as ::core::ffi::c_int as usize]
                        < (if costs[1 as ::core::ffi::c_int as usize]
                            < (if costs[2 as ::core::ffi::c_int as usize]
                                < costs[3 as ::core::ffi::c_int as usize]
                            {
                                costs[2 as ::core::ffi::c_int as usize]
                            } else {
                                costs[3 as ::core::ffi::c_int as usize]
                            })
                        {
                            costs[1 as ::core::ffi::c_int as usize]
                        } else {
                            (if costs[2 as ::core::ffi::c_int as usize]
                                < costs[3 as ::core::ffi::c_int as usize]
                            {
                                costs[2 as ::core::ffi::c_int as usize]
                            } else {
                                costs[3 as ::core::ffi::c_int as usize]
                            })
                        })
                    {
                        costs[0 as ::core::ffi::c_int as usize]
                    } else {
                        (if costs[1 as ::core::ffi::c_int as usize]
                            < (if costs[2 as ::core::ffi::c_int as usize]
                                < costs[3 as ::core::ffi::c_int as usize]
                            {
                                costs[2 as ::core::ffi::c_int as usize]
                            } else {
                                costs[3 as ::core::ffi::c_int as usize]
                            })
                        {
                            costs[1 as ::core::ffi::c_int as usize]
                        } else {
                            (if costs[2 as ::core::ffi::c_int as usize]
                                < costs[3 as ::core::ffi::c_int as usize]
                            {
                                costs[2 as ::core::ffi::c_int as usize]
                            } else {
                                costs[3 as ::core::ffi::c_int as usize]
                            })
                        })
                    }) * 5 as ::core::ffi::c_int
                        / 4 as ::core::ffi::c_int
                } else {
                    COST_MAX
                };
                let mut subtype: ::core::ffi::c_int = 0;
                let mut btype: ::core::ffi::c_int = D_L0_8x8 as ::core::ffi::c_int;
                let mut bcost: uint64_t = COST_MAX64 as uint64_t;
                subtype = D_L0_4x4 as ::core::ffi::c_int;
                while subtype <= D_L0_8x8 as ::core::ffi::c_int {
                    let mut cost: uint64_t = 0;
                    if !(costs[subtype as usize] > sub8x8_thresh) {
                        (*h).mb.i_sub_partition[i as usize] = subtype as uint8_t;
                        mb_cache_mv_p8x8(h, a, i);
                        if !(subtype == btype) {
                            cost = x264_10_rd_cost_part(
                                h,
                                (*a).i_lambda2,
                                i << 2 as ::core::ffi::c_int,
                                PIXEL_8x8 as ::core::ffi::c_int,
                            );
                            if cost < bcost {
                                bcost = cost;
                                btype = subtype;
                            }
                        }
                    }
                    subtype += 1;
                }
                if (*h).mb.i_sub_partition[i as usize] as ::core::ffi::c_int != btype {
                    (*h).mb.i_sub_partition[i as usize] = btype as uint8_t;
                    mb_cache_mv_p8x8(h, a, i);
                }
                i += 1;
            }
        } else {
            analyse_update_cache(h, a);
        }
        (*a).l0.i_cost8x8 = rd_cost_mb(h, (*a).i_lambda2);
    } else {
        (*a).l0.i_cost8x8 = COST_MAX;
    };
}
#[c2rust::src_loc = "2622:1"]
unsafe extern "C" fn mb_analyse_b_rd(
    mut h: *mut x264_t,
    mut a: *mut x264_mb_analysis_t,
    mut i_satd_inter: ::core::ffi::c_int,
) {
    let mut thresh: ::core::ffi::c_int = if (*a).b_early_terminate != 0 {
        i_satd_inter * (17 as ::core::ffi::c_int + ((*h).mb.i_psy_rd != 0) as ::core::ffi::c_int)
            / 16 as ::core::ffi::c_int
            + 1 as ::core::ffi::c_int
    } else {
        COST_MAX
    };
    if (*a).b_direct_available != 0 && (*a).i_rd16x16direct == COST_MAX {
        (*h).mb.i_type = B_DIRECT as ::core::ffi::c_int;
        (*h).mb.b_skip_mc = 1 as ::core::ffi::c_int;
        analyse_update_cache(h, a);
        (*a).i_rd16x16direct = rd_cost_mb(h, (*a).i_lambda2);
        (*h).mb.b_skip_mc = 0 as ::core::ffi::c_int;
    }
    (*h).mb.i_partition = D_16x16 as ::core::ffi::c_int;
    if (*a).l0.me16x16.cost < thresh && (*a).l0.i_rd16x16 == COST_MAX {
        (*h).mb.i_type = B_L0_L0 as ::core::ffi::c_int;
        analyse_update_cache(h, a);
        (*a).l0.i_rd16x16 = rd_cost_mb(h, (*a).i_lambda2);
    }
    if (*a).l1.me16x16.cost < thresh && (*a).l1.i_rd16x16 == COST_MAX {
        (*h).mb.i_type = B_L1_L1 as ::core::ffi::c_int;
        analyse_update_cache(h, a);
        (*a).l1.i_rd16x16 = rd_cost_mb(h, (*a).i_lambda2);
    }
    if (*a).i_cost16x16bi < thresh && (*a).i_rd16x16bi == COST_MAX {
        (*h).mb.i_type = B_BI_BI as ::core::ffi::c_int;
        analyse_update_cache(h, a);
        (*a).i_rd16x16bi = rd_cost_mb(h, (*a).i_lambda2);
    }
    if (*a).i_cost8x8bi < thresh && (*a).i_rd8x8bi == COST_MAX {
        (*h).mb.i_type = B_8x8 as ::core::ffi::c_int;
        (*h).mb.i_partition = D_8x8 as ::core::ffi::c_int;
        analyse_update_cache(h, a);
        (*a).i_rd8x8bi = rd_cost_mb(h, (*a).i_lambda2);
        x264_macroblock_cache_skip(
            h,
            0 as ::core::ffi::c_int,
            0 as ::core::ffi::c_int,
            4 as ::core::ffi::c_int,
            4 as ::core::ffi::c_int,
            0 as ::core::ffi::c_int,
        );
    }
    if (*a).i_cost16x8bi < thresh && (*a).i_rd16x8bi == COST_MAX {
        (*h).mb.i_type = (*a).i_mb_type16x8;
        (*h).mb.i_partition = D_16x8 as ::core::ffi::c_int;
        analyse_update_cache(h, a);
        (*a).i_rd16x8bi = rd_cost_mb(h, (*a).i_lambda2);
    }
    if (*a).i_cost8x16bi < thresh && (*a).i_rd8x16bi == COST_MAX {
        (*h).mb.i_type = (*a).i_mb_type8x16;
        (*h).mb.i_partition = D_8x16 as ::core::ffi::c_int;
        analyse_update_cache(h, a);
        (*a).i_rd8x16bi = rd_cost_mb(h, (*a).i_lambda2);
    }
}
#[c2rust::src_loc = "2692:1"]
unsafe extern "C" fn refine_bidir(mut h: *mut x264_t, mut a: *mut x264_mb_analysis_t) {
    let mut i_biweight: ::core::ffi::c_int = 0;
    if (*h).mb.i_type == I_4x4 as ::core::ffi::c_int
        || (*h).mb.i_type == I_8x8 as ::core::ffi::c_int
        || (*h).mb.i_type == I_16x16 as ::core::ffi::c_int
        || (*h).mb.i_type == I_PCM as ::core::ffi::c_int
    {
        return;
    }
    match (*h).mb.i_partition {
        16 => {
            if (*h).mb.i_type == B_BI_BI as ::core::ffi::c_int {
                i_biweight = (*(*h).mb.bipred_weight.offset((*a).l0.bi16x16.i_ref as isize))
                    [(*a).l1.bi16x16.i_ref as usize]
                    as ::core::ffi::c_int;
                x264_10_me_refine_bidir_satd(
                    h,
                    &mut (*a).l0.bi16x16,
                    &mut (*a).l1.bi16x16,
                    i_biweight,
                );
            }
        }
        14 => {
            let mut i: ::core::ffi::c_int = 0 as ::core::ffi::c_int;
            while i < 2 as ::core::ffi::c_int {
                if (*a).i_mb_partition16x8[i as usize] == D_BI_8x8 as ::core::ffi::c_int {
                    i_biweight = (*(*h)
                        .mb
                        .bipred_weight
                        .offset((*a).l0.me16x8[i as usize].i_ref as isize))
                        [(*a).l1.me16x8[i as usize].i_ref as usize]
                        as ::core::ffi::c_int;
                    x264_10_me_refine_bidir_satd(
                        h,
                        &mut *(*a).l0.me16x8.as_mut_ptr().offset(i as isize),
                        &mut *(*a).l1.me16x8.as_mut_ptr().offset(i as isize),
                        i_biweight,
                    );
                }
                i += 1;
            }
        }
        15 => {
            let mut i_0: ::core::ffi::c_int = 0 as ::core::ffi::c_int;
            while i_0 < 2 as ::core::ffi::c_int {
                if (*a).i_mb_partition8x16[i_0 as usize] == D_BI_8x8 as ::core::ffi::c_int {
                    i_biweight = (*(*h)
                        .mb
                        .bipred_weight
                        .offset((*a).l0.me8x16[i_0 as usize].i_ref as isize))
                        [(*a).l1.me8x16[i_0 as usize].i_ref as usize]
                        as ::core::ffi::c_int;
                    x264_10_me_refine_bidir_satd(
                        h,
                        &mut *(*a).l0.me8x16.as_mut_ptr().offset(i_0 as isize),
                        &mut *(*a).l1.me8x16.as_mut_ptr().offset(i_0 as isize),
                        i_biweight,
                    );
                }
                i_0 += 1;
            }
        }
        13 => {
            let mut i_1: ::core::ffi::c_int = 0 as ::core::ffi::c_int;
            while i_1 < 4 as ::core::ffi::c_int {
                if (*h).mb.i_sub_partition[i_1 as usize] as ::core::ffi::c_int
                    == D_BI_8x8 as ::core::ffi::c_int
                {
                    i_biweight = (*(*h)
                        .mb
                        .bipred_weight
                        .offset((*a).l0.me8x8[i_1 as usize].i_ref as isize))
                        [(*a).l1.me8x8[i_1 as usize].i_ref as usize]
                        as ::core::ffi::c_int;
                    x264_10_me_refine_bidir_satd(
                        h,
                        &mut *(*a).l0.me8x8.as_mut_ptr().offset(i_1 as isize),
                        &mut *(*a).l1.me8x8.as_mut_ptr().offset(i_1 as isize),
                        i_biweight,
                    );
                }
                i_1 += 1;
            }
        }
        _ => {}
    };
}
#[inline]
#[c2rust::src_loc = "2735:1"]
unsafe extern "C" fn mb_analyse_transform(mut h: *mut x264_t) {
    if x264_mb_transform_8x8_allowed(h) != 0
        && (*h).param.analyse.b_transform_8x8 != 0
        && (*h).mb.b_lossless == 0
    {
        x264_10_mb_mc(h);
        let mut plane_count: ::core::ffi::c_int = if (*(*h).sps.as_mut_ptr()).i_chroma_format_idc
            == CHROMA_444 as ::core::ffi::c_int
            && (*h).mb.b_chroma_me != 0
        {
            3 as ::core::ffi::c_int
        } else {
            1 as ::core::ffi::c_int
        };
        let mut i_cost8: ::core::ffi::c_int = 0 as ::core::ffi::c_int;
        let mut i_cost4: ::core::ffi::c_int = 0 as ::core::ffi::c_int;
        if (*h).pixf.sa8d_satd[PIXEL_16x16 as ::core::ffi::c_int as usize].is_some() {
            let mut cost: uint64_t = 0 as uint64_t;
            let mut p: ::core::ffi::c_int = 0 as ::core::ffi::c_int;
            while p < plane_count {
                cost = cost.wrapping_add((*h).pixf.sa8d_satd
                    [PIXEL_16x16 as ::core::ffi::c_int as usize]
                    .expect("non-null function pointer")(
                    (*h).mb.pic.p_fenc[p as usize],
                    FENC_STRIDE as intptr_t,
                    (*h).mb.pic.p_fdec[p as usize],
                    FDEC_STRIDE as intptr_t,
                ));
                p += 1;
            }
            i_cost8 = cost as uint32_t as ::core::ffi::c_int;
            i_cost4 = (cost >> 32 as ::core::ffi::c_int) as uint32_t as ::core::ffi::c_int;
        } else {
            let mut p_0: ::core::ffi::c_int = 0 as ::core::ffi::c_int;
            while p_0 < plane_count {
                i_cost8 += (*h).pixf.sa8d[PIXEL_16x16 as ::core::ffi::c_int as usize]
                    .expect("non-null function pointer")(
                    (*h).mb.pic.p_fenc[p_0 as usize],
                    FENC_STRIDE as intptr_t,
                    (*h).mb.pic.p_fdec[p_0 as usize],
                    FDEC_STRIDE as intptr_t,
                );
                i_cost4 += (*h).pixf.satd[PIXEL_16x16 as ::core::ffi::c_int as usize]
                    .expect("non-null function pointer")(
                    (*h).mb.pic.p_fenc[p_0 as usize],
                    FENC_STRIDE as intptr_t,
                    (*h).mb.pic.p_fdec[p_0 as usize],
                    FDEC_STRIDE as intptr_t,
                );
                p_0 += 1;
            }
        }
        (*h).mb.b_transform_8x8 = (i_cost8 < i_cost4) as ::core::ffi::c_int;
        (*h).mb.b_skip_mc = 1 as ::core::ffi::c_int;
    }
}
#[inline]
#[c2rust::src_loc = "2773:1"]
unsafe extern "C" fn mb_analyse_transform_rd(
    mut h: *mut x264_t,
    mut a: *mut x264_mb_analysis_t,
    mut i_satd: *mut ::core::ffi::c_int,
    mut i_rd: *mut ::core::ffi::c_int,
) {
    if (*h).param.analyse.b_transform_8x8 != 0 && (*(*h).pps.as_mut_ptr()).b_transform_8x8_mode != 0
    {
        let mut subpart_bak: uint32_t =
            (*((*h).mb.i_sub_partition.as_mut_ptr() as *mut x264_union32_t)).i;
        if (*h).mb.i_type == P_8x8 as ::core::ffi::c_int {
            (*((*h).mb.i_sub_partition.as_mut_ptr() as *mut x264_union32_t)).i =
                (D_L0_8x8 as ::core::ffi::c_int * 0x1010101 as ::core::ffi::c_int) as uint32_t;
        } else if x264_transform_allowed[(*h).mb.i_type as usize] == 0 {
            return;
        }
        analyse_update_cache(h, a);
        (*h).mb.b_transform_8x8 ^= 1 as ::core::ffi::c_int;
        let mut i_rd8: ::core::ffi::c_int = rd_cost_mb(h, (*a).i_lambda2);
        if *i_rd >= i_rd8 {
            if *i_rd > 0 as ::core::ffi::c_int {
                *i_satd = (*i_satd as int64_t * i_rd8 as int64_t / *i_rd as int64_t)
                    as ::core::ffi::c_int;
            }
            *i_rd = i_rd8;
        } else {
            (*h).mb.b_transform_8x8 ^= 1 as ::core::ffi::c_int;
            (*((*h).mb.i_sub_partition.as_mut_ptr() as *mut x264_union32_t)).i = subpart_bak;
        }
    }
}
#[inline]
#[c2rust::src_loc = "2810:1"]
unsafe extern "C" fn mb_analyse_qp_rd(mut h: *mut x264_t, mut a: *mut x264_mb_analysis_t) {
    let mut bcost: ::core::ffi::c_int = 0;
    let mut cost: ::core::ffi::c_int = 0;
    let mut failures: ::core::ffi::c_int = 0;
    let mut prevcost: ::core::ffi::c_int = 0;
    let mut origcost: ::core::ffi::c_int = 0;
    let mut orig_qp: ::core::ffi::c_int = (*h).mb.i_qp;
    let mut bqp: ::core::ffi::c_int = (*h).mb.i_qp;
    let mut last_qp_tried: ::core::ffi::c_int = 0 as ::core::ffi::c_int;
    bcost = rd_cost_mb(h, (*a).i_lambda2);
    origcost = bcost;
    let mut origcbp: ::core::ffi::c_int =
        *(*h).mb.cbp.offset((*h).mb.i_mb_xy as isize) as ::core::ffi::c_int;
    let mut direction: ::core::ffi::c_int = if origcbp != 0 {
        1 as ::core::ffi::c_int
    } else {
        -(1 as ::core::ffi::c_int)
    };
    while direction >= -(1 as ::core::ffi::c_int) {
        let mut threshold: ::core::ffi::c_int = ((*h).mb.i_psy_rd != 0) as ::core::ffi::c_int;
        if (*h).mb.i_last_qp < orig_qp && direction == -(1 as ::core::ffi::c_int)
            || (*h).mb.i_last_qp > orig_qp && direction == 1 as ::core::ffi::c_int
        {
            threshold += 1;
        }
        (*h).mb.i_qp = orig_qp;
        failures = 0 as ::core::ffi::c_int;
        prevcost = origcost;
        let mut already_checked_qp: ::core::ffi::c_int = -(1 as ::core::ffi::c_int);
        let mut already_checked_cost: ::core::ffi::c_int = COST_MAX;
        if direction == -(1 as ::core::ffi::c_int) {
            if origcbp == 0 {
                (*h).mb.i_qp = if (*h).mb.i_qp - threshold - 1 as ::core::ffi::c_int
                    > (if (*h).param.rc.i_qp_min
                        < 51 as ::core::ffi::c_int
                            + 6 as ::core::ffi::c_int
                                * (10 as ::core::ffi::c_int - 8 as ::core::ffi::c_int)
                    {
                        (*h).param.rc.i_qp_min
                    } else {
                        51 as ::core::ffi::c_int
                            + 6 as ::core::ffi::c_int
                                * (10 as ::core::ffi::c_int - 8 as ::core::ffi::c_int)
                    }) {
                    (*h).mb.i_qp - threshold - 1 as ::core::ffi::c_int
                } else if (*h).param.rc.i_qp_min
                    < 51 as ::core::ffi::c_int
                        + 6 as ::core::ffi::c_int
                            * (10 as ::core::ffi::c_int - 8 as ::core::ffi::c_int)
                {
                    (*h).param.rc.i_qp_min
                } else {
                    51 as ::core::ffi::c_int
                        + 6 as ::core::ffi::c_int
                            * (10 as ::core::ffi::c_int - 8 as ::core::ffi::c_int)
                };
                (*h).mb.i_chroma_qp =
                    *(*h).chroma_qp_table.offset((*h).mb.i_qp as isize) as ::core::ffi::c_int;
                already_checked_cost = rd_cost_mb(h, (*a).i_lambda2);
                if *(*h).mb.cbp.offset((*h).mb.i_mb_xy as isize) == 0 {
                    if (*h).mb.i_last_qp > (*h).mb.i_qp {
                        last_qp_tried = 1 as ::core::ffi::c_int;
                    }
                    break;
                } else {
                    already_checked_qp = (*h).mb.i_qp;
                    (*h).mb.i_qp = orig_qp;
                }
            }
        }
        (*h).mb.i_qp += direction;
        while (*h).mb.i_qp >= (*h).param.rc.i_qp_min
            && (*h).mb.i_qp
                <= (if (*h).param.rc.i_qp_max
                    < 51 as ::core::ffi::c_int
                        + 6 as ::core::ffi::c_int
                            * (10 as ::core::ffi::c_int - 8 as ::core::ffi::c_int)
                {
                    (*h).param.rc.i_qp_max
                } else {
                    51 as ::core::ffi::c_int
                        + 6 as ::core::ffi::c_int
                            * (10 as ::core::ffi::c_int - 8 as ::core::ffi::c_int)
                })
        {
            if (*h).mb.i_last_qp == (*h).mb.i_qp {
                last_qp_tried = 1 as ::core::ffi::c_int;
            }
            if (*h).mb.i_qp == already_checked_qp {
                cost = already_checked_cost;
            } else {
                (*h).mb.i_chroma_qp =
                    *(*h).chroma_qp_table.offset((*h).mb.i_qp as isize) as ::core::ffi::c_int;
                cost = rd_cost_mb(h, (*a).i_lambda2);
                if cost < bcost {
                    bcost = cost;
                    bqp = (*h).mb.i_qp;
                }
            }
            if cost < prevcost {
                failures = 0 as ::core::ffi::c_int;
            } else {
                failures += 1;
            }
            prevcost = cost;
            if failures > threshold {
                break;
            }
            if direction == 1 as ::core::ffi::c_int
                && *(*h).mb.cbp.offset((*h).mb.i_mb_xy as isize) == 0
            {
                break;
            }
            (*h).mb.i_qp += direction;
        }
        direction -= 2 as ::core::ffi::c_int;
    }
    if last_qp_tried == 0 {
        (*h).mb.i_qp = (*h).mb.i_last_qp;
        (*h).mb.i_chroma_qp =
            *(*h).chroma_qp_table.offset((*h).mb.i_qp as isize) as ::core::ffi::c_int;
        cost = rd_cost_mb(h, (*a).i_lambda2);
        if cost < bcost {
            bcost = cost;
            bqp = (*h).mb.i_qp;
        }
    }
    (*h).mb.i_qp = bqp;
    (*h).mb.i_chroma_qp = *(*h).chroma_qp_table.offset((*h).mb.i_qp as isize) as ::core::ffi::c_int;
    if (*h).mb.i_qp != orig_qp
        && (*h).param.analyse.b_transform_8x8 != 0
        && x264_mb_transform_8x8_allowed(h) != 0
    {
        (*h).mb.b_transform_8x8 ^= 1 as ::core::ffi::c_int;
        cost = rd_cost_mb(h, (*a).i_lambda2);
        if cost > bcost {
            (*h).mb.b_transform_8x8 ^= 1 as ::core::ffi::c_int;
        }
    }
}
#[no_mangle]
#[c2rust::src_loc = "2918:1"]
pub unsafe extern "C" fn x264_10_macroblock_analyse(mut h: *mut x264_t) {
    let mut current_block: u64;
    let mut analysis: x264_mb_analysis_t = x264_mb_analysis_t {
        i_lambda: 0,
        i_lambda2: 0,
        i_qp: 0,
        p_cost_mv: 0 as *mut uint16_t,
        p_cost_ref: [0 as *mut uint16_t; 2],
        i_mbrd: 0,
        b_fast_intra: 0,
        b_force_intra: 0,
        b_avoid_topright: 0,
        b_try_skip: 0,
        i_satd_i16x16: 0,
        i_satd_i16x16_dir: [0; 7],
        i_predict16x16: 0,
        i_satd_i8x8: 0,
        i_cbp_i8x8_luma: 0,
        i_satd_i8x8_dir: [[0; 16]; 4],
        i_predict8x8: [0; 4],
        i_satd_i4x4: 0,
        i_predict4x4: [0; 16],
        i_satd_pcm: 0,
        i_satd_chroma: 0,
        i_satd_chroma_dir: [0; 7],
        i_predict8x8chroma: 0,
        l0: x264_mb_analysis_list_t {
            me16x16: x264_me_t {
                i_pixel: 0,
                p_cost_mv: 0 as *mut uint16_t,
                i_ref_cost: 0,
                i_ref: 0,
                weight: 0 as *const x264_weight_t,
                p_fref: [0 as *mut pixel; 12],
                p_fref_w: 0 as *mut pixel,
                p_fenc: [0 as *mut pixel; 3],
                integral: 0 as *mut uint16_t,
                i_stride: [0; 3],
                mvp: [0; 2],
                cost_mv: 0,
                cost: 0,
                mv: [0; 2],
            },
            bi16x16: x264_me_t {
                i_pixel: 0,
                p_cost_mv: 0 as *mut uint16_t,
                i_ref_cost: 0,
                i_ref: 0,
                weight: 0 as *const x264_weight_t,
                p_fref: [0 as *mut pixel; 12],
                p_fref_w: 0 as *mut pixel,
                p_fenc: [0 as *mut pixel; 3],
                integral: 0 as *mut uint16_t,
                i_stride: [0; 3],
                mvp: [0; 2],
                cost_mv: 0,
                cost: 0,
                mv: [0; 2],
            },
            me8x8: [x264_me_t {
                i_pixel: 0,
                p_cost_mv: 0 as *mut uint16_t,
                i_ref_cost: 0,
                i_ref: 0,
                weight: 0 as *const x264_weight_t,
                p_fref: [0 as *mut pixel; 12],
                p_fref_w: 0 as *mut pixel,
                p_fenc: [0 as *mut pixel; 3],
                integral: 0 as *mut uint16_t,
                i_stride: [0; 3],
                mvp: [0; 2],
                cost_mv: 0,
                cost: 0,
                mv: [0; 2],
            }; 4],
            me4x4: [[x264_me_t {
                i_pixel: 0,
                p_cost_mv: 0 as *mut uint16_t,
                i_ref_cost: 0,
                i_ref: 0,
                weight: 0 as *const x264_weight_t,
                p_fref: [0 as *mut pixel; 12],
                p_fref_w: 0 as *mut pixel,
                p_fenc: [0 as *mut pixel; 3],
                integral: 0 as *mut uint16_t,
                i_stride: [0; 3],
                mvp: [0; 2],
                cost_mv: 0,
                cost: 0,
                mv: [0; 2],
            }; 4]; 4],
            me8x4: [[x264_me_t {
                i_pixel: 0,
                p_cost_mv: 0 as *mut uint16_t,
                i_ref_cost: 0,
                i_ref: 0,
                weight: 0 as *const x264_weight_t,
                p_fref: [0 as *mut pixel; 12],
                p_fref_w: 0 as *mut pixel,
                p_fenc: [0 as *mut pixel; 3],
                integral: 0 as *mut uint16_t,
                i_stride: [0; 3],
                mvp: [0; 2],
                cost_mv: 0,
                cost: 0,
                mv: [0; 2],
            }; 2]; 4],
            me4x8: [[x264_me_t {
                i_pixel: 0,
                p_cost_mv: 0 as *mut uint16_t,
                i_ref_cost: 0,
                i_ref: 0,
                weight: 0 as *const x264_weight_t,
                p_fref: [0 as *mut pixel; 12],
                p_fref_w: 0 as *mut pixel,
                p_fenc: [0 as *mut pixel; 3],
                integral: 0 as *mut uint16_t,
                i_stride: [0; 3],
                mvp: [0; 2],
                cost_mv: 0,
                cost: 0,
                mv: [0; 2],
            }; 2]; 4],
            me16x8: [x264_me_t {
                i_pixel: 0,
                p_cost_mv: 0 as *mut uint16_t,
                i_ref_cost: 0,
                i_ref: 0,
                weight: 0 as *const x264_weight_t,
                p_fref: [0 as *mut pixel; 12],
                p_fref_w: 0 as *mut pixel,
                p_fenc: [0 as *mut pixel; 3],
                integral: 0 as *mut uint16_t,
                i_stride: [0; 3],
                mvp: [0; 2],
                cost_mv: 0,
                cost: 0,
                mv: [0; 2],
            }; 2],
            me8x16: [x264_me_t {
                i_pixel: 0,
                p_cost_mv: 0 as *mut uint16_t,
                i_ref_cost: 0,
                i_ref: 0,
                weight: 0 as *const x264_weight_t,
                p_fref: [0 as *mut pixel; 12],
                p_fref_w: 0 as *mut pixel,
                p_fenc: [0 as *mut pixel; 3],
                integral: 0 as *mut uint16_t,
                i_stride: [0; 3],
                mvp: [0; 2],
                cost_mv: 0,
                cost: 0,
                mv: [0; 2],
            }; 2],
            i_rd16x16: 0,
            i_cost8x8: 0,
            i_cost4x4: [0; 4],
            i_cost8x4: [0; 4],
            i_cost4x8: [0; 4],
            i_cost16x8: 0,
            i_cost8x16: 0,
            mvc: [[[0; 2]; 6]; 32],
        },
        l1: x264_mb_analysis_list_t {
            me16x16: x264_me_t {
                i_pixel: 0,
                p_cost_mv: 0 as *mut uint16_t,
                i_ref_cost: 0,
                i_ref: 0,
                weight: 0 as *const x264_weight_t,
                p_fref: [0 as *mut pixel; 12],
                p_fref_w: 0 as *mut pixel,
                p_fenc: [0 as *mut pixel; 3],
                integral: 0 as *mut uint16_t,
                i_stride: [0; 3],
                mvp: [0; 2],
                cost_mv: 0,
                cost: 0,
                mv: [0; 2],
            },
            bi16x16: x264_me_t {
                i_pixel: 0,
                p_cost_mv: 0 as *mut uint16_t,
                i_ref_cost: 0,
                i_ref: 0,
                weight: 0 as *const x264_weight_t,
                p_fref: [0 as *mut pixel; 12],
                p_fref_w: 0 as *mut pixel,
                p_fenc: [0 as *mut pixel; 3],
                integral: 0 as *mut uint16_t,
                i_stride: [0; 3],
                mvp: [0; 2],
                cost_mv: 0,
                cost: 0,
                mv: [0; 2],
            },
            me8x8: [x264_me_t {
                i_pixel: 0,
                p_cost_mv: 0 as *mut uint16_t,
                i_ref_cost: 0,
                i_ref: 0,
                weight: 0 as *const x264_weight_t,
                p_fref: [0 as *mut pixel; 12],
                p_fref_w: 0 as *mut pixel,
                p_fenc: [0 as *mut pixel; 3],
                integral: 0 as *mut uint16_t,
                i_stride: [0; 3],
                mvp: [0; 2],
                cost_mv: 0,
                cost: 0,
                mv: [0; 2],
            }; 4],
            me4x4: [[x264_me_t {
                i_pixel: 0,
                p_cost_mv: 0 as *mut uint16_t,
                i_ref_cost: 0,
                i_ref: 0,
                weight: 0 as *const x264_weight_t,
                p_fref: [0 as *mut pixel; 12],
                p_fref_w: 0 as *mut pixel,
                p_fenc: [0 as *mut pixel; 3],
                integral: 0 as *mut uint16_t,
                i_stride: [0; 3],
                mvp: [0; 2],
                cost_mv: 0,
                cost: 0,
                mv: [0; 2],
            }; 4]; 4],
            me8x4: [[x264_me_t {
                i_pixel: 0,
                p_cost_mv: 0 as *mut uint16_t,
                i_ref_cost: 0,
                i_ref: 0,
                weight: 0 as *const x264_weight_t,
                p_fref: [0 as *mut pixel; 12],
                p_fref_w: 0 as *mut pixel,
                p_fenc: [0 as *mut pixel; 3],
                integral: 0 as *mut uint16_t,
                i_stride: [0; 3],
                mvp: [0; 2],
                cost_mv: 0,
                cost: 0,
                mv: [0; 2],
            }; 2]; 4],
            me4x8: [[x264_me_t {
                i_pixel: 0,
                p_cost_mv: 0 as *mut uint16_t,
                i_ref_cost: 0,
                i_ref: 0,
                weight: 0 as *const x264_weight_t,
                p_fref: [0 as *mut pixel; 12],
                p_fref_w: 0 as *mut pixel,
                p_fenc: [0 as *mut pixel; 3],
                integral: 0 as *mut uint16_t,
                i_stride: [0; 3],
                mvp: [0; 2],
                cost_mv: 0,
                cost: 0,
                mv: [0; 2],
            }; 2]; 4],
            me16x8: [x264_me_t {
                i_pixel: 0,
                p_cost_mv: 0 as *mut uint16_t,
                i_ref_cost: 0,
                i_ref: 0,
                weight: 0 as *const x264_weight_t,
                p_fref: [0 as *mut pixel; 12],
                p_fref_w: 0 as *mut pixel,
                p_fenc: [0 as *mut pixel; 3],
                integral: 0 as *mut uint16_t,
                i_stride: [0; 3],
                mvp: [0; 2],
                cost_mv: 0,
                cost: 0,
                mv: [0; 2],
            }; 2],
            me8x16: [x264_me_t {
                i_pixel: 0,
                p_cost_mv: 0 as *mut uint16_t,
                i_ref_cost: 0,
                i_ref: 0,
                weight: 0 as *const x264_weight_t,
                p_fref: [0 as *mut pixel; 12],
                p_fref_w: 0 as *mut pixel,
                p_fenc: [0 as *mut pixel; 3],
                integral: 0 as *mut uint16_t,
                i_stride: [0; 3],
                mvp: [0; 2],
                cost_mv: 0,
                cost: 0,
                mv: [0; 2],
            }; 2],
            i_rd16x16: 0,
            i_cost8x8: 0,
            i_cost4x4: [0; 4],
            i_cost8x4: [0; 4],
            i_cost4x8: [0; 4],
            i_cost16x8: 0,
            i_cost8x16: 0,
            mvc: [[[0; 2]; 6]; 32],
        },
        i_cost16x16bi: 0,
        i_cost16x16direct: 0,
        i_cost8x8bi: 0,
        i_cost8x8direct: [0; 4],
        i_satd8x8: [[0; 4]; 3],
        i_cost_est16x8: [0; 2],
        i_cost_est8x16: [0; 2],
        i_cost16x8bi: 0,
        i_cost8x16bi: 0,
        i_rd16x16bi: 0,
        i_rd16x16direct: 0,
        i_rd16x8bi: 0,
        i_rd8x16bi: 0,
        i_rd8x8bi: 0,
        i_mb_partition16x8: [0; 2],
        i_mb_partition8x16: [0; 2],
        i_mb_type16x8: 0,
        i_mb_type8x16: 0,
        b_direct_available: 0,
        b_early_terminate: 0,
    };
    let mut i_cost: ::core::ffi::c_int = COST_MAX;
    (*h).mb.i_qp = x264_10_ratecontrol_mb_qp(h);
    if (*h).param.rc.i_aq_mode != 0 && (*h).param.analyse.i_subpel_refine < 10 as ::core::ffi::c_int
    {
        (*h).mb.i_qp = if abs((*h).mb.i_qp - (*h).mb.i_last_qp) == 1 as ::core::ffi::c_int {
            (*h).mb.i_last_qp
        } else {
            (*h).mb.i_qp
        };
    }
    if (*h).param.analyse.b_mb_info != 0 {
        *(*(*h).fdec).effective_qp.offset((*h).mb.i_mb_xy as isize) = (*h).mb.i_qp as uint8_t;
    }
    mb_analyse_init(h, &mut analysis, (*h).mb.i_qp);
    if (*h).sh.i_type == SLICE_TYPE_I as ::core::ffi::c_int {
        current_block = 3870634877451421603;
    } else if (*h).sh.i_type == SLICE_TYPE_P as ::core::ffi::c_int {
        let mut b_skip: ::core::ffi::c_int = 0 as ::core::ffi::c_int;
        (*h).mc.prefetch_ref.expect("non-null function pointer")(
            (*h).mb.pic.p_fref[0 as ::core::ffi::c_int as usize][0 as ::core::ffi::c_int as usize]
                [((*h).mb.i_mb_x & 3 as ::core::ffi::c_int) as usize],
            (*h).mb.pic.i_stride[0 as ::core::ffi::c_int as usize] as intptr_t,
            0 as ::core::ffi::c_int,
        );
        analysis.b_try_skip = 0 as ::core::ffi::c_int;
        if analysis.b_force_intra != 0 {
            if (*h).param.analyse.b_psy == 0 {
                mb_analyse_init_qp(
                    h,
                    &mut analysis,
                    if (*h).mb.i_qp - (*h).mb.ip_offset > (*h).param.rc.i_qp_min {
                        (*h).mb.i_qp - (*h).mb.ip_offset
                    } else {
                        (*h).param.rc.i_qp_min
                    },
                );
                current_block = 3870634877451421603;
            } else {
                current_block = 13460095289871124136;
            }
        } else {
            if !(*(*h).fdec).mb_info.is_null()
                && *(*(*h).fdec).mb_info.offset((*h).mb.i_mb_xy as isize) as ::core::ffi::c_uint
                    & X264_MBINFO_CONSTANT
                    != 0
            {
                if (*h).sh.b_mbaff == 0
                    && (*(*h).fdec).i_frame
                        - (*(*h).fref[0 as ::core::ffi::c_int as usize]
                            [0 as ::core::ffi::c_int as usize])
                            .i_frame
                        == 1 as ::core::ffi::c_int
                    && (*h).sh.b_weighted_pred == 0
                    && *(*(*h).fref[0 as ::core::ffi::c_int as usize]
                        [0 as ::core::ffi::c_int as usize])
                        .effective_qp
                        .offset((*h).mb.i_mb_xy as isize)
                        as ::core::ffi::c_int
                        <= (*h).mb.i_qp
                {
                    (*h).mb.i_partition = D_16x16 as ::core::ffi::c_int;
                    if (*((*h).mb.cache.pskip_mv.as_mut_ptr() as *mut x264_union32_t)).i == 0 {
                        b_skip = 1 as ::core::ffi::c_int;
                        (*h).mb.i_type = P_SKIP as ::core::ffi::c_int;
                    } else {
                        (*h).mb.i_type = P_L0 as ::core::ffi::c_int;
                        analysis.l0.me16x16.i_ref = 0 as ::core::ffi::c_int;
                        (*(analysis.l0.me16x16.mv.as_mut_ptr() as *mut x264_union32_t)).i =
                            0 as uint32_t;
                    }
                    current_block = 10061345519188545595;
                } else {
                    if (*h).param.analyse.b_mb_info_update != 0 {
                        let ref mut fresh3 = *(*(*h).fdec).mb_info.offset((*h).mb.i_mb_xy as isize);
                        *fresh3 =
                            (*fresh3 as ::core::ffi::c_uint & !X264_MBINFO_CONSTANT) as uint8_t;
                    }
                    current_block = 14072441030219150333;
                }
            } else {
                current_block = 14072441030219150333;
            }
            match current_block {
                10061345519188545595 => {}
                _ => {
                    let mut skip_invalid: ::core::ffi::c_int = ((*h).i_thread_frames
                        > 1 as ::core::ffi::c_int
                        && (*h).mb.cache.pskip_mv[1 as ::core::ffi::c_int as usize]
                            as ::core::ffi::c_int
                            > (*h).mb.mv_max_spel[1 as ::core::ffi::c_int as usize])
                        as ::core::ffi::c_int;
                    if HAVE_INTERLACED != 0
                        && (*h).mb.b_interlaced == 0
                        && (*h).mb.i_mb_y * 16 as ::core::ffi::c_int >= (*h).param.i_height
                        && skip_invalid == 0
                    {
                        b_skip = 1 as ::core::ffi::c_int;
                    } else if (*h).param.analyse.b_fast_pskip != 0 {
                        if !(skip_invalid != 0) {
                            if (*h).param.analyse.i_subpel_refine >= 3 as ::core::ffi::c_int {
                                analysis.b_try_skip = 1 as ::core::ffi::c_int;
                            } else if (*h).mb.i_mb_type_left[0 as ::core::ffi::c_int as usize]
                                == P_SKIP as ::core::ffi::c_int
                                || (*h).mb.i_mb_type_top == P_SKIP as ::core::ffi::c_int
                                || (*h).mb.i_mb_type_topleft == P_SKIP as ::core::ffi::c_int
                                || (*h).mb.i_mb_type_topright == P_SKIP as ::core::ffi::c_int
                            {
                                b_skip = x264_10_macroblock_probe_skip(h, 0 as ::core::ffi::c_int);
                            }
                        }
                    }
                    current_block = 13460095289871124136;
                }
            }
        }
        match current_block {
            3870634877451421603 => {}
            _ => {
                match current_block {
                    13460095289871124136 => {
                        (*h).mc.prefetch_ref.expect("non-null function pointer")(
                            (*h).mb.pic.p_fref[0 as ::core::ffi::c_int as usize]
                                [0 as ::core::ffi::c_int as usize]
                                [((*h).mb.i_mb_x & 3 as ::core::ffi::c_int) as usize],
                            (*h).mb.pic.i_stride[0 as ::core::ffi::c_int as usize] as intptr_t,
                            1 as ::core::ffi::c_int,
                        );
                        if b_skip != 0 {
                            (*h).mb.i_type = P_SKIP as ::core::ffi::c_int;
                            (*h).mb.i_partition = D_16x16 as ::core::ffi::c_int;
                            if (*h).mb.cache.pskip_mv[1 as ::core::ffi::c_int as usize]
                                as ::core::ffi::c_int
                                <= (*h).mb.mv_max_spel[1 as ::core::ffi::c_int as usize]
                                || (*h).i_thread_frames == 1 as ::core::ffi::c_int
                            {
                            } else {
                                __assert_fail(
                                    b"h->mb.cache.pskip_mv[1] <= h->mb.mv_max_spel[1] || h->i_thread_frames == 1\0"
                                        as *const u8 as *const ::core::ffi::c_char,
                                    b"encoder/analyse.c\0" as *const u8
                                        as *const ::core::ffi::c_char,
                                    3023 as ::core::ffi::c_uint,
                                    ::core::mem::transmute::<
                                        [u8; 42],
                                        [::core::ffi::c_char; 42],
                                    >(*b"void x264_10_macroblock_analyse(x264_t *)\0")
                                        .as_ptr(),
                                );
                            }
                            'c_106575: {
                                if (*h).mb.cache.pskip_mv[1 as ::core::ffi::c_int as usize]
                                    as ::core::ffi::c_int
                                    <= (*h).mb.mv_max_spel[1 as ::core::ffi::c_int as usize]
                                    || (*h).i_thread_frames == 1 as ::core::ffi::c_int
                                {
                                } else {
                                    __assert_fail(
                                        b"h->mb.cache.pskip_mv[1] <= h->mb.mv_max_spel[1] || h->i_thread_frames == 1\0"
                                            as *const u8 as *const ::core::ffi::c_char,
                                        b"encoder/analyse.c\0" as *const u8
                                            as *const ::core::ffi::c_char,
                                        3023 as ::core::ffi::c_uint,
                                        ::core::mem::transmute::<
                                            [u8; 42],
                                            [::core::ffi::c_char; 42],
                                        >(*b"void x264_10_macroblock_analyse(x264_t *)\0")
                                            .as_ptr(),
                                    );
                                }
                            };
                            current_block = 10061345519188545595;
                        } else {
                            let flags: ::core::ffi::c_uint = (*h).param.analyse.inter;
                            let mut i_type: ::core::ffi::c_int = 0;
                            let mut i_partition: ::core::ffi::c_int = 0;
                            let mut i_satd_inter: ::core::ffi::c_int = 0;
                            let mut i_satd_intra: ::core::ffi::c_int = 0;
                            mb_analyse_load_costs(h, &mut analysis);
                            mb_analyse_inter_p16x16(h, &mut analysis);
                            if (*h).mb.i_type == P_SKIP as ::core::ffi::c_int {
                                let mut i_0: ::core::ffi::c_int = 1 as ::core::ffi::c_int;
                                while i_0 < (*h).mb.pic.i_fref[0 as ::core::ffi::c_int as usize] {
                                    (*((*(*(*(*h)
                                        .mb
                                        .mvr
                                        .as_mut_ptr()
                                        .offset(0 as ::core::ffi::c_int as isize))
                                    .as_mut_ptr()
                                    .offset(i_0 as isize))
                                    .offset((*h).mb.i_mb_xy as isize))
                                    .as_mut_ptr()
                                        as *mut x264_union32_t))
                                        .i = 0 as uint32_t;
                                    i_0 += 1;
                                }
                                return;
                            }
                            if flags & X264_ANALYSE_PSUB16x16 != 0 {
                                if (*h).param.analyse.b_mixed_references != 0 {
                                    mb_analyse_inter_p8x8_mixed_ref(h, &mut analysis);
                                } else {
                                    mb_analyse_inter_p8x8(h, &mut analysis);
                                }
                            }
                            i_type = P_L0 as ::core::ffi::c_int;
                            i_partition = D_16x16 as ::core::ffi::c_int;
                            i_cost = analysis.l0.me16x16.cost;
                            if flags & X264_ANALYSE_PSUB16x16 != 0
                                && (analysis.b_early_terminate == 0
                                    || analysis.l0.i_cost8x8 < analysis.l0.me16x16.cost)
                            {
                                i_type = P_8x8 as ::core::ffi::c_int;
                                i_partition = D_8x8 as ::core::ffi::c_int;
                                i_cost = analysis.l0.i_cost8x8;
                                if flags & X264_ANALYSE_PSUB8x8 != 0 {
                                    let mut i_1: ::core::ffi::c_int = 0 as ::core::ffi::c_int;
                                    while i_1 < 4 as ::core::ffi::c_int {
                                        mb_analyse_inter_p4x4(h, &mut analysis, i_1);
                                        let mut i_thresh8x4: ::core::ffi::c_int = analysis.l0.me4x4
                                            [i_1 as usize]
                                            [1 as ::core::ffi::c_int as usize]
                                            .cost_mv
                                            + analysis.l0.me4x4[i_1 as usize]
                                                [2 as ::core::ffi::c_int as usize]
                                                .cost_mv;
                                        if analysis.b_early_terminate == 0
                                            || analysis.l0.i_cost4x4[i_1 as usize]
                                                < analysis.l0.me8x8[i_1 as usize].cost + i_thresh8x4
                                        {
                                            let mut i_cost8x8: ::core::ffi::c_int =
                                                analysis.l0.i_cost4x4[i_1 as usize];
                                            (*h).mb.i_sub_partition[i_1 as usize] =
                                                D_L0_4x4 as ::core::ffi::c_int as uint8_t;
                                            mb_analyse_inter_p8x4(h, &mut analysis, i_1);
                                            if analysis.l0.i_cost8x4[i_1 as usize] < i_cost8x8 {
                                                i_cost8x8 = analysis.l0.i_cost8x4[i_1 as usize];
                                                (*h).mb.i_sub_partition[i_1 as usize] =
                                                    D_L0_8x4 as ::core::ffi::c_int as uint8_t;
                                            }
                                            mb_analyse_inter_p4x8(h, &mut analysis, i_1);
                                            if analysis.l0.i_cost4x8[i_1 as usize] < i_cost8x8 {
                                                i_cost8x8 = analysis.l0.i_cost4x8[i_1 as usize];
                                                (*h).mb.i_sub_partition[i_1 as usize] =
                                                    D_L0_4x8 as ::core::ffi::c_int as uint8_t;
                                            }
                                            i_cost +=
                                                i_cost8x8 - analysis.l0.me8x8[i_1 as usize].cost;
                                        }
                                        mb_cache_mv_p8x8(h, &mut analysis, i_1);
                                        i_1 += 1;
                                    }
                                    analysis.l0.i_cost8x8 = i_cost;
                                }
                            }
                            let mut i_thresh16x8: ::core::ffi::c_int =
                                analysis.l0.me8x8[1 as ::core::ffi::c_int as usize].cost_mv
                                    + analysis.l0.me8x8[2 as ::core::ffi::c_int as usize].cost_mv;
                            if flags & X264_ANALYSE_PSUB16x16 != 0
                                && (analysis.b_early_terminate == 0
                                    || analysis.l0.i_cost8x8
                                        < analysis.l0.me16x16.cost + i_thresh16x8)
                            {
                                let mut i_avg_mv_ref_cost: ::core::ffi::c_int = analysis.l0.me8x8
                                    [2 as ::core::ffi::c_int as usize]
                                    .cost_mv
                                    + analysis.l0.me8x8[2 as ::core::ffi::c_int as usize]
                                        .i_ref_cost
                                    + analysis.l0.me8x8[3 as ::core::ffi::c_int as usize].cost_mv
                                    + analysis.l0.me8x8[3 as ::core::ffi::c_int as usize]
                                        .i_ref_cost
                                    + 1 as ::core::ffi::c_int
                                    >> 1 as ::core::ffi::c_int;
                                analysis.i_cost_est16x8[1 as ::core::ffi::c_int as usize] =
                                    analysis.i_satd8x8[0 as ::core::ffi::c_int as usize]
                                        [2 as ::core::ffi::c_int as usize]
                                        + analysis.i_satd8x8[0 as ::core::ffi::c_int as usize]
                                            [3 as ::core::ffi::c_int as usize]
                                        + i_avg_mv_ref_cost;
                                mb_analyse_inter_p16x8(h, &mut analysis, i_cost);
                                if analysis.l0.i_cost16x8 < i_cost {
                                    i_cost = analysis.l0.i_cost16x8;
                                    i_type = P_L0 as ::core::ffi::c_int;
                                    i_partition = D_16x8 as ::core::ffi::c_int;
                                }
                                i_avg_mv_ref_cost = analysis.l0.me8x8
                                    [1 as ::core::ffi::c_int as usize]
                                    .cost_mv
                                    + analysis.l0.me8x8[1 as ::core::ffi::c_int as usize]
                                        .i_ref_cost
                                    + analysis.l0.me8x8[3 as ::core::ffi::c_int as usize].cost_mv
                                    + analysis.l0.me8x8[3 as ::core::ffi::c_int as usize]
                                        .i_ref_cost
                                    + 1 as ::core::ffi::c_int
                                    >> 1 as ::core::ffi::c_int;
                                analysis.i_cost_est8x16[1 as ::core::ffi::c_int as usize] =
                                    analysis.i_satd8x8[0 as ::core::ffi::c_int as usize]
                                        [1 as ::core::ffi::c_int as usize]
                                        + analysis.i_satd8x8[0 as ::core::ffi::c_int as usize]
                                            [3 as ::core::ffi::c_int as usize]
                                        + i_avg_mv_ref_cost;
                                mb_analyse_inter_p8x16(h, &mut analysis, i_cost);
                                if analysis.l0.i_cost8x16 < i_cost {
                                    i_cost = analysis.l0.i_cost8x16;
                                    i_type = P_L0 as ::core::ffi::c_int;
                                    i_partition = D_8x16 as ::core::ffi::c_int;
                                }
                            }
                            (*h).mb.i_partition = i_partition;
                            if !(analysis.i_mbrd != 0 || (*h).mb.i_subpel_refine == 0) {
                                if i_partition == D_16x16 as ::core::ffi::c_int {
                                    x264_10_me_refine_qpel(h, &mut analysis.l0.me16x16);
                                    i_cost = analysis.l0.me16x16.cost;
                                } else if i_partition == D_16x8 as ::core::ffi::c_int {
                                    x264_10_me_refine_qpel(
                                        h,
                                        &mut *analysis
                                            .l0
                                            .me16x8
                                            .as_mut_ptr()
                                            .offset(0 as ::core::ffi::c_int as isize),
                                    );
                                    x264_10_me_refine_qpel(
                                        h,
                                        &mut *analysis
                                            .l0
                                            .me16x8
                                            .as_mut_ptr()
                                            .offset(1 as ::core::ffi::c_int as isize),
                                    );
                                    i_cost = analysis.l0.me16x8[0 as ::core::ffi::c_int as usize]
                                        .cost
                                        + analysis.l0.me16x8[1 as ::core::ffi::c_int as usize].cost;
                                } else if i_partition == D_8x16 as ::core::ffi::c_int {
                                    x264_10_me_refine_qpel(
                                        h,
                                        &mut *analysis
                                            .l0
                                            .me8x16
                                            .as_mut_ptr()
                                            .offset(0 as ::core::ffi::c_int as isize),
                                    );
                                    x264_10_me_refine_qpel(
                                        h,
                                        &mut *analysis
                                            .l0
                                            .me8x16
                                            .as_mut_ptr()
                                            .offset(1 as ::core::ffi::c_int as isize),
                                    );
                                    i_cost = analysis.l0.me8x16[0 as ::core::ffi::c_int as usize]
                                        .cost
                                        + analysis.l0.me8x16[1 as ::core::ffi::c_int as usize].cost;
                                } else if i_partition == D_8x8 as ::core::ffi::c_int {
                                    i_cost = 0 as ::core::ffi::c_int;
                                    let mut i8x8: ::core::ffi::c_int = 0 as ::core::ffi::c_int;
                                    while i8x8 < 4 as ::core::ffi::c_int {
                                        match (*h).mb.i_sub_partition[i8x8 as usize]
                                            as ::core::ffi::c_int
                                        {
                                            3 => {
                                                x264_10_me_refine_qpel(
                                                    h,
                                                    &mut *analysis
                                                        .l0
                                                        .me8x8
                                                        .as_mut_ptr()
                                                        .offset(i8x8 as isize),
                                                );
                                                i_cost += analysis.l0.me8x8[i8x8 as usize].cost;
                                            }
                                            1 => {
                                                x264_10_me_refine_qpel(
                                                    h,
                                                    &mut *(*analysis
                                                        .l0
                                                        .me8x4
                                                        .as_mut_ptr()
                                                        .offset(i8x8 as isize))
                                                    .as_mut_ptr()
                                                    .offset(0 as ::core::ffi::c_int as isize),
                                                );
                                                x264_10_me_refine_qpel(
                                                    h,
                                                    &mut *(*analysis
                                                        .l0
                                                        .me8x4
                                                        .as_mut_ptr()
                                                        .offset(i8x8 as isize))
                                                    .as_mut_ptr()
                                                    .offset(1 as ::core::ffi::c_int as isize),
                                                );
                                                i_cost += analysis.l0.me8x4[i8x8 as usize]
                                                    [0 as ::core::ffi::c_int as usize]
                                                    .cost
                                                    + analysis.l0.me8x4[i8x8 as usize]
                                                        [1 as ::core::ffi::c_int as usize]
                                                        .cost;
                                            }
                                            2 => {
                                                x264_10_me_refine_qpel(
                                                    h,
                                                    &mut *(*analysis
                                                        .l0
                                                        .me4x8
                                                        .as_mut_ptr()
                                                        .offset(i8x8 as isize))
                                                    .as_mut_ptr()
                                                    .offset(0 as ::core::ffi::c_int as isize),
                                                );
                                                x264_10_me_refine_qpel(
                                                    h,
                                                    &mut *(*analysis
                                                        .l0
                                                        .me4x8
                                                        .as_mut_ptr()
                                                        .offset(i8x8 as isize))
                                                    .as_mut_ptr()
                                                    .offset(1 as ::core::ffi::c_int as isize),
                                                );
                                                i_cost += analysis.l0.me4x8[i8x8 as usize]
                                                    [0 as ::core::ffi::c_int as usize]
                                                    .cost
                                                    + analysis.l0.me4x8[i8x8 as usize]
                                                        [1 as ::core::ffi::c_int as usize]
                                                        .cost;
                                            }
                                            0 => {
                                                x264_10_me_refine_qpel(
                                                    h,
                                                    &mut *(*analysis
                                                        .l0
                                                        .me4x4
                                                        .as_mut_ptr()
                                                        .offset(i8x8 as isize))
                                                    .as_mut_ptr()
                                                    .offset(0 as ::core::ffi::c_int as isize),
                                                );
                                                x264_10_me_refine_qpel(
                                                    h,
                                                    &mut *(*analysis
                                                        .l0
                                                        .me4x4
                                                        .as_mut_ptr()
                                                        .offset(i8x8 as isize))
                                                    .as_mut_ptr()
                                                    .offset(1 as ::core::ffi::c_int as isize),
                                                );
                                                x264_10_me_refine_qpel(
                                                    h,
                                                    &mut *(*analysis
                                                        .l0
                                                        .me4x4
                                                        .as_mut_ptr()
                                                        .offset(i8x8 as isize))
                                                    .as_mut_ptr()
                                                    .offset(2 as ::core::ffi::c_int as isize),
                                                );
                                                x264_10_me_refine_qpel(
                                                    h,
                                                    &mut *(*analysis
                                                        .l0
                                                        .me4x4
                                                        .as_mut_ptr()
                                                        .offset(i8x8 as isize))
                                                    .as_mut_ptr()
                                                    .offset(3 as ::core::ffi::c_int as isize),
                                                );
                                                i_cost += analysis.l0.me4x4[i8x8 as usize]
                                                    [0 as ::core::ffi::c_int as usize]
                                                    .cost
                                                    + analysis.l0.me4x4[i8x8 as usize]
                                                        [1 as ::core::ffi::c_int as usize]
                                                        .cost
                                                    + analysis.l0.me4x4[i8x8 as usize]
                                                        [2 as ::core::ffi::c_int as usize]
                                                        .cost
                                                    + analysis.l0.me4x4[i8x8 as usize]
                                                        [3 as ::core::ffi::c_int as usize]
                                                        .cost;
                                            }
                                            _ => {
                                                x264_10_log(
                                                    h,
                                                    X264_LOG_ERROR,
                                                    b"internal error (!8x8 && !4x4)\n\0"
                                                        as *const u8
                                                        as *const ::core::ffi::c_char,
                                                );
                                            }
                                        }
                                        i8x8 += 1;
                                    }
                                }
                            }
                            if (*h).mb.b_chroma_me != 0 {
                                if (*(*h).sps.as_mut_ptr()).i_chroma_format_idc
                                    == CHROMA_444 as ::core::ffi::c_int
                                {
                                    mb_analyse_intra(h, &mut analysis, i_cost);
                                    mb_analyse_intra_chroma(h, &mut analysis);
                                } else {
                                    mb_analyse_intra_chroma(h, &mut analysis);
                                    mb_analyse_intra(
                                        h,
                                        &mut analysis,
                                        i_cost - analysis.i_satd_chroma,
                                    );
                                }
                                analysis.i_satd_i16x16 += analysis.i_satd_chroma;
                                analysis.i_satd_i8x8 += analysis.i_satd_chroma;
                                analysis.i_satd_i4x4 += analysis.i_satd_chroma;
                            } else {
                                mb_analyse_intra(h, &mut analysis, i_cost);
                            }
                            i_satd_inter = i_cost;
                            i_satd_intra = if analysis.i_satd_i16x16
                                < (if analysis.i_satd_i8x8 < analysis.i_satd_i4x4 {
                                    analysis.i_satd_i8x8
                                } else {
                                    analysis.i_satd_i4x4
                                }) {
                                analysis.i_satd_i16x16
                            } else if analysis.i_satd_i8x8 < analysis.i_satd_i4x4 {
                                analysis.i_satd_i8x8
                            } else {
                                analysis.i_satd_i4x4
                            };
                            if analysis.i_mbrd != 0 {
                                mb_analyse_p_rd(
                                    h,
                                    &mut analysis,
                                    if i_satd_inter < i_satd_intra {
                                        i_satd_inter
                                    } else {
                                        i_satd_intra
                                    },
                                );
                                i_type = P_L0 as ::core::ffi::c_int;
                                i_partition = D_16x16 as ::core::ffi::c_int;
                                i_cost = analysis.l0.i_rd16x16;
                                if analysis.l0.i_cost16x8 < i_cost {
                                    i_cost = analysis.l0.i_cost16x8;
                                    i_partition = D_16x8 as ::core::ffi::c_int;
                                }
                                if analysis.l0.i_cost8x16 < i_cost {
                                    i_cost = analysis.l0.i_cost8x16;
                                    i_partition = D_8x16 as ::core::ffi::c_int;
                                }
                                if analysis.l0.i_cost8x8 < i_cost {
                                    i_cost = analysis.l0.i_cost8x8;
                                    i_partition = D_8x8 as ::core::ffi::c_int;
                                    i_type = P_8x8 as ::core::ffi::c_int;
                                }
                                (*h).mb.i_type = i_type;
                                (*h).mb.i_partition = i_partition;
                                if i_cost < COST_MAX {
                                    mb_analyse_transform_rd(
                                        h,
                                        &mut analysis,
                                        &mut i_satd_inter,
                                        &mut i_cost,
                                    );
                                }
                                intra_rd(
                                    h,
                                    &mut analysis,
                                    i_satd_inter * 5 as ::core::ffi::c_int
                                        / 4 as ::core::ffi::c_int
                                        + 1 as ::core::ffi::c_int,
                                );
                            }
                            if analysis.i_satd_i16x16 < i_cost {
                                i_cost = analysis.i_satd_i16x16;
                                i_type = I_16x16 as ::core::ffi::c_int;
                            }
                            if analysis.i_satd_i8x8 < i_cost {
                                i_cost = analysis.i_satd_i8x8;
                                i_type = I_8x8 as ::core::ffi::c_int;
                            }
                            if analysis.i_satd_i4x4 < i_cost {
                                i_cost = analysis.i_satd_i4x4;
                                i_type = I_4x4 as ::core::ffi::c_int;
                            }
                            if analysis.i_satd_pcm < i_cost {
                                i_cost = analysis.i_satd_pcm;
                                i_type = I_PCM as ::core::ffi::c_int;
                            }
                            (*h).mb.i_type = i_type;
                            if analysis.b_force_intra != 0
                                && !(i_type == I_4x4 as ::core::ffi::c_int
                                    || i_type == I_8x8 as ::core::ffi::c_int
                                    || i_type == I_16x16 as ::core::ffi::c_int
                                    || i_type == I_PCM as ::core::ffi::c_int)
                            {
                                analyse_update_cache(h, &mut analysis);
                                x264_10_macroblock_encode(h);
                                let mut p: ::core::ffi::c_int = 0 as ::core::ffi::c_int;
                                while p
                                    < (if (*(*h).sps.as_mut_ptr()).i_chroma_format_idc
                                        == CHROMA_444 as ::core::ffi::c_int
                                    {
                                        3 as ::core::ffi::c_int
                                    } else {
                                        1 as ::core::ffi::c_int
                                    })
                                {
                                    (*h).mc.copy[PIXEL_16x16 as ::core::ffi::c_int as usize]
                                        .expect("non-null function pointer")(
                                        (*h).mb.pic.p_fenc[p as usize],
                                        FENC_STRIDE as intptr_t,
                                        (*h).mb.pic.p_fdec[p as usize],
                                        FDEC_STRIDE as intptr_t,
                                        16 as ::core::ffi::c_int,
                                    );
                                    p += 1;
                                }
                                if !((*(*h).sps.as_mut_ptr()).i_chroma_format_idc
                                    == CHROMA_444 as ::core::ffi::c_int)
                                {
                                    let mut height: ::core::ffi::c_int =
                                        16 as ::core::ffi::c_int >> (*h).mb.chroma_v_shift;
                                    (*h).mc.copy[PIXEL_8x8 as ::core::ffi::c_int as usize]
                                        .expect("non-null function pointer")(
                                        (*h).mb.pic.p_fenc[1 as ::core::ffi::c_int as usize],
                                        FENC_STRIDE as intptr_t,
                                        (*h).mb.pic.p_fdec[1 as ::core::ffi::c_int as usize],
                                        FDEC_STRIDE as intptr_t,
                                        height,
                                    );
                                    (*h).mc.copy[PIXEL_8x8 as ::core::ffi::c_int as usize]
                                        .expect("non-null function pointer")(
                                        (*h).mb.pic.p_fenc[2 as ::core::ffi::c_int as usize],
                                        FENC_STRIDE as intptr_t,
                                        (*h).mb.pic.p_fdec[2 as ::core::ffi::c_int as usize],
                                        FDEC_STRIDE as intptr_t,
                                        height,
                                    );
                                }
                                mb_analyse_init_qp(
                                    h,
                                    &mut analysis,
                                    if (*h).mb.i_qp - (*h).mb.ip_offset > (*h).param.rc.i_qp_min {
                                        (*h).mb.i_qp - (*h).mb.ip_offset
                                    } else {
                                        (*h).param.rc.i_qp_min
                                    },
                                );
                                current_block = 3870634877451421603;
                            } else {
                                if analysis.i_mbrd >= 2 as ::core::ffi::c_int
                                    && (*h).mb.i_type != I_PCM as ::core::ffi::c_int
                                {
                                    if (*h).mb.i_type == I_4x4 as ::core::ffi::c_int
                                        || (*h).mb.i_type == I_8x8 as ::core::ffi::c_int
                                        || (*h).mb.i_type == I_16x16 as ::core::ffi::c_int
                                        || (*h).mb.i_type == I_PCM as ::core::ffi::c_int
                                    {
                                        intra_rd_refine(h, &mut analysis);
                                    } else if i_partition == D_16x16 as ::core::ffi::c_int {
                                        x264_macroblock_cache_ref(
                                            h,
                                            0 as ::core::ffi::c_int,
                                            0 as ::core::ffi::c_int,
                                            4 as ::core::ffi::c_int,
                                            4 as ::core::ffi::c_int,
                                            0 as ::core::ffi::c_int,
                                            analysis.l0.me16x16.i_ref as int8_t,
                                        );
                                        analysis.l0.me16x16.cost = i_cost;
                                        x264_10_me_refine_qpel_rd(
                                            h,
                                            &mut analysis.l0.me16x16,
                                            analysis.i_lambda2,
                                            0 as ::core::ffi::c_int,
                                            0 as ::core::ffi::c_int,
                                        );
                                    } else if i_partition == D_16x8 as ::core::ffi::c_int {
                                        (*((*h).mb.i_sub_partition.as_mut_ptr()
                                            as *mut x264_union32_t))
                                            .i = (D_L0_8x8 as ::core::ffi::c_int
                                            * 0x1010101 as ::core::ffi::c_int)
                                            as uint32_t;
                                        x264_macroblock_cache_ref(
                                            h,
                                            0 as ::core::ffi::c_int,
                                            0 as ::core::ffi::c_int,
                                            4 as ::core::ffi::c_int,
                                            2 as ::core::ffi::c_int,
                                            0 as ::core::ffi::c_int,
                                            analysis.l0.me16x8[0 as ::core::ffi::c_int as usize]
                                                .i_ref
                                                as int8_t,
                                        );
                                        x264_macroblock_cache_ref(
                                            h,
                                            0 as ::core::ffi::c_int,
                                            2 as ::core::ffi::c_int,
                                            4 as ::core::ffi::c_int,
                                            2 as ::core::ffi::c_int,
                                            0 as ::core::ffi::c_int,
                                            analysis.l0.me16x8[1 as ::core::ffi::c_int as usize]
                                                .i_ref
                                                as int8_t,
                                        );
                                        x264_10_me_refine_qpel_rd(
                                            h,
                                            &mut *analysis
                                                .l0
                                                .me16x8
                                                .as_mut_ptr()
                                                .offset(0 as ::core::ffi::c_int as isize),
                                            analysis.i_lambda2,
                                            0 as ::core::ffi::c_int,
                                            0 as ::core::ffi::c_int,
                                        );
                                        x264_10_me_refine_qpel_rd(
                                            h,
                                            &mut *analysis
                                                .l0
                                                .me16x8
                                                .as_mut_ptr()
                                                .offset(1 as ::core::ffi::c_int as isize),
                                            analysis.i_lambda2,
                                            8 as ::core::ffi::c_int,
                                            0 as ::core::ffi::c_int,
                                        );
                                    } else if i_partition == D_8x16 as ::core::ffi::c_int {
                                        (*((*h).mb.i_sub_partition.as_mut_ptr()
                                            as *mut x264_union32_t))
                                            .i = (D_L0_8x8 as ::core::ffi::c_int
                                            * 0x1010101 as ::core::ffi::c_int)
                                            as uint32_t;
                                        x264_macroblock_cache_ref(
                                            h,
                                            0 as ::core::ffi::c_int,
                                            0 as ::core::ffi::c_int,
                                            2 as ::core::ffi::c_int,
                                            4 as ::core::ffi::c_int,
                                            0 as ::core::ffi::c_int,
                                            analysis.l0.me8x16[0 as ::core::ffi::c_int as usize]
                                                .i_ref
                                                as int8_t,
                                        );
                                        x264_macroblock_cache_ref(
                                            h,
                                            2 as ::core::ffi::c_int,
                                            0 as ::core::ffi::c_int,
                                            2 as ::core::ffi::c_int,
                                            4 as ::core::ffi::c_int,
                                            0 as ::core::ffi::c_int,
                                            analysis.l0.me8x16[1 as ::core::ffi::c_int as usize]
                                                .i_ref
                                                as int8_t,
                                        );
                                        x264_10_me_refine_qpel_rd(
                                            h,
                                            &mut *analysis
                                                .l0
                                                .me8x16
                                                .as_mut_ptr()
                                                .offset(0 as ::core::ffi::c_int as isize),
                                            analysis.i_lambda2,
                                            0 as ::core::ffi::c_int,
                                            0 as ::core::ffi::c_int,
                                        );
                                        x264_10_me_refine_qpel_rd(
                                            h,
                                            &mut *analysis
                                                .l0
                                                .me8x16
                                                .as_mut_ptr()
                                                .offset(1 as ::core::ffi::c_int as isize),
                                            analysis.i_lambda2,
                                            4 as ::core::ffi::c_int,
                                            0 as ::core::ffi::c_int,
                                        );
                                    } else if i_partition == D_8x8 as ::core::ffi::c_int {
                                        analyse_update_cache(h, &mut analysis);
                                        let mut i8x8_0: ::core::ffi::c_int =
                                            0 as ::core::ffi::c_int;
                                        while i8x8_0 < 4 as ::core::ffi::c_int {
                                            if (*h).mb.i_sub_partition[i8x8_0 as usize]
                                                as ::core::ffi::c_int
                                                == D_L0_8x8 as ::core::ffi::c_int
                                            {
                                                x264_10_me_refine_qpel_rd(
                                                    h,
                                                    &mut *analysis
                                                        .l0
                                                        .me8x8
                                                        .as_mut_ptr()
                                                        .offset(i8x8_0 as isize),
                                                    analysis.i_lambda2,
                                                    i8x8_0 * 4 as ::core::ffi::c_int,
                                                    0 as ::core::ffi::c_int,
                                                );
                                            } else if (*h).mb.i_sub_partition[i8x8_0 as usize]
                                                as ::core::ffi::c_int
                                                == D_L0_8x4 as ::core::ffi::c_int
                                            {
                                                x264_10_me_refine_qpel_rd(
                                                    h,
                                                    &mut *(*analysis
                                                        .l0
                                                        .me8x4
                                                        .as_mut_ptr()
                                                        .offset(i8x8_0 as isize))
                                                    .as_mut_ptr()
                                                    .offset(0 as ::core::ffi::c_int as isize),
                                                    analysis.i_lambda2,
                                                    i8x8_0 * 4 as ::core::ffi::c_int
                                                        + 0 as ::core::ffi::c_int,
                                                    0 as ::core::ffi::c_int,
                                                );
                                                x264_10_me_refine_qpel_rd(
                                                    h,
                                                    &mut *(*analysis
                                                        .l0
                                                        .me8x4
                                                        .as_mut_ptr()
                                                        .offset(i8x8_0 as isize))
                                                    .as_mut_ptr()
                                                    .offset(1 as ::core::ffi::c_int as isize),
                                                    analysis.i_lambda2,
                                                    i8x8_0 * 4 as ::core::ffi::c_int
                                                        + 2 as ::core::ffi::c_int,
                                                    0 as ::core::ffi::c_int,
                                                );
                                            } else if (*h).mb.i_sub_partition[i8x8_0 as usize]
                                                as ::core::ffi::c_int
                                                == D_L0_4x8 as ::core::ffi::c_int
                                            {
                                                x264_10_me_refine_qpel_rd(
                                                    h,
                                                    &mut *(*analysis
                                                        .l0
                                                        .me4x8
                                                        .as_mut_ptr()
                                                        .offset(i8x8_0 as isize))
                                                    .as_mut_ptr()
                                                    .offset(0 as ::core::ffi::c_int as isize),
                                                    analysis.i_lambda2,
                                                    i8x8_0 * 4 as ::core::ffi::c_int
                                                        + 0 as ::core::ffi::c_int,
                                                    0 as ::core::ffi::c_int,
                                                );
                                                x264_10_me_refine_qpel_rd(
                                                    h,
                                                    &mut *(*analysis
                                                        .l0
                                                        .me4x8
                                                        .as_mut_ptr()
                                                        .offset(i8x8_0 as isize))
                                                    .as_mut_ptr()
                                                    .offset(1 as ::core::ffi::c_int as isize),
                                                    analysis.i_lambda2,
                                                    i8x8_0 * 4 as ::core::ffi::c_int
                                                        + 1 as ::core::ffi::c_int,
                                                    0 as ::core::ffi::c_int,
                                                );
                                            } else if (*h).mb.i_sub_partition[i8x8_0 as usize]
                                                as ::core::ffi::c_int
                                                == D_L0_4x4 as ::core::ffi::c_int
                                            {
                                                x264_10_me_refine_qpel_rd(
                                                    h,
                                                    &mut *(*analysis
                                                        .l0
                                                        .me4x4
                                                        .as_mut_ptr()
                                                        .offset(i8x8_0 as isize))
                                                    .as_mut_ptr()
                                                    .offset(0 as ::core::ffi::c_int as isize),
                                                    analysis.i_lambda2,
                                                    i8x8_0 * 4 as ::core::ffi::c_int
                                                        + 0 as ::core::ffi::c_int,
                                                    0 as ::core::ffi::c_int,
                                                );
                                                x264_10_me_refine_qpel_rd(
                                                    h,
                                                    &mut *(*analysis
                                                        .l0
                                                        .me4x4
                                                        .as_mut_ptr()
                                                        .offset(i8x8_0 as isize))
                                                    .as_mut_ptr()
                                                    .offset(1 as ::core::ffi::c_int as isize),
                                                    analysis.i_lambda2,
                                                    i8x8_0 * 4 as ::core::ffi::c_int
                                                        + 1 as ::core::ffi::c_int,
                                                    0 as ::core::ffi::c_int,
                                                );
                                                x264_10_me_refine_qpel_rd(
                                                    h,
                                                    &mut *(*analysis
                                                        .l0
                                                        .me4x4
                                                        .as_mut_ptr()
                                                        .offset(i8x8_0 as isize))
                                                    .as_mut_ptr()
                                                    .offset(2 as ::core::ffi::c_int as isize),
                                                    analysis.i_lambda2,
                                                    i8x8_0 * 4 as ::core::ffi::c_int
                                                        + 2 as ::core::ffi::c_int,
                                                    0 as ::core::ffi::c_int,
                                                );
                                                x264_10_me_refine_qpel_rd(
                                                    h,
                                                    &mut *(*analysis
                                                        .l0
                                                        .me4x4
                                                        .as_mut_ptr()
                                                        .offset(i8x8_0 as isize))
                                                    .as_mut_ptr()
                                                    .offset(3 as ::core::ffi::c_int as isize),
                                                    analysis.i_lambda2,
                                                    i8x8_0 * 4 as ::core::ffi::c_int
                                                        + 3 as ::core::ffi::c_int,
                                                    0 as ::core::ffi::c_int,
                                                );
                                            }
                                            i8x8_0 += 1;
                                        }
                                    }
                                }
                                current_block = 17193116482801528934;
                            }
                        }
                    }
                    _ => {}
                }
                match current_block {
                    17193116482801528934 => {}
                    3870634877451421603 => {}
                    _ => {
                        let mut i: ::core::ffi::c_int = 0 as ::core::ffi::c_int;
                        while i < (*h).mb.pic.i_fref[0 as ::core::ffi::c_int as usize] {
                            (*((*(*(*(*h)
                                .mb
                                .mvr
                                .as_mut_ptr()
                                .offset(0 as ::core::ffi::c_int as isize))
                            .as_mut_ptr()
                            .offset(i as isize))
                            .offset((*h).mb.i_mb_xy as isize))
                            .as_mut_ptr() as *mut x264_union32_t))
                                .i = 0 as uint32_t;
                            i += 1;
                        }
                        current_block = 17193116482801528934;
                    }
                }
            }
        }
    } else {
        if (*h).sh.i_type == SLICE_TYPE_B as ::core::ffi::c_int {
            let mut i_bskip_cost: ::core::ffi::c_int = COST_MAX;
            let mut b_skip_0: ::core::ffi::c_int = 0 as ::core::ffi::c_int;
            if analysis.i_mbrd != 0 {
                mb_init_fenc_cache(
                    h,
                    (analysis.i_mbrd >= 2 as ::core::ffi::c_int) as ::core::ffi::c_int,
                );
            }
            (*h).mb.i_type = B_SKIP as ::core::ffi::c_int;
            if (*h).mb.b_direct_auto_write != 0 {
                let mut i_2: ::core::ffi::c_int = 0 as ::core::ffi::c_int;
                while i_2 < 2 as ::core::ffi::c_int {
                    let mut b_changed: ::core::ffi::c_int = 1 as ::core::ffi::c_int;
                    (*h).sh.b_direct_spatial_mv_pred ^= 1 as ::core::ffi::c_int;
                    analysis.b_direct_available = x264_10_mb_predict_mv_direct16x16(
                        h,
                        if i_2 != 0 && analysis.b_direct_available != 0 {
                            &mut b_changed
                        } else {
                            0 as *mut ::core::ffi::c_int
                        },
                    );
                    if analysis.b_direct_available != 0 {
                        if b_changed != 0 {
                            x264_10_mb_mc(h);
                            b_skip_0 = x264_10_macroblock_probe_skip(h, 1 as ::core::ffi::c_int);
                        }
                        (*h).stat.frame.i_direct_score
                            [(*h).sh.b_direct_spatial_mv_pred as usize] += b_skip_0;
                    } else {
                        b_skip_0 = 0 as ::core::ffi::c_int;
                    }
                    i_2 += 1;
                }
            } else {
                analysis.b_direct_available =
                    x264_10_mb_predict_mv_direct16x16(h, 0 as *mut ::core::ffi::c_int);
            }
            analysis.b_try_skip = 0 as ::core::ffi::c_int;
            if analysis.b_direct_available != 0 {
                if (*h).mb.b_direct_auto_write == 0 {
                    x264_10_mb_mc(h);
                }
                if HAVE_INTERLACED != 0
                    && (*h).mb.b_interlaced == 0
                    && (*h).mb.i_mb_y * 16 as ::core::ffi::c_int >= (*h).param.i_height
                {
                    b_skip_0 = 1 as ::core::ffi::c_int;
                } else if analysis.i_mbrd != 0 {
                    i_bskip_cost = ssd_mb(h);
                    (*h).mb.b_skip_mc = (i_bskip_cost
                        <= 6 as ::core::ffi::c_int * analysis.i_lambda2 + 128 as ::core::ffi::c_int
                            >> 8 as ::core::ffi::c_int)
                        as ::core::ffi::c_int;
                    b_skip_0 = (*h).mb.b_skip_mc;
                } else if (*h).mb.b_direct_auto_write == 0 {
                    analysis.b_try_skip = x264_10_macroblock_probe_skip(h, 1 as ::core::ffi::c_int);
                    if (*h).param.analyse.i_subpel_refine < 3 as ::core::ffi::c_int {
                        b_skip_0 = analysis.b_try_skip;
                    }
                }
                if b_skip_0 != 0 {
                    let mut i_3: ::core::ffi::c_int = 0 as ::core::ffi::c_int;
                    while i_3 < (*h).mb.pic.i_fref[0 as ::core::ffi::c_int as usize] {
                        (*((*(*(*(*h)
                            .mb
                            .mvr
                            .as_mut_ptr()
                            .offset(0 as ::core::ffi::c_int as isize))
                        .as_mut_ptr()
                        .offset(i_3 as isize))
                        .offset((*h).mb.i_mb_xy as isize))
                        .as_mut_ptr() as *mut x264_union32_t))
                            .i = 0 as uint32_t;
                        i_3 += 1;
                    }
                    let mut i_4: ::core::ffi::c_int = 0 as ::core::ffi::c_int;
                    while i_4 < (*h).mb.pic.i_fref[1 as ::core::ffi::c_int as usize] {
                        (*((*(*(*(*h)
                            .mb
                            .mvr
                            .as_mut_ptr()
                            .offset(1 as ::core::ffi::c_int as isize))
                        .as_mut_ptr()
                        .offset(i_4 as isize))
                        .offset((*h).mb.i_mb_xy as isize))
                        .as_mut_ptr() as *mut x264_union32_t))
                            .i = 0 as uint32_t;
                        i_4 += 1;
                    }
                }
            }
            if b_skip_0 == 0 {
                let flags_0: ::core::ffi::c_uint = (*h).param.analyse.inter;
                let mut i_type_0: ::core::ffi::c_int = 0;
                let mut i_partition_0: ::core::ffi::c_int = 0;
                let mut i_satd_inter_0: ::core::ffi::c_int = 0;
                (*h).mb.b_skip_mc = 0 as ::core::ffi::c_int;
                (*h).mb.i_type = B_DIRECT as ::core::ffi::c_int;
                mb_analyse_load_costs(h, &mut analysis);
                if analysis.b_direct_available != 0 {
                    mb_analyse_inter_direct(h, &mut analysis);
                }
                mb_analyse_inter_b16x16(h, &mut analysis);
                if (*h).mb.i_type == B_SKIP as ::core::ffi::c_int {
                    let mut i_5: ::core::ffi::c_int = 1 as ::core::ffi::c_int;
                    while i_5 < (*h).mb.pic.i_fref[0 as ::core::ffi::c_int as usize] {
                        (*((*(*(*(*h)
                            .mb
                            .mvr
                            .as_mut_ptr()
                            .offset(0 as ::core::ffi::c_int as isize))
                        .as_mut_ptr()
                        .offset(i_5 as isize))
                        .offset((*h).mb.i_mb_xy as isize))
                        .as_mut_ptr() as *mut x264_union32_t))
                            .i = 0 as uint32_t;
                        i_5 += 1;
                    }
                    let mut i_6: ::core::ffi::c_int = 1 as ::core::ffi::c_int;
                    while i_6 < (*h).mb.pic.i_fref[1 as ::core::ffi::c_int as usize] {
                        (*((*(*(*(*h)
                            .mb
                            .mvr
                            .as_mut_ptr()
                            .offset(1 as ::core::ffi::c_int as isize))
                        .as_mut_ptr()
                        .offset(i_6 as isize))
                        .offset((*h).mb.i_mb_xy as isize))
                        .as_mut_ptr() as *mut x264_union32_t))
                            .i = 0 as uint32_t;
                        i_6 += 1;
                    }
                    return;
                }
                i_type_0 = B_L0_L0 as ::core::ffi::c_int;
                i_partition_0 = D_16x16 as ::core::ffi::c_int;
                i_cost = analysis.l0.me16x16.cost;
                if analysis.l1.me16x16.cost < i_cost {
                    i_cost = analysis.l1.me16x16.cost;
                    i_type_0 = B_L1_L1 as ::core::ffi::c_int;
                }
                if analysis.i_cost16x16bi < i_cost {
                    i_cost = analysis.i_cost16x16bi;
                    i_type_0 = B_BI_BI as ::core::ffi::c_int;
                }
                if analysis.i_cost16x16direct < i_cost {
                    i_cost = analysis.i_cost16x16direct;
                    i_type_0 = B_DIRECT as ::core::ffi::c_int;
                }
                if analysis.i_mbrd != 0
                    && analysis.b_early_terminate != 0
                    && analysis.i_cost16x16direct
                        <= i_cost * 33 as ::core::ffi::c_int / 32 as ::core::ffi::c_int
                {
                    mb_analyse_b_rd(h, &mut analysis, i_cost);
                    if i_bskip_cost < analysis.i_rd16x16direct
                        && i_bskip_cost < analysis.i_rd16x16bi
                        && i_bskip_cost < analysis.l0.i_rd16x16
                        && i_bskip_cost < analysis.l1.i_rd16x16
                    {
                        (*h).mb.i_type = B_SKIP as ::core::ffi::c_int;
                        analyse_update_cache(h, &mut analysis);
                        return;
                    }
                }
                if flags_0 & X264_ANALYSE_BSUB16x16 != 0 {
                    if (*h).param.analyse.b_mixed_references != 0 {
                        mb_analyse_inter_b8x8_mixed_ref(h, &mut analysis);
                    } else {
                        mb_analyse_inter_b8x8(h, &mut analysis);
                    }
                    if analysis.i_cost8x8bi < i_cost {
                        i_cost = analysis.i_cost8x8bi;
                        i_type_0 = B_8x8 as ::core::ffi::c_int;
                        i_partition_0 = D_8x8 as ::core::ffi::c_int;
                    }
                    let mut i_cost_est16x8bi_total: ::core::ffi::c_int = 0 as ::core::ffi::c_int;
                    let mut i_cost_est8x16bi_total: ::core::ffi::c_int = 0 as ::core::ffi::c_int;
                    let mut i_mb_type: ::core::ffi::c_int = 0;
                    let mut i_partition16x8: [::core::ffi::c_int; 2] = [0; 2];
                    let mut i_partition8x16: [::core::ffi::c_int; 2] = [0; 2];
                    let mut i_7: ::core::ffi::c_int = 0 as ::core::ffi::c_int;
                    while i_7 < 2 as ::core::ffi::c_int {
                        let mut avg_l0_mv_ref_cost: ::core::ffi::c_int = 0;
                        let mut avg_l1_mv_ref_cost: ::core::ffi::c_int = 0;
                        let mut i_l0_satd: ::core::ffi::c_int = 0;
                        let mut i_l1_satd: ::core::ffi::c_int = 0;
                        let mut i_bi_satd: ::core::ffi::c_int = 0;
                        let mut i_best_cost: ::core::ffi::c_int = 0;
                        i_best_cost = COST_MAX;
                        i_l0_satd = analysis.i_satd8x8[0 as ::core::ffi::c_int as usize]
                            [(i_7 * 2 as ::core::ffi::c_int) as usize]
                            + analysis.i_satd8x8[0 as ::core::ffi::c_int as usize][(i_7
                                * 2 as ::core::ffi::c_int
                                + 1 as ::core::ffi::c_int)
                                as usize];
                        i_l1_satd = analysis.i_satd8x8[1 as ::core::ffi::c_int as usize]
                            [(i_7 * 2 as ::core::ffi::c_int) as usize]
                            + analysis.i_satd8x8[1 as ::core::ffi::c_int as usize][(i_7
                                * 2 as ::core::ffi::c_int
                                + 1 as ::core::ffi::c_int)
                                as usize];
                        i_bi_satd = analysis.i_satd8x8[2 as ::core::ffi::c_int as usize]
                            [(i_7 * 2 as ::core::ffi::c_int) as usize]
                            + analysis.i_satd8x8[2 as ::core::ffi::c_int as usize][(i_7
                                * 2 as ::core::ffi::c_int
                                + 1 as ::core::ffi::c_int)
                                as usize];
                        avg_l0_mv_ref_cost =
                            analysis.l0.me8x8[(i_7 * 2 as ::core::ffi::c_int) as usize].cost_mv
                                + analysis.l0.me8x8[(i_7 * 2 as ::core::ffi::c_int) as usize]
                                    .i_ref_cost
                                + analysis.l0.me8x8[(i_7 * 2 as ::core::ffi::c_int
                                    + 1 as ::core::ffi::c_int)
                                    as usize]
                                    .cost_mv
                                + analysis.l0.me8x8[(i_7 * 2 as ::core::ffi::c_int
                                    + 1 as ::core::ffi::c_int)
                                    as usize]
                                    .i_ref_cost
                                + 1 as ::core::ffi::c_int
                                >> 1 as ::core::ffi::c_int;
                        avg_l1_mv_ref_cost =
                            analysis.l1.me8x8[(i_7 * 2 as ::core::ffi::c_int) as usize].cost_mv
                                + analysis.l1.me8x8[(i_7 * 2 as ::core::ffi::c_int) as usize]
                                    .i_ref_cost
                                + analysis.l1.me8x8[(i_7 * 2 as ::core::ffi::c_int
                                    + 1 as ::core::ffi::c_int)
                                    as usize]
                                    .cost_mv
                                + analysis.l1.me8x8[(i_7 * 2 as ::core::ffi::c_int
                                    + 1 as ::core::ffi::c_int)
                                    as usize]
                                    .i_ref_cost
                                + 1 as ::core::ffi::c_int
                                >> 1 as ::core::ffi::c_int;
                        if i_l0_satd + avg_l0_mv_ref_cost < i_best_cost {
                            i_best_cost = i_l0_satd + avg_l0_mv_ref_cost;
                            i_partition16x8[i_7 as usize] = D_L0_8x8 as ::core::ffi::c_int;
                        }
                        if i_l1_satd + avg_l1_mv_ref_cost < i_best_cost {
                            i_best_cost = i_l1_satd + avg_l1_mv_ref_cost;
                            i_partition16x8[i_7 as usize] = D_L1_8x8 as ::core::ffi::c_int;
                        }
                        if i_bi_satd + avg_l0_mv_ref_cost + avg_l1_mv_ref_cost < i_best_cost {
                            i_best_cost = i_bi_satd + avg_l0_mv_ref_cost + avg_l1_mv_ref_cost;
                            i_partition16x8[i_7 as usize] = D_BI_8x8 as ::core::ffi::c_int;
                        }
                        analysis.i_cost_est16x8[i_7 as usize] = i_best_cost;
                        i_best_cost = COST_MAX;
                        i_l0_satd = analysis.i_satd8x8[0 as ::core::ffi::c_int as usize]
                            [i_7 as usize]
                            + analysis.i_satd8x8[0 as ::core::ffi::c_int as usize]
                                [(i_7 + 2 as ::core::ffi::c_int) as usize];
                        i_l1_satd = analysis.i_satd8x8[1 as ::core::ffi::c_int as usize]
                            [i_7 as usize]
                            + analysis.i_satd8x8[1 as ::core::ffi::c_int as usize]
                                [(i_7 + 2 as ::core::ffi::c_int) as usize];
                        i_bi_satd = analysis.i_satd8x8[2 as ::core::ffi::c_int as usize]
                            [i_7 as usize]
                            + analysis.i_satd8x8[2 as ::core::ffi::c_int as usize]
                                [(i_7 + 2 as ::core::ffi::c_int) as usize];
                        avg_l0_mv_ref_cost = analysis.l0.me8x8[i_7 as usize].cost_mv
                            + analysis.l0.me8x8[i_7 as usize].i_ref_cost
                            + analysis.l0.me8x8[(i_7 + 2 as ::core::ffi::c_int) as usize].cost_mv
                            + analysis.l0.me8x8[(i_7 + 2 as ::core::ffi::c_int) as usize]
                                .i_ref_cost
                            + 1 as ::core::ffi::c_int
                            >> 1 as ::core::ffi::c_int;
                        avg_l1_mv_ref_cost = analysis.l1.me8x8[i_7 as usize].cost_mv
                            + analysis.l1.me8x8[i_7 as usize].i_ref_cost
                            + analysis.l1.me8x8[(i_7 + 2 as ::core::ffi::c_int) as usize].cost_mv
                            + analysis.l1.me8x8[(i_7 + 2 as ::core::ffi::c_int) as usize]
                                .i_ref_cost
                            + 1 as ::core::ffi::c_int
                            >> 1 as ::core::ffi::c_int;
                        if i_l0_satd + avg_l0_mv_ref_cost < i_best_cost {
                            i_best_cost = i_l0_satd + avg_l0_mv_ref_cost;
                            i_partition8x16[i_7 as usize] = D_L0_8x8 as ::core::ffi::c_int;
                        }
                        if i_l1_satd + avg_l1_mv_ref_cost < i_best_cost {
                            i_best_cost = i_l1_satd + avg_l1_mv_ref_cost;
                            i_partition8x16[i_7 as usize] = D_L1_8x8 as ::core::ffi::c_int;
                        }
                        if i_bi_satd + avg_l0_mv_ref_cost + avg_l1_mv_ref_cost < i_best_cost {
                            i_best_cost = i_bi_satd + avg_l0_mv_ref_cost + avg_l1_mv_ref_cost;
                            i_partition8x16[i_7 as usize] = D_BI_8x8 as ::core::ffi::c_int;
                        }
                        analysis.i_cost_est8x16[i_7 as usize] = i_best_cost;
                        i_7 += 1;
                    }
                    i_mb_type = B_L0_L0 as ::core::ffi::c_int
                        + (i_partition16x8[0 as ::core::ffi::c_int as usize]
                            >> 2 as ::core::ffi::c_int)
                            * 3 as ::core::ffi::c_int
                        + (i_partition16x8[1 as ::core::ffi::c_int as usize]
                            >> 2 as ::core::ffi::c_int);
                    analysis.i_cost_est16x8[1 as ::core::ffi::c_int as usize] += analysis.i_lambda
                        * i_mb_b16x8_cost_table[i_mb_type as usize] as ::core::ffi::c_int;
                    i_cost_est16x8bi_total = analysis.i_cost_est16x8
                        [0 as ::core::ffi::c_int as usize]
                        + analysis.i_cost_est16x8[1 as ::core::ffi::c_int as usize];
                    i_mb_type = B_L0_L0 as ::core::ffi::c_int
                        + (i_partition8x16[0 as ::core::ffi::c_int as usize]
                            >> 2 as ::core::ffi::c_int)
                            * 3 as ::core::ffi::c_int
                        + (i_partition8x16[1 as ::core::ffi::c_int as usize]
                            >> 2 as ::core::ffi::c_int);
                    analysis.i_cost_est8x16[1 as ::core::ffi::c_int as usize] += analysis.i_lambda
                        * i_mb_b16x8_cost_table[i_mb_type as usize] as ::core::ffi::c_int;
                    i_cost_est8x16bi_total = analysis.i_cost_est8x16
                        [0 as ::core::ffi::c_int as usize]
                        + analysis.i_cost_est8x16[1 as ::core::ffi::c_int as usize];
                    let mut try_16x8_first: ::core::ffi::c_int =
                        (i_cost_est16x8bi_total < i_cost_est8x16bi_total) as ::core::ffi::c_int;
                    if try_16x8_first != 0
                        && (analysis.b_early_terminate == 0 || i_cost_est16x8bi_total < i_cost)
                    {
                        mb_analyse_inter_b16x8(h, &mut analysis, i_cost);
                        if analysis.i_cost16x8bi < i_cost {
                            i_cost = analysis.i_cost16x8bi;
                            i_type_0 = analysis.i_mb_type16x8;
                            i_partition_0 = D_16x8 as ::core::ffi::c_int;
                        }
                    }
                    if analysis.b_early_terminate == 0 || i_cost_est8x16bi_total < i_cost {
                        mb_analyse_inter_b8x16(h, &mut analysis, i_cost);
                        if analysis.i_cost8x16bi < i_cost {
                            i_cost = analysis.i_cost8x16bi;
                            i_type_0 = analysis.i_mb_type8x16;
                            i_partition_0 = D_8x16 as ::core::ffi::c_int;
                        }
                    }
                    if try_16x8_first == 0
                        && (analysis.b_early_terminate == 0 || i_cost_est16x8bi_total < i_cost)
                    {
                        mb_analyse_inter_b16x8(h, &mut analysis, i_cost);
                        if analysis.i_cost16x8bi < i_cost {
                            i_cost = analysis.i_cost16x8bi;
                            i_type_0 = analysis.i_mb_type16x8;
                            i_partition_0 = D_16x8 as ::core::ffi::c_int;
                        }
                    }
                }
                if !(analysis.i_mbrd != 0 || (*h).mb.i_subpel_refine == 0) {
                    if i_partition_0 == D_16x16 as ::core::ffi::c_int {
                        analysis.l0.me16x16.cost -= analysis.i_lambda
                            * i_mb_b_cost_table[B_L0_L0 as ::core::ffi::c_int as usize]
                                as ::core::ffi::c_int;
                        analysis.l1.me16x16.cost -= analysis.i_lambda
                            * i_mb_b_cost_table[B_L1_L1 as ::core::ffi::c_int as usize]
                                as ::core::ffi::c_int;
                        if i_type_0 == B_L0_L0 as ::core::ffi::c_int {
                            x264_10_me_refine_qpel(h, &mut analysis.l0.me16x16);
                            i_cost = analysis.l0.me16x16.cost
                                + analysis.i_lambda
                                    * i_mb_b_cost_table[B_L0_L0 as ::core::ffi::c_int as usize]
                                        as ::core::ffi::c_int;
                        } else if i_type_0 == B_L1_L1 as ::core::ffi::c_int {
                            x264_10_me_refine_qpel(h, &mut analysis.l1.me16x16);
                            i_cost = analysis.l1.me16x16.cost
                                + analysis.i_lambda
                                    * i_mb_b_cost_table[B_L1_L1 as ::core::ffi::c_int as usize]
                                        as ::core::ffi::c_int;
                        } else if i_type_0 == B_BI_BI as ::core::ffi::c_int {
                            x264_10_me_refine_qpel(h, &mut analysis.l0.bi16x16);
                            x264_10_me_refine_qpel(h, &mut analysis.l1.bi16x16);
                        }
                    } else if i_partition_0 == D_16x8 as ::core::ffi::c_int {
                        let mut i_8: ::core::ffi::c_int = 0 as ::core::ffi::c_int;
                        while i_8 < 2 as ::core::ffi::c_int {
                            if analysis.i_mb_partition16x8[i_8 as usize]
                                != D_L1_8x8 as ::core::ffi::c_int
                            {
                                x264_10_me_refine_qpel(
                                    h,
                                    &mut *analysis.l0.me16x8.as_mut_ptr().offset(i_8 as isize),
                                );
                            }
                            if analysis.i_mb_partition16x8[i_8 as usize]
                                != D_L0_8x8 as ::core::ffi::c_int
                            {
                                x264_10_me_refine_qpel(
                                    h,
                                    &mut *analysis.l1.me16x8.as_mut_ptr().offset(i_8 as isize),
                                );
                            }
                            i_8 += 1;
                        }
                    } else if i_partition_0 == D_8x16 as ::core::ffi::c_int {
                        let mut i_9: ::core::ffi::c_int = 0 as ::core::ffi::c_int;
                        while i_9 < 2 as ::core::ffi::c_int {
                            if analysis.i_mb_partition8x16[i_9 as usize]
                                != D_L1_8x8 as ::core::ffi::c_int
                            {
                                x264_10_me_refine_qpel(
                                    h,
                                    &mut *analysis.l0.me8x16.as_mut_ptr().offset(i_9 as isize),
                                );
                            }
                            if analysis.i_mb_partition8x16[i_9 as usize]
                                != D_L0_8x8 as ::core::ffi::c_int
                            {
                                x264_10_me_refine_qpel(
                                    h,
                                    &mut *analysis.l1.me8x16.as_mut_ptr().offset(i_9 as isize),
                                );
                            }
                            i_9 += 1;
                        }
                    } else if i_partition_0 == D_8x8 as ::core::ffi::c_int {
                        let mut i_10: ::core::ffi::c_int = 0 as ::core::ffi::c_int;
                        while i_10 < 4 as ::core::ffi::c_int {
                            let mut m: *mut x264_me_t = 0 as *mut x264_me_t;
                            let mut i_part_cost_old: ::core::ffi::c_int = 0;
                            let mut i_type_cost: ::core::ffi::c_int = 0;
                            let mut i_part_type: ::core::ffi::c_int =
                                (*h).mb.i_sub_partition[i_10 as usize] as ::core::ffi::c_int;
                            let mut b_bidir: ::core::ffi::c_int = (i_part_type
                                == D_BI_8x8 as ::core::ffi::c_int)
                                as ::core::ffi::c_int;
                            if !(i_part_type == D_DIRECT_8x8 as ::core::ffi::c_int) {
                                if x264_mb_partition_listX_table[0 as ::core::ffi::c_int as usize]
                                    [i_part_type as usize]
                                    != 0
                                {
                                    m = &mut *analysis.l0.me8x8.as_mut_ptr().offset(i_10 as isize)
                                        as *mut x264_me_t;
                                    i_part_cost_old = (*m).cost;
                                    i_type_cost = analysis.i_lambda
                                        * i_sub_mb_b_cost_table
                                            [D_L0_8x8 as ::core::ffi::c_int as usize]
                                            as ::core::ffi::c_int;
                                    (*m).cost -= i_type_cost;
                                    x264_10_me_refine_qpel(h, m);
                                    if b_bidir == 0 {
                                        analysis.i_cost8x8bi +=
                                            (*m).cost + i_type_cost - i_part_cost_old;
                                    }
                                }
                                if x264_mb_partition_listX_table[1 as ::core::ffi::c_int as usize]
                                    [i_part_type as usize]
                                    != 0
                                {
                                    m = &mut *analysis.l1.me8x8.as_mut_ptr().offset(i_10 as isize)
                                        as *mut x264_me_t;
                                    i_part_cost_old = (*m).cost;
                                    i_type_cost = analysis.i_lambda
                                        * i_sub_mb_b_cost_table
                                            [D_L1_8x8 as ::core::ffi::c_int as usize]
                                            as ::core::ffi::c_int;
                                    (*m).cost -= i_type_cost;
                                    x264_10_me_refine_qpel(h, m);
                                    if b_bidir == 0 {
                                        analysis.i_cost8x8bi +=
                                            (*m).cost + i_type_cost - i_part_cost_old;
                                    }
                                }
                            }
                            i_10 += 1;
                        }
                    }
                }
                i_satd_inter_0 = i_cost;
                if analysis.i_mbrd != 0 {
                    mb_analyse_b_rd(h, &mut analysis, i_satd_inter_0);
                    i_type_0 = B_SKIP as ::core::ffi::c_int;
                    i_cost = i_bskip_cost;
                    i_partition_0 = D_16x16 as ::core::ffi::c_int;
                    if analysis.l0.i_rd16x16 < i_cost {
                        i_cost = analysis.l0.i_rd16x16;
                        i_type_0 = B_L0_L0 as ::core::ffi::c_int;
                    }
                    if analysis.l1.i_rd16x16 < i_cost {
                        i_cost = analysis.l1.i_rd16x16;
                        i_type_0 = B_L1_L1 as ::core::ffi::c_int;
                    }
                    if analysis.i_rd16x16bi < i_cost {
                        i_cost = analysis.i_rd16x16bi;
                        i_type_0 = B_BI_BI as ::core::ffi::c_int;
                    }
                    if analysis.i_rd16x16direct < i_cost {
                        i_cost = analysis.i_rd16x16direct;
                        i_type_0 = B_DIRECT as ::core::ffi::c_int;
                    }
                    if analysis.i_rd16x8bi < i_cost {
                        i_cost = analysis.i_rd16x8bi;
                        i_type_0 = analysis.i_mb_type16x8;
                        i_partition_0 = D_16x8 as ::core::ffi::c_int;
                    }
                    if analysis.i_rd8x16bi < i_cost {
                        i_cost = analysis.i_rd8x16bi;
                        i_type_0 = analysis.i_mb_type8x16;
                        i_partition_0 = D_8x16 as ::core::ffi::c_int;
                    }
                    if analysis.i_rd8x8bi < i_cost {
                        i_cost = analysis.i_rd8x8bi;
                        i_type_0 = B_8x8 as ::core::ffi::c_int;
                        i_partition_0 = D_8x8 as ::core::ffi::c_int;
                    }
                    (*h).mb.i_type = i_type_0;
                    (*h).mb.i_partition = i_partition_0;
                }
                if (*h).mb.b_chroma_me != 0 {
                    if (*(*h).sps.as_mut_ptr()).i_chroma_format_idc
                        == CHROMA_444 as ::core::ffi::c_int
                    {
                        mb_analyse_intra(h, &mut analysis, i_satd_inter_0);
                        mb_analyse_intra_chroma(h, &mut analysis);
                    } else {
                        mb_analyse_intra_chroma(h, &mut analysis);
                        mb_analyse_intra(h, &mut analysis, i_satd_inter_0 - analysis.i_satd_chroma);
                    }
                    analysis.i_satd_i16x16 += analysis.i_satd_chroma;
                    analysis.i_satd_i8x8 += analysis.i_satd_chroma;
                    analysis.i_satd_i4x4 += analysis.i_satd_chroma;
                } else {
                    mb_analyse_intra(h, &mut analysis, i_satd_inter_0);
                }
                if analysis.i_mbrd != 0 {
                    mb_analyse_transform_rd(h, &mut analysis, &mut i_satd_inter_0, &mut i_cost);
                    intra_rd(
                        h,
                        &mut analysis,
                        i_satd_inter_0 * 17 as ::core::ffi::c_int / 16 as ::core::ffi::c_int
                            + 1 as ::core::ffi::c_int,
                    );
                }
                if analysis.i_satd_i16x16 < i_cost {
                    i_cost = analysis.i_satd_i16x16;
                    i_type_0 = I_16x16 as ::core::ffi::c_int;
                }
                if analysis.i_satd_i8x8 < i_cost {
                    i_cost = analysis.i_satd_i8x8;
                    i_type_0 = I_8x8 as ::core::ffi::c_int;
                }
                if analysis.i_satd_i4x4 < i_cost {
                    i_cost = analysis.i_satd_i4x4;
                    i_type_0 = I_4x4 as ::core::ffi::c_int;
                }
                if analysis.i_satd_pcm < i_cost {
                    i_cost = analysis.i_satd_pcm;
                    i_type_0 = I_PCM as ::core::ffi::c_int;
                }
                (*h).mb.i_type = i_type_0;
                (*h).mb.i_partition = i_partition_0;
                if analysis.i_mbrd >= 2 as ::core::ffi::c_int
                    && (i_type_0 == I_4x4 as ::core::ffi::c_int
                        || i_type_0 == I_8x8 as ::core::ffi::c_int
                        || i_type_0 == I_16x16 as ::core::ffi::c_int
                        || i_type_0 == I_PCM as ::core::ffi::c_int)
                    && i_type_0 != I_PCM as ::core::ffi::c_int
                {
                    intra_rd_refine(h, &mut analysis);
                }
                if (*h).mb.i_subpel_refine >= 5 as ::core::ffi::c_int {
                    refine_bidir(h, &mut analysis);
                }
                if analysis.i_mbrd >= 2 as ::core::ffi::c_int
                    && i_type_0 > B_DIRECT as ::core::ffi::c_int
                    && i_type_0 < B_SKIP as ::core::ffi::c_int
                {
                    let mut i_biweight: ::core::ffi::c_int = 0;
                    analyse_update_cache(h, &mut analysis);
                    if i_partition_0 == D_16x16 as ::core::ffi::c_int {
                        if i_type_0 == B_L0_L0 as ::core::ffi::c_int {
                            analysis.l0.me16x16.cost = i_cost;
                            x264_10_me_refine_qpel_rd(
                                h,
                                &mut analysis.l0.me16x16,
                                analysis.i_lambda2,
                                0 as ::core::ffi::c_int,
                                0 as ::core::ffi::c_int,
                            );
                        } else if i_type_0 == B_L1_L1 as ::core::ffi::c_int {
                            analysis.l1.me16x16.cost = i_cost;
                            x264_10_me_refine_qpel_rd(
                                h,
                                &mut analysis.l1.me16x16,
                                analysis.i_lambda2,
                                0 as ::core::ffi::c_int,
                                1 as ::core::ffi::c_int,
                            );
                        } else if i_type_0 == B_BI_BI as ::core::ffi::c_int {
                            i_biweight = (*(*h)
                                .mb
                                .bipred_weight
                                .offset(analysis.l0.bi16x16.i_ref as isize))
                                [analysis.l1.bi16x16.i_ref as usize]
                                as ::core::ffi::c_int;
                            x264_10_me_refine_bidir_rd(
                                h,
                                &mut analysis.l0.bi16x16,
                                &mut analysis.l1.bi16x16,
                                i_biweight,
                                0 as ::core::ffi::c_int,
                                analysis.i_lambda2,
                            );
                        }
                    } else if i_partition_0 == D_16x8 as ::core::ffi::c_int {
                        let mut i_11: ::core::ffi::c_int = 0 as ::core::ffi::c_int;
                        while i_11 < 2 as ::core::ffi::c_int {
                            (*h).mb.i_sub_partition[(i_11 * 2 as ::core::ffi::c_int
                                + 1 as ::core::ffi::c_int)
                                as usize] = analysis.i_mb_partition16x8[i_11 as usize] as uint8_t;
                            (*h).mb.i_sub_partition[(i_11 * 2 as ::core::ffi::c_int) as usize] =
                                (*h).mb.i_sub_partition[(i_11 * 2 as ::core::ffi::c_int
                                    + 1 as ::core::ffi::c_int)
                                    as usize];
                            if analysis.i_mb_partition16x8[i_11 as usize]
                                == D_L0_8x8 as ::core::ffi::c_int
                            {
                                x264_10_me_refine_qpel_rd(
                                    h,
                                    &mut *analysis.l0.me16x8.as_mut_ptr().offset(i_11 as isize),
                                    analysis.i_lambda2,
                                    i_11 * 8 as ::core::ffi::c_int,
                                    0 as ::core::ffi::c_int,
                                );
                            } else if analysis.i_mb_partition16x8[i_11 as usize]
                                == D_L1_8x8 as ::core::ffi::c_int
                            {
                                x264_10_me_refine_qpel_rd(
                                    h,
                                    &mut *analysis.l1.me16x8.as_mut_ptr().offset(i_11 as isize),
                                    analysis.i_lambda2,
                                    i_11 * 8 as ::core::ffi::c_int,
                                    1 as ::core::ffi::c_int,
                                );
                            } else if analysis.i_mb_partition16x8[i_11 as usize]
                                == D_BI_8x8 as ::core::ffi::c_int
                            {
                                i_biweight = (*(*h)
                                    .mb
                                    .bipred_weight
                                    .offset(analysis.l0.me16x8[i_11 as usize].i_ref as isize))
                                    [analysis.l1.me16x8[i_11 as usize].i_ref as usize]
                                    as ::core::ffi::c_int;
                                x264_10_me_refine_bidir_rd(
                                    h,
                                    &mut *analysis.l0.me16x8.as_mut_ptr().offset(i_11 as isize),
                                    &mut *analysis.l1.me16x8.as_mut_ptr().offset(i_11 as isize),
                                    i_biweight,
                                    i_11 * 2 as ::core::ffi::c_int,
                                    analysis.i_lambda2,
                                );
                            }
                            i_11 += 1;
                        }
                    } else if i_partition_0 == D_8x16 as ::core::ffi::c_int {
                        let mut i_12: ::core::ffi::c_int = 0 as ::core::ffi::c_int;
                        while i_12 < 2 as ::core::ffi::c_int {
                            (*h).mb.i_sub_partition[(i_12 + 2 as ::core::ffi::c_int) as usize] =
                                analysis.i_mb_partition8x16[i_12 as usize] as uint8_t;
                            (*h).mb.i_sub_partition[i_12 as usize] =
                                (*h).mb.i_sub_partition[(i_12 + 2 as ::core::ffi::c_int) as usize];
                            if analysis.i_mb_partition8x16[i_12 as usize]
                                == D_L0_8x8 as ::core::ffi::c_int
                            {
                                x264_10_me_refine_qpel_rd(
                                    h,
                                    &mut *analysis.l0.me8x16.as_mut_ptr().offset(i_12 as isize),
                                    analysis.i_lambda2,
                                    i_12 * 4 as ::core::ffi::c_int,
                                    0 as ::core::ffi::c_int,
                                );
                            } else if analysis.i_mb_partition8x16[i_12 as usize]
                                == D_L1_8x8 as ::core::ffi::c_int
                            {
                                x264_10_me_refine_qpel_rd(
                                    h,
                                    &mut *analysis.l1.me8x16.as_mut_ptr().offset(i_12 as isize),
                                    analysis.i_lambda2,
                                    i_12 * 4 as ::core::ffi::c_int,
                                    1 as ::core::ffi::c_int,
                                );
                            } else if analysis.i_mb_partition8x16[i_12 as usize]
                                == D_BI_8x8 as ::core::ffi::c_int
                            {
                                i_biweight = (*(*h)
                                    .mb
                                    .bipred_weight
                                    .offset(analysis.l0.me8x16[i_12 as usize].i_ref as isize))
                                    [analysis.l1.me8x16[i_12 as usize].i_ref as usize]
                                    as ::core::ffi::c_int;
                                x264_10_me_refine_bidir_rd(
                                    h,
                                    &mut *analysis.l0.me8x16.as_mut_ptr().offset(i_12 as isize),
                                    &mut *analysis.l1.me8x16.as_mut_ptr().offset(i_12 as isize),
                                    i_biweight,
                                    i_12,
                                    analysis.i_lambda2,
                                );
                            }
                            i_12 += 1;
                        }
                    } else if i_partition_0 == D_8x8 as ::core::ffi::c_int {
                        let mut i_13: ::core::ffi::c_int = 0 as ::core::ffi::c_int;
                        while i_13 < 4 as ::core::ffi::c_int {
                            if (*h).mb.i_sub_partition[i_13 as usize] as ::core::ffi::c_int
                                == D_L0_8x8 as ::core::ffi::c_int
                            {
                                x264_10_me_refine_qpel_rd(
                                    h,
                                    &mut *analysis.l0.me8x8.as_mut_ptr().offset(i_13 as isize),
                                    analysis.i_lambda2,
                                    i_13 * 4 as ::core::ffi::c_int,
                                    0 as ::core::ffi::c_int,
                                );
                            } else if (*h).mb.i_sub_partition[i_13 as usize] as ::core::ffi::c_int
                                == D_L1_8x8 as ::core::ffi::c_int
                            {
                                x264_10_me_refine_qpel_rd(
                                    h,
                                    &mut *analysis.l1.me8x8.as_mut_ptr().offset(i_13 as isize),
                                    analysis.i_lambda2,
                                    i_13 * 4 as ::core::ffi::c_int,
                                    1 as ::core::ffi::c_int,
                                );
                            } else if (*h).mb.i_sub_partition[i_13 as usize] as ::core::ffi::c_int
                                == D_BI_8x8 as ::core::ffi::c_int
                            {
                                i_biweight = (*(*h)
                                    .mb
                                    .bipred_weight
                                    .offset(analysis.l0.me8x8[i_13 as usize].i_ref as isize))
                                    [analysis.l1.me8x8[i_13 as usize].i_ref as usize]
                                    as ::core::ffi::c_int;
                                x264_10_me_refine_bidir_rd(
                                    h,
                                    &mut *analysis.l0.me8x8.as_mut_ptr().offset(i_13 as isize),
                                    &mut *analysis.l1.me8x8.as_mut_ptr().offset(i_13 as isize),
                                    i_biweight,
                                    i_13,
                                    analysis.i_lambda2,
                                );
                            }
                            i_13 += 1;
                        }
                    }
                }
            }
        }
        current_block = 17193116482801528934;
    }
    match current_block {
        3870634877451421603 => {
            if analysis.i_mbrd != 0 {
                mb_init_fenc_cache(
                    h,
                    (analysis.i_mbrd >= 2 as ::core::ffi::c_int) as ::core::ffi::c_int,
                );
            }
            mb_analyse_intra(h, &mut analysis, COST_MAX);
            if analysis.i_mbrd != 0 {
                intra_rd(h, &mut analysis, COST_MAX);
            }
            i_cost = analysis.i_satd_i16x16;
            (*h).mb.i_type = I_16x16 as ::core::ffi::c_int;
            if analysis.i_satd_i4x4 < i_cost {
                i_cost = analysis.i_satd_i4x4;
                (*h).mb.i_type = I_4x4 as ::core::ffi::c_int;
            }
            if analysis.i_satd_i8x8 < i_cost {
                i_cost = analysis.i_satd_i8x8;
                (*h).mb.i_type = I_8x8 as ::core::ffi::c_int;
            }
            if analysis.i_satd_pcm < i_cost {
                (*h).mb.i_type = I_PCM as ::core::ffi::c_int;
            } else if analysis.i_mbrd >= 2 as ::core::ffi::c_int {
                intra_rd_refine(h, &mut analysis);
            }
        }
        _ => {}
    }
    analyse_update_cache(h, &mut analysis);
    if analysis.i_mbrd >= 2 as ::core::ffi::c_int {
        static mut check_mv_lists: [uint8_t; 19] = [
            0,
            0,
            0,
            0,
            1 as ::core::ffi::c_int as uint8_t,
            0,
            0,
            0,
            1 as ::core::ffi::c_int as uint8_t,
            0,
            0,
            0,
            2 as ::core::ffi::c_int as uint8_t,
            0,
            0,
            0,
            0,
            0,
            0,
        ];
        let mut list: ::core::ffi::c_int =
            check_mv_lists[(*h).mb.i_type as usize] as ::core::ffi::c_int - 1 as ::core::ffi::c_int;
        if list >= 0 as ::core::ffi::c_int
            && (*h).mb.i_partition != D_16x16 as ::core::ffi::c_int
            && (*(&mut *(*(*h).mb.cache.mv.as_mut_ptr().offset(list as isize))
                .as_mut_ptr()
                .offset(*x264_scan8.as_ptr().offset(0 as ::core::ffi::c_int as isize) as isize)
                as *mut [int16_t; 2] as *mut x264_union32_t))
                .i
                == (*(&mut *(*(*h).mb.cache.mv.as_mut_ptr().offset(list as isize))
                    .as_mut_ptr()
                    .offset(
                        *x264_scan8
                            .as_ptr()
                            .offset(12 as ::core::ffi::c_int as isize)
                            as isize,
                    ) as *mut [int16_t; 2] as *mut x264_union32_t))
                    .i
            && (*h).mb.cache.ref_0[list as usize]
                [x264_scan8[0 as ::core::ffi::c_int as usize] as usize]
                as ::core::ffi::c_int
                == (*h).mb.cache.ref_0[list as usize]
                    [x264_scan8[12 as ::core::ffi::c_int as usize] as usize]
                    as ::core::ffi::c_int
        {
            (*h).mb.i_partition = D_16x16 as ::core::ffi::c_int;
        }
    }
    if analysis.i_mbrd == 0 {
        mb_analyse_transform(h);
    }
    if analysis.i_mbrd == 3 as ::core::ffi::c_int
        && !((*h).mb.i_type == P_SKIP as ::core::ffi::c_int
            || (*h).mb.i_type == B_SKIP as ::core::ffi::c_int)
    {
        mb_analyse_qp_rd(h, &mut analysis);
    }
    (*h).mb.b_trellis = (*h).param.analyse.i_trellis;
    (*h).mb.b_noise_reduction = ((*h).mb.b_noise_reduction != 0
        || (*h).param.analyse.i_noise_reduction != 0
            && !((*h).mb.i_type == I_4x4 as ::core::ffi::c_int
                || (*h).mb.i_type == I_8x8 as ::core::ffi::c_int
                || (*h).mb.i_type == I_16x16 as ::core::ffi::c_int
                || (*h).mb.i_type == I_PCM as ::core::ffi::c_int))
        as ::core::ffi::c_int;
    if !((*h).mb.i_type == P_SKIP as ::core::ffi::c_int
        || (*h).mb.i_type == B_SKIP as ::core::ffi::c_int)
        && (*h).mb.i_psy_trellis != 0
        && (*h).param.analyse.i_trellis == 1 as ::core::ffi::c_int
    {
        psy_trellis_init(h, 0 as ::core::ffi::c_int);
    }
    if (*h).mb.b_trellis == 1 as ::core::ffi::c_int || (*h).mb.b_noise_reduction != 0 {
        (*h).mb.i_skip_intra = 0 as ::core::ffi::c_int;
    }
}
#[c2rust::src_loc = "3734:1"]
unsafe extern "C" fn analyse_update_cache(mut h: *mut x264_t, mut a: *mut x264_mb_analysis_t) {
    match (*h).mb.i_type {
        0 => {
            let mut i: ::core::ffi::c_int = 0 as ::core::ffi::c_int;
            while i < 16 as ::core::ffi::c_int {
                (*h).mb.cache.intra4x4_pred_mode[x264_scan8[i as usize] as usize] =
                    (*a).i_predict4x4[i as usize] as int8_t;
                i += 1;
            }
            mb_analyse_intra_chroma(h, a);
        }
        1 => {
            let mut i_0: ::core::ffi::c_int = 0 as ::core::ffi::c_int;
            while i_0 < 4 as ::core::ffi::c_int {
                x264_macroblock_cache_intra8x8_pred(
                    h,
                    2 as ::core::ffi::c_int * (i_0 & 1 as ::core::ffi::c_int),
                    2 as ::core::ffi::c_int * (i_0 >> 1 as ::core::ffi::c_int),
                    (*a).i_predict8x8[i_0 as usize],
                );
                i_0 += 1;
            }
            mb_analyse_intra_chroma(h, a);
        }
        2 => {
            (*h).mb.i_intra16x16_pred_mode = (*a).i_predict16x16;
            mb_analyse_intra_chroma(h, a);
        }
        3 => {}
        4 => match (*h).mb.i_partition {
            16 => {
                x264_macroblock_cache_ref(
                    h,
                    0 as ::core::ffi::c_int,
                    0 as ::core::ffi::c_int,
                    4 as ::core::ffi::c_int,
                    4 as ::core::ffi::c_int,
                    0 as ::core::ffi::c_int,
                    (*a).l0.me16x16.i_ref as int8_t,
                );
                x264_macroblock_cache_mv(
                    h,
                    0 as ::core::ffi::c_int,
                    0 as ::core::ffi::c_int,
                    4 as ::core::ffi::c_int,
                    4 as ::core::ffi::c_int,
                    0 as ::core::ffi::c_int,
                    (*((*a).l0.me16x16.mv.as_mut_ptr() as *mut x264_union32_t)).i,
                );
            }
            14 => {
                x264_macroblock_cache_ref(
                    h,
                    0 as ::core::ffi::c_int,
                    0 as ::core::ffi::c_int,
                    4 as ::core::ffi::c_int,
                    2 as ::core::ffi::c_int,
                    0 as ::core::ffi::c_int,
                    (*a).l0.me16x8[0 as ::core::ffi::c_int as usize].i_ref as int8_t,
                );
                x264_macroblock_cache_ref(
                    h,
                    0 as ::core::ffi::c_int,
                    2 as ::core::ffi::c_int,
                    4 as ::core::ffi::c_int,
                    2 as ::core::ffi::c_int,
                    0 as ::core::ffi::c_int,
                    (*a).l0.me16x8[1 as ::core::ffi::c_int as usize].i_ref as int8_t,
                );
                x264_macroblock_cache_mv(
                    h,
                    0 as ::core::ffi::c_int,
                    0 as ::core::ffi::c_int,
                    4 as ::core::ffi::c_int,
                    2 as ::core::ffi::c_int,
                    0 as ::core::ffi::c_int,
                    (*((*(*a)
                        .l0
                        .me16x8
                        .as_mut_ptr()
                        .offset(0 as ::core::ffi::c_int as isize))
                    .mv
                    .as_mut_ptr() as *mut x264_union32_t))
                        .i,
                );
                x264_macroblock_cache_mv(
                    h,
                    0 as ::core::ffi::c_int,
                    2 as ::core::ffi::c_int,
                    4 as ::core::ffi::c_int,
                    2 as ::core::ffi::c_int,
                    0 as ::core::ffi::c_int,
                    (*((*(*a)
                        .l0
                        .me16x8
                        .as_mut_ptr()
                        .offset(1 as ::core::ffi::c_int as isize))
                    .mv
                    .as_mut_ptr() as *mut x264_union32_t))
                        .i,
                );
            }
            15 => {
                x264_macroblock_cache_ref(
                    h,
                    0 as ::core::ffi::c_int,
                    0 as ::core::ffi::c_int,
                    2 as ::core::ffi::c_int,
                    4 as ::core::ffi::c_int,
                    0 as ::core::ffi::c_int,
                    (*a).l0.me8x16[0 as ::core::ffi::c_int as usize].i_ref as int8_t,
                );
                x264_macroblock_cache_ref(
                    h,
                    2 as ::core::ffi::c_int,
                    0 as ::core::ffi::c_int,
                    2 as ::core::ffi::c_int,
                    4 as ::core::ffi::c_int,
                    0 as ::core::ffi::c_int,
                    (*a).l0.me8x16[1 as ::core::ffi::c_int as usize].i_ref as int8_t,
                );
                x264_macroblock_cache_mv(
                    h,
                    0 as ::core::ffi::c_int,
                    0 as ::core::ffi::c_int,
                    2 as ::core::ffi::c_int,
                    4 as ::core::ffi::c_int,
                    0 as ::core::ffi::c_int,
                    (*((*(*a)
                        .l0
                        .me8x16
                        .as_mut_ptr()
                        .offset(0 as ::core::ffi::c_int as isize))
                    .mv
                    .as_mut_ptr() as *mut x264_union32_t))
                        .i,
                );
                x264_macroblock_cache_mv(
                    h,
                    2 as ::core::ffi::c_int,
                    0 as ::core::ffi::c_int,
                    2 as ::core::ffi::c_int,
                    4 as ::core::ffi::c_int,
                    0 as ::core::ffi::c_int,
                    (*((*(*a)
                        .l0
                        .me8x16
                        .as_mut_ptr()
                        .offset(1 as ::core::ffi::c_int as isize))
                    .mv
                    .as_mut_ptr() as *mut x264_union32_t))
                        .i,
                );
            }
            _ => {
                x264_10_log(
                    h,
                    X264_LOG_ERROR,
                    b"internal error P_L0 and partition=%d\n\0" as *const u8
                        as *const ::core::ffi::c_char,
                    (*h).mb.i_partition,
                );
            }
        },
        5 => {
            x264_macroblock_cache_ref(
                h,
                0 as ::core::ffi::c_int,
                0 as ::core::ffi::c_int,
                2 as ::core::ffi::c_int,
                2 as ::core::ffi::c_int,
                0 as ::core::ffi::c_int,
                (*a).l0.me8x8[0 as ::core::ffi::c_int as usize].i_ref as int8_t,
            );
            x264_macroblock_cache_ref(
                h,
                2 as ::core::ffi::c_int,
                0 as ::core::ffi::c_int,
                2 as ::core::ffi::c_int,
                2 as ::core::ffi::c_int,
                0 as ::core::ffi::c_int,
                (*a).l0.me8x8[1 as ::core::ffi::c_int as usize].i_ref as int8_t,
            );
            x264_macroblock_cache_ref(
                h,
                0 as ::core::ffi::c_int,
                2 as ::core::ffi::c_int,
                2 as ::core::ffi::c_int,
                2 as ::core::ffi::c_int,
                0 as ::core::ffi::c_int,
                (*a).l0.me8x8[2 as ::core::ffi::c_int as usize].i_ref as int8_t,
            );
            x264_macroblock_cache_ref(
                h,
                2 as ::core::ffi::c_int,
                2 as ::core::ffi::c_int,
                2 as ::core::ffi::c_int,
                2 as ::core::ffi::c_int,
                0 as ::core::ffi::c_int,
                (*a).l0.me8x8[3 as ::core::ffi::c_int as usize].i_ref as int8_t,
            );
            let mut i_1: ::core::ffi::c_int = 0 as ::core::ffi::c_int;
            while i_1 < 4 as ::core::ffi::c_int {
                mb_cache_mv_p8x8(h, a, i_1);
                i_1 += 1;
            }
        }
        6 => {
            (*h).mb.i_partition = D_16x16 as ::core::ffi::c_int;
            x264_macroblock_cache_ref(
                h,
                0 as ::core::ffi::c_int,
                0 as ::core::ffi::c_int,
                4 as ::core::ffi::c_int,
                4 as ::core::ffi::c_int,
                0 as ::core::ffi::c_int,
                0 as int8_t,
            );
            x264_macroblock_cache_mv(
                h,
                0 as ::core::ffi::c_int,
                0 as ::core::ffi::c_int,
                4 as ::core::ffi::c_int,
                4 as ::core::ffi::c_int,
                0 as ::core::ffi::c_int,
                (*((*h).mb.cache.pskip_mv.as_mut_ptr() as *mut x264_union32_t)).i,
            );
        }
        18 | 7 => {
            (*h).mb.i_partition = (*h).mb.cache.direct_partition;
            mb_load_mv_direct8x8(h, 0 as ::core::ffi::c_int);
            mb_load_mv_direct8x8(h, 1 as ::core::ffi::c_int);
            mb_load_mv_direct8x8(h, 2 as ::core::ffi::c_int);
            mb_load_mv_direct8x8(h, 3 as ::core::ffi::c_int);
        }
        17 => {
            let mut i_2: ::core::ffi::c_int = 0 as ::core::ffi::c_int;
            while i_2 < 4 as ::core::ffi::c_int {
                mb_cache_mv_b8x8(h, a, i_2, 1 as ::core::ffi::c_int);
                i_2 += 1;
            }
        }
        _ => match (*h).mb.i_partition {
            16 => match (*h).mb.i_type {
                8 => {
                    x264_macroblock_cache_ref(
                        h,
                        0 as ::core::ffi::c_int,
                        0 as ::core::ffi::c_int,
                        4 as ::core::ffi::c_int,
                        4 as ::core::ffi::c_int,
                        0 as ::core::ffi::c_int,
                        (*a).l0.me16x16.i_ref as int8_t,
                    );
                    x264_macroblock_cache_mv(
                        h,
                        0 as ::core::ffi::c_int,
                        0 as ::core::ffi::c_int,
                        4 as ::core::ffi::c_int,
                        4 as ::core::ffi::c_int,
                        0 as ::core::ffi::c_int,
                        (*((*a).l0.me16x16.mv.as_mut_ptr() as *mut x264_union32_t)).i,
                    );
                    x264_macroblock_cache_ref(
                        h,
                        0 as ::core::ffi::c_int,
                        0 as ::core::ffi::c_int,
                        4 as ::core::ffi::c_int,
                        4 as ::core::ffi::c_int,
                        1 as ::core::ffi::c_int,
                        -(1 as ::core::ffi::c_int) as int8_t,
                    );
                    x264_macroblock_cache_mv(
                        h,
                        0 as ::core::ffi::c_int,
                        0 as ::core::ffi::c_int,
                        4 as ::core::ffi::c_int,
                        4 as ::core::ffi::c_int,
                        1 as ::core::ffi::c_int,
                        0 as uint32_t,
                    );
                    x264_macroblock_cache_mvd(
                        h,
                        0 as ::core::ffi::c_int,
                        0 as ::core::ffi::c_int,
                        4 as ::core::ffi::c_int,
                        4 as ::core::ffi::c_int,
                        1 as ::core::ffi::c_int,
                        0 as uint16_t,
                    );
                }
                12 => {
                    x264_macroblock_cache_ref(
                        h,
                        0 as ::core::ffi::c_int,
                        0 as ::core::ffi::c_int,
                        4 as ::core::ffi::c_int,
                        4 as ::core::ffi::c_int,
                        0 as ::core::ffi::c_int,
                        -(1 as ::core::ffi::c_int) as int8_t,
                    );
                    x264_macroblock_cache_mv(
                        h,
                        0 as ::core::ffi::c_int,
                        0 as ::core::ffi::c_int,
                        4 as ::core::ffi::c_int,
                        4 as ::core::ffi::c_int,
                        0 as ::core::ffi::c_int,
                        0 as uint32_t,
                    );
                    x264_macroblock_cache_mvd(
                        h,
                        0 as ::core::ffi::c_int,
                        0 as ::core::ffi::c_int,
                        4 as ::core::ffi::c_int,
                        4 as ::core::ffi::c_int,
                        0 as ::core::ffi::c_int,
                        0 as uint16_t,
                    );
                    x264_macroblock_cache_ref(
                        h,
                        0 as ::core::ffi::c_int,
                        0 as ::core::ffi::c_int,
                        4 as ::core::ffi::c_int,
                        4 as ::core::ffi::c_int,
                        1 as ::core::ffi::c_int,
                        (*a).l1.me16x16.i_ref as int8_t,
                    );
                    x264_macroblock_cache_mv(
                        h,
                        0 as ::core::ffi::c_int,
                        0 as ::core::ffi::c_int,
                        4 as ::core::ffi::c_int,
                        4 as ::core::ffi::c_int,
                        1 as ::core::ffi::c_int,
                        (*((*a).l1.me16x16.mv.as_mut_ptr() as *mut x264_union32_t)).i,
                    );
                }
                16 => {
                    x264_macroblock_cache_ref(
                        h,
                        0 as ::core::ffi::c_int,
                        0 as ::core::ffi::c_int,
                        4 as ::core::ffi::c_int,
                        4 as ::core::ffi::c_int,
                        0 as ::core::ffi::c_int,
                        (*a).l0.bi16x16.i_ref as int8_t,
                    );
                    x264_macroblock_cache_mv(
                        h,
                        0 as ::core::ffi::c_int,
                        0 as ::core::ffi::c_int,
                        4 as ::core::ffi::c_int,
                        4 as ::core::ffi::c_int,
                        0 as ::core::ffi::c_int,
                        (*((*a).l0.bi16x16.mv.as_mut_ptr() as *mut x264_union32_t)).i,
                    );
                    x264_macroblock_cache_ref(
                        h,
                        0 as ::core::ffi::c_int,
                        0 as ::core::ffi::c_int,
                        4 as ::core::ffi::c_int,
                        4 as ::core::ffi::c_int,
                        1 as ::core::ffi::c_int,
                        (*a).l1.bi16x16.i_ref as int8_t,
                    );
                    x264_macroblock_cache_mv(
                        h,
                        0 as ::core::ffi::c_int,
                        0 as ::core::ffi::c_int,
                        4 as ::core::ffi::c_int,
                        4 as ::core::ffi::c_int,
                        1 as ::core::ffi::c_int,
                        (*((*a).l1.bi16x16.mv.as_mut_ptr() as *mut x264_union32_t)).i,
                    );
                }
                _ => {}
            },
            14 => {
                mb_cache_mv_b16x8(h, a, 0 as ::core::ffi::c_int, 1 as ::core::ffi::c_int);
                mb_cache_mv_b16x8(h, a, 1 as ::core::ffi::c_int, 1 as ::core::ffi::c_int);
            }
            15 => {
                mb_cache_mv_b8x16(h, a, 0 as ::core::ffi::c_int, 1 as ::core::ffi::c_int);
                mb_cache_mv_b8x16(h, a, 1 as ::core::ffi::c_int, 1 as ::core::ffi::c_int);
            }
            _ => {
                x264_10_log(
                    h,
                    X264_LOG_ERROR,
                    b"internal error (invalid MB type)\n\0" as *const u8
                        as *const ::core::ffi::c_char,
                );
            }
        },
    }
    if (*h).i_thread_frames > 1 as ::core::ffi::c_int
        && !((*h).mb.i_type == I_4x4 as ::core::ffi::c_int
            || (*h).mb.i_type == I_8x8 as ::core::ffi::c_int
            || (*h).mb.i_type == I_16x16 as ::core::ffi::c_int
            || (*h).mb.i_type == I_PCM as ::core::ffi::c_int)
    {
        let mut l: ::core::ffi::c_int = 0 as ::core::ffi::c_int;
        while l <= ((*h).sh.i_type == SLICE_TYPE_B as ::core::ffi::c_int) as ::core::ffi::c_int {
            let mut completed: ::core::ffi::c_int = 0;
            let mut ref_0: ::core::ffi::c_int = (*h).mb.cache.ref_0[l as usize]
                [x264_scan8[0 as ::core::ffi::c_int as usize] as usize]
                as ::core::ffi::c_int;
            if !(ref_0 < 0 as ::core::ffi::c_int) {
                completed = x264_10_frame_cond_wait(
                    (*(*h).fref[l as usize][(ref_0 >> (*h).mb.b_interlaced) as usize]).orig
                        as *mut x264_frame_t,
                    -(1 as ::core::ffi::c_int),
                );
                if ((*h).mb.cache.mv[l as usize]
                    [x264_scan8[15 as ::core::ffi::c_int as usize] as usize]
                    [1 as ::core::ffi::c_int as usize] as ::core::ffi::c_int
                    >> 2 as ::core::ffi::c_int - (*h).mb.b_interlaced)
                    + (*h).mb.i_mb_y * 16 as ::core::ffi::c_int
                    > completed
                {
                    x264_10_log(
                        h,
                        X264_LOG_WARNING,
                        b"internal error (MV out of thread range)\n\0" as *const u8
                            as *const ::core::ffi::c_char,
                    );
                    x264_10_log(
                        h,
                        X264_LOG_DEBUG,
                        b"mb type: %d \n\0" as *const u8 as *const ::core::ffi::c_char,
                        (*h).mb.i_type,
                    );
                    x264_10_log(
                        h,
                        X264_LOG_DEBUG,
                        b"mv: l%dr%d (%d,%d) \n\0" as *const u8 as *const ::core::ffi::c_char,
                        l,
                        ref_0,
                        (*h).mb.cache.mv[l as usize]
                            [x264_scan8[15 as ::core::ffi::c_int as usize] as usize]
                            [0 as ::core::ffi::c_int as usize]
                            as ::core::ffi::c_int,
                        (*h).mb.cache.mv[l as usize]
                            [x264_scan8[15 as ::core::ffi::c_int as usize] as usize]
                            [1 as ::core::ffi::c_int as usize]
                            as ::core::ffi::c_int,
                    );
                    x264_10_log(
                        h,
                        X264_LOG_DEBUG,
                        b"limit: %d \n\0" as *const u8 as *const ::core::ffi::c_char,
                        (*h).mb.mv_max_spel[1 as ::core::ffi::c_int as usize],
                    );
                    x264_10_log(
                        h,
                        X264_LOG_DEBUG,
                        b"mb_xy: %d,%d \n\0" as *const u8 as *const ::core::ffi::c_char,
                        (*h).mb.i_mb_x,
                        (*h).mb.i_mb_y,
                    );
                    x264_10_log(
                        h,
                        X264_LOG_DEBUG,
                        b"completed: %d \n\0" as *const u8 as *const ::core::ffi::c_char,
                        completed,
                    );
                    x264_10_log(
                        h,
                        X264_LOG_WARNING,
                        b"recovering by using intra mode\n\0" as *const u8
                            as *const ::core::ffi::c_char,
                    );
                    mb_analyse_intra(h, a, COST_MAX);
                    (*h).mb.i_type = I_16x16 as ::core::ffi::c_int;
                    (*h).mb.i_intra16x16_pred_mode = (*a).i_predict16x16;
                    mb_analyse_intra_chroma(h, a);
                }
            }
            l += 1;
        }
    }
}
