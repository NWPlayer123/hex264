#![allow(dead_code)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(unused_assignments)]
#![allow(unused_mut)]
#![feature(c_variadic)]
#![allow(internal_features)]
#![feature(core_intrinsics)]
#![feature(extern_types)]
#![feature(lint_reasons)]
#![feature(register_tool)]
// TODO: migrate to newer Rust version and remove this.
#![feature(let_chains)]
//#![feature(stdsimd)]
#![register_tool(c2rust)]
// This is meant to be pure Rust, eventually, shut up all complaints about Option<T>.
#![allow(improper_ctypes)]

#[macro_use]
extern crate c2rust_bitfields;
pub mod src {
    pub mod autocomplete;
    pub mod common {
        pub mod base;
        pub mod bitstream;
        pub mod cabac;
        pub mod common;
        pub mod cpu;
        pub mod dct;
        pub mod deblock;
        pub mod frame;
        pub mod macroblock;
        pub mod mc;
        pub mod mvpred;
        pub mod osdep;
        pub mod pixel;
        pub mod predict;
        pub mod quant;
        pub mod rectangle;
        pub mod set;
        pub mod tables;
        pub mod threadpool;
        pub mod vlc;
    } // mod common
    pub mod encoder {
        pub mod analyse;
        pub mod api;
        pub mod cabac;
        pub mod cavlc;
        pub mod encoder;
        pub mod lookahead;
        pub mod macroblock;
        pub mod me;
        pub mod ratecontrol;
        pub mod set;
    } // mod encoder
    pub mod filters {
        pub mod filters;
        pub mod video {
            pub mod cache;
            pub mod crop;
            pub mod depth;
            pub mod fix_vfr_pts;
            pub mod internal;
            pub mod resize;
            pub mod select_every;
            pub mod source;
            pub mod video;
        } // mod video
    } // mod filters
    pub mod input {
        pub mod avs;
        pub mod input;
        pub mod lavf;
        pub mod raw;
        pub mod thread;
        pub mod timecode;
        pub mod y4m;
    } // mod input
    pub mod output {
        pub mod flv;
        pub mod flv_bytestream;
        pub mod matroska;
        pub mod matroska_ebml;
        pub mod mp4_lsmash;
        pub mod raw;
    } // mod output
    pub mod x264;
} // mod src

#[c2rust::header_src = "internal:0"]
pub mod internal {
    use core::ffi::{c_int, c_uint, c_void};

    #[c2rust::src_loc = "0:0"]
    pub type __builtin_va_list = [__va_list_tag; 1];
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "0:0"]
    pub struct __va_list_tag {
        pub gp_offset: c_uint,
        pub fp_offset: c_uint,
        pub overflow_arg_area: *mut c_void,
        pub reg_save_area: *mut c_void,
    }
    #[c2rust::src_loc = "3:9"]
    pub const BIT_DEPTH: c_int = 10 as c_int;
    #[c2rust::src_loc = "61:9"]
    pub const __INT_MAX__: c_int = 2147483647 as c_int;
}
#[c2rust::header_src = "/usr/lib/clang/21/include/__stddef_size_t.h:37"]
pub mod __stddef_size_t_h {
    #[c2rust::src_loc = "18:1"]
    pub type size_t = usize;
}
#[c2rust::header_src = "/usr/lib/clang/21/include/__stdarg___gnuc_va_list.h:37"]
pub mod __stdarg___gnuc_va_list_h {
    #[c2rust::src_loc = "12:1"]
    pub type __gnuc_va_list = __builtin_va_list;
    use super::internal::__builtin_va_list;
}
#[c2rust::header_src = "/usr/include/bits/types.h:37"]
pub mod types_h {
    use ::core::ffi::{c_int, c_long, c_uint, c_ulong};

    #[c2rust::src_loc = "37:1"]
    pub type __int8_t = i8;
    #[c2rust::src_loc = "38:1"]
    pub type __uint8_t = u8;
    #[c2rust::src_loc = "39:1"]
    pub type __int16_t = i16;
    #[c2rust::src_loc = "40:1"]
    pub type __uint16_t = u16;
    #[c2rust::src_loc = "41:1"]
    pub type __int32_t = i32;
    #[c2rust::src_loc = "42:1"]
    pub type __uint32_t = u32;
    #[c2rust::src_loc = "44:1"]
    pub type __int64_t = i64;
    #[c2rust::src_loc = "45:1"]
    pub type __uint64_t = u64;
    #[c2rust::src_loc = "145:1"]
    pub type __dev_t = c_ulong;
    #[c2rust::src_loc = "146:1"]
    pub type __uid_t = c_uint;
    #[c2rust::src_loc = "147:1"]
    pub type __gid_t = c_uint;
    #[c2rust::src_loc = "148:1"]
    pub type __ino_t = c_ulong;
    #[c2rust::src_loc = "150:1"]
    pub type __mode_t = c_uint;
    #[c2rust::src_loc = "151:1"]
    pub type __nlink_t = c_ulong;
    #[c2rust::src_loc = "152:1"]
    pub type __off_t = c_long;
    #[c2rust::src_loc = "153:1"]
    pub type __off64_t = c_long;
    #[c2rust::src_loc = "154:1"]
    pub type __pid_t = c_int;
    #[c2rust::src_loc = "160:1"]
    pub type __time_t = c_long;
    #[c2rust::src_loc = "169:1"]
    pub type __clockid_t = c_int;
    #[c2rust::src_loc = "175:1"]
    pub type __blksize_t = c_long;
    #[c2rust::src_loc = "180:1"]
    pub type __blkcnt_t = c_long;
    #[c2rust::src_loc = "197:1"]
    pub type __syscall_slong_t = c_long;
}
#[c2rust::header_src = "/usr/include/bits/types/struct_FILE.h:37"]
pub mod struct_FILE_h {
    #[derive(Copy, Clone, BitfieldStruct)]
    #[repr(C)]
    #[c2rust::src_loc = "51:8"]
    pub struct _IO_FILE {
        pub _flags: c_int,
        pub _IO_read_ptr: *mut c_char,
        pub _IO_read_end: *mut c_char,
        pub _IO_read_base: *mut c_char,
        pub _IO_write_base: *mut c_char,
        pub _IO_write_ptr: *mut c_char,
        pub _IO_write_end: *mut c_char,
        pub _IO_buf_base: *mut c_char,
        pub _IO_buf_end: *mut c_char,
        pub _IO_save_base: *mut c_char,
        pub _IO_backup_base: *mut c_char,
        pub _IO_save_end: *mut c_char,
        pub _markers: *mut _IO_marker,
        pub _chain: *mut _IO_FILE,
        pub _fileno: c_int,
        #[bitfield(name = "_flags2", ty = "core::ffi::c_int", bits = "0..=23")]
        pub _flags2: [u8; 3],
        pub _short_backupbuf: [c_char; 1],
        pub _old_offset: __off_t,
        pub _cur_column: c_ushort,
        pub _vtable_offset: c_schar,
        pub _shortbuf: [c_char; 1],
        pub _lock: *mut c_void,
        pub _offset: __off64_t,
        pub _codecvt: *mut _IO_codecvt,
        pub _wide_data: *mut _IO_wide_data,
        pub _freeres_list: *mut _IO_FILE,
        pub _freeres_buf: *mut c_void,
        pub _prevchain: *mut *mut _IO_FILE,
        pub _mode: c_int,
        pub _unused3: c_int,
        pub _total_written: __uint64_t,
        pub _unused2: [c_char; 8],
    }
    #[c2rust::src_loc = "45:1"]
    pub type _IO_lock_t = ();
    use ::core::ffi::{c_char, c_int, c_schar, c_ushort, c_void};

    use super::types_h::{__off64_t, __off_t, __uint64_t};
    extern "C" {
        #[c2rust::src_loc = "40:8"]
        pub type _IO_wide_data;
        #[c2rust::src_loc = "39:8"]
        pub type _IO_codecvt;
        #[c2rust::src_loc = "38:8"]
        pub type _IO_marker;
    }
}
#[c2rust::header_src = "/usr/include/bits/types/FILE.h:37"]
pub mod FILE_h {
    #[c2rust::src_loc = "7:1"]
    pub type FILE = _IO_FILE;
    use super::struct_FILE_h::_IO_FILE;
}
#[c2rust::header_src = "/usr/include/stdio.h:37"]
pub mod stdio_h {
    #[c2rust::src_loc = "53:1"]
    pub type va_list = __gnuc_va_list;
    #[c2rust::src_loc = "105:9"]
    pub const EOF: c_int = -1;
    #[c2rust::src_loc = "110:9"]
    pub const SEEK_SET: c_int = 0 as c_int;
    use ::core::ffi::{c_char, c_int, c_ulong, c_void};

    use super::FILE_h::FILE;
    use super::__stdarg___gnuc_va_list_h::__gnuc_va_list;
    use super::types_h::__off64_t;
    extern "C" {
        #[c2rust::src_loc = "151:14"]
        pub static mut stderr: *mut FILE;
        #[c2rust::src_loc = "187:1"]
        pub fn fclose(__stream: *mut FILE) -> c_int;
        #[c2rust::src_loc = "239:1"]
        pub fn fflush(__stream: *mut FILE) -> c_int;
        #[c2rust::src_loc = "279:1"]
        pub fn fopen(__filename: *const c_char, __modes: *const c_char) -> *mut FILE;
        #[c2rust::src_loc = "360:1"]
        pub fn fprintf(__stream: *mut FILE, __format: *const c_char, ...) -> c_int;
        #[c2rust::src_loc = "366:1"]
        pub fn printf(__format: *const c_char, ...) -> c_int;
        #[c2rust::src_loc = "368:1"]
        pub fn sprintf(__s: *mut c_char, __format: *const c_char, ...) -> c_int;
        #[c2rust::src_loc = "375:1"]
        pub fn vfprintf(
            __s: *mut FILE,
            __format: *const c_char,
            __arg: ::core::ffi::VaList,
        ) -> c_int;
        #[c2rust::src_loc = "445:1"]
        pub fn fscanf(__stream: *mut FILE, __format: *const c_char, ...) -> c_int;
        #[c2rust::src_loc = "450:1"]
        pub fn sscanf(__s: *const c_char, __format: *const c_char, ...) -> c_int;
        #[c2rust::src_loc = "802:1"]
        pub fn fseeko(__stream: *mut FILE, __off: __off64_t, __whence: c_int) -> c_int;
        #[c2rust::src_loc = "805:1"]
        pub fn ftello(__stream: *mut FILE) -> __off64_t;
        #[c2rust::src_loc = "873:1"]
        pub fn fileno(__stream: *mut FILE) -> c_int;
    }
    use super::__stddef_size_t_h::size_t;
    extern "C" {
        #[c2rust::src_loc = "150:14"]
        pub static mut stdout: *mut FILE;
        #[c2rust::src_loc = "388:1"]
        pub fn snprintf(__s: *mut c_char, __maxlen: size_t, __format: *const c_char, ...) -> c_int;
        #[c2rust::src_loc = "612:1"]
        pub fn putc(__c: c_int, __stream: *mut FILE) -> c_int;
    }
    extern "C" {
        #[c2rust::src_loc = "735:1"]
        pub fn fwrite(__ptr: *const c_void, __size: size_t, __n: size_t, __s: *mut FILE)
            -> c_ulong;
    }
    #[c2rust::src_loc = "112:9"]
    pub const SEEK_END: c_int = 2 as c_int;
    extern "C" {
        #[c2rust::src_loc = "728:1"]
        pub fn fread(
            __ptr: *mut c_void,
            __size: size_t,
            __n: size_t,
            __stream: *mut FILE,
        ) -> c_ulong;
    }

    extern "C" {
        #[c2rust::src_loc = "160:1"]
        pub fn rename(__old: *const c_char, __new: *const c_char) -> c_int;
    }
    extern "C" {
        #[c2rust::src_loc = "149:14"]
        pub static mut stdin: *mut FILE;
    }

    extern "C" {
        #[c2rust::src_loc = "654:1"]
        pub fn fgets(__s: *mut c_char, __n: c_int, __stream: *mut FILE) -> *mut c_char;
    }

    extern "C" {
        #[c2rust::src_loc = "578:1"]
        pub fn fgetc(__stream: *mut FILE) -> c_int;
    }
}
#[c2rust::header_src = "/usr/include/bits/types/struct_timespec.h:37"]
pub mod struct_timespec_h {
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "11:8"]
    pub struct timespec {
        pub tv_sec: __time_t,
        pub tv_nsec: __syscall_slong_t,
    }
    use super::types_h::{__syscall_slong_t, __time_t};
}
#[c2rust::header_src = "/usr/include/bits/struct_stat.h:37"]
pub mod struct_stat_h {
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "26:8"]
    pub struct stat {
        pub st_dev: __dev_t,
        pub st_ino: __ino_t,
        pub st_nlink: __nlink_t,
        pub st_mode: __mode_t,
        pub st_uid: __uid_t,
        pub st_gid: __gid_t,
        pub __pad0: c_int,
        pub st_rdev: __dev_t,
        pub st_size: __off_t,
        pub st_blksize: __blksize_t,
        pub st_blocks: __blkcnt_t,
        pub st_atim: timespec,
        pub st_mtim: timespec,
        pub st_ctim: timespec,
        pub __glibc_reserved: [__syscall_slong_t; 3],
    }
    use ::core::ffi::c_int;

    use super::struct_timespec_h::timespec;
    use super::types_h::{
        __blkcnt_t, __blksize_t, __dev_t, __gid_t, __ino_t, __mode_t, __nlink_t, __off_t,
        __syscall_slong_t, __uid_t,
    };
}
#[c2rust::header_src = "/usr/include/bits/stdint-intn.h:37"]
pub mod stdint_intn_h {
    #[c2rust::src_loc = "24:1"]
    pub type int8_t = __int8_t;
    #[c2rust::src_loc = "25:1"]
    pub type int16_t = __int16_t;
    #[c2rust::src_loc = "26:1"]
    pub type int32_t = __int32_t;
    #[c2rust::src_loc = "27:1"]
    pub type int64_t = __int64_t;
    use super::types_h::{__int16_t, __int32_t, __int64_t, __int8_t};
}
#[c2rust::header_src = "/usr/include/bits/stdint-uintn.h:37"]
pub mod stdint_uintn_h {
    #[c2rust::src_loc = "24:1"]
    pub type uint8_t = __uint8_t;
    #[c2rust::src_loc = "25:1"]
    pub type uint16_t = __uint16_t;
    #[c2rust::src_loc = "26:1"]
    pub type uint32_t = __uint32_t;
    #[c2rust::src_loc = "27:1"]
    pub type uint64_t = __uint64_t;
    use super::types_h::{__uint16_t, __uint32_t, __uint64_t, __uint8_t};
}
#[c2rust::header_src = "/home/nwplayer123/Hacks/hex264/x264/x264.h:37"]
pub mod x264_h {
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "114:16"]
    pub struct x264_nal_t {
        pub i_ref_idc: c_int,
        pub i_type: c_int,
        pub b_long_startcode: c_int,
        pub i_first_mb: c_int,
        pub i_last_mb: c_int,
        pub i_payload: c_int,
        pub p_payload: *mut uint8_t,
        pub i_padding: c_int,
    }
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "306:16"]
    pub struct x264_zone_t {
        pub i_start: c_int,
        pub i_end: c_int,
        pub b_force_qp: c_int,
        pub i_qp: c_int,
        pub f_bitrate_factor: c_float,
        pub param: *mut x264_param_t,
    }
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "315:16"]
    pub struct x264_param_t {
        pub cpu: uint32_t,
        pub i_threads: c_int,
        pub i_lookahead_threads: c_int,
        pub b_sliced_threads: c_int,
        pub b_deterministic: c_int,
        pub b_cpu_independent: c_int,
        pub i_sync_lookahead: c_int,
        pub width: u32,
        pub height: u32,
        pub i_csp: c_int,
        pub i_bitdepth: c_int,
        pub i_level_idc: c_int,
        pub i_frame_total: c_int,
        pub i_nal_hrd: c_int,
        pub vui: C2RustUnnamed_4,
        pub i_frame_reference: c_int,
        pub i_dpb_size: c_int,
        pub i_keyint_max: c_int,
        pub i_keyint_min: c_int,
        pub i_scenecut_threshold: c_int,
        pub b_intra_refresh: c_int,
        pub i_bframe: c_int,
        pub i_bframe_adaptive: c_int,
        pub i_bframe_bias: c_int,
        pub i_bframe_pyramid: c_int,
        pub b_open_gop: c_int,
        pub b_bluray_compat: c_int,
        pub i_avcintra_class: c_int,
        pub i_avcintra_flavor: c_int,
        pub b_deblocking_filter: c_int,
        pub i_deblocking_filter_alphac0: c_int,
        pub i_deblocking_filter_beta: c_int,
        pub b_cabac: c_int,
        pub i_cabac_init_idc: c_int,
        pub b_interlaced: c_int,
        pub b_constrained_intra: c_int,
        pub i_cqm_preset: c_int,
        pub psz_cqm_file: *mut c_char,
        pub cqm_4iy: [uint8_t; 16],
        pub cqm_4py: [uint8_t; 16],
        pub cqm_4ic: [uint8_t; 16],
        pub cqm_4pc: [uint8_t; 16],
        pub cqm_8iy: [uint8_t; 64],
        pub cqm_8py: [uint8_t; 64],
        pub cqm_8ic: [uint8_t; 64],
        pub cqm_8pc: [uint8_t; 64],
        pub pf_log: Option<
            unsafe extern "C" fn(*mut c_void, c_int, *const c_char, ::core::ffi::VaList) -> (),
        >,
        pub p_log_private: *mut c_void,
        pub i_log_level: c_int,
        pub b_full_recon: c_int,
        pub psz_dump_yuv: *mut c_char,
        pub analyse: C2RustUnnamed_3,
        pub rc: C2RustUnnamed_2,
        pub crop_rect: CropRectangle,
        /// Frame Packing Arrangement SEI metadata.
        pub frame_packing: Option<FramePacking>,
        /// Mastering Display Color Volume SEI metadata.
        pub mastering_display: Option<MasteringDisplay>,
        /// Content Light Level SEI metadata.
        pub content_light_level: Option<ContentLightLevel>,
        pub i_alternative_transfer: c_int,
        pub b_aud: c_int,
        pub b_repeat_headers: c_int,
        pub b_annexb: c_int,
        pub i_sps_id: c_int,
        pub b_vfr_input: c_int,
        pub b_pulldown: c_int,
        pub i_fps_num: uint32_t,
        pub i_fps_den: uint32_t,
        pub i_timebase_num: uint32_t,
        pub i_timebase_den: uint32_t,
        pub b_tff: c_int,
        pub b_pic_struct: c_int,
        pub b_fake_interlaced: c_int,
        pub b_stitchable: c_int,
        pub b_opencl: c_int,
        pub i_opencl_device: c_int,
        pub opencl_device_id: *mut c_void,
        pub psz_clbin_file: *mut c_char,
        pub i_slice_max_size: c_int,
        pub i_slice_max_mbs: c_int,
        pub i_slice_min_mbs: c_int,
        pub i_slice_count: c_int,
        pub i_slice_count_max: c_int,
        pub param_free: Option<unsafe extern "C" fn(*mut c_void) -> ()>,
        pub nalu_process:
            Option<unsafe extern "C" fn(*mut x264_t, *mut x264_nal_t, *mut c_void) -> ()>,
        pub opaque: *mut c_void,
    }

    impl x264_param_t {
        fn new() -> Self {
            Self {
                cpu: 0,
                i_threads: 0,
                i_lookahead_threads: 0,
                b_sliced_threads: 0,
                b_deterministic: 0,
                b_cpu_independent: 0,
                i_sync_lookahead: 0,
                width: 0,
                height: 0,
                i_csp: 0,
                i_bitdepth: 0,
                i_level_idc: 0,
                i_frame_total: 0,
                i_nal_hrd: 0,
                vui: C2RustUnnamed_4::new(),
                i_frame_reference: 0,
                i_dpb_size: 0,
                i_keyint_max: 0,
                i_keyint_min: 0,
                i_scenecut_threshold: 0,
                b_intra_refresh: 0,
                i_bframe: 0,
                i_bframe_adaptive: 0,
                i_bframe_bias: 0,
                i_bframe_pyramid: 0,
                b_open_gop: 0,
                b_bluray_compat: 0,
                i_avcintra_class: 0,
                i_avcintra_flavor: 0,
                b_deblocking_filter: 0,
                i_deblocking_filter_alphac0: 0,
                i_deblocking_filter_beta: 0,
                b_cabac: 0,
                i_cabac_init_idc: 0,
                b_interlaced: 0,
                b_constrained_intra: 0,
                i_cqm_preset: 0,
                psz_cqm_file: core::ptr::null_mut(),
                cqm_4iy: [0; 16],
                cqm_4py: [0; 16],
                cqm_4ic: [0; 16],
                cqm_4pc: [0; 16],
                cqm_8iy: [0; 64],
                cqm_8py: [0; 64],
                cqm_8ic: [0; 64],
                cqm_8pc: [0; 64],
                pf_log: None,
                p_log_private: core::ptr::null_mut(),
                i_log_level: 0,
                b_full_recon: 0,
                psz_dump_yuv: core::ptr::null_mut(),
                analyse: C2RustUnnamed_3::new(),
                rc: C2RustUnnamed_2::new(),
                crop_rect: CropRectangle::default(),
                frame_packing: None,
                mastering_display: None,
                content_light_level: None,
                i_alternative_transfer: 0,
                b_aud: 0,
                b_repeat_headers: 0,
                b_annexb: 0,
                i_sps_id: 0,
                b_vfr_input: 0,
                b_pulldown: 0,
                i_fps_num: 0,
                i_fps_den: 0,
                i_timebase_num: 0,
                i_timebase_den: 0,
                b_tff: 0,
                b_pic_struct: 0,
                b_fake_interlaced: 0,
                b_stitchable: 0,
                b_opencl: 0,
                i_opencl_device: 0,
                opencl_device_id: core::ptr::null_mut(),
                psz_clbin_file: core::ptr::null_mut(),
                i_slice_max_size: 0,
                i_slice_max_mbs: 0,
                i_slice_min_mbs: 0,
                i_slice_count: 0,
                i_slice_count_max: 0,
                param_free: None,
                nalu_process: None,
                opaque: core::ptr::null_mut(),
            }
        }
    }

    /// HDR metadata used for tonemapping.
    #[derive(Debug, Default, Clone, Copy, PartialEq, Eq)]
    pub struct ContentLightLevel {
        /// Maximum Content Light Level, peak brightness for any single pixel.
        pub max_cll: u16,
        /// Maximum Frame Average Light Level, peak average brightness for any single frame.
        pub max_fall: u16,
    }

    /// HDR metadata used for tonemapping.
    ///
    /// Defines the Mastering Display Color Volume used to grade/master the video. These include the
    /// Red, Green, and Blue (x, y) coordinates that define the color gamut, as well as the white
    /// point, in 0.00002 increments. Additionally, this includes the maximum/minimum brightness for
    /// the display, in 0.0001 cd/m^2 increments.
    #[derive(Debug, Default, Clone, Copy, PartialEq, Eq)]
    pub struct MasteringDisplay {
        pub green: (u16, u16),
        pub blue: (u16, u16),
        pub red: (u16, u16),
        pub white: (u16, u16),
        pub display_max: u32,
        pub display_min: u32,
    }

    /// Frame packing arrangement SEI metadata.
    ///
    /// Table D-9 in the H.264 specification.
    #[derive(Debug, Clone, Copy, PartialEq, Eq)]
    pub enum FramePacking {
        /// Checkerboard-based interleaving (quincunx sampling).
        Checkerboard = 0,
        /// Column-based interleaving of two constituent frames.
        ColumnInterleaved = 1,
        /// Row-based interleaving of two constituent frames.
        RowInterleaved = 2,
        /// Side-by-side packing arrangement.
        SideBySide = 3,
        /// Top-bottom packing arrangement.
        TopBottom = 4,
        /// Temporal interleaving of alternating first and second frames
        /// (frames alternate in output order)
        TemporalInterleaved = 5,
        /// Complete 3D frame without any frame packing (used for compatibility)
        Packing2D = 6,
        /// File format packing arrangement (3x3 tiles for autostereoscopic displays)
        TileFormat = 7,
        // Values 8-255 are reserved for future use by ITU-T | ISO/IEC.
    }

    impl FramePacking {
        pub fn from_i32(value: i32) -> Option<Self> {
            match value {
                0 => Some(Self::Checkerboard),
                1 => Some(Self::ColumnInterleaved),
                2 => Some(Self::RowInterleaved),
                3 => Some(Self::SideBySide),
                4 => Some(Self::TopBottom),
                5 => Some(Self::TemporalInterleaved),
                6 => Some(Self::Packing2D),
                7 => Some(Self::TileFormat),
                _ => None,
            }
        }

        /// Base frame duration for ratecontrol curve centering (0.04s = 25fps).
        /// Halved for temporal interleaving to compensate for doubled framerate.
        pub fn base_frame_duration(packing: Option<Self>) -> f64 {
            0.04 / (matches!(packing, Some(Self::TemporalInterleaved)) as u8 + 1) as f64
        }

        /// Maximum frame duration sanity check (1.0s = 1fps minimum).
        pub fn max_frame_duration(packing: Option<Self>) -> f64 {
            1.00 / (matches!(packing, Some(Self::TemporalInterleaved)) as u8 + 1) as f64
        }

        /// Minimum frame duration sanity check (0.01s = 100fps maximum).
        pub fn min_frame_duration(packing: Option<Self>) -> f64 {
            0.01 / (matches!(packing, Some(Self::TemporalInterleaved)) as u8 + 1) as f64
        }
    }

    /// Frame cropping offsets added to automatic mod16 padding compensation.
    ///
    /// Encoded in SPS as `frame_crop_{left,right,top,bottom}_offset` (H.264 ยง7.4.2.1).
    /// Values are scaled by chroma subsampling factors before being applied to the decoded picture.
    #[derive(Debug, Default, Clone, Copy, PartialEq, Eq)]
    pub struct CropRectangle {
        /// Samples to crop from left edge
        pub left: u32,
        /// Samples to crop from top edge
        pub top: u32,
        /// Samples to crop from right edge
        pub right: u32,
        /// Samples to crop from bottom edge
        pub bottom: u32,
    }

    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "443:5"]
    pub struct C2RustUnnamed_2 {
        pub i_rc_method: c_int,
        pub i_qp_constant: c_int,
        pub i_qp_min: c_int,
        pub i_qp_max: c_int,
        pub i_qp_step: c_int,
        pub i_bitrate: c_int,
        pub f_rf_constant: c_float,
        pub f_rf_constant_max: c_float,
        pub f_rate_tolerance: c_float,
        pub i_vbv_max_bitrate: c_int,
        pub i_vbv_buffer_size: c_int,
        pub f_vbv_buffer_init: c_float,
        pub f_ip_factor: c_float,
        pub f_pb_factor: c_float,
        pub b_filler: c_int,
        pub i_aq_mode: c_int,
        pub f_aq_strength: c_float,
        pub b_mb_tree: c_int,
        pub i_lookahead: c_int,
        pub b_stat_write: c_int,
        pub psz_stat_out: *mut c_char,
        pub b_stat_read: c_int,
        pub psz_stat_in: *mut c_char,
        pub f_qcompress: c_float,
        pub f_qblur: c_float,
        pub f_complexity_blur: c_float,
        pub zones: *mut x264_zone_t,
        pub i_zones: c_int,
        pub psz_zones: *mut c_char,
    }

    impl C2RustUnnamed_2 {
        fn new() -> Self {
            Self {
                i_rc_method: 0,
                i_qp_constant: 0,
                i_qp_min: 0,
                i_qp_max: 0,
                i_qp_step: 0,
                i_bitrate: 0,
                f_rf_constant: 0.0,
                f_rf_constant_max: 0.0,
                f_rate_tolerance: 0.0,
                i_vbv_max_bitrate: 0,
                i_vbv_buffer_size: 0,
                f_vbv_buffer_init: 0.0,
                f_ip_factor: 0.0,
                f_pb_factor: 0.0,
                b_filler: 0,
                i_aq_mode: 0,
                f_aq_strength: 0.0,
                b_mb_tree: 0,
                i_lookahead: 0,
                b_stat_write: 0,
                psz_stat_out: core::ptr::null_mut(),
                b_stat_read: 0,
                psz_stat_in: core::ptr::null_mut(),
                f_qcompress: 0.0,
                f_qblur: 0.0,
                f_complexity_blur: 0.0,
                zones: core::ptr::null_mut(),
                i_zones: 0,
                psz_zones: core::ptr::null_mut(),
            }
        }
    }

    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "406:5"]
    pub struct C2RustUnnamed_3 {
        pub intra: c_uint,
        pub inter: c_uint,
        pub b_transform_8x8: c_int,
        pub i_weighted_pred: c_int,
        pub b_weighted_bipred: c_int,
        pub i_direct_mv_pred: c_int,
        pub i_chroma_qp_offset: c_int,
        pub i_me_method: c_int,
        pub i_me_range: c_int,
        pub i_mv_range: c_int,
        pub i_mv_range_thread: c_int,
        pub i_subpel_refine: c_int,
        pub b_chroma_me: c_int,
        pub b_mixed_references: c_int,
        pub i_trellis: c_int,
        pub b_fast_pskip: c_int,
        pub b_dct_decimate: c_int,
        pub i_noise_reduction: c_int,
        pub f_psy_rd: c_float,
        pub f_psy_trellis: c_float,
        pub b_psy: c_int,
        pub b_mb_info: c_int,
        pub b_mb_info_update: c_int,
        pub i_luma_deadzone: [c_int; 2],
        pub b_psnr: c_int,
        pub b_ssim: c_int,
    }

    impl C2RustUnnamed_3 {
        fn new() -> Self {
            Self {
                intra: 0,
                inter: 0,
                b_transform_8x8: 0,
                i_weighted_pred: 0,
                b_weighted_bipred: 0,
                i_direct_mv_pred: 0,
                i_chroma_qp_offset: 0,
                i_me_method: 0,
                i_me_range: 0,
                i_mv_range: 0,
                i_mv_range_thread: 0,
                i_subpel_refine: 0,
                b_chroma_me: 0,
                b_mixed_references: 0,
                i_trellis: 0,
                b_fast_pskip: 0,
                b_dct_decimate: 0,
                i_noise_reduction: 0,
                f_psy_rd: 0.0f32,
                f_psy_trellis: 0.0f32,
                b_psy: 0,
                b_mb_info: 0,
                b_mb_info_update: 0,
                i_luma_deadzone: [0; 2],
                b_psnr: 0,
                b_ssim: 0,
            }
        }
    }

    #[derive(Default, Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "342:5"]
    pub struct C2RustUnnamed_4 {
        pub i_sar_height: c_int,
        pub i_sar_width: c_int,
        pub i_overscan: c_int,
        pub i_vidformat: c_int,
        pub b_fullrange: c_int,
        pub i_colorprim: c_int,
        pub i_transfer: c_int,
        pub i_colmatrix: c_int,
        pub i_chroma_loc: c_int,
    }

    impl C2RustUnnamed_4 {
        fn new() -> Self {
            Self {
                i_sar_height: 0,
                i_sar_width: 0,
                i_overscan: 0,
                i_vidformat: 0,
                b_fullrange: 0,
                i_colorprim: 0,
                i_transfer: 0,
                i_colmatrix: 0,
                i_chroma_loc: 0,
            }
        }
    }

    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "633:16"]
    pub struct x264_level_t {
        pub level_idc: uint8_t,
        pub mbps: int32_t,
        pub frame_size: int32_t,
        pub dpb: int32_t,
        pub bitrate: int32_t,
        pub cpb: int32_t,
        pub mv_range: uint16_t,
        pub mvs_per_2mb: uint8_t,
        pub slice_rate: uint8_t,
        pub mincr: uint8_t,
        pub bipred8x8: uint8_t,
        pub direct8x8: uint8_t,
        pub frame_only: uint8_t,
    }
    #[c2rust::src_loc = "757:1"]
    pub type pic_struct_e = c_uint;
    #[c2rust::src_loc = "767:5"]
    pub const PIC_STRUCT_TRIPLE: pic_struct_e = 9;
    #[c2rust::src_loc = "766:5"]
    pub const PIC_STRUCT_DOUBLE: pic_struct_e = 8;
    #[c2rust::src_loc = "765:5"]
    pub const PIC_STRUCT_BOTTOM_TOP_BOTTOM: pic_struct_e = 7;
    #[c2rust::src_loc = "764:5"]
    pub const PIC_STRUCT_TOP_BOTTOM_TOP: pic_struct_e = 6;
    #[c2rust::src_loc = "763:5"]
    pub const PIC_STRUCT_BOTTOM_TOP: pic_struct_e = 5;
    #[c2rust::src_loc = "762:5"]
    pub const PIC_STRUCT_TOP_BOTTOM: pic_struct_e = 4;
    #[c2rust::src_loc = "760:5"]
    pub const PIC_STRUCT_PROGRESSIVE: pic_struct_e = 1;
    #[c2rust::src_loc = "759:5"]
    pub const PIC_STRUCT_AUTO: pic_struct_e = 0;
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "770:16"]
    pub struct x264_hrd_t {
        pub cpb_initial_arrival_time: c_double,
        pub cpb_final_arrival_time: c_double,
        pub cpb_removal_time: c_double,
        pub dpb_output_time: c_double,
    }
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "788:16"]
    pub struct x264_sei_payload_t {
        pub payload_size: c_int,
        pub payload_type: c_int,
        pub payload: *mut uint8_t,
    }
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "795:16"]
    pub struct x264_sei_t {
        pub num_payloads: c_int,
        pub payloads: *mut x264_sei_payload_t,
        pub sei_free: Option<unsafe extern "C" fn(*mut c_void) -> ()>,
    }
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "803:16"]
    pub struct x264_image_t {
        pub i_csp: c_int,
        pub i_plane: c_int,
        pub i_stride: [c_int; 4],
        pub plane: [*mut uint8_t; 4],
    }
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "811:16"]
    pub struct x264_image_properties_t {
        pub quant_offsets: *mut c_float,
        pub quant_offsets_free: Option<unsafe extern "C" fn(*mut c_void) -> ()>,
        pub mb_info: *mut uint8_t,
        pub mb_info_free: Option<unsafe extern "C" fn(*mut c_void) -> ()>,
        pub f_ssim: c_double,
        pub f_psnr_avg: c_double,
        pub f_psnr: [c_double; 3],
        pub f_crf_avg: c_double,
    }
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "867:16"]
    pub struct x264_picture_t {
        pub i_type: c_int,
        pub i_qpplus1: c_int,
        pub i_pic_struct: c_int,
        pub b_keyframe: c_int,
        pub i_pts: int64_t,
        pub i_dts: int64_t,
        pub param: *mut x264_param_t,
        pub img: x264_image_t,
        pub prop: x264_image_properties_t,
        pub hrd_timing: x264_hrd_t,
        pub extra_sei: x264_sei_t,
        pub opaque: *mut c_void,
    }
    #[c2rust::src_loc = "48:9"]
    pub const X264_BUILD: c_int = 165 as c_int;
    #[c2rust::src_loc = "217:9"]
    pub const X264_QP_AUTO: c_int = 0 as c_int;
    #[c2rust::src_loc = "238:27"]
    pub static mut x264_direct_pred_names: [*const c_char; 5] = [
        b"none\0" as *const u8 as *const c_char,
        b"spatial\0" as *const u8 as *const c_char,
        b"temporal\0" as *const u8 as *const c_char,
        b"auto\0" as *const u8 as *const c_char,
        0 as *const c_char,
    ];
    #[c2rust::src_loc = "239:27"]
    pub static mut x264_motion_est_names: [*const c_char; 6] = [
        b"dia\0" as *const u8 as *const c_char,
        b"hex\0" as *const u8 as *const c_char,
        b"umh\0" as *const u8 as *const c_char,
        b"esa\0" as *const u8 as *const c_char,
        b"tesa\0" as *const u8 as *const c_char,
        0 as *const c_char,
    ];
    #[c2rust::src_loc = "240:27"]
    pub static mut x264_b_pyramid_names: [*const c_char; 4] = [
        b"none\0" as *const u8 as *const c_char,
        b"strict\0" as *const u8 as *const c_char,
        b"normal\0" as *const u8 as *const c_char,
        0 as *const c_char,
    ];
    #[c2rust::src_loc = "241:27"]
    pub static mut x264_overscan_names: [*const c_char; 4] = [
        b"undef\0" as *const u8 as *const c_char,
        b"show\0" as *const u8 as *const c_char,
        b"crop\0" as *const u8 as *const c_char,
        0 as *const c_char,
    ];
    #[c2rust::src_loc = "242:27"]
    pub static mut x264_vidformat_names: [*const c_char; 7] = [
        b"component\0" as *const u8 as *const c_char,
        b"pal\0" as *const u8 as *const c_char,
        b"ntsc\0" as *const u8 as *const c_char,
        b"secam\0" as *const u8 as *const c_char,
        b"mac\0" as *const u8 as *const c_char,
        b"undef\0" as *const u8 as *const c_char,
        0 as *const c_char,
    ];
    #[c2rust::src_loc = "244:27"]
    pub static mut x264_colorprim_names: [*const c_char; 14] = [
        b"\0" as *const u8 as *const c_char,
        b"bt709\0" as *const u8 as *const c_char,
        b"undef\0" as *const u8 as *const c_char,
        b"\0" as *const u8 as *const c_char,
        b"bt470m\0" as *const u8 as *const c_char,
        b"bt470bg\0" as *const u8 as *const c_char,
        b"smpte170m\0" as *const u8 as *const c_char,
        b"smpte240m\0" as *const u8 as *const c_char,
        b"film\0" as *const u8 as *const c_char,
        b"bt2020\0" as *const u8 as *const c_char,
        b"smpte428\0" as *const u8 as *const c_char,
        b"smpte431\0" as *const u8 as *const c_char,
        b"smpte432\0" as *const u8 as *const c_char,
        0 as *const c_char,
    ];
    #[c2rust::src_loc = "246:27"]
    pub static mut x264_transfer_names: [*const c_char; 20] = [
        b"\0" as *const u8 as *const c_char,
        b"bt709\0" as *const u8 as *const c_char,
        b"undef\0" as *const u8 as *const c_char,
        b"\0" as *const u8 as *const c_char,
        b"bt470m\0" as *const u8 as *const c_char,
        b"bt470bg\0" as *const u8 as *const c_char,
        b"smpte170m\0" as *const u8 as *const c_char,
        b"smpte240m\0" as *const u8 as *const c_char,
        b"linear\0" as *const u8 as *const c_char,
        b"log100\0" as *const u8 as *const c_char,
        b"log316\0" as *const u8 as *const c_char,
        b"iec61966-2-4\0" as *const u8 as *const c_char,
        b"bt1361e\0" as *const u8 as *const c_char,
        b"iec61966-2-1\0" as *const u8 as *const c_char,
        b"bt2020-10\0" as *const u8 as *const c_char,
        b"bt2020-12\0" as *const u8 as *const c_char,
        b"smpte2084\0" as *const u8 as *const c_char,
        b"smpte428\0" as *const u8 as *const c_char,
        b"arib-std-b67\0" as *const u8 as *const c_char,
        0 as *const c_char,
    ];
    #[c2rust::src_loc = "248:27"]
    pub static mut x264_colmatrix_names: [*const c_char; 16] = [
        b"GBR\0" as *const u8 as *const c_char,
        b"bt709\0" as *const u8 as *const c_char,
        b"undef\0" as *const u8 as *const c_char,
        b"\0" as *const u8 as *const c_char,
        b"fcc\0" as *const u8 as *const c_char,
        b"bt470bg\0" as *const u8 as *const c_char,
        b"smpte170m\0" as *const u8 as *const c_char,
        b"smpte240m\0" as *const u8 as *const c_char,
        b"YCgCo\0" as *const u8 as *const c_char,
        b"bt2020nc\0" as *const u8 as *const c_char,
        b"bt2020c\0" as *const u8 as *const c_char,
        b"smpte2085\0" as *const u8 as *const c_char,
        b"chroma-derived-nc\0" as *const u8 as *const c_char,
        b"chroma-derived-c\0" as *const u8 as *const c_char,
        b"ICtCp\0" as *const u8 as *const c_char,
        0 as *const c_char,
    ];
    #[c2rust::src_loc = "251:27"]
    pub static mut x264_avcintra_flavor_names: [*const c_char; 3] = [
        b"panasonic\0" as *const u8 as *const c_char,
        b"sony\0" as *const u8 as *const c_char,
        0 as *const c_char,
    ];
    #[c2rust::src_loc = "254:9"]
    pub const X264_CSP_MASK: c_int = 0xff as c_int;
    #[c2rust::src_loc = "255:9"]
    pub const X264_CSP_NONE: c_int = 0 as c_int;
    #[c2rust::src_loc = "256:9"]
    pub const X264_CSP_I400: c_int = 0x1 as c_int;
    #[c2rust::src_loc = "257:9"]
    pub const X264_CSP_I420: c_int = 0x2 as c_int;
    #[c2rust::src_loc = "261:9"]
    pub const X264_CSP_I422: c_int = 0x6 as c_int;
    #[c2rust::src_loc = "267:9"]
    pub const X264_CSP_I444: c_int = 0xc as c_int;
    #[c2rust::src_loc = "269:9"]
    pub const X264_CSP_BGR: c_int = 0xe as c_int;
    #[c2rust::src_loc = "271:9"]
    pub const X264_CSP_RGB: c_int = 0x10 as c_int;
    #[c2rust::src_loc = "272:9"]
    pub const X264_CSP_MAX: c_int = 0x11 as c_int;
    #[c2rust::src_loc = "274:9"]
    pub const X264_CSP_HIGH_DEPTH: c_int = 0x2000 as c_int;
    #[c2rust::src_loc = "277:9"]
    pub const X264_TYPE_AUTO: c_int = 0 as c_int;
    #[c2rust::src_loc = "278:9"]
    pub const X264_TYPE_IDR: c_int = 0x1 as c_int;
    #[c2rust::src_loc = "279:9"]
    pub const X264_TYPE_I: c_int = 0x2 as c_int;
    #[c2rust::src_loc = "280:9"]
    pub const X264_TYPE_P: c_int = 0x3 as c_int;
    #[c2rust::src_loc = "281:9"]
    pub const X264_TYPE_BREF: c_int = 0x4 as c_int;
    #[c2rust::src_loc = "282:9"]
    pub const X264_TYPE_B: c_int = 0x5 as c_int;
    #[c2rust::src_loc = "283:9"]
    pub const X264_TYPE_KEYFRAME: c_int = 0x6 as c_int;
    #[c2rust::src_loc = "288:9"]
    pub const X264_LOG_NONE: c_int = -1;
    #[c2rust::src_loc = "289:9"]
    pub const X264_LOG_ERROR: c_int = 0;
    #[c2rust::src_loc = "290:9"]
    pub const X264_LOG_WARNING: c_int = 1;
    #[c2rust::src_loc = "291:9"]
    pub const X264_LOG_INFO: c_int = 2;
    #[c2rust::src_loc = "292:9"]
    pub const X264_LOG_DEBUG: c_int = 3;
    #[c2rust::src_loc = "295:9"]
    pub const X264_THREADS_AUTO: c_int = 0 as c_int;
    #[c2rust::src_loc = "300:9"]
    pub const X264_NAL_HRD_VBR: c_int = 1 as c_int;
    #[c2rust::src_loc = "301:9"]
    pub const X264_NAL_HRD_CBR: c_int = 2 as c_int;
    use ::core::ffi::{c_char, c_double, c_float, c_int, c_uint, c_void};

    use super::stdint_intn_h::{int32_t, int64_t};
    use super::stdint_uintn_h::{uint16_t, uint32_t, uint8_t};
    extern "C" {
        #[c2rust::src_loc = "80:16"]
        pub type x264_t;
        #[c2rust::src_loc = "651:36"]
        pub static x264_levels: [x264_level_t; 0];
        #[c2rust::src_loc = "659:10"]
        pub fn x264_param_default(_: *mut x264_param_t);
        #[c2rust::src_loc = "672:10"]
        pub fn x264_param_parse(
            _: *mut x264_param_t,
            name: *const c_char,
            value: *const c_char,
        ) -> c_int;
        #[c2rust::src_loc = "679:10"]
        pub fn x264_param_cleanup(param: *mut x264_param_t);
        #[c2rust::src_loc = "723:10"]
        pub fn x264_param_default_preset(
            _: *mut x264_param_t,
            preset: *const c_char,
            tune: *const c_char,
        ) -> c_int;
        #[c2rust::src_loc = "729:10"]
        pub fn x264_param_apply_fastfirstpass(_: *mut x264_param_t);
        #[c2rust::src_loc = "744:10"]
        pub fn x264_param_apply_profile(_: *mut x264_param_t, profile: *const c_char) -> c_int;
        #[c2rust::src_loc = "755:27"]
        pub static x264_chroma_format: c_int;
        #[c2rust::src_loc = "914:10"]
        pub fn x264_picture_init(pic: *mut x264_picture_t);
        #[c2rust::src_loc = "939:10"]
        pub fn x264_encoder_open_165(_: *mut x264_param_t) -> *mut x264_t;
        #[c2rust::src_loc = "962:10"]
        pub fn x264_encoder_parameters(_: *mut x264_t, _: *mut x264_param_t);
        #[c2rust::src_loc = "969:10"]
        pub fn x264_encoder_headers(
            _: *mut x264_t,
            pp_nal: *mut *mut x264_nal_t,
            pi_nal: *mut c_int,
        ) -> c_int;
        #[c2rust::src_loc = "976:10"]
        pub fn x264_encoder_encode(
            _: *mut x264_t,
            pp_nal: *mut *mut x264_nal_t,
            pi_nal: *mut c_int,
            pic_in: *mut x264_picture_t,
            pic_out: *mut x264_picture_t,
        ) -> c_int;
        #[c2rust::src_loc = "979:10"]
        pub fn x264_encoder_close(_: *mut x264_t);
        #[c2rust::src_loc = "983:10"]
        pub fn x264_encoder_delayed_frames(_: *mut x264_t) -> c_int;
    }

    #[c2rust::src_loc = "250:27"]
    pub static mut x264_nal_hrd_names: [*const c_char; 4] = [
        b"none\0" as *const u8 as *const c_char,
        b"vbr\0" as *const u8 as *const c_char,
        b"cbr\0" as *const u8 as *const c_char,
        0 as *const c_char,
    ];
    #[c2rust::src_loc = "704:27"]
    pub static mut x264_preset_names: [*const c_char; 11] = [
        b"ultrafast\0" as *const u8 as *const c_char,
        b"superfast\0" as *const u8 as *const c_char,
        b"veryfast\0" as *const u8 as *const c_char,
        b"faster\0" as *const u8 as *const c_char,
        b"fast\0" as *const u8 as *const c_char,
        b"medium\0" as *const u8 as *const c_char,
        b"slow\0" as *const u8 as *const c_char,
        b"slower\0" as *const u8 as *const c_char,
        b"veryslow\0" as *const u8 as *const c_char,
        b"placebo\0" as *const u8 as *const c_char,
        0 as *const c_char,
    ];
    #[c2rust::src_loc = "716:27"]
    pub static mut x264_tune_names: [*const c_char; 9] = [
        b"film\0" as *const u8 as *const c_char,
        b"animation\0" as *const u8 as *const c_char,
        b"grain\0" as *const u8 as *const c_char,
        b"stillimage\0" as *const u8 as *const c_char,
        b"psnr\0" as *const u8 as *const c_char,
        b"ssim\0" as *const u8 as *const c_char,
        b"fastdecode\0" as *const u8 as *const c_char,
        b"zerolatency\0" as *const u8 as *const c_char,
        0 as *const c_char,
    ];

    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "342:5"]
    pub struct C2RustUnnamed_5 {
        pub i_sar_height: c_int,
        pub i_sar_width: c_int,
        pub i_overscan: c_int,
        pub i_vidformat: c_int,
        pub b_fullrange: c_int,
        pub i_colorprim: c_int,
        pub i_transfer: c_int,
        pub i_colmatrix: c_int,
        pub i_chroma_loc: c_int,
    }
    #[c2rust::src_loc = "196:9"]
    pub const X264_ANALYSE_I4x4: c_uint = 0x1 as c_uint;
    #[c2rust::src_loc = "197:9"]
    pub const X264_ANALYSE_I8x8: c_uint = 0x2 as c_uint;
    #[c2rust::src_loc = "198:9"]
    pub const X264_ANALYSE_PSUB16x16: c_uint = 0x10 as c_uint;
    #[c2rust::src_loc = "199:9"]
    pub const X264_ANALYSE_PSUB8x8: c_uint = 0x20 as c_uint;
    #[c2rust::src_loc = "200:9"]
    pub const X264_ANALYSE_BSUB16x16: c_uint = 0x100 as c_uint;
    #[c2rust::src_loc = "206:9"]
    pub const X264_ME_DIA: c_int = 0 as c_int;
    #[c2rust::src_loc = "209:9"]
    pub const X264_ME_ESA: c_int = 3 as c_int;
    #[c2rust::src_loc = "214:9"]
    pub const X264_RC_CQP: c_int = 0 as c_int;
    #[c2rust::src_loc = "223:9"]
    pub const X264_B_ADAPT_FAST: c_int = 1 as c_int;
    #[c2rust::src_loc = "224:9"]
    pub const X264_B_ADAPT_TRELLIS: c_int = 2 as c_int;
    #[c2rust::src_loc = "226:9"]
    pub const X264_WEIGHTP_SIMPLE: c_int = 1 as c_int;
    #[c2rust::src_loc = "230:9"]
    pub const X264_B_PYRAMID_NORMAL: c_int = 2 as c_int;
    #[c2rust::src_loc = "853:13"]
    pub const X264_MBINFO_CONSTANT: c_uint = (1 as c_uint) << 0 as c_int;
    #[c2rust::src_loc = "86:1"]
    pub type nal_unit_type_e = c_uint;
    #[c2rust::src_loc = "98:5"]
    pub const NAL_FILLER: nal_unit_type_e = 12;
    #[c2rust::src_loc = "97:5"]
    pub const NAL_AUD: nal_unit_type_e = 9;
    #[c2rust::src_loc = "96:5"]
    pub const NAL_PPS: nal_unit_type_e = 8;
    #[c2rust::src_loc = "95:5"]
    pub const NAL_SPS: nal_unit_type_e = 7;
    #[c2rust::src_loc = "94:5"]
    pub const NAL_SEI: nal_unit_type_e = 6;
    #[c2rust::src_loc = "93:5"]
    pub const NAL_SLICE_IDR: nal_unit_type_e = 5;
    #[c2rust::src_loc = "92:5"]
    pub const NAL_SLICE_DPC: nal_unit_type_e = 4;
    #[c2rust::src_loc = "91:5"]
    pub const NAL_SLICE_DPB: nal_unit_type_e = 3;
    #[c2rust::src_loc = "90:5"]
    pub const NAL_SLICE_DPA: nal_unit_type_e = 2;
    #[c2rust::src_loc = "89:5"]
    pub const NAL_SLICE: nal_unit_type_e = 1;
    #[c2rust::src_loc = "88:5"]
    pub const NAL_UNKNOWN: nal_unit_type_e = 0;
    #[c2rust::src_loc = "101:1"]
    pub type nal_priority_e = c_uint;
    #[c2rust::src_loc = "106:5"]
    pub const NAL_PRIORITY_HIGHEST: nal_priority_e = 3;
    #[c2rust::src_loc = "105:5"]
    pub const NAL_PRIORITY_HIGH: nal_priority_e = 2;
    #[c2rust::src_loc = "104:5"]
    pub const NAL_PRIORITY_LOW: nal_priority_e = 1;
    #[c2rust::src_loc = "103:5"]
    pub const NAL_PRIORITY_DISPOSABLE: nal_priority_e = 0;
    #[c2rust::src_loc = "143:9"]
    pub const X264_CPU_SSE2: c_uint = (1 as c_uint) << 3 as c_int;
    #[c2rust::src_loc = "146:9"]
    pub const X264_CPU_SSSE3: c_uint = (1 as c_uint) << 6 as c_int;
    #[c2rust::src_loc = "148:9"]
    pub const X264_CPU_SSE42: c_uint = (1 as c_uint) << 8 as c_int;
    #[c2rust::src_loc = "152:9"]
    pub const X264_CPU_FMA3: c_uint = (1 as c_uint) << 12 as c_int;
    #[c2rust::src_loc = "153:9"]
    pub const X264_CPU_BMI1: c_uint = (1 as c_uint) << 13 as c_int;
    #[c2rust::src_loc = "154:9"]
    pub const X264_CPU_BMI2: c_uint = (1 as c_uint) << 14 as c_int;
    #[c2rust::src_loc = "156:9"]
    pub const X264_CPU_AVX512: c_uint = (1 as c_uint) << 16 as c_int;
    #[c2rust::src_loc = "159:9"]
    pub const X264_CPU_CACHELINE_64: c_uint = (1 as c_uint) << 18 as c_int;
    #[c2rust::src_loc = "160:9"]
    pub const X264_CPU_SSE2_IS_SLOW: c_uint = (1 as c_uint) << 19 as c_int;
    #[c2rust::src_loc = "161:9"]
    pub const X264_CPU_SSE2_IS_FAST: c_uint = (1 as c_uint) << 20 as c_int;
    #[c2rust::src_loc = "202:9"]
    pub const X264_DIRECT_PRED_NONE: c_int = 0 as c_int;
    #[c2rust::src_loc = "203:9"]
    pub const X264_DIRECT_PRED_SPATIAL: c_int = 1 as c_int;
    #[c2rust::src_loc = "205:9"]
    pub const X264_DIRECT_PRED_AUTO: c_int = 3 as c_int;
    #[c2rust::src_loc = "207:9"]
    pub const X264_ME_HEX: c_int = 1 as c_int;
    #[c2rust::src_loc = "208:9"]
    pub const X264_ME_UMH: c_int = 2 as c_int;
    #[c2rust::src_loc = "210:9"]
    pub const X264_ME_TESA: c_int = 4 as c_int;
    #[c2rust::src_loc = "211:9"]
    pub const X264_CQM_FLAT: c_int = 0 as c_int;
    #[c2rust::src_loc = "213:9"]
    pub const X264_CQM_CUSTOM: c_int = 2 as c_int;
    #[c2rust::src_loc = "215:9"]
    pub const X264_RC_CRF: c_int = 1 as c_int;
    #[c2rust::src_loc = "216:9"]
    pub const X264_RC_ABR: c_int = 2 as c_int;
    #[c2rust::src_loc = "222:9"]
    pub const X264_B_ADAPT_NONE: c_int = 0 as c_int;
    #[c2rust::src_loc = "225:9"]
    pub const X264_WEIGHTP_NONE: c_int = 0 as c_int;
    #[c2rust::src_loc = "227:9"]
    pub const X264_WEIGHTP_SMART: c_int = 2 as c_int;
    #[c2rust::src_loc = "228:9"]
    pub const X264_B_PYRAMID_NONE: c_int = 0 as c_int;
    #[c2rust::src_loc = "229:9"]
    pub const X264_B_PYRAMID_STRICT: c_int = 1 as c_int;
    #[c2rust::src_loc = "231:9"]
    pub const X264_KEYINT_MIN_AUTO: c_int = 0 as c_int;
    #[c2rust::src_loc = "232:9"]
    pub const X264_KEYINT_MAX_INFINITE: c_int = (1 as c_int) << 30 as c_int;
    #[c2rust::src_loc = "236:9"]
    pub const X264_AVCINTRA_FLAVOR_SONY: c_int = 1 as c_int;
    #[c2rust::src_loc = "299:9"]
    pub const X264_NAL_HRD_NONE: c_int = 0 as c_int;

    #[c2rust::src_loc = "149:9"]
    pub const X264_CPU_AVX: c_uint = (1 as c_uint) << 9 as c_int;
    #[c2rust::src_loc = "158:9"]
    pub const X264_CPU_CACHELINE_32: c_uint = (1 as c_uint) << 17 as c_int;
    #[c2rust::src_loc = "258:9"]
    pub const X264_CSP_YV12: c_int = 0x3 as c_int;
    #[c2rust::src_loc = "259:9"]
    pub const X264_CSP_NV12: c_int = 0x4 as c_int;
    #[c2rust::src_loc = "260:9"]
    pub const X264_CSP_NV21: c_int = 0x5 as c_int;
    #[c2rust::src_loc = "262:9"]
    pub const X264_CSP_YV16: c_int = 0x7 as c_int;
    #[c2rust::src_loc = "263:9"]
    pub const X264_CSP_NV16: c_int = 0x8 as c_int;
    #[c2rust::src_loc = "264:9"]
    pub const X264_CSP_YUYV: c_int = 0x9 as c_int;
    #[c2rust::src_loc = "265:9"]
    pub const X264_CSP_UYVY: c_int = 0xa as c_int;
    #[c2rust::src_loc = "266:9"]
    pub const X264_CSP_V210: c_int = 0xb as c_int;
    #[c2rust::src_loc = "268:9"]
    pub const X264_CSP_YV24: c_int = 0xd as c_int;
    #[c2rust::src_loc = "270:9"]
    pub const X264_CSP_BGRA: c_int = 0xf as c_int;
    #[c2rust::src_loc = "273:9"]
    pub const X264_CSP_VFLIP: c_int = 0x1000 as c_int;

    #[c2rust::src_loc = "139:9"]
    pub const X264_CPU_MMX: c_uint = (1 as c_uint) << 0 as c_int;
    #[c2rust::src_loc = "140:9"]
    pub const X264_CPU_MMX2: c_uint = (1 as c_uint) << 1 as c_int;
    #[c2rust::src_loc = "142:9"]
    pub const X264_CPU_SSE: c_uint = (1 as c_uint) << 2 as c_int;
    #[c2rust::src_loc = "144:9"]
    pub const X264_CPU_LZCNT: c_uint = (1 as c_uint) << 4 as c_int;
    #[c2rust::src_loc = "145:9"]
    pub const X264_CPU_SSE3: c_uint = (1 as c_uint) << 5 as c_int;
    #[c2rust::src_loc = "147:9"]
    pub const X264_CPU_SSE4: c_uint = (1 as c_uint) << 7 as c_int;
    #[c2rust::src_loc = "150:9"]
    pub const X264_CPU_XOP: c_uint = (1 as c_uint) << 10 as c_int;
    #[c2rust::src_loc = "151:9"]
    pub const X264_CPU_FMA4: c_uint = (1 as c_uint) << 11 as c_int;
    #[c2rust::src_loc = "155:9"]
    pub const X264_CPU_AVX2: c_uint = (1 as c_uint) << 15 as c_int;
    #[c2rust::src_loc = "162:9"]
    pub const X264_CPU_SLOW_SHUFFLE: c_uint = (1 as c_uint) << 21 as c_int;
    #[c2rust::src_loc = "163:9"]
    pub const X264_CPU_STACK_MOD4: c_uint = (1 as c_uint) << 22 as c_int;
    #[c2rust::src_loc = "164:9"]
    pub const X264_CPU_SLOW_ATOM: c_uint = (1 as c_uint) << 23 as c_int;
    #[c2rust::src_loc = "169:9"]
    pub const X264_CPU_SLOW_PSHUFB: c_uint = (1 as c_uint) << 24 as c_int;
    #[c2rust::src_loc = "170:9"]
    pub const X264_CPU_SLOW_PALIGNR: c_uint = (1 as c_uint) << 25 as c_int;

    #[c2rust::src_loc = "212:9"]
    pub const X264_CQM_JVT: c_int = 1 as c_int;
    #[c2rust::src_loc = "218:9"]
    pub const X264_AQ_NONE: c_int = 0 as c_int;
    #[c2rust::src_loc = "219:9"]
    pub const X264_AQ_VARIANCE: c_int = 1 as c_int;
    #[c2rust::src_loc = "220:9"]
    pub const X264_AQ_AUTOVARIANCE: c_int = 2 as c_int;
    #[c2rust::src_loc = "235:9"]
    pub const X264_AVCINTRA_FLAVOR_PANASONIC: c_int = 0 as c_int;
    #[c2rust::src_loc = "243:27"]
    pub static mut x264_fullrange_names: [*const c_char; 3] = [
        b"off\0" as *const u8 as *const c_char,
        b"on\0" as *const u8 as *const c_char,
        0 as *const c_char,
    ];
    #[c2rust::src_loc = "296:9"]
    pub const X264_SYNC_LOOKAHEAD_AUTO: c_int = -1;
    #[c2rust::src_loc = "669:9"]
    pub const X264_PARAM_BAD_NAME: c_int = -1;
    #[c2rust::src_loc = "670:9"]
    pub const X264_PARAM_BAD_VALUE: c_int = -(2 as c_int);
    #[c2rust::src_loc = "671:9"]
    pub const X264_PARAM_ALLOC_FAILED: c_int = -(3 as c_int);

    #[c2rust::src_loc = "221:9"]
    pub const X264_AQ_AUTOVARIANCE_BIASED: c_int = 3 as c_int;
}
#[c2rust::header_src = "/home/nwplayer123/Hacks/hex264/x264/x264cli.h:37"]
pub mod x264cli_h {
    #[c2rust::src_loc = "37:1"]
    pub type hnd_t = *mut c_void;
    #[c2rust::src_loc = "99:9"]
    pub type C2RustUnnamed_5 = c_int;
    #[c2rust::src_loc = "103:5"]
    pub const RANGE_PC: C2RustUnnamed_5 = 1;
    #[c2rust::src_loc = "102:5"]
    pub const RANGE_TV: C2RustUnnamed_5 = 0;
    #[c2rust::src_loc = "101:5"]
    pub const RANGE_AUTO: C2RustUnnamed_5 = -1;
    #[c2rust::src_loc = "33:9"]
    pub const UPDATE_INTERVAL: c_int = 250000 as c_int;
    #[inline]
    #[c2rust::src_loc = "67:1"]
    pub unsafe extern "C" fn get_filename_extension(mut filename: *mut c_char) -> *mut c_char {
        let mut ext: *mut c_char = filename.offset(strlen(filename) as isize);
        while *ext as c_int != '.' as i32 && ext > filename {
            ext = ext.offset(-1);
        }
        ext = ext.offset((*ext as c_int == '.' as i32) as c_int as isize);
        return ext;
    }
    use ::core::ffi::{c_char, c_int, c_void};

    use super::string_h::strlen;
    extern "C" {
        #[c2rust::src_loc = "78:1"]
        pub fn x264_cli_autocomplete(prev: *const c_char, cur: *const c_char) -> c_int;
    }
    extern "C" {
        #[c2rust::src_loc = "39:27"]
        pub static x264_avcintra_class_names: [*const c_char; 0];
        #[c2rust::src_loc = "40:27"]
        pub static x264_cqm_names: [*const c_char; 0];
        #[c2rust::src_loc = "41:27"]
        pub static x264_log_level_names: [*const c_char; 0];
        #[c2rust::src_loc = "42:27"]
        pub static x264_partition_names: [*const c_char; 0];
        #[c2rust::src_loc = "43:27"]
        pub static x264_pulldown_names: [*const c_char; 0];
        #[c2rust::src_loc = "44:27"]
        pub static x264_range_names: [*const c_char; 0];
        #[c2rust::src_loc = "45:27"]
        pub static x264_output_csp_names: [*const c_char; 0];
        #[c2rust::src_loc = "46:27"]
        pub static x264_valid_profile_names: [*const c_char; 0];
        #[c2rust::src_loc = "47:27"]
        pub static x264_demuxer_names: [*const c_char; 0];
        #[c2rust::src_loc = "48:27"]
        pub static x264_muxer_names: [*const c_char; 0];
    }
    extern "C" {
        #[c2rust::src_loc = "76:1"]
        pub fn x264_cli_log(name: *const c_char, i_level: c_int, fmt: *const c_char, ...);
    }
    extern "C" {
        #[c2rust::src_loc = "77:1"]
        pub fn x264_cli_printf(i_level: c_int, fmt: *const c_char, ...);
    }

    #[inline]
    #[c2rust::src_loc = "50:1"]
    pub unsafe extern "C" fn gcd(mut a: uint64_t, mut b: uint64_t) -> uint64_t {
        loop {
            let mut c: int64_t = a.wrapping_rem(b) as int64_t;
            if c == 0 {
                return b;
            }
            a = b;
            b = c as uint64_t;
        }
    }
    #[inline]
    #[c2rust::src_loc = "62:1"]
    pub unsafe extern "C" fn lcm(mut a: uint64_t, mut b: uint64_t) -> uint64_t {
        return a.wrapping_div(gcd(a, b)).wrapping_mul(b);
    }
    use super::stdint_intn_h::int64_t;
    use super::stdint_uintn_h::uint64_t;
}
#[c2rust::header_src = "/usr/include/signal.h:37"]
pub mod signal_h {
    use ::core::ffi::c_int;

    #[c2rust::src_loc = "72:1"]
    pub type __sighandler_t = Option<unsafe extern "C" fn(c_int) -> ()>;
    extern "C" {
        #[c2rust::src_loc = "88:1"]
        pub fn signal(__sig: c_int, __handler: __sighandler_t) -> __sighandler_t;
    }
}
#[c2rust::header_src = "/usr/include/bits/getopt_ext.h:37"]
pub mod getopt_ext_h {
    use ::core::ffi::{c_char, c_int};

    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "50:8"]
    pub struct option {
        pub name: *const c_char,
        pub has_arg: c_int,
        pub flag: *mut c_int,
        pub val: c_int,
    }
    #[c2rust::src_loc = "62:9"]
    pub const no_argument: c_int = 0 as c_int;
    #[c2rust::src_loc = "63:9"]
    pub const required_argument: c_int = 1 as c_int;
    extern "C" {
        #[c2rust::src_loc = "66:1"]
        pub fn getopt_long(
            ___argc: c_int,
            ___argv: *const *mut c_char,
            __shortopts: *const c_char,
            __longopts: *const option,
            __longind: *mut c_int,
        ) -> c_int;
    }
}
#[c2rust::header_src = "/home/nwplayer123/Hacks/hex264/x264/input/input.h:37"]
pub mod input_h {
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "38:9"]
    pub struct cli_input_opt_t {
        pub index_file: *mut c_char,
        pub format: *mut c_char,
        pub resolution: *mut c_char,
        pub colorspace: *mut c_char,
        pub bit_depth: c_int,
        pub timebase: *mut c_char,
        pub seek: c_int,
        pub progress: c_int,
        pub output_csp: c_int,
        pub output_range: c_int,
        pub input_range: c_int,
    }
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "54:9"]
    pub struct video_info_t {
        pub csp: c_int,
        pub fps_num: uint32_t,
        pub fps_den: uint32_t,
        pub fullrange: c_int,
        pub width: u32,
        pub height: u32,
        pub interlaced: c_int,
        pub num_frames: c_int,
        pub sar_width: uint32_t,
        pub sar_height: uint32_t,
        pub tff: c_int,
        pub thread_safe: c_int,
        pub timebase_num: uint32_t,
        pub timebase_den: uint32_t,
        pub vfr: c_int,
    }
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "74:9"]
    pub struct cli_image_t {
        pub csp: c_int,
        pub width: c_int,
        pub height: c_int,
        pub planes: c_int,
        pub plane: [*mut uint8_t; 4],
        pub stride: [c_int; 4],
    }
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "84:9"]
    pub struct cli_pic_t {
        pub img: cli_image_t,
        pub pts: int64_t,
        pub duration: int64_t,
        pub opaque: *mut c_void,
    }
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "92:9"]
    pub struct cli_input_t {
        pub open_file: Option<
            unsafe extern "C" fn(
                *mut c_char,
                *mut hnd_t,
                *mut video_info_t,
                *mut cli_input_opt_t,
            ) -> c_int,
        >,
        pub picture_alloc:
            Option<unsafe extern "C" fn(*mut cli_pic_t, hnd_t, c_int, c_int, c_int) -> c_int>,
        pub read_frame: Option<unsafe extern "C" fn(*mut cli_pic_t, hnd_t, c_int) -> c_int>,
        pub release_frame: Option<unsafe extern "C" fn(*mut cli_pic_t, hnd_t) -> c_int>,
        pub picture_clean: Option<unsafe extern "C" fn(*mut cli_pic_t, hnd_t) -> ()>,
        pub close_file: Option<unsafe extern "C" fn(hnd_t) -> c_int>,
    }
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "117:9"]
    pub struct x264_cli_csp_t {
        pub name: *const c_char,
        pub planes: c_int,
        pub width: [c_float; 4],
        pub height: [c_float; 4],
        pub mod_width: c_int,
        pub mod_height: c_int,
    }
    #[c2rust::src_loc = "114:9"]
    pub const X264_CSP_CLI_MAX: c_int = X264_CSP_MAX;
    use ::core::ffi::{c_char, c_float, c_int, c_void};

    use super::stdint_intn_h::int64_t;
    use super::stdint_uintn_h::{uint32_t, uint8_t};
    use super::x264_h::X264_CSP_MAX;
    use super::x264cli_h::hnd_t;
    extern "C" {
        #[c2rust::src_loc = "102:26"]
        pub static raw_input: cli_input_t;
        #[c2rust::src_loc = "103:26"]
        pub static y4m_input: cli_input_t;
        #[c2rust::src_loc = "104:26"]
        pub static avs_input: cli_input_t;
        #[c2rust::src_loc = "105:26"]
        pub static thread_8_input: cli_input_t;
        #[c2rust::src_loc = "106:26"]
        pub static thread_10_input: cli_input_t;
        #[c2rust::src_loc = "107:26"]
        pub static lavf_input: cli_input_t;
        #[c2rust::src_loc = "109:26"]
        pub static timecode_input: cli_input_t;
        #[c2rust::src_loc = "127:29"]
        pub static x264_cli_csps: [x264_cli_csp_t; 0];
    }
    extern "C" {
        #[c2rust::src_loc = "131:1"]
        pub fn x264_cli_pic_alloc(
            pic: *mut cli_pic_t,
            csp: c_int,
            width: c_int,
            height: c_int,
        ) -> c_int;
        #[c2rust::src_loc = "134:1"]
        pub fn x264_cli_pic_clean(pic: *mut cli_pic_t);
    }
    extern "C" {
        #[c2rust::src_loc = "129:1"]
        pub fn x264_cli_csp_is_invalid(csp: c_int) -> c_int;
        #[c2rust::src_loc = "130:1"]
        pub fn x264_cli_csp_depth_factor(csp: c_int) -> c_int;
        #[c2rust::src_loc = "137:1"]
        pub fn x264_cli_get_csp(csp: c_int) -> *const x264_cli_csp_t;
    }
    #[c2rust::src_loc = "115:9"]
    pub const X264_CSP_OTHER: c_int = 0x4000 as c_int;
    extern "C" {
        #[c2rust::src_loc = "132:1"]
        pub fn x264_cli_pic_alloc_aligned(
            pic: *mut cli_pic_t,
            csp: c_int,
            width: c_int,
            height: c_int,
        ) -> c_int;
    }

    extern "C" {
        #[c2rust::src_loc = "111:20"]
        pub static mut cli_input: cli_input_t;
    }

    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "139:9"]
    pub struct cli_mmap_t {
        pub file_size: int64_t,
        pub align_mask: c_int,
        pub fd: c_int,
    }

    use super::FILE_h::FILE;
    extern "C" {
        #[c2rust::src_loc = "133:1"]
        pub fn x264_cli_pic_init_noalloc(
            pic: *mut cli_pic_t,
            csp: c_int,
            width: c_int,
            height: c_int,
        ) -> c_int;
        #[c2rust::src_loc = "135:1"]
        pub fn x264_cli_pic_plane_size(
            csp: c_int,
            width: c_int,
            height: c_int,
            plane: c_int,
        ) -> int64_t;
        #[c2rust::src_loc = "153:1"]
        pub fn x264_cli_mmap_init(h: *mut cli_mmap_t, fh: *mut FILE) -> c_int;
        #[c2rust::src_loc = "154:1"]
        pub fn x264_cli_mmap(h: *mut cli_mmap_t, offset: int64_t, size: int64_t) -> *mut c_void;
        #[c2rust::src_loc = "155:1"]
        pub fn x264_cli_munmap(h: *mut cli_mmap_t, addr: *mut c_void, size: int64_t) -> c_int;
        #[c2rust::src_loc = "156:1"]
        pub fn x264_cli_mmap_close(h: *mut cli_mmap_t);
    }
}
#[c2rust::header_src = "/home/nwplayer123/Hacks/hex264/x264/output/output.h:37"]
pub mod output_h {
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "32:9"]
    pub struct cli_output_opt_t {
        pub use_dts_compress: c_int,
    }
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "37:9"]
    pub struct cli_output_t {
        pub open_file:
            Option<unsafe extern "C" fn(*mut c_char, *mut hnd_t, *mut cli_output_opt_t) -> c_int>,
        pub set_param: Option<unsafe extern "C" fn(hnd_t, *mut x264_param_t) -> c_int>,
        pub write_headers: Option<unsafe extern "C" fn(hnd_t, *mut x264_nal_t) -> c_int>,
        pub write_frame:
            Option<unsafe extern "C" fn(hnd_t, *mut uint8_t, c_int, *mut x264_picture_t) -> c_int>,
        pub close_file: Option<unsafe extern "C" fn(hnd_t, int64_t, int64_t) -> c_int>,
    }
    use ::core::ffi::{c_char, c_int};

    use super::stdint_intn_h::int64_t;
    use super::stdint_uintn_h::uint8_t;
    use super::x264_h::{x264_nal_t, x264_param_t, x264_picture_t};
    use super::x264cli_h::hnd_t;
    extern "C" {
        #[c2rust::src_loc = "46:27"]
        pub static raw_output: cli_output_t;
        #[c2rust::src_loc = "47:27"]
        pub static mkv_output: cli_output_t;
        #[c2rust::src_loc = "48:27"]
        pub static mp4_output: cli_output_t;
        #[c2rust::src_loc = "49:27"]
        pub static flv_output: cli_output_t;
    }
}
#[c2rust::header_src = "/home/nwplayer123/Hacks/hex264/x264/filters/video/video.h:0"]
pub mod video_h {
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "34:8"]
    pub struct cli_vid_filter_t {
        pub name: *const c_char,
        pub help: Option<unsafe extern "C" fn(c_int) -> ()>,
        pub init: Option<
            unsafe extern "C" fn(
                *mut hnd_t,
                *mut cli_vid_filter_t,
                *mut video_info_t,
                *mut x264_param_t,
                *mut c_char,
            ) -> c_int,
        >,
        pub get_frame: Option<unsafe extern "C" fn(hnd_t, *mut cli_pic_t, c_int) -> c_int>,
        pub release_frame: Option<unsafe extern "C" fn(hnd_t, *mut cli_pic_t, c_int) -> c_int>,
        pub free: Option<unsafe extern "C" fn(hnd_t) -> ()>,
        pub next: *mut cli_vid_filter_t,
    }
    use ::core::ffi::{c_char, c_int};

    use super::input_h::{cli_pic_t, video_info_t};
    use super::x264_h::x264_param_t;
    use super::x264cli_h::hnd_t;
    extern "C" {
        #[c2rust::src_loc = "58:1"]
        pub fn x264_register_vid_filters();
        #[c2rust::src_loc = "59:1"]
        pub fn x264_vid_filter_help(longhelp: c_int);
    }
}
#[c2rust::header_src = "/usr/include/libavutil/pixfmt.h:45"]
pub mod pixfmt_h {
    use ::core::ffi::{c_int, c_uint};

    #[c2rust::src_loc = "71:1"]
    pub type AVPixelFormat = c_int;
    #[c2rust::src_loc = "502:5"]
    pub const AV_PIX_FMT_NB: AVPixelFormat = 267;
    #[c2rust::src_loc = "500:5"]
    pub const AV_PIX_FMT_OHCODEC: AVPixelFormat = 266;
    #[c2rust::src_loc = "498:5"]
    pub const AV_PIX_FMT_GBRP12MSBLE: AVPixelFormat = 265;
    #[c2rust::src_loc = "497:5"]
    pub const AV_PIX_FMT_GBRP12MSBBE: AVPixelFormat = 264;
    #[c2rust::src_loc = "496:5"]
    pub const AV_PIX_FMT_GBRP10MSBLE: AVPixelFormat = 263;
    #[c2rust::src_loc = "495:5"]
    pub const AV_PIX_FMT_GBRP10MSBBE: AVPixelFormat = 262;
    #[c2rust::src_loc = "494:5"]
    pub const AV_PIX_FMT_YUV444P12MSBLE: AVPixelFormat = 261;
    #[c2rust::src_loc = "493:5"]
    pub const AV_PIX_FMT_YUV444P12MSBBE: AVPixelFormat = 260;
    #[c2rust::src_loc = "492:5"]
    pub const AV_PIX_FMT_YUV444P10MSBLE: AVPixelFormat = 259;
    #[c2rust::src_loc = "491:5"]
    pub const AV_PIX_FMT_YUV444P10MSBBE: AVPixelFormat = 258;
    #[c2rust::src_loc = "489:5"]
    pub const AV_PIX_FMT_GBRAP32LE: AVPixelFormat = 257;
    #[c2rust::src_loc = "488:5"]
    pub const AV_PIX_FMT_GBRAP32BE: AVPixelFormat = 256;
    #[c2rust::src_loc = "486:5"]
    pub const AV_PIX_FMT_YAF16LE: AVPixelFormat = 255;
    #[c2rust::src_loc = "485:5"]
    pub const AV_PIX_FMT_YAF16BE: AVPixelFormat = 254;
    #[c2rust::src_loc = "483:5"]
    pub const AV_PIX_FMT_YAF32LE: AVPixelFormat = 253;
    #[c2rust::src_loc = "482:5"]
    pub const AV_PIX_FMT_YAF32BE: AVPixelFormat = 252;
    #[c2rust::src_loc = "480:5"]
    pub const AV_PIX_FMT_GRAY32LE: AVPixelFormat = 251;
    #[c2rust::src_loc = "479:5"]
    pub const AV_PIX_FMT_GRAY32BE: AVPixelFormat = 250;
    #[c2rust::src_loc = "477:5"]
    pub const AV_PIX_FMT_AMF_SURFACE: AVPixelFormat = 249;
    #[c2rust::src_loc = "472:5"]
    pub const AV_PIX_FMT_GRAYF16LE: AVPixelFormat = 248;
    #[c2rust::src_loc = "471:5"]
    pub const AV_PIX_FMT_GRAYF16BE: AVPixelFormat = 247;
    #[c2rust::src_loc = "469:5"]
    pub const AV_PIX_FMT_GBRAPF16LE: AVPixelFormat = 246;
    #[c2rust::src_loc = "468:5"]
    pub const AV_PIX_FMT_GBRAPF16BE: AVPixelFormat = 245;
    #[c2rust::src_loc = "467:5"]
    pub const AV_PIX_FMT_GBRPF16LE: AVPixelFormat = 244;
    #[c2rust::src_loc = "466:5"]
    pub const AV_PIX_FMT_GBRPF16BE: AVPixelFormat = 243;
    #[c2rust::src_loc = "464:5"]
    pub const AV_PIX_FMT_XV48LE: AVPixelFormat = 242;
    #[c2rust::src_loc = "463:5"]
    pub const AV_PIX_FMT_XV48BE: AVPixelFormat = 241;
    #[c2rust::src_loc = "461:5"]
    pub const AV_PIX_FMT_Y216LE: AVPixelFormat = 240;
    #[c2rust::src_loc = "460:5"]
    pub const AV_PIX_FMT_Y216BE: AVPixelFormat = 239;
    #[c2rust::src_loc = "458:5"]
    pub const AV_PIX_FMT_RGB96LE: AVPixelFormat = 238;
    #[c2rust::src_loc = "457:5"]
    pub const AV_PIX_FMT_RGB96BE: AVPixelFormat = 237;
    #[c2rust::src_loc = "455:5"]
    pub const AV_PIX_FMT_RGBA128LE: AVPixelFormat = 236;
    #[c2rust::src_loc = "454:5"]
    pub const AV_PIX_FMT_RGBA128BE: AVPixelFormat = 235;
    #[c2rust::src_loc = "452:5"]
    pub const AV_PIX_FMT_RGBF16LE: AVPixelFormat = 234;
    #[c2rust::src_loc = "451:5"]
    pub const AV_PIX_FMT_RGBF16BE: AVPixelFormat = 233;
    #[c2rust::src_loc = "449:5"]
    pub const AV_PIX_FMT_V30XLE: AVPixelFormat = 232;
    #[c2rust::src_loc = "448:5"]
    pub const AV_PIX_FMT_V30XBE: AVPixelFormat = 231;
    #[c2rust::src_loc = "446:5"]
    pub const AV_PIX_FMT_VYU444: AVPixelFormat = 230;
    #[c2rust::src_loc = "444:5"]
    pub const AV_PIX_FMT_UYVA: AVPixelFormat = 229;
    #[c2rust::src_loc = "442:5"]
    pub const AV_PIX_FMT_AYUV: AVPixelFormat = 228;
    #[c2rust::src_loc = "440:5"]
    pub const AV_PIX_FMT_D3D12: AVPixelFormat = 227;
    #[c2rust::src_loc = "433:5"]
    pub const AV_PIX_FMT_GBRAP14LE: AVPixelFormat = 226;
    #[c2rust::src_loc = "432:5"]
    pub const AV_PIX_FMT_GBRAP14BE: AVPixelFormat = 225;
    #[c2rust::src_loc = "430:5"]
    pub const AV_PIX_FMT_P412LE: AVPixelFormat = 224;
    #[c2rust::src_loc = "429:5"]
    pub const AV_PIX_FMT_P412BE: AVPixelFormat = 223;
    #[c2rust::src_loc = "427:5"]
    pub const AV_PIX_FMT_P212LE: AVPixelFormat = 222;
    #[c2rust::src_loc = "426:5"]
    pub const AV_PIX_FMT_P212BE: AVPixelFormat = 221;
    #[c2rust::src_loc = "424:5"]
    pub const AV_PIX_FMT_RGBAF32LE: AVPixelFormat = 220;
    #[c2rust::src_loc = "423:5"]
    pub const AV_PIX_FMT_RGBAF32BE: AVPixelFormat = 219;
    #[c2rust::src_loc = "421:5"]
    pub const AV_PIX_FMT_RGBF32LE: AVPixelFormat = 218;
    #[c2rust::src_loc = "420:5"]
    pub const AV_PIX_FMT_RGBF32BE: AVPixelFormat = 217;
    #[c2rust::src_loc = "418:5"]
    pub const AV_PIX_FMT_XV36LE: AVPixelFormat = 216;
    #[c2rust::src_loc = "417:5"]
    pub const AV_PIX_FMT_XV36BE: AVPixelFormat = 215;
    #[c2rust::src_loc = "415:5"]
    pub const AV_PIX_FMT_XV30LE: AVPixelFormat = 214;
    #[c2rust::src_loc = "414:5"]
    pub const AV_PIX_FMT_XV30BE: AVPixelFormat = 213;
    #[c2rust::src_loc = "412:5"]
    pub const AV_PIX_FMT_Y212LE: AVPixelFormat = 212;
    #[c2rust::src_loc = "411:5"]
    pub const AV_PIX_FMT_Y212BE: AVPixelFormat = 211;
    #[c2rust::src_loc = "409:5"]
    pub const AV_PIX_FMT_P012BE: AVPixelFormat = 210;
    #[c2rust::src_loc = "408:5"]
    pub const AV_PIX_FMT_P012LE: AVPixelFormat = 209;
    #[c2rust::src_loc = "406:5"]
    pub const AV_PIX_FMT_VUYX: AVPixelFormat = 208;
    #[c2rust::src_loc = "404:5"]
    pub const AV_PIX_FMT_RGBAF16LE: AVPixelFormat = 207;
    #[c2rust::src_loc = "403:5"]
    pub const AV_PIX_FMT_RGBAF16BE: AVPixelFormat = 206;
    #[c2rust::src_loc = "401:5"]
    pub const AV_PIX_FMT_VUYA: AVPixelFormat = 205;
    #[c2rust::src_loc = "399:5"]
    pub const AV_PIX_FMT_P416LE: AVPixelFormat = 204;
    #[c2rust::src_loc = "398:5"]
    pub const AV_PIX_FMT_P416BE: AVPixelFormat = 203;
    #[c2rust::src_loc = "396:5"]
    pub const AV_PIX_FMT_P216LE: AVPixelFormat = 202;
    #[c2rust::src_loc = "395:5"]
    pub const AV_PIX_FMT_P216BE: AVPixelFormat = 201;
    #[c2rust::src_loc = "393:5"]
    pub const AV_PIX_FMT_P410LE: AVPixelFormat = 200;
    #[c2rust::src_loc = "392:5"]
    pub const AV_PIX_FMT_P410BE: AVPixelFormat = 199;
    #[c2rust::src_loc = "390:5"]
    pub const AV_PIX_FMT_P210LE: AVPixelFormat = 198;
    #[c2rust::src_loc = "389:5"]
    pub const AV_PIX_FMT_P210BE: AVPixelFormat = 197;
    #[c2rust::src_loc = "387:5"]
    pub const AV_PIX_FMT_X2BGR10BE: AVPixelFormat = 196;
    #[c2rust::src_loc = "386:5"]
    pub const AV_PIX_FMT_X2BGR10LE: AVPixelFormat = 195;
    #[c2rust::src_loc = "385:5"]
    pub const AV_PIX_FMT_X2RGB10BE: AVPixelFormat = 194;
    #[c2rust::src_loc = "384:5"]
    pub const AV_PIX_FMT_X2RGB10LE: AVPixelFormat = 193;
    #[c2rust::src_loc = "382:5"]
    pub const AV_PIX_FMT_Y210LE: AVPixelFormat = 192;
    #[c2rust::src_loc = "381:5"]
    pub const AV_PIX_FMT_Y210BE: AVPixelFormat = 191;
    #[c2rust::src_loc = "379:5"]
    pub const AV_PIX_FMT_VULKAN: AVPixelFormat = 190;
    #[c2rust::src_loc = "372:5"]
    pub const AV_PIX_FMT_NV42: AVPixelFormat = 189;
    #[c2rust::src_loc = "371:5"]
    pub const AV_PIX_FMT_NV24: AVPixelFormat = 188;
    #[c2rust::src_loc = "369:5"]
    pub const AV_PIX_FMT_YUVA444P12LE: AVPixelFormat = 187;
    #[c2rust::src_loc = "368:5"]
    pub const AV_PIX_FMT_YUVA444P12BE: AVPixelFormat = 186;
    #[c2rust::src_loc = "367:5"]
    pub const AV_PIX_FMT_YUVA422P12LE: AVPixelFormat = 185;
    #[c2rust::src_loc = "366:5"]
    pub const AV_PIX_FMT_YUVA422P12BE: AVPixelFormat = 184;
    #[c2rust::src_loc = "364:5"]
    pub const AV_PIX_FMT_GRAYF32LE: AVPixelFormat = 183;
    #[c2rust::src_loc = "363:5"]
    pub const AV_PIX_FMT_GRAYF32BE: AVPixelFormat = 182;
    #[c2rust::src_loc = "361:5"]
    pub const AV_PIX_FMT_GRAY14LE: AVPixelFormat = 181;
    #[c2rust::src_loc = "360:5"]
    pub const AV_PIX_FMT_GRAY14BE: AVPixelFormat = 180;
    #[c2rust::src_loc = "358:5"]
    pub const AV_PIX_FMT_OPENCL: AVPixelFormat = 179;
    #[c2rust::src_loc = "351:5"]
    pub const AV_PIX_FMT_DRM_PRIME: AVPixelFormat = 178;
    #[c2rust::src_loc = "344:5"]
    pub const AV_PIX_FMT_GBRAPF32LE: AVPixelFormat = 177;
    #[c2rust::src_loc = "343:5"]
    pub const AV_PIX_FMT_GBRAPF32BE: AVPixelFormat = 176;
    #[c2rust::src_loc = "342:5"]
    pub const AV_PIX_FMT_GBRPF32LE: AVPixelFormat = 175;
    #[c2rust::src_loc = "341:5"]
    pub const AV_PIX_FMT_GBRPF32BE: AVPixelFormat = 174;
    #[c2rust::src_loc = "339:5"]
    pub const AV_PIX_FMT_GRAY9LE: AVPixelFormat = 173;
    #[c2rust::src_loc = "338:5"]
    pub const AV_PIX_FMT_GRAY9BE: AVPixelFormat = 172;
    #[c2rust::src_loc = "336:5"]
    pub const AV_PIX_FMT_D3D11: AVPixelFormat = 171;
    #[c2rust::src_loc = "324:5"]
    pub const AV_PIX_FMT_P016BE: AVPixelFormat = 170;
    #[c2rust::src_loc = "323:5"]
    pub const AV_PIX_FMT_P016LE: AVPixelFormat = 169;
    #[c2rust::src_loc = "321:5"]
    pub const AV_PIX_FMT_GRAY10LE: AVPixelFormat = 168;
    #[c2rust::src_loc = "320:5"]
    pub const AV_PIX_FMT_GRAY10BE: AVPixelFormat = 167;
    #[c2rust::src_loc = "319:5"]
    pub const AV_PIX_FMT_GRAY12LE: AVPixelFormat = 166;
    #[c2rust::src_loc = "318:5"]
    pub const AV_PIX_FMT_GRAY12BE: AVPixelFormat = 165;
    #[c2rust::src_loc = "316:5"]
    pub const AV_PIX_FMT_MEDIACODEC: AVPixelFormat = 164;
    #[c2rust::src_loc = "314:5"]
    pub const AV_PIX_FMT_GBRAP10LE: AVPixelFormat = 163;
    #[c2rust::src_loc = "313:5"]
    pub const AV_PIX_FMT_GBRAP10BE: AVPixelFormat = 162;
    #[c2rust::src_loc = "311:5"]
    pub const AV_PIX_FMT_GBRAP12LE: AVPixelFormat = 161;
    #[c2rust::src_loc = "310:5"]
    pub const AV_PIX_FMT_GBRAP12BE: AVPixelFormat = 160;
    #[c2rust::src_loc = "308:5"]
    pub const AV_PIX_FMT_P010BE: AVPixelFormat = 159;
    #[c2rust::src_loc = "307:5"]
    pub const AV_PIX_FMT_P010LE: AVPixelFormat = 158;
    #[c2rust::src_loc = "305:5"]
    pub const AV_PIX_FMT_VIDEOTOOLBOX: AVPixelFormat = 157;
    #[c2rust::src_loc = "303:5"]
    pub const AV_PIX_FMT_AYUV64BE: AVPixelFormat = 156;
    #[c2rust::src_loc = "302:5"]
    pub const AV_PIX_FMT_AYUV64LE: AVPixelFormat = 155;
    #[c2rust::src_loc = "301:5"]
    pub const AV_PIX_FMT_YUV440P12BE: AVPixelFormat = 154;
    #[c2rust::src_loc = "300:5"]
    pub const AV_PIX_FMT_YUV440P12LE: AVPixelFormat = 153;
    #[c2rust::src_loc = "299:5"]
    pub const AV_PIX_FMT_YUV440P10BE: AVPixelFormat = 152;
    #[c2rust::src_loc = "298:5"]
    pub const AV_PIX_FMT_YUV440P10LE: AVPixelFormat = 151;
    #[c2rust::src_loc = "296:5"]
    pub const AV_PIX_FMT_BAYER_GRBG16BE: AVPixelFormat = 150;
    #[c2rust::src_loc = "295:5"]
    pub const AV_PIX_FMT_BAYER_GRBG16LE: AVPixelFormat = 149;
    #[c2rust::src_loc = "294:5"]
    pub const AV_PIX_FMT_BAYER_GBRG16BE: AVPixelFormat = 148;
    #[c2rust::src_loc = "293:5"]
    pub const AV_PIX_FMT_BAYER_GBRG16LE: AVPixelFormat = 147;
    #[c2rust::src_loc = "292:5"]
    pub const AV_PIX_FMT_BAYER_RGGB16BE: AVPixelFormat = 146;
    #[c2rust::src_loc = "291:5"]
    pub const AV_PIX_FMT_BAYER_RGGB16LE: AVPixelFormat = 145;
    #[c2rust::src_loc = "290:5"]
    pub const AV_PIX_FMT_BAYER_BGGR16BE: AVPixelFormat = 144;
    #[c2rust::src_loc = "289:5"]
    pub const AV_PIX_FMT_BAYER_BGGR16LE: AVPixelFormat = 143;
    #[c2rust::src_loc = "288:5"]
    pub const AV_PIX_FMT_BAYER_GRBG8: AVPixelFormat = 142;
    #[c2rust::src_loc = "287:5"]
    pub const AV_PIX_FMT_BAYER_GBRG8: AVPixelFormat = 141;
    #[c2rust::src_loc = "286:5"]
    pub const AV_PIX_FMT_BAYER_RGGB8: AVPixelFormat = 140;
    #[c2rust::src_loc = "285:5"]
    pub const AV_PIX_FMT_BAYER_BGGR8: AVPixelFormat = 139;
    #[c2rust::src_loc = "283:5"]
    pub const AV_PIX_FMT_YUVJ411P: AVPixelFormat = 138;
    #[c2rust::src_loc = "282:5"]
    pub const AV_PIX_FMT_GBRP14LE: AVPixelFormat = 137;
    #[c2rust::src_loc = "281:5"]
    pub const AV_PIX_FMT_GBRP14BE: AVPixelFormat = 136;
    #[c2rust::src_loc = "280:5"]
    pub const AV_PIX_FMT_GBRP12LE: AVPixelFormat = 135;
    #[c2rust::src_loc = "279:5"]
    pub const AV_PIX_FMT_GBRP12BE: AVPixelFormat = 134;
    #[c2rust::src_loc = "278:5"]
    pub const AV_PIX_FMT_YUV444P14LE: AVPixelFormat = 133;
    #[c2rust::src_loc = "277:5"]
    pub const AV_PIX_FMT_YUV444P14BE: AVPixelFormat = 132;
    #[c2rust::src_loc = "276:5"]
    pub const AV_PIX_FMT_YUV444P12LE: AVPixelFormat = 131;
    #[c2rust::src_loc = "275:5"]
    pub const AV_PIX_FMT_YUV444P12BE: AVPixelFormat = 130;
    #[c2rust::src_loc = "274:5"]
    pub const AV_PIX_FMT_YUV422P14LE: AVPixelFormat = 129;
    #[c2rust::src_loc = "273:5"]
    pub const AV_PIX_FMT_YUV422P14BE: AVPixelFormat = 128;
    #[c2rust::src_loc = "272:5"]
    pub const AV_PIX_FMT_YUV422P12LE: AVPixelFormat = 127;
    #[c2rust::src_loc = "271:5"]
    pub const AV_PIX_FMT_YUV422P12BE: AVPixelFormat = 126;
    #[c2rust::src_loc = "270:5"]
    pub const AV_PIX_FMT_YUV420P14LE: AVPixelFormat = 125;
    #[c2rust::src_loc = "269:5"]
    pub const AV_PIX_FMT_YUV420P14BE: AVPixelFormat = 124;
    #[c2rust::src_loc = "268:5"]
    pub const AV_PIX_FMT_YUV420P12LE: AVPixelFormat = 123;
    #[c2rust::src_loc = "267:5"]
    pub const AV_PIX_FMT_YUV420P12BE: AVPixelFormat = 122;
    #[c2rust::src_loc = "265:5"]
    pub const AV_PIX_FMT_BGR0: AVPixelFormat = 121;
    #[c2rust::src_loc = "264:5"]
    pub const AV_PIX_FMT_0BGR: AVPixelFormat = 120;
    #[c2rust::src_loc = "263:5"]
    pub const AV_PIX_FMT_RGB0: AVPixelFormat = 119;
    #[c2rust::src_loc = "262:5"]
    pub const AV_PIX_FMT_0RGB: AVPixelFormat = 118;
    #[c2rust::src_loc = "260:5"]
    pub const AV_PIX_FMT_CUDA: AVPixelFormat = 117;
    #[c2rust::src_loc = "254:5"]
    pub const AV_PIX_FMT_D3D11VA_VLD: AVPixelFormat = 116;
    #[c2rust::src_loc = "252:5"]
    pub const AV_PIX_FMT_MMAL: AVPixelFormat = 115;
    #[c2rust::src_loc = "247:5"]
    pub const AV_PIX_FMT_QSV: AVPixelFormat = 114;
    #[c2rust::src_loc = "214:5"]
    pub const AV_PIX_FMT_GBRAP16LE: AVPixelFormat = 113;
    #[c2rust::src_loc = "213:5"]
    pub const AV_PIX_FMT_GBRAP16BE: AVPixelFormat = 112;
    #[c2rust::src_loc = "212:5"]
    pub const AV_PIX_FMT_GBRAP: AVPixelFormat = 111;
    #[c2rust::src_loc = "210:5"]
    pub const AV_PIX_FMT_YA16LE: AVPixelFormat = 110;
    #[c2rust::src_loc = "209:5"]
    pub const AV_PIX_FMT_YA16BE: AVPixelFormat = 109;
    #[c2rust::src_loc = "207:5"]
    pub const AV_PIX_FMT_YVYU422: AVPixelFormat = 108;
    #[c2rust::src_loc = "205:5"]
    pub const AV_PIX_FMT_BGRA64LE: AVPixelFormat = 107;
    #[c2rust::src_loc = "204:5"]
    pub const AV_PIX_FMT_BGRA64BE: AVPixelFormat = 106;
    #[c2rust::src_loc = "203:5"]
    pub const AV_PIX_FMT_RGBA64LE: AVPixelFormat = 105;
    #[c2rust::src_loc = "202:5"]
    pub const AV_PIX_FMT_RGBA64BE: AVPixelFormat = 104;
    #[c2rust::src_loc = "200:5"]
    pub const AV_PIX_FMT_NV20BE: AVPixelFormat = 103;
    #[c2rust::src_loc = "199:5"]
    pub const AV_PIX_FMT_NV20LE: AVPixelFormat = 102;
    #[c2rust::src_loc = "198:5"]
    pub const AV_PIX_FMT_NV16: AVPixelFormat = 101;
    #[c2rust::src_loc = "197:5"]
    pub const AV_PIX_FMT_XYZ12BE: AVPixelFormat = 100;
    #[c2rust::src_loc = "196:5"]
    pub const AV_PIX_FMT_XYZ12LE: AVPixelFormat = 99;
    #[c2rust::src_loc = "194:5"]
    pub const AV_PIX_FMT_VDPAU: AVPixelFormat = 98;
    #[c2rust::src_loc = "192:5"]
    pub const AV_PIX_FMT_YUVA444P16LE: AVPixelFormat = 97;
    #[c2rust::src_loc = "191:5"]
    pub const AV_PIX_FMT_YUVA444P16BE: AVPixelFormat = 96;
    #[c2rust::src_loc = "190:5"]
    pub const AV_PIX_FMT_YUVA422P16LE: AVPixelFormat = 95;
    #[c2rust::src_loc = "189:5"]
    pub const AV_PIX_FMT_YUVA422P16BE: AVPixelFormat = 94;
    #[c2rust::src_loc = "188:5"]
    pub const AV_PIX_FMT_YUVA420P16LE: AVPixelFormat = 93;
    #[c2rust::src_loc = "187:5"]
    pub const AV_PIX_FMT_YUVA420P16BE: AVPixelFormat = 92;
    #[c2rust::src_loc = "186:5"]
    pub const AV_PIX_FMT_YUVA444P10LE: AVPixelFormat = 91;
    #[c2rust::src_loc = "185:5"]
    pub const AV_PIX_FMT_YUVA444P10BE: AVPixelFormat = 90;
    #[c2rust::src_loc = "184:5"]
    pub const AV_PIX_FMT_YUVA422P10LE: AVPixelFormat = 89;
    #[c2rust::src_loc = "183:5"]
    pub const AV_PIX_FMT_YUVA422P10BE: AVPixelFormat = 88;
    #[c2rust::src_loc = "182:5"]
    pub const AV_PIX_FMT_YUVA420P10LE: AVPixelFormat = 87;
    #[c2rust::src_loc = "181:5"]
    pub const AV_PIX_FMT_YUVA420P10BE: AVPixelFormat = 86;
    #[c2rust::src_loc = "180:5"]
    pub const AV_PIX_FMT_YUVA444P9LE: AVPixelFormat = 85;
    #[c2rust::src_loc = "179:5"]
    pub const AV_PIX_FMT_YUVA444P9BE: AVPixelFormat = 84;
    #[c2rust::src_loc = "178:5"]
    pub const AV_PIX_FMT_YUVA422P9LE: AVPixelFormat = 83;
    #[c2rust::src_loc = "177:5"]
    pub const AV_PIX_FMT_YUVA422P9BE: AVPixelFormat = 82;
    #[c2rust::src_loc = "176:5"]
    pub const AV_PIX_FMT_YUVA420P9LE: AVPixelFormat = 81;
    #[c2rust::src_loc = "175:5"]
    pub const AV_PIX_FMT_YUVA420P9BE: AVPixelFormat = 80;
    #[c2rust::src_loc = "174:5"]
    pub const AV_PIX_FMT_YUVA444P: AVPixelFormat = 79;
    #[c2rust::src_loc = "173:5"]
    pub const AV_PIX_FMT_YUVA422P: AVPixelFormat = 78;
    #[c2rust::src_loc = "172:5"]
    pub const AV_PIX_FMT_GBRP16LE: AVPixelFormat = 77;
    #[c2rust::src_loc = "171:5"]
    pub const AV_PIX_FMT_GBRP16BE: AVPixelFormat = 76;
    #[c2rust::src_loc = "170:5"]
    pub const AV_PIX_FMT_GBRP10LE: AVPixelFormat = 75;
    #[c2rust::src_loc = "169:5"]
    pub const AV_PIX_FMT_GBRP10BE: AVPixelFormat = 74;
    #[c2rust::src_loc = "168:5"]
    pub const AV_PIX_FMT_GBRP9LE: AVPixelFormat = 73;
    #[c2rust::src_loc = "167:5"]
    pub const AV_PIX_FMT_GBRP9BE: AVPixelFormat = 72;
    #[c2rust::src_loc = "166:5"]
    pub const AV_PIX_FMT_GBR24P: AVPixelFormat = 71;
    #[c2rust::src_loc = "165:5"]
    pub const AV_PIX_FMT_GBRP: AVPixelFormat = 71;
    #[c2rust::src_loc = "164:5"]
    pub const AV_PIX_FMT_YUV422P9LE: AVPixelFormat = 70;
    #[c2rust::src_loc = "163:5"]
    pub const AV_PIX_FMT_YUV422P9BE: AVPixelFormat = 69;
    #[c2rust::src_loc = "162:5"]
    pub const AV_PIX_FMT_YUV444P10LE: AVPixelFormat = 68;
    #[c2rust::src_loc = "161:5"]
    pub const AV_PIX_FMT_YUV444P10BE: AVPixelFormat = 67;
    #[c2rust::src_loc = "160:5"]
    pub const AV_PIX_FMT_YUV444P9LE: AVPixelFormat = 66;
    #[c2rust::src_loc = "159:5"]
    pub const AV_PIX_FMT_YUV444P9BE: AVPixelFormat = 65;
    #[c2rust::src_loc = "158:5"]
    pub const AV_PIX_FMT_YUV422P10LE: AVPixelFormat = 64;
    #[c2rust::src_loc = "157:5"]
    pub const AV_PIX_FMT_YUV422P10BE: AVPixelFormat = 63;
    #[c2rust::src_loc = "156:5"]
    pub const AV_PIX_FMT_YUV420P10LE: AVPixelFormat = 62;
    #[c2rust::src_loc = "155:5"]
    pub const AV_PIX_FMT_YUV420P10BE: AVPixelFormat = 61;
    #[c2rust::src_loc = "154:5"]
    pub const AV_PIX_FMT_YUV420P9LE: AVPixelFormat = 60;
    #[c2rust::src_loc = "153:5"]
    pub const AV_PIX_FMT_YUV420P9BE: AVPixelFormat = 59;
    #[c2rust::src_loc = "146:5"]
    pub const AV_PIX_FMT_BGR48LE: AVPixelFormat = 58;
    #[c2rust::src_loc = "145:5"]
    pub const AV_PIX_FMT_BGR48BE: AVPixelFormat = 57;
    #[c2rust::src_loc = "143:5"]
    pub const AV_PIX_FMT_GRAY8A: AVPixelFormat = 56;
    #[c2rust::src_loc = "142:5"]
    pub const AV_PIX_FMT_Y400A: AVPixelFormat = 56;
    #[c2rust::src_loc = "140:5"]
    pub const AV_PIX_FMT_YA8: AVPixelFormat = 56;
    #[c2rust::src_loc = "139:5"]
    pub const AV_PIX_FMT_BGR444BE: AVPixelFormat = 55;
    #[c2rust::src_loc = "138:5"]
    pub const AV_PIX_FMT_BGR444LE: AVPixelFormat = 54;
    #[c2rust::src_loc = "137:5"]
    pub const AV_PIX_FMT_RGB444BE: AVPixelFormat = 53;
    #[c2rust::src_loc = "136:5"]
    pub const AV_PIX_FMT_RGB444LE: AVPixelFormat = 52;
    #[c2rust::src_loc = "134:5"]
    pub const AV_PIX_FMT_DXVA2_VLD: AVPixelFormat = 51;
    #[c2rust::src_loc = "133:5"]
    pub const AV_PIX_FMT_YUV444P16BE: AVPixelFormat = 50;
    #[c2rust::src_loc = "132:5"]
    pub const AV_PIX_FMT_YUV444P16LE: AVPixelFormat = 49;
    #[c2rust::src_loc = "131:5"]
    pub const AV_PIX_FMT_YUV422P16BE: AVPixelFormat = 48;
    #[c2rust::src_loc = "130:5"]
    pub const AV_PIX_FMT_YUV422P16LE: AVPixelFormat = 47;
    #[c2rust::src_loc = "129:5"]
    pub const AV_PIX_FMT_YUV420P16BE: AVPixelFormat = 46;
    #[c2rust::src_loc = "128:5"]
    pub const AV_PIX_FMT_YUV420P16LE: AVPixelFormat = 45;
    #[c2rust::src_loc = "126:5"]
    pub const AV_PIX_FMT_VAAPI: AVPixelFormat = 44;
    #[c2rust::src_loc = "120:5"]
    pub const AV_PIX_FMT_BGR555LE: AVPixelFormat = 43;
    #[c2rust::src_loc = "119:5"]
    pub const AV_PIX_FMT_BGR555BE: AVPixelFormat = 42;
    #[c2rust::src_loc = "118:5"]
    pub const AV_PIX_FMT_BGR565LE: AVPixelFormat = 41;
    #[c2rust::src_loc = "117:5"]
    pub const AV_PIX_FMT_BGR565BE: AVPixelFormat = 40;
    #[c2rust::src_loc = "115:5"]
    pub const AV_PIX_FMT_RGB555LE: AVPixelFormat = 39;
    #[c2rust::src_loc = "114:5"]
    pub const AV_PIX_FMT_RGB555BE: AVPixelFormat = 38;
    #[c2rust::src_loc = "113:5"]
    pub const AV_PIX_FMT_RGB565LE: AVPixelFormat = 37;
    #[c2rust::src_loc = "112:5"]
    pub const AV_PIX_FMT_RGB565BE: AVPixelFormat = 36;
    #[c2rust::src_loc = "110:5"]
    pub const AV_PIX_FMT_RGB48LE: AVPixelFormat = 35;
    #[c2rust::src_loc = "109:5"]
    pub const AV_PIX_FMT_RGB48BE: AVPixelFormat = 34;
    #[c2rust::src_loc = "108:5"]
    pub const AV_PIX_FMT_YUVA420P: AVPixelFormat = 33;
    #[c2rust::src_loc = "107:5"]
    pub const AV_PIX_FMT_YUVJ440P: AVPixelFormat = 32;
    #[c2rust::src_loc = "106:5"]
    pub const AV_PIX_FMT_YUV440P: AVPixelFormat = 31;
    #[c2rust::src_loc = "105:5"]
    pub const AV_PIX_FMT_GRAY16LE: AVPixelFormat = 30;
    #[c2rust::src_loc = "104:5"]
    pub const AV_PIX_FMT_GRAY16BE: AVPixelFormat = 29;
    #[c2rust::src_loc = "102:5"]
    pub const AV_PIX_FMT_BGRA: AVPixelFormat = 28;
    #[c2rust::src_loc = "101:5"]
    pub const AV_PIX_FMT_ABGR: AVPixelFormat = 27;
    #[c2rust::src_loc = "100:5"]
    pub const AV_PIX_FMT_RGBA: AVPixelFormat = 26;
    #[c2rust::src_loc = "99:5"]
    pub const AV_PIX_FMT_ARGB: AVPixelFormat = 25;
    #[c2rust::src_loc = "97:5"]
    pub const AV_PIX_FMT_NV21: AVPixelFormat = 24;
    #[c2rust::src_loc = "96:5"]
    pub const AV_PIX_FMT_NV12: AVPixelFormat = 23;
    #[c2rust::src_loc = "95:5"]
    pub const AV_PIX_FMT_RGB4_BYTE: AVPixelFormat = 22;
    #[c2rust::src_loc = "94:5"]
    pub const AV_PIX_FMT_RGB4: AVPixelFormat = 21;
    #[c2rust::src_loc = "93:5"]
    pub const AV_PIX_FMT_RGB8: AVPixelFormat = 20;
    #[c2rust::src_loc = "92:5"]
    pub const AV_PIX_FMT_BGR4_BYTE: AVPixelFormat = 19;
    #[c2rust::src_loc = "91:5"]
    pub const AV_PIX_FMT_BGR4: AVPixelFormat = 18;
    #[c2rust::src_loc = "90:5"]
    pub const AV_PIX_FMT_BGR8: AVPixelFormat = 17;
    #[c2rust::src_loc = "89:5"]
    pub const AV_PIX_FMT_UYYVYY411: AVPixelFormat = 16;
    #[c2rust::src_loc = "88:5"]
    pub const AV_PIX_FMT_UYVY422: AVPixelFormat = 15;
    #[c2rust::src_loc = "87:5"]
    pub const AV_PIX_FMT_YUVJ444P: AVPixelFormat = 14;
    #[c2rust::src_loc = "86:5"]
    pub const AV_PIX_FMT_YUVJ422P: AVPixelFormat = 13;
    #[c2rust::src_loc = "85:5"]
    pub const AV_PIX_FMT_YUVJ420P: AVPixelFormat = 12;
    #[c2rust::src_loc = "84:5"]
    pub const AV_PIX_FMT_PAL8: AVPixelFormat = 11;
    #[c2rust::src_loc = "83:5"]
    pub const AV_PIX_FMT_MONOBLACK: AVPixelFormat = 10;
    #[c2rust::src_loc = "82:5"]
    pub const AV_PIX_FMT_MONOWHITE: AVPixelFormat = 9;
    #[c2rust::src_loc = "81:5"]
    pub const AV_PIX_FMT_GRAY8: AVPixelFormat = 8;
    #[c2rust::src_loc = "80:5"]
    pub const AV_PIX_FMT_YUV411P: AVPixelFormat = 7;
    #[c2rust::src_loc = "79:5"]
    pub const AV_PIX_FMT_YUV410P: AVPixelFormat = 6;
    #[c2rust::src_loc = "78:5"]
    pub const AV_PIX_FMT_YUV444P: AVPixelFormat = 5;
    #[c2rust::src_loc = "77:5"]
    pub const AV_PIX_FMT_YUV422P: AVPixelFormat = 4;
    #[c2rust::src_loc = "76:5"]
    pub const AV_PIX_FMT_BGR24: AVPixelFormat = 3;
    #[c2rust::src_loc = "75:5"]
    pub const AV_PIX_FMT_RGB24: AVPixelFormat = 2;
    #[c2rust::src_loc = "74:5"]
    pub const AV_PIX_FMT_YUYV422: AVPixelFormat = 1;
    #[c2rust::src_loc = "73:5"]
    pub const AV_PIX_FMT_YUV420P: AVPixelFormat = 0;
    #[c2rust::src_loc = "72:5"]
    pub const AV_PIX_FMT_NONE: AVPixelFormat = -1;

    #[c2rust::src_loc = "786:1"]
    pub type AVChromaLocation = c_uint;
    #[c2rust::src_loc = "794:5"]
    pub const AVCHROMA_LOC_NB: AVChromaLocation = 7;
    #[c2rust::src_loc = "793:5"]
    pub const AVCHROMA_LOC_BOTTOM: AVChromaLocation = 6;
    #[c2rust::src_loc = "792:5"]
    pub const AVCHROMA_LOC_BOTTOMLEFT: AVChromaLocation = 5;
    #[c2rust::src_loc = "791:5"]
    pub const AVCHROMA_LOC_TOP: AVChromaLocation = 4;
    #[c2rust::src_loc = "790:5"]
    pub const AVCHROMA_LOC_TOPLEFT: AVChromaLocation = 3;
    #[c2rust::src_loc = "789:5"]
    pub const AVCHROMA_LOC_CENTER: AVChromaLocation = 2;
    #[c2rust::src_loc = "788:5"]
    pub const AVCHROMA_LOC_LEFT: AVChromaLocation = 1;
    #[c2rust::src_loc = "787:5"]
    pub const AVCHROMA_LOC_UNSPECIFIED: AVChromaLocation = 0;
    #[c2rust::src_loc = "690:1"]
    pub type AVColorSpace = c_uint;
    #[c2rust::src_loc = "710:5"]
    pub const AVCOL_SPC_NB: AVColorSpace = 18;
    #[c2rust::src_loc = "709:5"]
    pub const AVCOL_SPC_YCGCO_RO: AVColorSpace = 17;
    #[c2rust::src_loc = "708:5"]
    pub const AVCOL_SPC_YCGCO_RE: AVColorSpace = 16;
    #[c2rust::src_loc = "707:5"]
    pub const AVCOL_SPC_IPT_C2: AVColorSpace = 15;
    #[c2rust::src_loc = "706:5"]
    pub const AVCOL_SPC_ICTCP: AVColorSpace = 14;
    #[c2rust::src_loc = "705:5"]
    pub const AVCOL_SPC_CHROMA_DERIVED_CL: AVColorSpace = 13;
    #[c2rust::src_loc = "704:5"]
    pub const AVCOL_SPC_CHROMA_DERIVED_NCL: AVColorSpace = 12;
    #[c2rust::src_loc = "703:5"]
    pub const AVCOL_SPC_SMPTE2085: AVColorSpace = 11;
    #[c2rust::src_loc = "702:5"]
    pub const AVCOL_SPC_BT2020_CL: AVColorSpace = 10;
    #[c2rust::src_loc = "701:5"]
    pub const AVCOL_SPC_BT2020_NCL: AVColorSpace = 9;
    #[c2rust::src_loc = "700:5"]
    pub const AVCOL_SPC_YCOCG: AVColorSpace = 8;
    #[c2rust::src_loc = "699:5"]
    pub const AVCOL_SPC_YCGCO: AVColorSpace = 8;
    #[c2rust::src_loc = "698:5"]
    pub const AVCOL_SPC_SMPTE240M: AVColorSpace = 7;
    #[c2rust::src_loc = "697:5"]
    pub const AVCOL_SPC_SMPTE170M: AVColorSpace = 6;
    #[c2rust::src_loc = "696:5"]
    pub const AVCOL_SPC_BT470BG: AVColorSpace = 5;
    #[c2rust::src_loc = "695:5"]
    pub const AVCOL_SPC_FCC: AVColorSpace = 4;
    #[c2rust::src_loc = "694:5"]
    pub const AVCOL_SPC_RESERVED: AVColorSpace = 3;
    #[c2rust::src_loc = "693:5"]
    pub const AVCOL_SPC_UNSPECIFIED: AVColorSpace = 2;
    #[c2rust::src_loc = "692:5"]
    pub const AVCOL_SPC_BT709: AVColorSpace = 1;
    #[c2rust::src_loc = "691:5"]
    pub const AVCOL_SPC_RGB: AVColorSpace = 0;
    #[c2rust::src_loc = "661:1"]
    pub type AVColorTransferCharacteristic = c_uint;
    #[c2rust::src_loc = "683:5"]
    pub const AVCOL_TRC_NB: AVColorTransferCharacteristic = 19;
    #[c2rust::src_loc = "682:5"]
    pub const AVCOL_TRC_ARIB_STD_B67: AVColorTransferCharacteristic = 18;
    #[c2rust::src_loc = "681:5"]
    pub const AVCOL_TRC_SMPTEST428_1: AVColorTransferCharacteristic = 17;
    #[c2rust::src_loc = "680:5"]
    pub const AVCOL_TRC_SMPTE428: AVColorTransferCharacteristic = 17;
    #[c2rust::src_loc = "679:5"]
    pub const AVCOL_TRC_SMPTEST2084: AVColorTransferCharacteristic = 16;
    #[c2rust::src_loc = "678:5"]
    pub const AVCOL_TRC_SMPTE2084: AVColorTransferCharacteristic = 16;
    #[c2rust::src_loc = "677:5"]
    pub const AVCOL_TRC_BT2020_12: AVColorTransferCharacteristic = 15;
    #[c2rust::src_loc = "676:5"]
    pub const AVCOL_TRC_BT2020_10: AVColorTransferCharacteristic = 14;
    #[c2rust::src_loc = "675:5"]
    pub const AVCOL_TRC_IEC61966_2_1: AVColorTransferCharacteristic = 13;
    #[c2rust::src_loc = "674:5"]
    pub const AVCOL_TRC_BT1361_ECG: AVColorTransferCharacteristic = 12;
    #[c2rust::src_loc = "673:5"]
    pub const AVCOL_TRC_IEC61966_2_4: AVColorTransferCharacteristic = 11;
    #[c2rust::src_loc = "672:5"]
    pub const AVCOL_TRC_LOG_SQRT: AVColorTransferCharacteristic = 10;
    #[c2rust::src_loc = "671:5"]
    pub const AVCOL_TRC_LOG: AVColorTransferCharacteristic = 9;
    #[c2rust::src_loc = "670:5"]
    pub const AVCOL_TRC_LINEAR: AVColorTransferCharacteristic = 8;
    #[c2rust::src_loc = "669:5"]
    pub const AVCOL_TRC_SMPTE240M: AVColorTransferCharacteristic = 7;
    #[c2rust::src_loc = "668:5"]
    pub const AVCOL_TRC_SMPTE170M: AVColorTransferCharacteristic = 6;
    #[c2rust::src_loc = "667:5"]
    pub const AVCOL_TRC_GAMMA28: AVColorTransferCharacteristic = 5;
    #[c2rust::src_loc = "666:5"]
    pub const AVCOL_TRC_GAMMA22: AVColorTransferCharacteristic = 4;
    #[c2rust::src_loc = "665:5"]
    pub const AVCOL_TRC_RESERVED: AVColorTransferCharacteristic = 3;
    #[c2rust::src_loc = "664:5"]
    pub const AVCOL_TRC_UNSPECIFIED: AVColorTransferCharacteristic = 2;
    #[c2rust::src_loc = "663:5"]
    pub const AVCOL_TRC_BT709: AVColorTransferCharacteristic = 1;
    #[c2rust::src_loc = "662:5"]
    pub const AVCOL_TRC_RESERVED0: AVColorTransferCharacteristic = 0;
    #[c2rust::src_loc = "636:1"]
    pub type AVColorPrimaries = c_uint;
    #[c2rust::src_loc = "654:5"]
    pub const AVCOL_PRI_NB: AVColorPrimaries = 23;
    #[c2rust::src_loc = "653:5"]
    pub const AVCOL_PRI_JEDEC_P22: AVColorPrimaries = 22;
    #[c2rust::src_loc = "652:5"]
    pub const AVCOL_PRI_EBU3213: AVColorPrimaries = 22;
    #[c2rust::src_loc = "651:5"]
    pub const AVCOL_PRI_SMPTE432: AVColorPrimaries = 12;
    #[c2rust::src_loc = "650:5"]
    pub const AVCOL_PRI_SMPTE431: AVColorPrimaries = 11;
    #[c2rust::src_loc = "649:5"]
    pub const AVCOL_PRI_SMPTEST428_1: AVColorPrimaries = 10;
    #[c2rust::src_loc = "648:5"]
    pub const AVCOL_PRI_SMPTE428: AVColorPrimaries = 10;
    #[c2rust::src_loc = "647:5"]
    pub const AVCOL_PRI_BT2020: AVColorPrimaries = 9;
    #[c2rust::src_loc = "646:5"]
    pub const AVCOL_PRI_FILM: AVColorPrimaries = 8;
    #[c2rust::src_loc = "645:5"]
    pub const AVCOL_PRI_SMPTE240M: AVColorPrimaries = 7;
    #[c2rust::src_loc = "644:5"]
    pub const AVCOL_PRI_SMPTE170M: AVColorPrimaries = 6;
    #[c2rust::src_loc = "643:5"]
    pub const AVCOL_PRI_BT470BG: AVColorPrimaries = 5;
    #[c2rust::src_loc = "641:5"]
    pub const AVCOL_PRI_BT470M: AVColorPrimaries = 4;
    #[c2rust::src_loc = "640:5"]
    pub const AVCOL_PRI_RESERVED: AVColorPrimaries = 3;
    #[c2rust::src_loc = "639:5"]
    pub const AVCOL_PRI_UNSPECIFIED: AVColorPrimaries = 2;
    #[c2rust::src_loc = "638:5"]
    pub const AVCOL_PRI_BT709: AVColorPrimaries = 1;
    #[c2rust::src_loc = "637:5"]
    pub const AVCOL_PRI_RESERVED0: AVColorPrimaries = 0;
    #[c2rust::src_loc = "732:1"]
    pub type AVColorRange = c_uint;
    #[c2rust::src_loc = "768:5"]
    pub const AVCOL_RANGE_NB: AVColorRange = 3;
    #[c2rust::src_loc = "767:5"]
    pub const AVCOL_RANGE_JPEG: AVColorRange = 2;
    #[c2rust::src_loc = "750:5"]
    pub const AVCOL_RANGE_MPEG: AVColorRange = 1;
    #[c2rust::src_loc = "733:5"]
    pub const AVCOL_RANGE_UNSPECIFIED: AVColorRange = 0;
}
#[c2rust::header_src = "/usr/include/sys/stat.h:37"]
pub mod stat_h {
    use ::core::ffi::{c_char, c_int};

    use super::struct_stat_h::stat;
    extern "C" {
        #[c2rust::src_loc = "227:1"]
        pub fn stat(__file: *const c_char, __buf: *mut stat) -> c_int;
        #[c2rust::src_loc = "230:1"]
        pub fn fstat(__fd: c_int, __buf: *mut stat) -> c_int;
    }
}
#[c2rust::header_src = "/usr/include/stdlib.h:37"]
pub mod stdlib_h {
    #[inline]
    #[c2rust::src_loc = "480:1"]
    pub unsafe extern "C" fn atoi(mut __nptr: *const c_char) -> c_int {
        return strtol(__nptr, NULL as *mut *mut c_char, 10 as c_int) as c_int;
    }
    use ::core::ffi::{c_char, c_double, c_int, c_long, c_ulong, c_void};

    use super::__stddef_null_h::NULL;
    extern "C" {
        #[c2rust::src_loc = "215:1"]
        pub fn strtol(__nptr: *const c_char, __endptr: *mut *mut c_char, __base: c_int) -> c_long;
        #[c2rust::src_loc = "219:1"]
        pub fn strtoul(__nptr: *const c_char, __endptr: *mut *mut c_char, __base: c_int)
            -> c_ulong;
        #[c2rust::src_loc = "756:1"]
        pub fn exit(__status: c_int) -> !;
    }
    extern "C" {
        #[c2rust::src_loc = "980:1"]
        pub fn abs(__x: c_int) -> c_int;
    }
    extern "C" {
        #[c2rust::src_loc = "118:1"]
        pub fn strtod(__nptr: *const c_char, __endptr: *mut *mut c_char) -> c_double;
    }
    use super::__stddef_size_t_h::size_t;
    extern "C" {
        #[c2rust::src_loc = "675:1"]
        pub fn calloc(__nmemb: size_t, __size: size_t) -> *mut c_void;
        #[c2rust::src_loc = "687:1"]
        pub fn free(__ptr: *mut c_void);
    }
    extern "C" {
        #[c2rust::src_loc = "672:1"]
        pub fn malloc(__size: size_t) -> *mut c_void;
    }
    extern "C" {
        #[c2rust::src_loc = "683:1"]
        pub fn realloc(__ptr: *mut c_void, __size: size_t) -> *mut c_void;
    }
}
#[c2rust::header_src = "/home/nwplayer123/Hacks/hex264/x264/common/osdep.h:37"]
pub mod osdep_h {
    #[inline]
    #[c2rust::src_loc = "261:1"]
    pub unsafe extern "C" fn x264_is_regular_file_path(mut filename: *const c_char) -> c_int {
        let mut file_stat: stat = stat {
            st_dev: 0,
            st_ino: 0,
            st_nlink: 0,
            st_mode: 0,
            st_uid: 0,
            st_gid: 0,
            __pad0: 0,
            st_rdev: 0,
            st_size: 0,
            st_blksize: 0,
            st_blocks: 0,
            st_atim: timespec {
                tv_sec: 0,
                tv_nsec: 0,
            },
            st_mtim: timespec {
                tv_sec: 0,
                tv_nsec: 0,
            },
            st_ctim: timespec {
                tv_sec: 0,
                tv_nsec: 0,
            },
            __glibc_reserved: [0; 3],
        };
        if stat(filename, &mut file_stat) != 0 {
            return 1 as c_int;
        }
        return (file_stat.st_mode & __S_IFMT as __mode_t == 0o100000 as __mode_t) as c_int;
    }
    #[inline]
    #[c2rust::src_loc = "270:1"]
    pub unsafe extern "C" fn x264_is_regular_file(mut filehandle: *mut FILE) -> c_int {
        let mut file_stat: stat = stat {
            st_dev: 0,
            st_ino: 0,
            st_nlink: 0,
            st_mode: 0,
            st_uid: 0,
            st_gid: 0,
            __pad0: 0,
            st_rdev: 0,
            st_size: 0,
            st_blksize: 0,
            st_blocks: 0,
            st_atim: timespec {
                tv_sec: 0,
                tv_nsec: 0,
            },
            st_mtim: timespec {
                tv_sec: 0,
                tv_nsec: 0,
            },
            st_ctim: timespec {
                tv_sec: 0,
                tv_nsec: 0,
            },
            __glibc_reserved: [0; 3],
        };
        if fstat(fileno(filehandle), &mut file_stat) != 0 {
            return 1 as c_int;
        }
        return (file_stat.st_mode & __S_IFMT as __mode_t == 0o100000 as __mode_t) as c_int;
    }
    use ::core::ffi::{c_char, c_int, c_void};

    use super::bits_stat_h::__S_IFMT;
    use super::stat_h::{fstat, stat};
    use super::stdint_intn_h::int64_t;
    use super::stdio_h::fileno;
    use super::struct_stat_h::stat;
    use super::struct_timespec_h::timespec;
    use super::types_h::__mode_t;
    use super::FILE_h::FILE;
    extern "C" {
        #[c2rust::src_loc = "206:10"]
        pub fn x264_mdate() -> int64_t;
    }
    #[c2rust::src_loc = "452:9"]
    pub const WORD_SIZE: uint64_t = ::core::mem::size_of::<*mut c_void>() as uint64_t;
    #[inline(always)]
    #[c2rust::src_loc = "503:1"]
    pub unsafe extern "C" fn x264_ctz_4bit(mut x: uint32_t) -> c_int {
        pub static mut lut: [uint8_t; 16] = [
            4 as c_int as uint8_t,
            0 as c_int as uint8_t,
            1 as c_int as uint8_t,
            0 as c_int as uint8_t,
            2 as c_int as uint8_t,
            0 as c_int as uint8_t,
            1 as c_int as uint8_t,
            0 as c_int as uint8_t,
            3 as c_int as uint8_t,
            0 as c_int as uint8_t,
            1 as c_int as uint8_t,
            0 as c_int as uint8_t,
            2 as c_int as uint8_t,
            0 as c_int as uint8_t,
            1 as c_int as uint8_t,
            0 as c_int as uint8_t,
        ];
        return lut[x as usize] as c_int;
    }
    use super::stdint_uintn_h::{uint32_t, uint64_t, uint8_t};

    #[inline(always)]
    #[c2rust::src_loc = "475:1"]
    pub unsafe extern "C" fn endian_fix32(mut x: uint32_t) -> uint32_t {
        return (x << 24 as c_int)
            .wrapping_add(x << 8 as c_int & 0xff0000 as uint32_t)
            .wrapping_add(x >> 8 as c_int & 0xff00 as uint32_t)
            .wrapping_add(x >> 24 as c_int);
    }
    #[inline(always)]
    #[c2rust::src_loc = "487:1"]
    pub unsafe extern "C" fn endian_fix64(mut x: uint64_t) -> uint64_t {
        return (endian_fix32((x >> 32 as c_int) as uint32_t) as uint64_t)
            .wrapping_add((endian_fix32(x as uint32_t) as uint64_t) << 32 as c_int);
    }
    #[inline(always)]
    #[c2rust::src_loc = "492:1"]
    pub unsafe extern "C" fn endian_fix(mut x: uintptr_t) -> uintptr_t {
        return if WORD_SIZE == 8 as uint64_t {
            endian_fix64(x as uint64_t) as uintptr_t
        } else {
            endian_fix32(x as uint32_t) as uintptr_t
        };
    }
    use super::stdint_h::uintptr_t;
    #[inline(always)]
    #[c2rust::src_loc = "496:1"]
    pub unsafe extern "C" fn endian_fix16(mut x: uint16_t) -> uint16_t {
        return ((x as c_int) << 8 as c_int | x as c_int >> 8 as c_int) as uint16_t;
    }
    use super::stdint_uintn_h::uint16_t;

    #[c2rust::src_loc = "317:9"]
    pub const NATIVE_ALIGN: c_int = 64 as c_int;
    #[inline(always)]
    #[c2rust::src_loc = "433:1"]
    pub unsafe extern "C" fn x264_pthread_fetch_and_add(
        mut val: *mut c_int,
        mut add: c_int,
        mut mutex: *mut pthread_mutex_t,
    ) -> c_int {
        return ::core::intrinsics::atomic_xadd_seqcst(val, add);
    }
    use super::pthreadtypes_h::pthread_mutex_t;
}
#[c2rust::header_src = "/usr/include/string.h:37"]
pub mod string_h {
    use ::core::ffi::{c_char, c_int, c_ulong, c_void};

    use super::__stddef_size_t_h::size_t;
    extern "C" {
        #[c2rust::src_loc = "43:1"]
        pub fn memcpy(__dest: *mut c_void, __src: *const c_void, __n: size_t) -> *mut c_void;
        #[c2rust::src_loc = "61:1"]
        pub fn memset(__s: *mut c_void, __c: c_int, __n: size_t) -> *mut c_void;
        #[c2rust::src_loc = "141:1"]
        pub fn strcpy(__dest: *mut c_char, __src: *const c_char) -> *mut c_char;
        #[c2rust::src_loc = "156:1"]
        pub fn strcmp(__s1: *const c_char, __s2: *const c_char) -> c_int;
        #[c2rust::src_loc = "293:1"]
        pub fn strcspn(__s: *const c_char, __reject: *const c_char) -> c_ulong;
        #[c2rust::src_loc = "407:1"]
        pub fn strlen(__s: *const c_char) -> size_t;
    }
    extern "C" {
        #[c2rust::src_loc = "159:1"]
        pub fn strncmp(__s1: *const c_char, __s2: *const c_char, __n: size_t) -> c_int;
        #[c2rust::src_loc = "246:1"]
        pub fn strchr(__s: *const c_char, __c: c_int) -> *mut c_char;
    }
    extern "C" {
        #[c2rust::src_loc = "47:1"]
        pub fn memmove(__dest: *mut c_void, __src: *const c_void, __n: size_t) -> *mut c_void;
    }
    extern "C" {
        #[c2rust::src_loc = "64:1"]
        pub fn memcmp(__s1: *const c_void, __s2: *const c_void, __n: size_t) -> c_int;
        #[c2rust::src_loc = "323:1"]
        pub fn strpbrk(__s: *const c_char, __accept: *const c_char) -> *mut c_char;
        #[c2rust::src_loc = "350:1"]
        pub fn strstr(__haystack: *const c_char, __needle: *const c_char) -> *mut c_char;
    }
    extern "C" {
        #[c2rust::src_loc = "187:1"]
        pub fn strdup(__s: *const c_char) -> *mut c_char;
        #[c2rust::src_loc = "297:1"]
        pub fn strspn(__s: *const c_char, __accept: *const c_char) -> c_ulong;
        #[c2rust::src_loc = "366:1"]
        pub fn strtok_r(
            __s: *mut c_char,
            __delim: *const c_char,
            __save_ptr: *mut *mut c_char,
        ) -> *mut c_char;
    }

    extern "C" {
        #[c2rust::src_loc = "149:1"]
        pub fn strcat(__dest: *mut c_char, __src: *const c_char) -> *mut c_char;
    }
}
#[c2rust::header_src = "/home/nwplayer123/Hacks/hex264/x264/common/base.h:37"]
pub mod base_h {
    use ::core::ffi::{c_char, c_double, c_float, c_int, c_uint, c_void};

    use super::stdint_uintn_h::uint32_t;
    extern "C" {
        #[c2rust::src_loc = "271:10"]
        pub fn x264_reduce_fraction(n: *mut uint32_t, d: *mut uint32_t);
    }
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "64:9"]
    pub union x264_union16_t {
        pub i: uint16_t,
        pub b: [uint8_t; 2],
    }
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "65:9"]
    pub union x264_union32_t {
        pub i: uint32_t,
        pub w: [uint16_t; 2],
        pub b: [uint8_t; 4],
    }
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "66:9"]
    pub union x264_union64_t {
        pub i: uint64_t,
        pub d: [uint32_t; 2],
        pub w: [uint16_t; 4],
        pub b: [uint8_t; 8],
    }
    #[c2rust::src_loc = "111:1"]
    pub type slice_type_e = c_uint;
    #[c2rust::src_loc = "115:5"]
    pub const SLICE_TYPE_I: slice_type_e = 2;
    #[c2rust::src_loc = "114:5"]
    pub const SLICE_TYPE_B: slice_type_e = 1;
    #[c2rust::src_loc = "113:5"]
    pub const SLICE_TYPE_P: slice_type_e = 0;
    #[c2rust::src_loc = "155:9"]
    pub const X264_SCAN8_0: c_int = 4 as c_int + 1 as c_int * 8 as c_int;
    #[c2rust::src_loc = "180:22"]
    pub static mut x264_scan8: [uint8_t; 51] = [
        (4 as c_int + 1 as c_int * 8 as c_int) as uint8_t,
        (5 as c_int + 1 as c_int * 8 as c_int) as uint8_t,
        (4 as c_int + 2 as c_int * 8 as c_int) as uint8_t,
        (5 as c_int + 2 as c_int * 8 as c_int) as uint8_t,
        (6 as c_int + 1 as c_int * 8 as c_int) as uint8_t,
        (7 as c_int + 1 as c_int * 8 as c_int) as uint8_t,
        (6 as c_int + 2 as c_int * 8 as c_int) as uint8_t,
        (7 as c_int + 2 as c_int * 8 as c_int) as uint8_t,
        (4 as c_int + 3 as c_int * 8 as c_int) as uint8_t,
        (5 as c_int + 3 as c_int * 8 as c_int) as uint8_t,
        (4 as c_int + 4 as c_int * 8 as c_int) as uint8_t,
        (5 as c_int + 4 as c_int * 8 as c_int) as uint8_t,
        (6 as c_int + 3 as c_int * 8 as c_int) as uint8_t,
        (7 as c_int + 3 as c_int * 8 as c_int) as uint8_t,
        (6 as c_int + 4 as c_int * 8 as c_int) as uint8_t,
        (7 as c_int + 4 as c_int * 8 as c_int) as uint8_t,
        (4 as c_int + 6 as c_int * 8 as c_int) as uint8_t,
        (5 as c_int + 6 as c_int * 8 as c_int) as uint8_t,
        (4 as c_int + 7 as c_int * 8 as c_int) as uint8_t,
        (5 as c_int + 7 as c_int * 8 as c_int) as uint8_t,
        (6 as c_int + 6 as c_int * 8 as c_int) as uint8_t,
        (7 as c_int + 6 as c_int * 8 as c_int) as uint8_t,
        (6 as c_int + 7 as c_int * 8 as c_int) as uint8_t,
        (7 as c_int + 7 as c_int * 8 as c_int) as uint8_t,
        (4 as c_int + 8 as c_int * 8 as c_int) as uint8_t,
        (5 as c_int + 8 as c_int * 8 as c_int) as uint8_t,
        (4 as c_int + 9 as c_int * 8 as c_int) as uint8_t,
        (5 as c_int + 9 as c_int * 8 as c_int) as uint8_t,
        (6 as c_int + 8 as c_int * 8 as c_int) as uint8_t,
        (7 as c_int + 8 as c_int * 8 as c_int) as uint8_t,
        (6 as c_int + 9 as c_int * 8 as c_int) as uint8_t,
        (7 as c_int + 9 as c_int * 8 as c_int) as uint8_t,
        (4 as c_int + 11 as c_int * 8 as c_int) as uint8_t,
        (5 as c_int + 11 as c_int * 8 as c_int) as uint8_t,
        (4 as c_int + 12 as c_int * 8 as c_int) as uint8_t,
        (5 as c_int + 12 as c_int * 8 as c_int) as uint8_t,
        (6 as c_int + 11 as c_int * 8 as c_int) as uint8_t,
        (7 as c_int + 11 as c_int * 8 as c_int) as uint8_t,
        (6 as c_int + 12 as c_int * 8 as c_int) as uint8_t,
        (7 as c_int + 12 as c_int * 8 as c_int) as uint8_t,
        (4 as c_int + 13 as c_int * 8 as c_int) as uint8_t,
        (5 as c_int + 13 as c_int * 8 as c_int) as uint8_t,
        (4 as c_int + 14 as c_int * 8 as c_int) as uint8_t,
        (5 as c_int + 14 as c_int * 8 as c_int) as uint8_t,
        (6 as c_int + 13 as c_int * 8 as c_int) as uint8_t,
        (7 as c_int + 13 as c_int * 8 as c_int) as uint8_t,
        (6 as c_int + 14 as c_int * 8 as c_int) as uint8_t,
        (7 as c_int + 14 as c_int * 8 as c_int) as uint8_t,
        (0 as c_int + 0 as c_int * 8 as c_int) as uint8_t,
        (0 as c_int + 5 as c_int * 8 as c_int) as uint8_t,
        (0 as c_int + 10 as c_int * 8 as c_int) as uint8_t,
    ];
    #[inline(always)]
    #[c2rust::src_loc = "206:1"]
    pub unsafe extern "C" fn x264_clip3(mut v: c_int, mut i_min: c_int, mut i_max: c_int) -> c_int {
        return if v < i_min {
            i_min
        } else if v > i_max {
            i_max
        } else {
            v
        };
    }
    #[inline(always)]
    #[c2rust::src_loc = "232:1"]
    pub unsafe extern "C" fn x264_median(mut a: c_int, mut b: c_int, mut c: c_int) -> c_int {
        let mut t: c_int = a - b & a - b >> 31 as c_int;
        a -= t;
        b += t;
        b -= b - c & b - c >> 31 as c_int;
        b += a - b & a - b >> 31 as c_int;
        return b;
    }
    #[inline(always)]
    #[c2rust::src_loc = "242:1"]
    pub unsafe extern "C" fn x264_median_mv(
        mut dst: *mut int16_t,
        mut a: *mut int16_t,
        mut b: *mut int16_t,
        mut c: *mut int16_t,
    ) {
        *dst.offset(0) = x264_median(
            *a.offset(0) as c_int,
            *b.offset(0) as c_int,
            *c.offset(0) as c_int,
        ) as int16_t;
        *dst.offset(1) = x264_median(
            *a.offset(1) as c_int,
            *b.offset(1) as c_int,
            *c.offset(1) as c_int,
        ) as int16_t;
    }
    use super::stdint_intn_h::int16_t;
    use super::stdint_uintn_h::{uint16_t, uint64_t, uint8_t};

    #[c2rust::src_loc = "93:1"]
    pub type profile_e = c_uint;
    #[c2rust::src_loc = "100:5"]
    pub const PROFILE_HIGH444_PREDICTIVE: profile_e = 244;
    #[c2rust::src_loc = "99:5"]
    pub const PROFILE_HIGH422: profile_e = 122;
    #[c2rust::src_loc = "98:5"]
    pub const PROFILE_HIGH10: profile_e = 110;
    #[c2rust::src_loc = "97:5"]
    pub const PROFILE_HIGH: profile_e = 100;
    #[c2rust::src_loc = "96:5"]
    pub const PROFILE_MAIN: profile_e = 77;
    #[c2rust::src_loc = "95:5"]
    pub const PROFILE_BASELINE: profile_e = 66;
    #[c2rust::src_loc = "103:1"]
    pub type chroma_format_e = c_uint;
    #[c2rust::src_loc = "108:5"]
    pub const CHROMA_444: chroma_format_e = 3;
    #[c2rust::src_loc = "107:5"]
    pub const CHROMA_422: chroma_format_e = 2;
    #[c2rust::src_loc = "106:5"]
    pub const CHROMA_420: chroma_format_e = 1;
    #[c2rust::src_loc = "105:5"]
    pub const CHROMA_400: chroma_format_e = 0;
    #[c2rust::src_loc = "136:9"]
    pub const X264_BFRAME_MAX: c_int = 16 as c_int;
    #[c2rust::src_loc = "151:9"]
    pub const X264_WEIGHTP_FAKE: c_int = -1;
    #[c2rust::src_loc = "177:9"]
    pub const LUMA_DC: c_int = 48 as c_int;
    #[c2rust::src_loc = "178:9"]
    pub const CHROMA_DC: c_int = 49 as c_int;
    #[inline(always)]
    #[c2rust::src_loc = "211:1"]
    pub unsafe extern "C" fn x264_clip3f(
        mut v: c_double,
        mut f_min: c_double,
        mut f_max: c_double,
    ) -> c_double {
        return if v < f_min {
            f_min
        } else if v > f_max {
            f_max
        } else {
            v
        };
    }
    #[inline(always)]
    #[c2rust::src_loc = "218:1"]
    pub unsafe extern "C" fn x264_exp2fix8(mut x: c_float) -> c_int {
        let mut i: c_int = (x * (-64.0f32 / 6.0f32) + 512.5f32) as c_int;
        if i < 0 as c_int {
            return 0 as c_int;
        }
        if i > 1023 as c_int {
            return 0xffff as c_int;
        }
        return (x264_exp2_lut[(i & 63 as c_int) as usize] as c_int + 256 as c_int)
            << (i >> 6 as c_int)
            >> 8 as c_int;
    }
    #[inline(always)]
    #[c2rust::src_loc = "226:1"]
    pub unsafe extern "C" fn x264_log2(mut x: uint32_t) -> c_float {
        let mut lz: c_int = x.leading_zeros() as i32;
        return x264_log2_lut[(x << lz >> 24 as c_int & 0x7f as uint32_t) as usize]
            + x264_log2_lz_lut[lz as usize];
    }
    #[inline(always)]
    #[c2rust::src_loc = "259:1"]
    pub unsafe extern "C" fn x264_cabac_mvd_sum(
        mut mvdleft: *mut uint8_t,
        mut mvdtop: *mut uint8_t,
    ) -> uint16_t {
        let mut amvd0: c_int = *mvdleft.offset(0) as c_int + *mvdtop.offset(0) as c_int;
        let mut amvd1: c_int = *mvdleft.offset(1) as c_int + *mvdtop.offset(1) as c_int;
        amvd0 = (amvd0 > 2 as c_int) as c_int + (amvd0 > 32 as c_int) as c_int;
        amvd1 = (amvd1 > 2 as c_int) as c_int + (amvd1 > 32 as c_int) as c_int;
        return (amvd0 + (amvd1 << 8 as c_int)) as uint16_t;
    }
    use super::stdint_intn_h::int64_t;
    use super::tables_h::{x264_exp2_lut, x264_log2_lut, x264_log2_lz_lut};
    extern "C" {
        #[c2rust::src_loc = "279:10"]
        pub fn x264_malloc(_: int64_t) -> *mut c_void;
        #[c2rust::src_loc = "280:10"]
        pub fn x264_free(_: *mut c_void);
    }

    #[c2rust::src_loc = "118:19"]
    pub static mut slice_type_to_char: [c_char; 3] = [
        'P' as i32 as c_char,
        'B' as i32 as c_char,
        'I' as i32 as c_char,
    ];
    #[c2rust::src_loc = "137:9"]
    pub const X264_REF_MAX: c_int = 16 as c_int;
    #[c2rust::src_loc = "138:9"]
    pub const X264_THREAD_MAX: c_int = 128 as c_int;
    #[c2rust::src_loc = "140:9"]
    pub const X264_LOOKAHEAD_MAX: c_int = 250 as c_int;
    #[c2rust::src_loc = "144:9"]
    pub const X264_THREAD_HEIGHT: c_int = 24 as c_int;
    use super::x264_h::x264_param_t;
    extern "C" {
        #[c2rust::src_loc = "275:10"]
        pub fn x264_log_internal(i_level: c_int, psz_fmt: *const c_char, ...);
        #[c2rust::src_loc = "287:1"]
        pub fn x264_param_strdup(param: *mut x264_param_t, src: *const c_char) -> *mut c_char;
    }
    extern "C" {
        #[c2rust::src_loc = "283:10"]
        pub fn x264_slurp_file(filename: *const c_char) -> *mut c_char;
    }
    extern "C" {
        #[c2rust::src_loc = "274:10"]
        pub fn x264_log_default(
            p_unused: *mut c_void,
            i_level: c_int,
            psz_fmt: *const c_char,
            arg: ::core::ffi::VaList,
        );
    }

    #[inline(always)]
    #[c2rust::src_loc = "248:1"]
    pub unsafe extern "C" fn x264_predictor_difference(
        mut mvc: *mut [int16_t; 2],
        mut i_mvc: intptr_t,
    ) -> c_int {
        let mut sum: c_int = 0 as c_int;
        let mut i: c_int = 0 as c_int;
        while (i as intptr_t) < i_mvc - 1 as intptr_t {
            sum += abs((*mvc.offset(i as isize))[0] as c_int
                - (*mvc.offset((i + 1 as c_int) as isize))[0] as c_int)
                + abs((*mvc.offset(i as isize))[1] as c_int
                    - (*mvc.offset((i + 1 as c_int) as isize))[1] as c_int);
            i += 1;
        }
        return sum;
    }
    use super::stdint_h::intptr_t;
    use super::stdlib_h::abs;

    extern "C" {
        #[c2rust::src_loc = "272:10"]
        pub fn x264_reduce_fraction64(n: *mut uint64_t, d: *mut uint64_t);
        #[c2rust::src_loc = "291:10"]
        pub fn x264_param2string(p: *mut x264_param_t, b_res: c_int) -> *mut c_char;
    }

    #[c2rust::src_loc = "120:1"]
    pub type sei_payload_type_e = c_uint;
    #[c2rust::src_loc = "133:5"]
    pub const SEI_ALTERNATIVE_TRANSFER: sei_payload_type_e = 147;
    #[c2rust::src_loc = "132:5"]
    pub const SEI_CONTENT_LIGHT_LEVEL: sei_payload_type_e = 144;
    #[c2rust::src_loc = "131:5"]
    pub const SEI_MASTERING_DISPLAY: sei_payload_type_e = 137;
    #[c2rust::src_loc = "130:5"]
    pub const SEI_FRAME_PACKING: sei_payload_type_e = 45;
    #[c2rust::src_loc = "129:5"]
    pub const SEI_DEC_REF_PIC_MARKING: sei_payload_type_e = 7;
    #[c2rust::src_loc = "128:5"]
    pub const SEI_RECOVERY_POINT: sei_payload_type_e = 6;
    #[c2rust::src_loc = "127:5"]
    pub const SEI_USER_DATA_UNREGISTERED: sei_payload_type_e = 5;
    #[c2rust::src_loc = "126:5"]
    pub const SEI_USER_DATA_REGISTERED: sei_payload_type_e = 4;
    #[c2rust::src_loc = "125:5"]
    pub const SEI_FILLER: sei_payload_type_e = 3;
    #[c2rust::src_loc = "124:5"]
    pub const SEI_PAN_SCAN_RECT: sei_payload_type_e = 2;
    #[c2rust::src_loc = "123:5"]
    pub const SEI_PIC_TIMING: sei_payload_type_e = 1;
    #[c2rust::src_loc = "122:5"]
    pub const SEI_BUFFERING_PERIOD: sei_payload_type_e = 0;
}
#[c2rust::header_src = "/usr/include/libavutil/pixdesc.h:58"]
pub mod pixdesc_h {
    use ::core::ffi::{c_char, c_int};

    use super::pixfmt_h::AVPixelFormat;
    extern "C" {
        #[c2rust::src_loc = "313:1"]
        pub fn av_get_pix_fmt_name(pix_fmt: AVPixelFormat) -> *const c_char;
    }
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "69:16"]
    pub struct AVPixFmtDescriptor {
        pub name: *const c_char,
        pub nb_components: uint8_t,
        pub log2_chroma_w: uint8_t,
        pub log2_chroma_h: uint8_t,
        pub flags: uint64_t,
        pub comp: [AVComponentDescriptor; 4],
        pub alias: *const c_char,
    }
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "30:16"]
    pub struct AVComponentDescriptor {
        pub plane: c_int,
        pub step: c_int,
        pub offset: c_int,
        pub shift: c_int,
        pub depth: c_int,
    }
    use super::stdint_uintn_h::{uint64_t, uint8_t};
    extern "C" {
        #[c2rust::src_loc = "195:1"]
        pub fn av_pix_fmt_desc_next(prev: *const AVPixFmtDescriptor) -> *const AVPixFmtDescriptor;
    }
    #[c2rust::src_loc = "120:9"]
    pub const AV_PIX_FMT_FLAG_PAL: c_int = (1 as c_int) << 1 as c_int;
    #[c2rust::src_loc = "136:9"]
    pub const AV_PIX_FMT_FLAG_RGB: c_int = (1 as c_int) << 5 as c_int;
    extern "C" {
        #[c2rust::src_loc = "186:1"]
        pub fn av_pix_fmt_desc_get(pix_fmt: AVPixelFormat) -> *const AVPixFmtDescriptor;
    }
}
#[c2rust::header_src = "/usr/include/bits/mathcalls.h:37"]
pub mod mathcalls_h {
    use ::core::ffi::{c_double, c_float};

    extern "C" {
        #[c2rust::src_loc = "222:1"]
        pub fn fmod(__x: c_double, __y: c_double) -> c_double;
    }
    extern "C" {
        #[c2rust::src_loc = "355:1"]
        pub fn round(__x: c_double) -> c_double;
        #[c2rust::src_loc = "170:1"]
        pub fn log2f(__x: c_float) -> c_float;
        #[c2rust::src_loc = "180:1"]
        pub fn sqrtf(__x: c_float) -> c_float;
        #[c2rust::src_loc = "216:1"]
        pub fn fabsf(__x: c_float) -> c_float;
    }
    extern "C" {
        #[c2rust::src_loc = "129:1"]
        pub fn log10(__x: c_double) -> c_double;
        #[c2rust::src_loc = "177:1"]
        pub fn pow(__x: c_double, __y: c_double) -> c_double;
        #[c2rust::src_loc = "216:1"]
        pub fn fabs(__x: c_double) -> c_double;
    }

    extern "C" {
        #[c2rust::src_loc = "117:1"]
        pub fn exp(__x: c_double) -> c_double;
        #[c2rust::src_loc = "126:1"]
        pub fn log(__x: c_double) -> c_double;
        #[c2rust::src_loc = "170:1"]
        pub fn log2(__x: c_double) -> c_double;
        #[c2rust::src_loc = "180:1"]
        pub fn sqrt(__x: c_double) -> c_double;
        #[c2rust::src_loc = "213:1"]
        pub fn ceil(__x: c_double) -> c_double;
        #[c2rust::src_loc = "177:1"]
        pub fn powf(__x: c_float, __y: c_float) -> c_float;
    }
    extern "C" {
        #[c2rust::src_loc = "219:1"]
        pub fn floor(__x: c_double) -> c_double;
    }
}
#[c2rust::header_src = "/usr/include/strings.h:37"]
pub mod strings_h {
    extern "C" {
        #[c2rust::src_loc = "116:1"]
        pub fn strcasecmp(__s1: *const c_char, __s2: *const c_char) -> c_int;
    }
    use ::core::ffi::{c_char, c_int};

    use super::__stddef_size_t_h::size_t;
    extern "C" {
        #[c2rust::src_loc = "120:1"]
        pub fn strncasecmp(__s1: *const c_char, __s2: *const c_char, __n: size_t) -> c_int;
    }
}
#[c2rust::header_src = "/home/nwplayer123/Hacks/hex264/x264/common/cpu.h:37"]
pub mod cpu_h {
    extern "C" {
        #[c2rust::src_loc = "30:10"]
        pub fn x264_cpu_num_processors() -> c_int;
    }
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "49:9"]
    pub struct x264_cpu_name_t {
        pub name: *const c_char,
        pub flags: uint32_t,
    }
    use ::core::ffi::{c_char, c_int};

    use super::stdint_uintn_h::uint32_t;
    extern "C" {
        #[c2rust::src_loc = "54:39"]
        pub static x264_cpu_names: [x264_cpu_name_t; 0];
    }
    extern "C" {
        #[c2rust::src_loc = "29:10"]
        pub fn x264_cpu_detect() -> uint32_t;
    }
}
#[c2rust::header_src = "/usr/include/bits/getopt_core.h:37"]
pub mod getopt_core_h {
    use ::core::ffi::{c_char, c_int};

    extern "C" {
        #[c2rust::src_loc = "36:14"]
        pub static mut optarg: *mut c_char;
        #[c2rust::src_loc = "50:12"]
        pub static mut optind: c_int;
    }
}
#[c2rust::header_src = "/usr/include/libswscale/swscale.h:58"]
pub mod swscale_h {
    extern "C" {
        #[c2rust::src_loc = "63:1"]
        pub fn swscale_license() -> *const c_char;
    }
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "182:16"]
    pub struct SwsContext {
        pub av_class: *const AVClass,
        pub opaque: *mut c_void,
        pub flags: c_uint,
        pub scaler_params: [c_double; 2],
        pub threads: c_int,
        pub dither: SwsDither,
        pub alpha_blend: SwsAlphaBlend,
        pub gamma_flag: c_int,
        pub src_w: c_int,
        pub src_h: c_int,
        pub dst_w: c_int,
        pub dst_h: c_int,
        pub src_format: c_int,
        pub dst_format: c_int,
        pub src_range: c_int,
        pub dst_range: c_int,
        pub src_v_chr_pos: c_int,
        pub src_h_chr_pos: c_int,
        pub dst_v_chr_pos: c_int,
        pub dst_h_chr_pos: c_int,
        pub intent: c_int,
    }
    #[c2rust::src_loc = "87:9"]
    pub type SwsAlphaBlend = c_uint;
    #[c2rust::src_loc = "91:5"]
    pub const SWS_ALPHA_BLEND_NB: SwsAlphaBlend = 3;
    #[c2rust::src_loc = "90:5"]
    pub const SWS_ALPHA_BLEND_CHECKERBOARD: SwsAlphaBlend = 2;
    #[c2rust::src_loc = "89:5"]
    pub const SWS_ALPHA_BLEND_UNIFORM: SwsAlphaBlend = 1;
    #[c2rust::src_loc = "88:5"]
    pub const SWS_ALPHA_BLEND_NONE: SwsAlphaBlend = 0;
    #[c2rust::src_loc = "77:9"]
    pub type SwsDither = c_uint;
    #[c2rust::src_loc = "84:5"]
    pub const SWS_DITHER_NB: SwsDither = 6;
    #[c2rust::src_loc = "83:5"]
    pub const SWS_DITHER_X_DITHER: SwsDither = 5;
    #[c2rust::src_loc = "82:5"]
    pub const SWS_DITHER_A_DITHER: SwsDither = 4;
    #[c2rust::src_loc = "81:5"]
    pub const SWS_DITHER_ED: SwsDither = 3;
    #[c2rust::src_loc = "80:5"]
    pub const SWS_DITHER_BAYER: SwsDither = 2;
    #[c2rust::src_loc = "79:5"]
    pub const SWS_DITHER_AUTO: SwsDither = 1;
    #[c2rust::src_loc = "78:5"]
    pub const SWS_DITHER_NONE: SwsDither = 0;
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "395:16"]
    pub struct SwsFilter {
        pub lumH: *mut SwsVector,
        pub lumV: *mut SwsVector,
        pub chrH: *mut SwsVector,
        pub chrV: *mut SwsVector,
    }
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "389:16"]
    pub struct SwsVector {
        pub coeff: *mut c_double,
        pub length: c_int,
    }
    #[c2rust::src_loc = "155:5"]
    pub const SWS_ACCURATE_RND: SwsFlags = 262144;
    #[c2rust::src_loc = "145:5"]
    pub const SWS_FULL_CHR_H_INP: SwsFlags = 16384;
    #[c2rust::src_loc = "132:5"]
    pub const SWS_FULL_CHR_H_INT: SwsFlags = 8192;
    #[c2rust::src_loc = "98:5"]
    pub const SWS_FAST_BILINEAR: SwsFlags = 1;
    #[c2rust::src_loc = "100:5"]
    pub const SWS_BICUBIC: SwsFlags = 4;
    #[c2rust::src_loc = "108:5"]
    pub const SWS_SPLINE: SwsFlags = 1024;
    #[c2rust::src_loc = "107:5"]
    pub const SWS_LANCZOS: SwsFlags = 512;
    #[c2rust::src_loc = "106:5"]
    pub const SWS_SINC: SwsFlags = 256;
    #[c2rust::src_loc = "105:5"]
    pub const SWS_GAUSS: SwsFlags = 128;
    #[c2rust::src_loc = "104:5"]
    pub const SWS_BICUBLIN: SwsFlags = 64;
    #[c2rust::src_loc = "103:5"]
    pub const SWS_AREA: SwsFlags = 32;
    #[c2rust::src_loc = "102:5"]
    pub const SWS_POINT: SwsFlags = 16;
    #[c2rust::src_loc = "101:5"]
    pub const SWS_X: SwsFlags = 8;
    #[c2rust::src_loc = "99:5"]
    pub const SWS_BILINEAR: SwsFlags = 2;
    #[c2rust::src_loc = "94:9"]
    pub type SwsFlags = c_uint;
    #[c2rust::src_loc = "162:5"]
    pub const SWS_ERROR_DIFFUSION: SwsFlags = 8388608;
    #[c2rust::src_loc = "161:5"]
    pub const SWS_DIRECT_BGR: SwsFlags = 32768;
    #[c2rust::src_loc = "156:5"]
    pub const SWS_BITEXACT: SwsFlags = 524288;
    #[c2rust::src_loc = "119:5"]
    pub const SWS_PRINT_INFO: SwsFlags = 4096;
    #[c2rust::src_loc = "114:5"]
    pub const SWS_STRICT: SwsFlags = 2048;
    #[c2rust::src_loc = "375:9"]
    pub const SWS_CS_DEFAULT: c_int = 5 as c_int;
    use ::core::ffi::{c_char, c_double, c_int, c_uint, c_void};

    use super::log_h::AVClass;
    use super::pixfmt_h::AVPixelFormat;
    use super::stdint_uintn_h::uint8_t;
    extern "C" {
        #[c2rust::src_loc = "248:1"]
        pub fn sws_alloc_context() -> *mut SwsContext;
        #[c2rust::src_loc = "385:1"]
        pub fn sws_getCoefficients(colorspace: c_int) -> *const c_int;
        #[c2rust::src_loc = "406:1"]
        pub fn sws_isSupportedInput(pix_fmt: AVPixelFormat) -> c_int;
        #[c2rust::src_loc = "412:1"]
        pub fn sws_isSupportedOutput(pix_fmt: AVPixelFormat) -> c_int;
        #[c2rust::src_loc = "432:1"]
        pub fn sws_init_context(
            sws_context: *mut SwsContext,
            srcFilter: *mut SwsFilter,
            dstFilter: *mut SwsFilter,
        ) -> c_int;
        #[c2rust::src_loc = "439:1"]
        pub fn sws_freeContext(swsContext: *mut SwsContext);
        #[c2rust::src_loc = "494:1"]
        pub fn sws_scale(
            c: *mut SwsContext,
            srcSlice: *const *const uint8_t,
            srcStride: *const c_int,
            srcSliceY: c_int,
            srcSliceH: c_int,
            dst: *const *mut uint8_t,
            dstStride: *const c_int,
        ) -> c_int;
        #[c2rust::src_loc = "596:1"]
        pub fn sws_setColorspaceDetails(
            c: *mut SwsContext,
            inv_table: *const c_int,
            srcRange: c_int,
            table: *const c_int,
            dstRange: c_int,
            brightness: c_int,
            contrast: c_int,
            saturation: c_int,
        ) -> c_int;
    }
}
#[c2rust::header_src = "/usr/include/lsmash.h:58"]
pub mod lsmash_h {
    #[c2rust::src_loc = "49:9"]
    pub const LSMASH_VERSION_MAJOR: c_int = 2 as c_int;
    #[c2rust::src_loc = "50:9"]
    pub const LSMASH_VERSION_MINOR: c_int = 14 as c_int;
    #[c2rust::src_loc = "51:9"]
    pub const LSMASH_VERSION_MICRO: c_int = 5 as c_int;

    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "204:9"]
    pub struct lsmash_file_parameters_t {
        pub mode: lsmash_file_mode,
        pub opaque: *mut c_void,
        pub read: Option<unsafe extern "C" fn(*mut c_void, *mut uint8_t, c_int) -> c_int>,
        pub write: Option<unsafe extern "C" fn(*mut c_void, *mut uint8_t, c_int) -> c_int>,
        pub seek: Option<unsafe extern "C" fn(*mut c_void, int64_t, c_int) -> int64_t>,
        pub major_brand: lsmash_brand_type,
        pub brands: *mut lsmash_brand_type,
        pub brand_count: uint32_t,
        pub minor_version: uint32_t,
        pub max_chunk_duration: c_double,
        pub max_async_tolerance: c_double,
        pub max_chunk_size: uint64_t,
        pub max_read_size: uint64_t,
    }
    #[c2rust::src_loc = "114:9"]
    pub type lsmash_brand_type = c_uint;
    #[c2rust::src_loc = "201:5"]
    pub const ISOM_BRAND_TYPE_SSSS: lsmash_brand_type = 1936946035;
    #[c2rust::src_loc = "200:5"]
    pub const ISOM_BRAND_TYPE_SISX: lsmash_brand_type = 1936290680;
    #[c2rust::src_loc = "199:5"]
    pub const ISOM_BRAND_TYPE_SIMS: lsmash_brand_type = 1936289139;
    #[c2rust::src_loc = "198:5"]
    pub const ISOM_BRAND_TYPE_SDV: lsmash_brand_type = 1935963680;
    #[c2rust::src_loc = "197:5"]
    pub const ISOM_BRAND_TYPE_RISX: lsmash_brand_type = 1919513464;
    #[c2rust::src_loc = "196:5"]
    pub const ISOM_BRAND_TYPE_QT: lsmash_brand_type = 1903435808;
    #[c2rust::src_loc = "195:5"]
    pub const ISOM_BRAND_TYPE_PNVI: lsmash_brand_type = 1886287465;
    #[c2rust::src_loc = "194:5"]
    pub const ISOM_BRAND_TYPE_PIFF: lsmash_brand_type = 1885955686;
    #[c2rust::src_loc = "193:5"]
    pub const ISOM_BRAND_TYPE_PANA: lsmash_brand_type = 1885433441;
    #[c2rust::src_loc = "192:5"]
    pub const ISOM_BRAND_TYPE_OPX2: lsmash_brand_type = 1869641778;
    #[c2rust::src_loc = "191:5"]
    pub const ISOM_BRAND_TYPE_OPF2: lsmash_brand_type = 1869637170;
    #[c2rust::src_loc = "190:5"]
    pub const ISOM_BRAND_TYPE_ODCF: lsmash_brand_type = 1868850022;
    #[c2rust::src_loc = "189:5"]
    pub const ISOM_BRAND_TYPE_NIKO: lsmash_brand_type = 1852402543;
    #[c2rust::src_loc = "188:5"]
    pub const ISOM_BRAND_TYPE_MSIX: lsmash_brand_type = 1836280184;
    #[c2rust::src_loc = "187:5"]
    pub const ISOM_BRAND_TYPE_MSDH: lsmash_brand_type = 1836278888;
    #[c2rust::src_loc = "186:5"]
    pub const ISOM_BRAND_TYPE_MP71: lsmash_brand_type = 1836070705;
    #[c2rust::src_loc = "185:5"]
    pub const ISOM_BRAND_TYPE_MP42: lsmash_brand_type = 1836069938;
    #[c2rust::src_loc = "184:5"]
    pub const ISOM_BRAND_TYPE_MP41: lsmash_brand_type = 1836069937;
    #[c2rust::src_loc = "183:5"]
    pub const ISOM_BRAND_TYPE_MP21: lsmash_brand_type = 1836069425;
    #[c2rust::src_loc = "182:5"]
    pub const ISOM_BRAND_TYPE_MJP2: lsmash_brand_type = 1835692082;
    #[c2rust::src_loc = "181:5"]
    pub const ISOM_BRAND_TYPE_MJ2S: lsmash_brand_type = 1835676275;
    #[c2rust::src_loc = "180:5"]
    pub const ISOM_BRAND_TYPE_LMSG: lsmash_brand_type = 1819112295;
    #[c2rust::src_loc = "179:5"]
    pub const ISOM_BRAND_TYPE_JPSI: lsmash_brand_type = 1785754473;
    #[c2rust::src_loc = "178:5"]
    pub const ISOM_BRAND_TYPE_ISOM: lsmash_brand_type = 1769172845;
    #[c2rust::src_loc = "177:5"]
    pub const ISOM_BRAND_TYPE_ISO7: lsmash_brand_type = 1769172791;
    #[c2rust::src_loc = "176:5"]
    pub const ISOM_BRAND_TYPE_ISO6: lsmash_brand_type = 1769172790;
    #[c2rust::src_loc = "175:5"]
    pub const ISOM_BRAND_TYPE_ISO5: lsmash_brand_type = 1769172789;
    #[c2rust::src_loc = "174:5"]
    pub const ISOM_BRAND_TYPE_ISO4: lsmash_brand_type = 1769172788;
    #[c2rust::src_loc = "173:5"]
    pub const ISOM_BRAND_TYPE_ISO3: lsmash_brand_type = 1769172787;
    #[c2rust::src_loc = "172:5"]
    pub const ISOM_BRAND_TYPE_ISO2: lsmash_brand_type = 1769172786;
    #[c2rust::src_loc = "171:5"]
    pub const ISOM_BRAND_TYPE_ISC2: lsmash_brand_type = 1769169714;
    #[c2rust::src_loc = "170:5"]
    pub const ISOM_BRAND_TYPE_IFRM: lsmash_brand_type = 1768321645;
    #[c2rust::src_loc = "169:5"]
    pub const ISOM_BRAND_TYPE_DVT1: lsmash_brand_type = 1685484593;
    #[c2rust::src_loc = "168:5"]
    pub const ISOM_BRAND_TYPE_DVR1: lsmash_brand_type = 1685484081;
    #[c2rust::src_loc = "167:5"]
    pub const ISOM_BRAND_TYPE_DV3B: lsmash_brand_type = 1685468002;
    #[c2rust::src_loc = "166:5"]
    pub const ISOM_BRAND_TYPE_DV3A: lsmash_brand_type = 1685468001;
    #[c2rust::src_loc = "165:5"]
    pub const ISOM_BRAND_TYPE_DV2B: lsmash_brand_type = 1685467746;
    #[c2rust::src_loc = "164:5"]
    pub const ISOM_BRAND_TYPE_DV2A: lsmash_brand_type = 1685467745;
    #[c2rust::src_loc = "163:5"]
    pub const ISOM_BRAND_TYPE_DV1B: lsmash_brand_type = 1685467490;
    #[c2rust::src_loc = "162:5"]
    pub const ISOM_BRAND_TYPE_DV1A: lsmash_brand_type = 1685467489;
    #[c2rust::src_loc = "161:5"]
    pub const ISOM_BRAND_TYPE_DSMS: lsmash_brand_type = 1685286259;
    #[c2rust::src_loc = "160:5"]
    pub const ISOM_BRAND_TYPE_DMB1: lsmash_brand_type = 1684890161;
    #[c2rust::src_loc = "159:5"]
    pub const ISOM_BRAND_TYPE_DBY1: lsmash_brand_type = 1684175153;
    #[c2rust::src_loc = "158:5"]
    pub const ISOM_BRAND_TYPE_DASH: lsmash_brand_type = 1684108136;
    #[c2rust::src_loc = "157:5"]
    pub const ISOM_BRAND_TYPE_DA3B: lsmash_brand_type = 1684091746;
    #[c2rust::src_loc = "156:5"]
    pub const ISOM_BRAND_TYPE_DA3A: lsmash_brand_type = 1684091745;
    #[c2rust::src_loc = "155:5"]
    pub const ISOM_BRAND_TYPE_DA2B: lsmash_brand_type = 1684091490;
    #[c2rust::src_loc = "154:5"]
    pub const ISOM_BRAND_TYPE_DA2A: lsmash_brand_type = 1684091489;
    #[c2rust::src_loc = "153:5"]
    pub const ISOM_BRAND_TYPE_DA1B: lsmash_brand_type = 1684091234;
    #[c2rust::src_loc = "152:5"]
    pub const ISOM_BRAND_TYPE_DA1A: lsmash_brand_type = 1684091233;
    #[c2rust::src_loc = "151:5"]
    pub const ISOM_BRAND_TYPE_DA0B: lsmash_brand_type = 1684090978;
    #[c2rust::src_loc = "150:5"]
    pub const ISOM_BRAND_TYPE_DA0A: lsmash_brand_type = 1684090977;
    #[c2rust::src_loc = "149:5"]
    pub const ISOM_BRAND_TYPE_CCFF: lsmash_brand_type = 1667458662;
    #[c2rust::src_loc = "148:5"]
    pub const ISOM_BRAND_TYPE_CAQV: lsmash_brand_type = 1667330422;
    #[c2rust::src_loc = "147:5"]
    pub const ISOM_BRAND_TYPE_BBXM: lsmash_brand_type = 1650620525;
    #[c2rust::src_loc = "146:5"]
    pub const ISOM_BRAND_TYPE_AVC1: lsmash_brand_type = 1635148593;
    #[c2rust::src_loc = "145:5"]
    pub const ISOM_BRAND_TYPE_ROSS: lsmash_brand_type = 1380930387;
    #[c2rust::src_loc = "144:5"]
    pub const ISOM_BRAND_TYPE_MPPI: lsmash_brand_type = 1297109065;
    #[c2rust::src_loc = "143:5"]
    pub const ISOM_BRAND_TYPE_MFSM: lsmash_brand_type = 1296454477;
    #[c2rust::src_loc = "142:5"]
    pub const ISOM_BRAND_TYPE_M4V: lsmash_brand_type = 1295275552;
    #[c2rust::src_loc = "141:5"]
    pub const ISOM_BRAND_TYPE_M4P: lsmash_brand_type = 1295274016;
    #[c2rust::src_loc = "140:5"]
    pub const ISOM_BRAND_TYPE_M4B: lsmash_brand_type = 1295270432;
    #[c2rust::src_loc = "139:5"]
    pub const ISOM_BRAND_TYPE_M4A: lsmash_brand_type = 1295270176;
    #[c2rust::src_loc = "138:5"]
    pub const ISOM_BRAND_TYPE_LCAG: lsmash_brand_type = 1279476039;
    #[c2rust::src_loc = "137:5"]
    pub const ISOM_BRAND_TYPE_CDES: lsmash_brand_type = 1128555891;
    #[c2rust::src_loc = "136:5"]
    pub const ISOM_BRAND_TYPE_CAEP: lsmash_brand_type = 1128351056;
    #[c2rust::src_loc = "135:5"]
    pub const ISOM_BRAND_TYPE_ARRI: lsmash_brand_type = 1095914057;
    #[c2rust::src_loc = "134:5"]
    pub const ISOM_BRAND_TYPE_3GT9: lsmash_brand_type = 862417977;
    #[c2rust::src_loc = "133:5"]
    pub const ISOM_BRAND_TYPE_3GS9: lsmash_brand_type = 862417721;
    #[c2rust::src_loc = "132:5"]
    pub const ISOM_BRAND_TYPE_3GS6: lsmash_brand_type = 862417718;
    #[c2rust::src_loc = "131:5"]
    pub const ISOM_BRAND_TYPE_3GR9: lsmash_brand_type = 862417465;
    #[c2rust::src_loc = "130:5"]
    pub const ISOM_BRAND_TYPE_3GR6: lsmash_brand_type = 862417462;
    #[c2rust::src_loc = "129:5"]
    pub const ISOM_BRAND_TYPE_3GP9: lsmash_brand_type = 862416953;
    #[c2rust::src_loc = "128:5"]
    pub const ISOM_BRAND_TYPE_3GP8: lsmash_brand_type = 862416952;
    #[c2rust::src_loc = "127:5"]
    pub const ISOM_BRAND_TYPE_3GP7: lsmash_brand_type = 862416951;
    #[c2rust::src_loc = "126:5"]
    pub const ISOM_BRAND_TYPE_3GP6: lsmash_brand_type = 862416950;
    #[c2rust::src_loc = "125:5"]
    pub const ISOM_BRAND_TYPE_3GP5: lsmash_brand_type = 862416949;
    #[c2rust::src_loc = "124:5"]
    pub const ISOM_BRAND_TYPE_3GP4: lsmash_brand_type = 862416948;
    #[c2rust::src_loc = "123:5"]
    pub const ISOM_BRAND_TYPE_3GM9: lsmash_brand_type = 862416185;
    #[c2rust::src_loc = "122:5"]
    pub const ISOM_BRAND_TYPE_3GH9: lsmash_brand_type = 862414905;
    #[c2rust::src_loc = "121:5"]
    pub const ISOM_BRAND_TYPE_3GG9: lsmash_brand_type = 862414649;
    #[c2rust::src_loc = "120:5"]
    pub const ISOM_BRAND_TYPE_3GG6: lsmash_brand_type = 862414646;
    #[c2rust::src_loc = "119:5"]
    pub const ISOM_BRAND_TYPE_3GF9: lsmash_brand_type = 862414393;
    #[c2rust::src_loc = "118:5"]
    pub const ISOM_BRAND_TYPE_3GE9: lsmash_brand_type = 862414137;
    #[c2rust::src_loc = "117:5"]
    pub const ISOM_BRAND_TYPE_3GE6: lsmash_brand_type = 862414134;
    #[c2rust::src_loc = "116:5"]
    pub const ISOM_BRAND_TYPE_3G2A: lsmash_brand_type = 862401121;
    #[c2rust::src_loc = "100:9"]
    pub type lsmash_file_mode = c_uint;
    #[c2rust::src_loc = "111:5"]
    pub const LSMASH_FILE_MODE_WRITE_FRAGMENTED: lsmash_file_mode = 5;
    #[c2rust::src_loc = "110:5"]
    pub const LSMASH_FILE_MODE_SEGMENT: lsmash_file_mode = 256;
    #[c2rust::src_loc = "109:5"]
    pub const LSMASH_FILE_MODE_INDEX: lsmash_file_mode = 128;
    #[c2rust::src_loc = "108:5"]
    pub const LSMASH_FILE_MODE_MEDIA: lsmash_file_mode = 64;
    #[c2rust::src_loc = "107:5"]
    pub const LSMASH_FILE_MODE_INITIALIZATION: lsmash_file_mode = 32;
    #[c2rust::src_loc = "106:5"]
    pub const LSMASH_FILE_MODE_BOX: lsmash_file_mode = 16;
    #[c2rust::src_loc = "105:5"]
    pub const LSMASH_FILE_MODE_DUMP: lsmash_file_mode = 8;
    #[c2rust::src_loc = "104:5"]
    pub const LSMASH_FILE_MODE_FRAGMENTED: lsmash_file_mode = 4;
    #[c2rust::src_loc = "103:5"]
    pub const LSMASH_FILE_MODE_READ: lsmash_file_mode = 2;
    #[c2rust::src_loc = "102:5"]
    pub const LSMASH_FILE_MODE_WRITE: lsmash_file_mode = 1;
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "1373:9"]
    pub struct lsmash_video_summary_t {
        pub summary_type: lsmash_summary_type,
        pub sample_type: lsmash_codec_type_t,
        pub opaque: *mut lsmash_codec_specific_list_t,
        pub max_au_length: uint32_t,
        pub data_ref_index: uint32_t,
        pub timescale: uint32_t,
        pub timebase: uint32_t,
        pub vfr: uint8_t,
        pub sample_per_field: uint8_t,
        pub width: uint32_t,
        pub height: uint32_t,
        pub compressorname: [c_char; 33],
        pub depth: lsmash_video_depth,
        pub clap: lsmash_clap_t,
        pub par_h: uint32_t,
        pub par_v: uint32_t,
        pub color: C2RustUnnamed_5,
    }
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "1392:5"]
    pub struct C2RustUnnamed_5 {
        pub primaries_index: uint16_t,
        pub transfer_index: uint16_t,
        pub matrix_index: uint16_t,
        pub full_range: uint8_t,
    }
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "1210:9"]
    pub struct lsmash_clap_t {
        pub width: lsmash_rational_u32_t,
        pub height: lsmash_rational_u32_t,
        pub horizontal_offset: lsmash_rational_s32_t,
        pub vertical_offset: lsmash_rational_s32_t,
    }
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "374:9"]
    pub struct lsmash_rational_s32_t {
        pub n: int32_t,
        pub d: uint32_t,
    }
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "368:9"]
    pub struct lsmash_rational_u32_t {
        pub n: uint32_t,
        pub d: uint32_t,
    }
    #[c2rust::src_loc = "1227:9"]
    pub type lsmash_video_depth = c_uint;
    #[c2rust::src_loc = "1253:5"]
    pub const QT_VIDEO_DEPTH_32ARGB: lsmash_video_depth = 32;
    #[c2rust::src_loc = "1252:5"]
    pub const QT_VIDEO_DEPTH_24RGB: lsmash_video_depth = 24;
    #[c2rust::src_loc = "1251:5"]
    pub const QT_VIDEO_DEPTH_555RGB: lsmash_video_depth = 16;
    #[c2rust::src_loc = "1248:5"]
    pub const QT_VIDEO_DEPTH_GRAYSCALE_8: lsmash_video_depth = 40;
    #[c2rust::src_loc = "1247:5"]
    pub const QT_VIDEO_DEPTH_GRAYSCALE_4: lsmash_video_depth = 36;
    #[c2rust::src_loc = "1246:5"]
    pub const QT_VIDEO_DEPTH_GRAYSCALE_2: lsmash_video_depth = 34;
    #[c2rust::src_loc = "1245:5"]
    pub const QT_VIDEO_DEPTH_GRAYSCALE_1: lsmash_video_depth = 33;
    #[c2rust::src_loc = "1244:5"]
    pub const QT_VIDEO_DEPTH_COLOR_32: lsmash_video_depth = 32;
    #[c2rust::src_loc = "1243:5"]
    pub const QT_VIDEO_DEPTH_COLOR_24: lsmash_video_depth = 24;
    #[c2rust::src_loc = "1242:5"]
    pub const QT_VIDEO_DEPTH_COLOR_16: lsmash_video_depth = 16;
    #[c2rust::src_loc = "1241:5"]
    pub const QT_VIDEO_DEPTH_COLOR_8: lsmash_video_depth = 8;
    #[c2rust::src_loc = "1240:5"]
    pub const QT_VIDEO_DEPTH_COLOR_4: lsmash_video_depth = 4;
    #[c2rust::src_loc = "1239:5"]
    pub const QT_VIDEO_DEPTH_COLOR_2: lsmash_video_depth = 2;
    #[c2rust::src_loc = "1238:5"]
    pub const QT_VIDEO_DEPTH_COLOR_1: lsmash_video_depth = 1;
    #[c2rust::src_loc = "1234:5"]
    pub const AVC_DEPTH_WITH_ALPHA: lsmash_video_depth = 32;
    #[c2rust::src_loc = "1233:5"]
    pub const AVC_DEPTH_GRAYSCALE_WITH_NO_ALPHA: lsmash_video_depth = 40;
    #[c2rust::src_loc = "1232:5"]
    pub const AVC_DEPTH_COLOR_WITH_NO_ALPHA: lsmash_video_depth = 24;
    #[c2rust::src_loc = "1229:5"]
    pub const ISOM_DEPTH_TEMPLATE: lsmash_video_depth = 24;
    #[c2rust::src_loc = "967:1"]
    pub type lsmash_codec_specific_list_t = lsmash_codec_specific_list_tag;
    #[c2rust::src_loc = "478:1"]
    pub type lsmash_box_type_t = lsmash_codec_type_t;
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "478:9"]
    pub struct lsmash_codec_type_t {
        pub fourcc: lsmash_compact_box_type_t,
        pub user: lsmash_extended_box_type_t,
    }
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "465:9"]
    pub struct lsmash_extended_box_type_t {
        pub fourcc: uint32_t,
        pub id: [uint8_t; 12],
    }
    #[c2rust::src_loc = "462:1"]
    pub type lsmash_compact_box_type_t = uint32_t;
    #[c2rust::src_loc = "903:9"]
    pub type lsmash_summary_type = c_uint;
    #[c2rust::src_loc = "907:5"]
    pub const LSMASH_SUMMARY_TYPE_AUDIO: lsmash_summary_type = 2;
    #[c2rust::src_loc = "906:5"]
    pub const LSMASH_SUMMARY_TYPE_VIDEO: lsmash_summary_type = 1;
    #[c2rust::src_loc = "905:5"]
    pub const LSMASH_SUMMARY_TYPE_UNKNOWN: lsmash_summary_type = 0;
    #[c2rust::src_loc = "77:1"]
    pub type lsmash_root_t = lsmash_root_tag;
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "987:9"]
    pub struct lsmash_summary_t {
        pub summary_type: lsmash_summary_type,
        pub sample_type: lsmash_codec_type_t,
        pub opaque: *mut lsmash_codec_specific_list_t,
        pub max_au_length: uint32_t,
        pub data_ref_index: uint32_t,
    }
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "261:9"]
    pub struct lsmash_adhoc_remux_t {
        pub buffer_size: uint64_t,
        pub func: lsmash_adhoc_remux_callback,
        pub param: *mut c_void,
    }
    #[c2rust::src_loc = "260:1"]
    pub type lsmash_adhoc_remux_callback =
        Option<unsafe extern "C" fn(*mut c_void, uint64_t, uint64_t) -> c_int>;
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "2044:9"]
    pub struct lsmash_edit_t {
        pub duration: uint64_t,
        pub start_time: int64_t,
        pub rate: int32_t,
    }
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "1542:9"]
    pub struct lsmash_sample_t {
        pub length: uint32_t,
        pub data: *mut uint8_t,
        pub dts: uint64_t,
        pub cts: uint64_t,
        pub pos: uint64_t,
        pub index: uint32_t,
        pub prop: lsmash_sample_property_t,
    }
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "1528:9"]
    pub struct lsmash_sample_property_t {
        pub ra_flags: lsmash_random_access_flag,
        pub post_roll: lsmash_post_roll_t,
        pub pre_roll: lsmash_pre_roll_t,
        pub allow_earlier: uint8_t,
        pub leading: uint8_t,
        pub independent: uint8_t,
        pub disposable: uint8_t,
        pub redundant: uint8_t,
        pub reserved: [uint8_t; 3],
    }
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "1513:9"]
    pub struct lsmash_pre_roll_t {
        pub distance: uint32_t,
    }
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "1499:9"]
    pub struct lsmash_post_roll_t {
        pub identifier: uint32_t,
        pub complete: uint32_t,
    }
    #[c2rust::src_loc = "1444:9"]
    pub type lsmash_random_access_flag = c_uint;
    #[c2rust::src_loc = "1488:5"]
    pub const QT_SAMPLE_RANDOM_ACCESS_FLAG_OPEN_RAP: lsmash_random_access_flag = 20;
    #[c2rust::src_loc = "1485:5"]
    pub const QT_SAMPLE_RANDOM_ACCESS_FLAG_CLOSED_RAP: lsmash_random_access_flag = 12;
    #[c2rust::src_loc = "1483:5"]
    pub const QT_SAMPLE_RANDOM_ACCESS_FLAG_OPEN: lsmash_random_access_flag = 16;
    #[c2rust::src_loc = "1482:5"]
    pub const QT_SAMPLE_RANDOM_ACCESS_FLAG_CLOSED: lsmash_random_access_flag = 8;
    #[c2rust::src_loc = "1481:5"]
    pub const QT_SAMPLE_RANDOM_ACCESS_FLAG_RAP: lsmash_random_access_flag = 4;
    #[c2rust::src_loc = "1476:5"]
    pub const QT_SAMPLE_RANDOM_ACCESS_FLAG_PARTIAL_SYNC: lsmash_random_access_flag = 2;
    #[c2rust::src_loc = "1475:5"]
    pub const QT_SAMPLE_RANDOM_ACCESS_FLAG_SYNC: lsmash_random_access_flag = 1;
    #[c2rust::src_loc = "1474:5"]
    pub const QT_SAMPLE_RANDOM_ACCESS_FLAG_NONE: lsmash_random_access_flag = 0;
    #[c2rust::src_loc = "1469:5"]
    pub const ISOM_SAMPLE_RANDOM_ACCESS_FLAG_PRE_ROLL_END: lsmash_random_access_flag = 160;
    #[c2rust::src_loc = "1466:5"]
    pub const ISOM_SAMPLE_RANDOM_ACCESS_FLAG_POST_ROLL_START: lsmash_random_access_flag = 96;
    #[c2rust::src_loc = "1463:5"]
    pub const ISOM_SAMPLE_RANDOM_ACCESS_FLAG_OPEN_RAP: lsmash_random_access_flag = 20;
    #[c2rust::src_loc = "1460:5"]
    pub const ISOM_SAMPLE_RANDOM_ACCESS_FLAG_CLOSED_RAP: lsmash_random_access_flag = 12;
    #[c2rust::src_loc = "1457:5"]
    pub const ISOM_SAMPLE_RANDOM_ACCESS_FLAG_GDR_END: lsmash_random_access_flag = 128;
    #[c2rust::src_loc = "1455:5"]
    pub const ISOM_SAMPLE_RANDOM_ACCESS_FLAG_GDR_START: lsmash_random_access_flag = 64;
    #[c2rust::src_loc = "1454:5"]
    pub const ISOM_SAMPLE_RANDOM_ACCESS_FLAG_GDR: lsmash_random_access_flag = 32;
    #[c2rust::src_loc = "1452:5"]
    pub const ISOM_SAMPLE_RANDOM_ACCESS_FLAG_OPEN: lsmash_random_access_flag = 16;
    #[c2rust::src_loc = "1450:5"]
    pub const ISOM_SAMPLE_RANDOM_ACCESS_FLAG_CLOSED: lsmash_random_access_flag = 8;
    #[c2rust::src_loc = "1449:5"]
    pub const ISOM_SAMPLE_RANDOM_ACCESS_FLAG_RAP: lsmash_random_access_flag = 4;
    #[c2rust::src_loc = "1448:5"]
    pub const ISOM_SAMPLE_RANDOM_ACCESS_FLAG_SYNC: lsmash_random_access_flag = 1;
    #[c2rust::src_loc = "1447:5"]
    pub const ISOM_SAMPLE_RANDOM_ACCESS_FLAG_NONE: lsmash_random_access_flag = 0;
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "958:9"]
    pub struct lsmash_codec_specific_t {
        pub type_0: lsmash_codec_specific_data_type,
        pub format: lsmash_codec_specific_format,
        pub data: lsmash_codec_specific_data_t,
        pub size: uint32_t,
        pub destruct: lsmash_codec_specific_destructor_t,
    }
    #[c2rust::src_loc = "957:1"]
    pub type lsmash_codec_specific_destructor_t = Option<unsafe extern "C" fn(*mut c_void) -> ()>;
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "950:9"]
    pub union lsmash_codec_specific_data_t {
        pub always_null: *mut c_void,
        pub structured: *mut c_void,
        pub unstructured: *mut uint8_t,
    }
    #[c2rust::src_loc = "943:9"]
    pub type lsmash_codec_specific_format = c_int;
    #[c2rust::src_loc = "947:5"]
    pub const LSMASH_CODEC_SPECIFIC_FORMAT_UNSTRUCTURED: lsmash_codec_specific_format = 1;
    #[c2rust::src_loc = "946:5"]
    pub const LSMASH_CODEC_SPECIFIC_FORMAT_STRUCTURED: lsmash_codec_specific_format = 0;
    #[c2rust::src_loc = "945:5"]
    pub const LSMASH_CODEC_SPECIFIC_FORMAT_UNSPECIFIED: lsmash_codec_specific_format = -1;
    #[c2rust::src_loc = "910:9"]
    pub type lsmash_codec_specific_data_type = c_int;
    #[c2rust::src_loc = "940:5"]
    pub const LSMASH_CODEC_SPECIFIC_DATA_TYPE_CODEC_GLOBAL_HEADER: lsmash_codec_specific_data_type =
        20;
    #[c2rust::src_loc = "938:5"]
    pub const LSMASH_CODEC_SPECIFIC_DATA_TYPE_QT_AUDIO_CHANNEL_LAYOUT:
        lsmash_codec_specific_data_type = 19;
    #[c2rust::src_loc = "937:5"]
    pub const LSMASH_CODEC_SPECIFIC_DATA_TYPE_QT_VIDEO_GAMMA_LEVEL:
        lsmash_codec_specific_data_type = 18;
    #[c2rust::src_loc = "936:5"]
    pub const LSMASH_CODEC_SPECIFIC_DATA_TYPE_QT_VIDEO_SIGNIFICANT_BITS:
        lsmash_codec_specific_data_type = 17;
    #[c2rust::src_loc = "935:5"]
    pub const LSMASH_CODEC_SPECIFIC_DATA_TYPE_QT_VIDEO_PIXEL_FORMAT:
        lsmash_codec_specific_data_type = 16;
    #[c2rust::src_loc = "934:5"]
    pub const LSMASH_CODEC_SPECIFIC_DATA_TYPE_QT_VIDEO_FIELD_INFO: lsmash_codec_specific_data_type =
        15;
    #[c2rust::src_loc = "932:5"]
    pub const LSMASH_CODEC_SPECIFIC_DATA_TYPE_QT_AUDIO_DECOMPRESSION_PARAMETERS:
        lsmash_codec_specific_data_type = 14;
    #[c2rust::src_loc = "931:5"]
    pub const LSMASH_CODEC_SPECIFIC_DATA_TYPE_QT_AUDIO_FORMAT_SPECIFIC_FLAGS:
        lsmash_codec_specific_data_type = 13;
    #[c2rust::src_loc = "930:5"]
    pub const LSMASH_CODEC_SPECIFIC_DATA_TYPE_QT_AUDIO_COMMON: lsmash_codec_specific_data_type = 12;
    #[c2rust::src_loc = "929:5"]
    pub const LSMASH_CODEC_SPECIFIC_DATA_TYPE_QT_VIDEO_COMMON: lsmash_codec_specific_data_type = 11;
    #[c2rust::src_loc = "927:5"]
    pub const LSMASH_CODEC_SPECIFIC_DATA_TYPE_ISOM_VIDEO_H264_BITRATE:
        lsmash_codec_specific_data_type = 10;
    #[c2rust::src_loc = "926:5"]
    pub const LSMASH_CODEC_SPECIFIC_DATA_TYPE_ISOM_VIDEO_SAMPLE_SCALE:
        lsmash_codec_specific_data_type = 9;
    #[c2rust::src_loc = "924:5"]
    pub const LSMASH_CODEC_SPECIFIC_DATA_TYPE_ISOM_AUDIO_ALAC: lsmash_codec_specific_data_type = 8;
    #[c2rust::src_loc = "923:5"]
    pub const LSMASH_CODEC_SPECIFIC_DATA_TYPE_ISOM_AUDIO_DTS: lsmash_codec_specific_data_type = 7;
    #[c2rust::src_loc = "922:5"]
    pub const LSMASH_CODEC_SPECIFIC_DATA_TYPE_ISOM_AUDIO_EC_3: lsmash_codec_specific_data_type = 6;
    #[c2rust::src_loc = "921:5"]
    pub const LSMASH_CODEC_SPECIFIC_DATA_TYPE_ISOM_AUDIO_AC_3: lsmash_codec_specific_data_type = 5;
    #[c2rust::src_loc = "920:5"]
    pub const LSMASH_CODEC_SPECIFIC_DATA_TYPE_ISOM_VIDEO_VC_1: lsmash_codec_specific_data_type = 4;
    #[c2rust::src_loc = "919:5"]
    pub const LSMASH_CODEC_SPECIFIC_DATA_TYPE_ISOM_VIDEO_HEVC: lsmash_codec_specific_data_type = 3;
    #[c2rust::src_loc = "918:5"]
    pub const LSMASH_CODEC_SPECIFIC_DATA_TYPE_ISOM_VIDEO_H264: lsmash_codec_specific_data_type = 2;
    #[c2rust::src_loc = "916:5"]
    pub const LSMASH_CODEC_SPECIFIC_DATA_TYPE_MP4SYS_DECODER_CONFIG:
        lsmash_codec_specific_data_type = 1;
    #[c2rust::src_loc = "914:5"]
    pub const LSMASH_CODEC_SPECIFIC_DATA_TYPE_UNKNOWN: lsmash_codec_specific_data_type = 0;
    #[c2rust::src_loc = "912:5"]
    pub const LSMASH_CODEC_SPECIFIC_DATA_TYPE_UNSPECIFIED: lsmash_codec_specific_data_type = -1;
    #[c2rust::src_loc = "3069:9"]
    pub type lsmash_h264_parameter_set_type = c_uint;
    #[c2rust::src_loc = "3075:5"]
    pub const H264_PARAMETER_SET_TYPE_NUM: lsmash_h264_parameter_set_type = 3;
    #[c2rust::src_loc = "3073:5"]
    pub const H264_PARAMETER_SET_TYPE_SPSEXT: lsmash_h264_parameter_set_type = 2;
    #[c2rust::src_loc = "3072:5"]
    pub const H264_PARAMETER_SET_TYPE_PPS: lsmash_h264_parameter_set_type = 1;
    #[c2rust::src_loc = "3071:5"]
    pub const H264_PARAMETER_SET_TYPE_SPS: lsmash_h264_parameter_set_type = 0;
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "3080:9"]
    pub struct lsmash_h264_specific_parameters_t {
        pub AVCProfileIndication: uint8_t,
        pub profile_compatibility: uint8_t,
        pub AVCLevelIndication: uint8_t,
        pub lengthSizeMinusOne: uint8_t,
        pub chroma_format: uint8_t,
        pub bit_depth_luma_minus8: uint8_t,
        pub bit_depth_chroma_minus8: uint8_t,
        pub parameter_sets: *mut lsmash_h264_parameter_sets_t,
    }
    #[c2rust::src_loc = "3078:1"]
    pub type lsmash_h264_parameter_sets_t = lsmash_h264_parameter_sets_tag;
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "1756:9"]
    pub struct lsmash_media_parameters_t {
        pub handler_type: lsmash_media_type,
        pub timescale: uint32_t,
        pub duration: uint64_t,
        pub roll_grouping: uint8_t,
        pub rap_grouping: uint8_t,
        pub MAC_language: uint16_t,
        pub ISO_language: uint16_t,
        pub media_handler_name: *mut c_char,
        pub data_handler_name: *mut c_char,
        pub media_handler_name_shadow: [c_char; 256],
        pub data_handler_name_shadow: [c_char; 256],
        pub compact_sample_size_table: uint8_t,
        pub no_sample_dependency_table: uint8_t,
        pub reserved: [uint8_t; 2],
    }
    #[c2rust::src_loc = "1619:9"]
    pub type lsmash_media_type = c_uint;
    #[c2rust::src_loc = "1645:5"]
    pub const ISOM_MEDIA_HANDLER_TYPE_VIDEO_TRACK: lsmash_media_type = 1986618469;
    #[c2rust::src_loc = "1644:5"]
    pub const ISOM_MEDIA_HANDLER_TYPE_PROPRIETARY_DESCRIPTIVE_METADATA: lsmash_media_type =
        1970432288;
    #[c2rust::src_loc = "1643:5"]
    pub const ISOM_MEDIA_HANDLER_TYPE_TEXT_TRACK: lsmash_media_type = 1952807028;
    #[c2rust::src_loc = "1642:5"]
    pub const ISOM_MEDIA_HANDLER_TYPE_AUDIO_TRACK: lsmash_media_type = 1936684398;
    #[c2rust::src_loc = "1641:5"]
    pub const ISOM_MEDIA_HANDLER_TYPE_KEY_MANAGEMENT_MESSAGES: lsmash_media_type = 1936420205;
    #[c2rust::src_loc = "1640:5"]
    pub const ISOM_MEDIA_HANDLER_TYPE_SCENE_DESCRIPTION_STREAM: lsmash_media_type = 1935962989;
    #[c2rust::src_loc = "1639:5"]
    pub const ISOM_MEDIA_HANDLER_TYPE_OBJECT_DESCRIPTOR_STREAM: lsmash_media_type = 1868854125;
    #[c2rust::src_loc = "1638:5"]
    pub const ISOM_MEDIA_HANDLER_TYPE_OBJECT_CONTENT_INFO_STREAM: lsmash_media_type = 1868788589;
    #[c2rust::src_loc = "1637:5"]
    pub const ISOM_MEDIA_HANDLER_TYPE_MPEG21_DIGITAL_ITEM: lsmash_media_type = 1836069425;
    #[c2rust::src_loc = "1636:5"]
    pub const ISOM_MEDIA_HANDLER_TYPE_MPEGJ_STREAM: lsmash_media_type = 1835692909;
    #[c2rust::src_loc = "1635:5"]
    pub const ISOM_MEDIA_HANDLER_TYPE_TIMED_METADATA_TRACK: lsmash_media_type = 1835365473;
    #[c2rust::src_loc = "1634:5"]
    pub const ISOM_MEDIA_HANDLER_TYPE_MPEG7_STREAM: lsmash_media_type = 1832350573;
    #[c2rust::src_loc = "1633:5"]
    pub const ISOM_MEDIA_HANDLER_TYPE_IPMP_STREAM: lsmash_media_type = 1768977261;
    #[c2rust::src_loc = "1632:5"]
    pub const ISOM_MEDIA_HANDLER_TYPE_IPDC_ELECTRONIC_SERVICE_GUIDE: lsmash_media_type = 1768973411;
    #[c2rust::src_loc = "1631:5"]
    pub const ISOM_MEDIA_HANDLER_TYPE_HINT_TRACK: lsmash_media_type = 1751740020;
    #[c2rust::src_loc = "1630:5"]
    pub const ISOM_MEDIA_HANDLER_TYPE_GENERAL_MPEG4_SYSTEM_STREAM: lsmash_media_type = 1734701933;
    #[c2rust::src_loc = "1629:5"]
    pub const ISOM_MEDIA_HANDLER_TYPE_FONT_DATA_STREAM: lsmash_media_type = 1717859181;
    #[c2rust::src_loc = "1628:5"]
    pub const ISOM_MEDIA_HANDLER_TYPE_BROADBAND_CONTENT_GUIDE: lsmash_media_type = 1685354081;
    #[c2rust::src_loc = "1627:5"]
    pub const ISOM_MEDIA_HANDLER_TYPE_TV_ANYTIME: lsmash_media_type = 1685354081;
    #[c2rust::src_loc = "1626:5"]
    pub const ISOM_MEDIA_HANDLER_TYPE_DVB_MANDATORY_BASIC_DESCRIPTION: lsmash_media_type =
        1684890212;
    #[c2rust::src_loc = "1625:5"]
    pub const ISOM_MEDIA_HANDLER_TYPE_CLOCK_REFERENCE_STREAM: lsmash_media_type = 1668445037;
    #[c2rust::src_loc = "1624:5"]
    pub const ISOM_MEDIA_HANDLER_TYPE_CPCM_AUXILIARY_METADATA: lsmash_media_type = 1668309348;
    #[c2rust::src_loc = "1623:5"]
    pub const ISOM_MEDIA_HANDLER_TYPE_AUXILIARY_VIDEO_TRACK: lsmash_media_type = 1635088502;
    #[c2rust::src_loc = "1622:5"]
    pub const ISOM_MEDIA_HANDLER_TYPE_ID3_VERSION2_METADATA: lsmash_media_type = 1229206322;
    #[c2rust::src_loc = "1621:5"]
    pub const ISOM_MEDIA_HANDLER_TYPE_3GPP_SCENE_DESCRIPTION: lsmash_media_type = 862417764;
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "1993:9"]
    pub struct lsmash_track_parameters_t {
        pub mode: lsmash_track_mode,
        pub track_ID: uint32_t,
        pub duration: uint64_t,
        pub alternate_group: int16_t,
        pub video_layer: int16_t,
        pub audio_volume: int16_t,
        pub matrix: [int32_t; 9],
        pub display_width: uint32_t,
        pub display_height: uint32_t,
        pub aperture_modes: uint8_t,
    }
    #[c2rust::src_loc = "1981:9"]
    pub type lsmash_track_mode = c_uint;
    #[c2rust::src_loc = "1990:5"]
    pub const QT_TRACK_IN_POSTER: lsmash_track_mode = 8;
    #[c2rust::src_loc = "1988:5"]
    pub const ISOM_TRACK_IN_PREVIEW: lsmash_track_mode = 4;
    #[c2rust::src_loc = "1987:5"]
    pub const ISOM_TRACK_IN_MOVIE: lsmash_track_mode = 2;
    #[c2rust::src_loc = "1985:5"]
    pub const ISOM_TRACK_ENABLED: lsmash_track_mode = 1;
    #[c2rust::src_loc = "1350:5"]
    pub const ISOM_MATRIX_INDEX_UNSPECIFIED: C2RustUnnamed_6 = 2;
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "2217:9"]
    pub struct lsmash_movie_parameters_t {
        pub timescale: uint32_t,
        pub duration: uint64_t,
        pub number_of_tracks: uint32_t,
        pub playback_rate: int32_t,
        pub playback_volume: int32_t,
        pub preview_time: int32_t,
        pub preview_duration: int32_t,
        pub poster_time: int32_t,
    }
    #[c2rust::src_loc = "98:1"]
    pub type lsmash_file_t = lsmash_file_tag;
    #[c2rust::src_loc = "1340:1"]
    pub type C2RustUnnamed_6 = c_uint;
    #[c2rust::src_loc = "1370:5"]
    pub const QT_MATRIX_INDEX_SMPTE_240M_1995: C2RustUnnamed_6 = 7;
    #[c2rust::src_loc = "1369:5"]
    pub const QT_MATRIX_INDEX_ITU_R_601_4: C2RustUnnamed_6 = 6;
    #[c2rust::src_loc = "1368:5"]
    pub const QT_MATRIX_INDEX_UNSPECIFIED: C2RustUnnamed_6 = 2;
    #[c2rust::src_loc = "1367:5"]
    pub const QT_MATRIX_INDEX_ITU_R_709_2: C2RustUnnamed_6 = 1;
    #[c2rust::src_loc = "1364:5"]
    pub const ISOM_MATRIX_INDEX_YCGCO: C2RustUnnamed_6 = 8;
    #[c2rust::src_loc = "1362:5"]
    pub const ISOM_MATRIX_INDEX_SMPTE_240M_1999: C2RustUnnamed_6 = 7;
    #[c2rust::src_loc = "1357:5"]
    pub const ISOM_MATRIX_INDEX_SMPTE_170M_2004: C2RustUnnamed_6 = 6;
    #[c2rust::src_loc = "1353:5"]
    pub const ISOM_MATRIX_INDEX_ITU_R470BG: C2RustUnnamed_6 = 5;
    #[c2rust::src_loc = "1351:5"]
    pub const ISOM_MATRIX_INDEX_USFCCT_47_CFR: C2RustUnnamed_6 = 4;
    #[c2rust::src_loc = "1345:5"]
    pub const ISOM_MATRIX_INDEX_ITU_R_709_5: C2RustUnnamed_6 = 1;
    #[c2rust::src_loc = "1343:5"]
    pub const ISOM_MATRIX_INDEX_NO_MATRIX: C2RustUnnamed_6 = 0;
    #[c2rust::src_loc = "2037:9"]
    pub const ISOM_EDIT_MODE_NORMAL: c_int = (1 as c_int) << 16 as c_int;
    #[c2rust::src_loc = "2040:9"]
    pub const ISOM_EDIT_DURATION_UNKNOWN32: c_uint = 0xffffffff as c_uint;
    use ::core::ffi::{c_char, c_double, c_int, c_uint, c_void};

    use super::stdint_intn_h::{int16_t, int32_t, int64_t};
    use super::stdint_uintn_h::{uint16_t, uint32_t, uint64_t, uint8_t};
    extern "C" {
        #[c2rust::src_loc = "967:16"]
        pub type lsmash_codec_specific_list_tag;
        #[c2rust::src_loc = "77:16"]
        pub type lsmash_root_tag;
        #[c2rust::src_loc = "3078:16"]
        pub type lsmash_h264_parameter_sets_tag;
        #[c2rust::src_loc = "98:16"]
        pub type lsmash_file_tag;
        #[c2rust::src_loc = "84:1"]
        pub fn lsmash_create_root() -> *mut lsmash_root_t;
        #[c2rust::src_loc = "90:1"]
        pub fn lsmash_destroy_root(root: *mut lsmash_root_t);
        #[c2rust::src_loc = "291:1"]
        pub fn lsmash_open_file(
            filename: *const c_char,
            open_mode: c_int,
            param: *mut lsmash_file_parameters_t,
        ) -> c_int;
        #[c2rust::src_loc = "302:1"]
        pub fn lsmash_close_file(param: *mut lsmash_file_parameters_t) -> c_int;
        #[c2rust::src_loc = "313:1"]
        pub fn lsmash_set_file(
            root: *mut lsmash_root_t,
            param: *mut lsmash_file_parameters_t,
        ) -> *mut lsmash_file_t;
        #[c2rust::src_loc = "751:25"]
        pub static ISOM_CODEC_TYPE_AVC1_VIDEO: lsmash_codec_type_t;
        #[c2rust::src_loc = "997:1"]
        pub fn lsmash_create_summary(summary_type: lsmash_summary_type) -> *mut lsmash_summary_t;
        #[c2rust::src_loc = "1003:1"]
        pub fn lsmash_cleanup_summary(summary: *mut lsmash_summary_t);
        #[c2rust::src_loc = "1012:1"]
        pub fn lsmash_add_sample_entry(
            root: *mut lsmash_root_t,
            track_ID: uint32_t,
            summary: *mut c_void,
        ) -> c_int;
        #[c2rust::src_loc = "1046:1"]
        pub fn lsmash_create_codec_specific_data(
            type_0: lsmash_codec_specific_data_type,
            format: lsmash_codec_specific_format,
        ) -> *mut lsmash_codec_specific_t;
        #[c2rust::src_loc = "1053:1"]
        pub fn lsmash_destroy_codec_specific_data(specific: *mut lsmash_codec_specific_t);
        #[c2rust::src_loc = "1062:1"]
        pub fn lsmash_add_codec_specific_data(
            summary: *mut lsmash_summary_t,
            specific: *mut lsmash_codec_specific_t,
        ) -> c_int;
        #[c2rust::src_loc = "1579:1"]
        pub fn lsmash_create_sample(size: uint32_t) -> *mut lsmash_sample_t;
        #[c2rust::src_loc = "1608:1"]
        pub fn lsmash_append_sample(
            root: *mut lsmash_root_t,
            track_ID: uint32_t,
            sample: *mut lsmash_sample_t,
        ) -> c_int;
        #[c2rust::src_loc = "1792:1"]
        pub fn lsmash_initialize_media_parameters(param: *mut lsmash_media_parameters_t);
        #[c2rust::src_loc = "1801:1"]
        pub fn lsmash_set_media_parameters(
            root: *mut lsmash_root_t,
            track_ID: uint32_t,
            param: *mut lsmash_media_parameters_t,
        ) -> c_int;
        #[c2rust::src_loc = "1824:1"]
        pub fn lsmash_flush_pooled_samples(
            root: *mut lsmash_root_t,
            track_ID: uint32_t,
            last_sample_delta: uint32_t,
        ) -> c_int;
        #[c2rust::src_loc = "1868:1"]
        pub fn lsmash_get_media_timescale(root: *mut lsmash_root_t, track_ID: uint32_t)
            -> uint32_t;
        #[c2rust::src_loc = "2068:1"]
        pub fn lsmash_create_track(
            root: *mut lsmash_root_t,
            media_type: lsmash_media_type,
        ) -> uint32_t;
        #[c2rust::src_loc = "2082:1"]
        pub fn lsmash_initialize_track_parameters(param: *mut lsmash_track_parameters_t);
        #[c2rust::src_loc = "2091:1"]
        pub fn lsmash_set_track_parameters(
            root: *mut lsmash_root_t,
            track_ID: uint32_t,
            param: *mut lsmash_track_parameters_t,
        ) -> c_int;
        #[c2rust::src_loc = "2159:1"]
        pub fn lsmash_create_explicit_timeline_map(
            root: *mut lsmash_root_t,
            track_ID: uint32_t,
            edit: lsmash_edit_t,
        ) -> c_int;
        #[c2rust::src_loc = "2206:1"]
        pub fn lsmash_modify_explicit_timeline_map(
            root: *mut lsmash_root_t,
            track_ID: uint32_t,
            edit_number: uint32_t,
            edit: lsmash_edit_t,
        ) -> c_int;
        #[c2rust::src_loc = "2233:1"]
        pub fn lsmash_initialize_movie_parameters(param: *mut lsmash_movie_parameters_t);
        #[c2rust::src_loc = "2242:1"]
        pub fn lsmash_set_movie_parameters(
            root: *mut lsmash_root_t,
            param: *mut lsmash_movie_parameters_t,
        ) -> c_int;
        #[c2rust::src_loc = "2256:1"]
        pub fn lsmash_finish_movie(
            root: *mut lsmash_root_t,
            remux: *mut lsmash_adhoc_remux_t,
        ) -> c_int;
        #[c2rust::src_loc = "2287:1"]
        pub fn lsmash_get_movie_timescale(root: *mut lsmash_root_t) -> uint32_t;
        #[c2rust::src_loc = "2365:1"]
        pub fn lsmash_create_fragment_movie(root: *mut lsmash_root_t) -> c_int;
        #[c2rust::src_loc = "3129:1"]
        pub fn lsmash_append_h264_parameter_set(
            param: *mut lsmash_h264_specific_parameters_t,
            ps_type: lsmash_h264_parameter_set_type,
            ps_data: *mut c_void,
            ps_length: uint32_t,
        ) -> c_int;
    }
}
#[c2rust::header_src = "/usr/include/bits/stat.h:58"]
pub mod bits_stat_h {
    use ::core::ffi::c_int;

    #[c2rust::src_loc = "29:9"]
    pub const __S_IFMT: c_int = 0o170000 as c_int;
}
#[c2rust::header_src = "/usr/lib/clang/21/include/__stddef_null.h:58"]
pub mod __stddef_null_h {
    use ::core::ffi::c_void;

    #[c2rust::src_loc = "26:9"]
    pub const NULL: *mut c_void = 0 as *mut c_void;
    #[c2rust::src_loc = "26:9"]
    pub const NULL_0: *mut c_void = 0 as *mut c_void;
}
#[c2rust::header_src = "/home/nwplayer123/Hacks/hex264/x264/config.h:58"]
pub mod config_h {
    use ::core::ffi::c_int;

    #[c2rust::src_loc = "17:9"]
    pub const HAVE_LAVF: c_int = 1 as c_int;
    #[c2rust::src_loc = "25:9"]
    pub const HAVE_GPL: c_int = 1 as c_int;
    #[c2rust::src_loc = "26:9"]
    pub const HAVE_INTERLACED: c_int = 1 as c_int;
    #[c2rust::src_loc = "36:9"]
    pub const HAVE_FFMS: c_int = 0 as c_int;
}
#[c2rust::header_src = "/home/nwplayer123/Hacks/hex264/x264/x264_config.h:58"]
pub mod x264_config_h {
    use ::core::ffi::{c_char, c_int};

    #[c2rust::src_loc = "4:9"]
    pub const X264_CHROMA_FORMAT: c_int = 0 as c_int;
    #[c2rust::src_loc = "7:9"]
    pub const X264_VERSION: [c_char; 16] =
        unsafe { ::core::mem::transmute::<[u8; 16], [c_char; 16]>(*b" r3223M 0480cb0\0") };
}
#[c2rust::header_src = "/usr/include/libswscale/version.h:58"]
pub mod version_h {
    use ::core::ffi::c_int;

    #[c2rust::src_loc = "31:9"]
    pub const LIBSWSCALE_VERSION_MINOR: c_int = 1 as c_int;
    #[c2rust::src_loc = "32:9"]
    pub const LIBSWSCALE_VERSION_MICRO: c_int = 100 as c_int;
}
#[c2rust::header_src = "/usr/include/bits/signum-generic.h:58"]
pub mod signum_generic_h {
    use ::core::ffi::c_int;

    #[c2rust::src_loc = "48:9"]
    pub const SIGINT: c_int = 2 as c_int;
}
#[c2rust::header_src = "/usr/include/libswscale/version_major.h:58"]
pub mod version_major_h {
    use ::core::ffi::c_int;

    #[c2rust::src_loc = "27:9"]
    pub const LIBSWSCALE_VERSION_MAJOR: c_int = 9 as c_int;
}
#[c2rust::header_src = "/usr/include/libavformat/version_major.h:58"]
pub mod libavformat_version_major_h {
    use ::core::ffi::c_int;

    #[c2rust::src_loc = "32:9"]
    pub const LIBAVFORMAT_VERSION_MAJOR: c_int = 62 as c_int;
}
#[c2rust::header_src = "/usr/include/libavformat/version.h:58"]
pub mod libavformat_version_h {
    use ::core::ffi::c_int;

    #[c2rust::src_loc = "34:9"]
    pub const LIBAVFORMAT_VERSION_MINOR: c_int = 3 as c_int;
    #[c2rust::src_loc = "35:9"]
    pub const LIBAVFORMAT_VERSION_MICRO: c_int = 100 as c_int;
}
#[c2rust::header_src = "/usr/include/libavformat/avformat.h:31"]
pub mod avformat_h {
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "544:16"]
    pub struct AVInputFormat {
        pub name: *const c_char,
        pub long_name: *const c_char,
        pub flags: c_int,
        pub extensions: *const c_char,
        pub codec_tag: *const *const AVCodecTag,
        pub priv_class: *const AVClass,
        pub mime_type: *const c_char,
    }
    use ::core::ffi::{c_char, c_int, c_uint, c_void};

    use super::log_h::AVClass;
    extern "C" {
        #[c2rust::src_loc = "446:8"]
        pub type AVCodecTag;
        #[c2rust::src_loc = "1959:1"]
        pub fn av_demuxer_iterate(opaque: *mut *mut c_void) -> *const AVInputFormat;
    }
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "1270:16"]
    pub struct AVFormatContext {
        pub av_class: *const AVClass,
        pub iformat: *const AVInputFormat,
        pub oformat: *const AVOutputFormat,
        pub priv_data: *mut c_void,
        pub pb: *mut AVIOContext,
        pub ctx_flags: c_int,
        pub nb_streams: c_uint,
        pub streams: *mut *mut AVStream,
        pub nb_stream_groups: c_uint,
        pub stream_groups: *mut *mut AVStreamGroup,
        pub nb_chapters: c_uint,
        pub chapters: *mut *mut AVChapter,
        pub url: *mut c_char,
        pub start_time: int64_t,
        pub duration: int64_t,
        pub bit_rate: int64_t,
        pub packet_size: c_uint,
        pub max_delay: c_int,
        pub flags: c_int,
        pub probesize: int64_t,
        pub max_analyze_duration: int64_t,
        pub key: *const uint8_t,
        pub keylen: c_int,
        pub nb_programs: c_uint,
        pub programs: *mut *mut AVProgram,
        pub video_codec_id: AVCodecID,
        pub audio_codec_id: AVCodecID,
        pub subtitle_codec_id: AVCodecID,
        pub data_codec_id: AVCodecID,
        pub metadata: *mut AVDictionary,
        pub start_time_realtime: int64_t,
        pub fps_probe_size: c_int,
        pub error_recognition: c_int,
        pub interrupt_callback: AVIOInterruptCB,
        pub debug: c_int,
        pub max_streams: c_int,
        pub max_index_size: c_uint,
        pub max_picture_buffer: c_uint,
        pub max_interleave_delta: int64_t,
        pub max_ts_probe: c_int,
        pub max_chunk_duration: c_int,
        pub max_chunk_size: c_int,
        pub max_probe_packets: c_int,
        pub strict_std_compliance: c_int,
        pub event_flags: c_int,
        pub avoid_negative_ts: c_int,
        pub audio_preload: c_int,
        pub use_wallclock_as_timestamps: c_int,
        pub skip_estimate_duration_from_pts: c_int,
        pub avio_flags: c_int,
        pub duration_estimation_method: AVDurationEstimationMethod,
        pub skip_initial_bytes: int64_t,
        pub correct_ts_overflow: c_uint,
        pub seek2any: c_int,
        pub flush_packets: c_int,
        pub probe_score: c_int,
        pub format_probesize: c_int,
        pub codec_whitelist: *mut c_char,
        pub format_whitelist: *mut c_char,
        pub protocol_whitelist: *mut c_char,
        pub protocol_blacklist: *mut c_char,
        pub io_repositioned: c_int,
        pub video_codec: *const AVCodec,
        pub audio_codec: *const AVCodec,
        pub subtitle_codec: *const AVCodec,
        pub data_codec: *const AVCodec,
        pub metadata_header_padding: c_int,
        pub opaque: *mut c_void,
        pub control_message_cb: av_format_control_message,
        pub output_ts_offset: int64_t,
        pub dump_separator: *mut uint8_t,
        pub io_open: Option<
            unsafe extern "C" fn(
                *mut AVFormatContext,
                *mut *mut AVIOContext,
                *const c_char,
                c_int,
                *mut *mut AVDictionary,
            ) -> c_int,
        >,
        pub io_close2:
            Option<unsafe extern "C" fn(*mut AVFormatContext, *mut AVIOContext) -> c_int>,
        pub duration_probesize: int64_t,
    }
    #[c2rust::src_loc = "1240:1"]
    pub type av_format_control_message =
        Option<unsafe extern "C" fn(*mut AVFormatContext, c_int, *mut c_void, size_t) -> c_int>;
    #[c2rust::src_loc = "1250:1"]
    pub type AVDurationEstimationMethod = c_uint;
    #[c2rust::src_loc = "1253:5"]
    pub const AVFMT_DURATION_FROM_BITRATE: AVDurationEstimationMethod = 2;
    #[c2rust::src_loc = "1252:5"]
    pub const AVFMT_DURATION_FROM_STREAM: AVDurationEstimationMethod = 1;
    #[c2rust::src_loc = "1251:5"]
    pub const AVFMT_DURATION_FROM_PTS: AVDurationEstimationMethod = 0;
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "1194:16"]
    pub struct AVProgram {
        pub id: c_int,
        pub flags: c_int,
        pub discard: AVDiscard,
        pub stream_index: *mut c_uint,
        pub nb_stream_indexes: c_uint,
        pub metadata: *mut AVDictionary,
        pub program_num: c_int,
        pub pmt_pid: c_int,
        pub pcr_pid: c_int,
        pub pmt_version: c_int,
        pub start_time: int64_t,
        pub end_time: int64_t,
        pub pts_wrap_reference: int64_t,
        pub pts_wrap_behavior: c_int,
    }
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "1229:16"]
    pub struct AVChapter {
        pub id: int64_t,
        pub time_base: AVRational,
        pub start: int64_t,
        pub end: int64_t,
        pub metadata: *mut AVDictionary,
    }
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "1100:16"]
    pub struct AVStreamGroup {
        pub av_class: *const AVClass,
        pub priv_data: *mut c_void,
        pub index: c_uint,
        pub id: int64_t,
        pub type_0: AVStreamGroupParamsType,
        pub params: C2RustUnnamed_0,
        pub metadata: *mut AVDictionary,
        pub nb_streams: c_uint,
        pub streams: *mut *mut AVStream,
        pub disposition: c_int,
    }
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "746:16"]
    pub struct AVStream {
        pub av_class: *const AVClass,
        pub index: c_int,
        pub id: c_int,
        pub codecpar: *mut AVCodecParameters,
        pub priv_data: *mut c_void,
        pub time_base: AVRational,
        pub start_time: int64_t,
        pub duration: int64_t,
        pub nb_frames: int64_t,
        pub disposition: c_int,
        pub discard: AVDiscard,
        pub sample_aspect_ratio: AVRational,
        pub metadata: *mut AVDictionary,
        pub avg_frame_rate: AVRational,
        pub attached_pic: AVPacket,
        pub event_flags: c_int,
        pub r_frame_rate: AVRational,
        pub pts_wrap_bits: c_int,
    }
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "1132:5"]
    pub union C2RustUnnamed_0 {
        pub iamf_audio_element: *mut AVIAMFAudioElement,
        pub iamf_mix_presentation: *mut AVIAMFMixPresentation,
        pub tile_grid: *mut AVStreamGroupTileGrid,
        pub lcevc: *mut AVStreamGroupLCEVC,
    }
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "1072:16"]
    pub struct AVStreamGroupLCEVC {
        pub av_class: *const AVClass,
        pub lcevc_index: c_uint,
        pub width: c_int,
        pub height: c_int,
    }
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "953:16"]
    pub struct AVStreamGroupTileGrid {
        pub av_class: *const AVClass,
        pub nb_tiles: c_uint,
        pub coded_width: c_int,
        pub coded_height: c_int,
        pub offsets: *mut C2RustUnnamed_1,
        pub background: [uint8_t; 4],
        pub horizontal_offset: c_int,
        pub vertical_offset: c_int,
        pub width: c_int,
        pub height: c_int,
        pub coded_side_data: *mut AVPacketSideData,
        pub nb_coded_side_data: c_int,
    }
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "986:5"]
    pub struct C2RustUnnamed_1 {
        pub idx: c_uint,
        pub horizontal: c_int,
        pub vertical: c_int,
    }
    #[c2rust::src_loc = "1089:1"]
    pub type AVStreamGroupParamsType = c_uint;
    #[c2rust::src_loc = "1094:5"]
    pub const AV_STREAM_GROUP_PARAMS_LCEVC: AVStreamGroupParamsType = 4;
    #[c2rust::src_loc = "1093:5"]
    pub const AV_STREAM_GROUP_PARAMS_TILE_GRID: AVStreamGroupParamsType = 3;
    #[c2rust::src_loc = "1092:5"]
    pub const AV_STREAM_GROUP_PARAMS_IAMF_MIX_PRESENTATION: AVStreamGroupParamsType = 2;
    #[c2rust::src_loc = "1091:5"]
    pub const AV_STREAM_GROUP_PARAMS_IAMF_AUDIO_ELEMENT: AVStreamGroupParamsType = 1;
    #[c2rust::src_loc = "1090:5"]
    pub const AV_STREAM_GROUP_PARAMS_NONE: AVStreamGroupParamsType = 0;
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "505:16"]
    pub struct AVOutputFormat {
        pub name: *const c_char,
        pub long_name: *const c_char,
        pub mime_type: *const c_char,
        pub extensions: *const c_char,
        pub audio_codec: AVCodecID,
        pub video_codec: AVCodecID,
        pub subtitle_codec: AVCodecID,
        pub flags: c_int,
        pub codec_tag: *const *const AVCodecTag,
        pub priv_class: *const AVClass,
    }
    use super::__stddef_size_t_h::size_t;
    use super::avio_h::{AVIOContext, AVIOInterruptCB};
    use super::codec_h::AVCodec;
    use super::codec_id_h::AVCodecID;
    use super::codec_par_h::AVCodecParameters;
    use super::defs_h::AVDiscard;
    use super::dict_h::AVDictionary;
    use super::packet_h::{AVPacket, AVPacketSideData};
    use super::rational_h::AVRational;
    use super::stdint_intn_h::int64_t;
    use super::stdint_uintn_h::uint8_t;
    extern "C" {
        #[c2rust::src_loc = "1098:8"]
        pub type AVIAMFMixPresentation;
        #[c2rust::src_loc = "1097:8"]
        pub type AVIAMFAudioElement;
        #[c2rust::src_loc = "2105:1"]
        pub fn av_find_input_format(short_name: *const c_char) -> *const AVInputFormat;
        #[c2rust::src_loc = "2192:1"]
        pub fn avformat_open_input(
            ps: *mut *mut AVFormatContext,
            url: *const c_char,
            fmt: *const AVInputFormat,
            options: *mut *mut AVDictionary,
        ) -> c_int;
        #[c2rust::src_loc = "2216:1"]
        pub fn avformat_find_stream_info(
            ic: *mut AVFormatContext,
            options: *mut *mut AVDictionary,
        ) -> c_int;
        #[c2rust::src_loc = "2293:1"]
        pub fn av_read_frame(s: *mut AVFormatContext, pkt: *mut AVPacket) -> c_int;
        #[c2rust::src_loc = "2375:1"]
        pub fn avformat_close_input(s: *mut *mut AVFormatContext);
    }
}
#[c2rust::header_src = "/usr/include/libavutil/log.h:26"]
pub mod log_h {
    use ::core::ffi::{c_char, c_int, c_uint, c_void};

    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "76:16"]
    pub struct AVClass {
        pub class_name: *const c_char,
        pub item_name: Option<unsafe extern "C" fn(*mut c_void) -> *const c_char>,
        pub option: *const AVOption,
        pub version: c_int,
        pub log_level_offset_offset: c_int,
        pub parent_log_context_offset: c_int,
        pub category: AVClassCategory,
        pub get_category: Option<unsafe extern "C" fn(*mut c_void) -> AVClassCategory>,
        pub query_ranges: Option<
            unsafe extern "C" fn(
                *mut *mut AVOptionRanges,
                *mut c_void,
                *const c_char,
                c_int,
            ) -> c_int,
        >,
        pub child_next: Option<unsafe extern "C" fn(*mut c_void, *mut c_void) -> *mut c_void>,
        pub child_class_iterate: Option<unsafe extern "C" fn(*mut *mut c_void) -> *const AVClass>,
        pub state_flags_offset: c_int,
    }
    #[c2rust::src_loc = "28:9"]
    pub type AVClassCategory = c_uint;
    #[c2rust::src_loc = "47:5"]
    pub const AV_CLASS_CATEGORY_NB: AVClassCategory = 46;
    #[c2rust::src_loc = "46:5"]
    pub const AV_CLASS_CATEGORY_DEVICE_INPUT: AVClassCategory = 45;
    #[c2rust::src_loc = "45:5"]
    pub const AV_CLASS_CATEGORY_DEVICE_OUTPUT: AVClassCategory = 44;
    #[c2rust::src_loc = "44:5"]
    pub const AV_CLASS_CATEGORY_DEVICE_AUDIO_INPUT: AVClassCategory = 43;
    #[c2rust::src_loc = "43:5"]
    pub const AV_CLASS_CATEGORY_DEVICE_AUDIO_OUTPUT: AVClassCategory = 42;
    #[c2rust::src_loc = "42:5"]
    pub const AV_CLASS_CATEGORY_DEVICE_VIDEO_INPUT: AVClassCategory = 41;
    #[c2rust::src_loc = "41:5"]
    pub const AV_CLASS_CATEGORY_DEVICE_VIDEO_OUTPUT: AVClassCategory = 40;
    #[c2rust::src_loc = "40:5"]
    pub const AV_CLASS_CATEGORY_HWDEVICE: AVClassCategory = 11;
    #[c2rust::src_loc = "39:5"]
    pub const AV_CLASS_CATEGORY_SWRESAMPLER: AVClassCategory = 10;
    #[c2rust::src_loc = "38:5"]
    pub const AV_CLASS_CATEGORY_SWSCALER: AVClassCategory = 9;
    #[c2rust::src_loc = "37:5"]
    pub const AV_CLASS_CATEGORY_BITSTREAM_FILTER: AVClassCategory = 8;
    #[c2rust::src_loc = "36:5"]
    pub const AV_CLASS_CATEGORY_FILTER: AVClassCategory = 7;
    #[c2rust::src_loc = "35:5"]
    pub const AV_CLASS_CATEGORY_DECODER: AVClassCategory = 6;
    #[c2rust::src_loc = "34:5"]
    pub const AV_CLASS_CATEGORY_ENCODER: AVClassCategory = 5;
    #[c2rust::src_loc = "33:5"]
    pub const AV_CLASS_CATEGORY_DEMUXER: AVClassCategory = 4;
    #[c2rust::src_loc = "32:5"]
    pub const AV_CLASS_CATEGORY_MUXER: AVClassCategory = 3;
    #[c2rust::src_loc = "31:5"]
    pub const AV_CLASS_CATEGORY_OUTPUT: AVClassCategory = 2;
    #[c2rust::src_loc = "30:5"]
    pub const AV_CLASS_CATEGORY_INPUT: AVClassCategory = 1;
    #[c2rust::src_loc = "29:5"]
    pub const AV_CLASS_CATEGORY_NA: AVClassCategory = 0;
    extern "C" {
        #[c2rust::src_loc = "69:8"]
        pub type AVOptionRanges;
        #[c2rust::src_loc = "96:18"]
        pub type AVOption;
    }
}
#[c2rust::header_src = "/usr/include/bits/stdio.h:26"]
pub mod bits_stdio_h {
    #[inline]
    #[c2rust::src_loc = "81:1"]
    pub unsafe extern "C" fn putchar(mut __c: c_int) -> c_int {
        return putc(__c, stdout);
    }
    use ::core::ffi::c_int;

    use super::stdio_h::{putc, stdout};
}

#[c2rust::header_src = "/usr/include/assert.h:28"]
pub mod assert_h {
    use ::core::ffi::{c_char, c_uint};

    #[c2rust::src_loc = "137:12"]
    pub const __ASSERT_FUNCTION: [c_char; 65] = unsafe {
        ::core::mem::transmute::<[u8; 65], [c_char; 65]>(
            *b"void x264_macroblock_cache_rect(void *, int, int, int, uint32_t)\0",
        )
    };
    extern "C" {
        #[c2rust::src_loc = "67:1"]
        pub fn __assert_fail(
            __assertion: *const c_char,
            __file: *const c_char,
            __line: c_uint,
            __function: *const c_char,
        ) -> !;
    }
}
#[c2rust::header_src = "/usr/include/bits/atomic_wide_counter.h:28"]
pub mod atomic_wide_counter_h {
    use ::core::ffi::{c_uint, c_ulonglong};

    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "25:9"]
    pub union __atomic_wide_counter {
        pub __value64: c_ulonglong,
        pub __value32: C2RustUnnamed,
    }
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "28:3"]
    pub struct C2RustUnnamed {
        pub __low: c_uint,
        pub __high: c_uint,
    }
}

#[c2rust::header_src = "/usr/include/stdint.h:28"]
pub mod stdint_h {
    use ::core::ffi::{c_int, c_uint, c_ulong};

    #[c2rust::src_loc = "76:1"]
    pub type intptr_t = isize;
    #[c2rust::src_loc = "79:1"]
    pub type uintptr_t = usize;
    #[c2rust::src_loc = "106:10"]
    pub const INT16_MIN: c_int = -(32767 as c_int) - 1 as c_int;
    #[c2rust::src_loc = "111:10"]
    pub const INT16_MAX: c_int = 32767 as c_int;
    #[c2rust::src_loc = "112:10"]
    pub const INT32_MAX: c_int = 2147483647 as c_int;
    #[c2rust::src_loc = "117:10"]
    pub const UINT16_MAX: c_int = 65535 as c_int;
    #[c2rust::src_loc = "118:10"]
    pub const UINT32_MAX: c_uint = 4294967295 as c_uint;
    #[c2rust::src_loc = "216:11"]
    pub const SIZE_MAX: c_ulong = 18446744073709551615 as c_ulong;
}
#[c2rust::header_src = "/usr/include/bits/thread-shared-types.h:28"]
pub mod thread_shared_types_h {
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "51:16"]
    pub struct __pthread_internal_list {
        pub __prev: *mut __pthread_internal_list,
        pub __next: *mut __pthread_internal_list,
    }
    #[c2rust::src_loc = "51:1"]
    pub type __pthread_list_t = __pthread_internal_list;
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "94:8"]
    pub struct __pthread_cond_s {
        pub __wseq: __atomic_wide_counter,
        pub __g1_start: __atomic_wide_counter,
        pub __g_size: [c_uint; 2],
        pub __g1_orig_size: c_uint,
        pub __wrefs: c_uint,
        pub __g_signals: [c_uint; 2],
        pub __unused_initialized_1: c_uint,
        pub __unused_initialized_2: c_uint,
    }
    use ::core::ffi::c_uint;

    use super::atomic_wide_counter_h::__atomic_wide_counter;
}
#[c2rust::header_src = "/usr/include/bits/struct_mutex.h:28"]
pub mod struct_mutex_h {
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "22:8"]
    pub struct __pthread_mutex_s {
        pub __lock: c_int,
        pub __count: c_uint,
        pub __owner: c_int,
        pub __nusers: c_uint,
        pub __kind: c_int,
        pub __spins: c_short,
        pub __elision: c_short,
        pub __list: __pthread_list_t,
    }
    use ::core::ffi::{c_int, c_short, c_uint};

    use super::thread_shared_types_h::__pthread_list_t;
}
#[c2rust::header_src = "/usr/include/bits/pthreadtypes.h:28"]
pub mod pthreadtypes_h {
    #[c2rust::src_loc = "27:1"]
    pub type pthread_t = c_ulong;
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "67:9"]
    pub union pthread_mutex_t {
        pub __data: __pthread_mutex_s,
        pub __size: [c_char; 40],
        pub __align: c_long,
    }
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "75:9"]
    pub union pthread_cond_t {
        pub __data: __pthread_cond_s,
        pub __size: [c_char; 48],
        pub __align: c_longlong,
    }
    use ::core::ffi::{c_char, c_int, c_long, c_longlong, c_ulong};

    use super::struct_mutex_h::__pthread_mutex_s;
    use super::thread_shared_types_h::__pthread_cond_s;
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "32:9"]
    pub union pthread_mutexattr_t {
        pub __size: [c_char; 4],
        pub __align: c_int,
    }
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "41:9"]
    pub union pthread_condattr_t {
        pub __size: [c_char; 4],
        pub __align: c_int,
    }

    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "56:7"]
    pub union pthread_attr_t {
        pub __size: [c_char; 56],
        pub __align: c_long,
    }
}
#[c2rust::header_src = "/home/nwplayer123/Hacks/hex264/x264/common/common.h:28"]
pub mod common_h {
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "270:8"]
    pub struct x264_t {
        pub param: x264_param_t,
        pub api: *mut c_void,
        pub thread: [*mut x264_t; 129],
        pub lookahead_thread: [*mut x264_t; 16],
        pub b_thread_active: c_int,
        pub i_thread_phase: c_int,
        pub i_thread_idx: c_int,
        pub i_threadslice_start: c_int,
        pub i_threadslice_end: c_int,
        pub i_threadslice_pass: c_int,
        pub threadpool: *mut x264_threadpool_t,
        pub lookaheadpool: *mut x264_threadpool_t,
        pub mutex: pthread_mutex_t,
        pub cv: pthread_cond_t,
        pub out: C2RustUnnamed_18,
        pub nal_buffer: *mut uint8_t,
        pub nal_buffer_size: c_int,
        pub reconfig_h: *mut x264_t,
        pub reconfig: c_int,
        pub i_frame: c_int,
        pub i_frame_num: c_int,
        pub i_thread_frames: c_int,
        pub i_nal_type: c_int,
        pub i_nal_ref_idc: c_int,
        pub i_disp_fields: int64_t,
        pub i_disp_fields_last_frame: c_int,
        pub i_prev_duration: int64_t,
        pub i_coded_fields: int64_t,
        pub i_cpb_delay: int64_t,
        pub i_coded_fields_lookahead: int64_t,
        pub i_cpb_delay_lookahead: int64_t,
        pub i_cpb_delay_pir_offset: int64_t,
        pub i_cpb_delay_pir_offset_next: int64_t,
        pub b_queued_intra_refresh: c_int,
        pub i_last_idr_pts: int64_t,
        pub i_idr_pic_id: c_int,
        pub dequant4_mf: [*mut [c_int; 16]; 4],
        pub dequant8_mf: [*mut [c_int; 64]; 4],
        pub unquant4_mf: [*mut [c_int; 16]; 4],
        pub unquant8_mf: [*mut [c_int; 64]; 4],
        pub quant4_mf: [*mut [udctcoef; 16]; 4],
        pub quant8_mf: [*mut [udctcoef; 64]; 4],
        pub quant4_bias: [*mut [udctcoef; 16]; 4],
        pub quant8_bias: [*mut [udctcoef; 64]; 4],
        pub quant4_bias0: [*mut [udctcoef; 16]; 4],
        pub quant8_bias0: [*mut [udctcoef; 64]; 4],
        pub nr_offset_emergency: *mut [[udctcoef; 64]; 4],
        pub cost_mv: [*mut uint16_t; 82],
        pub cost_mv_fpel: [[*mut uint16_t; 4]; 82],
        pub cost_table: *mut C2RustUnnamed_17,
        pub chroma_qp_table: *const uint8_t,
        pub sh: x264_slice_header_t,
        pub sps: [x264_sps_t; 1],
        pub pps: [x264_pps_t; 1],
        pub b_sh_backup: c_int,
        pub sh_backup: x264_slice_header_t,
        pub cabac: x264_cabac_t,
        pub frames: C2RustUnnamed_11,
        pub fenc: *mut x264_frame_t,
        pub fdec: *mut x264_frame_t,
        pub i_ref: [c_int; 2],
        pub fref: [[*mut x264_frame_t; 19]; 2],
        pub fref_nearest: [*mut x264_frame_t; 2],
        pub b_ref_reorder: [c_int; 2],
        pub initial_cpb_removal_delay: c_int,
        pub initial_cpb_removal_delay_offset: c_int,
        pub i_reordered_pts_delay: int64_t,
        pub dct: C2RustUnnamed_10,
        pub mb: C2RustUnnamed_7,
        pub rc: *mut crate::src::encoder::ratecontrol::x264_ratecontrol_t,
        pub stat: C2RustUnnamed_6,
        pub nr_offset: *mut [udctcoef; 64],
        pub nr_residual_sum: *mut [uint32_t; 64],
        pub nr_count: *mut uint32_t,
        pub nr_offset_denoise: [[udctcoef; 64]; 4],
        pub nr_residual_sum_buf: [[[uint32_t; 64]; 4]; 2],
        pub nr_count_buf: [[uint32_t; 4]; 2],
        pub luma2chroma_pixel: [uint8_t; 7],
        pub scratch_buffer: *mut c_void,
        pub scratch_buffer2: *mut c_void,
        pub intra_border_backup: [[*mut pixel; 3]; 5],
        pub deblock_strength: [*mut [[[uint8_t; 4]; 8]; 2]; 2],
        pub predict_16x16: [x264_predict_t; 7],
        pub predict_8x8: [x264_predict8x8_t; 12],
        pub predict_4x4: [x264_predict_t; 12],
        pub predict_chroma: [x264_predict_t; 7],
        pub predict_8x8c: [x264_predict_t; 7],
        pub predict_8x16c: [x264_predict_t; 7],
        pub predict_8x8_filter: x264_predict_8x8_filter_t,
        pub pixf: x264_pixel_function_t,
        pub mc: x264_mc_functions_t,
        pub dctf: x264_dct_function_t,
        pub zigzagf: x264_zigzag_function_t,
        pub zigzagf_interlaced: x264_zigzag_function_t,
        pub zigzagf_progressive: x264_zigzag_function_t,
        pub quantf: x264_quant_function_t,
        pub loopf: x264_deblock_function_t,
        pub bsf: x264_bitstream_function_t,
        pub lookahead: *mut x264_lookahead_t,
    }
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "217:16"]
    pub struct x264_lookahead_t {
        pub b_exit_thread: uint8_t,
        pub b_thread_active: uint8_t,
        pub b_analyse_keyframe: uint8_t,
        pub i_last_keyframe: c_int,
        pub i_slicetype_length: c_int,
        pub last_nonb: *mut x264_frame_t,
        pub thread_handle: pthread_t,
        pub ifbuf: x264_sync_frame_list_t,
        pub next: x264_sync_frame_list_t,
        pub ofbuf: x264_sync_frame_list_t,
    }
    #[c2rust::src_loc = "94:5"]
    pub type pixel = uint16_t;
    #[c2rust::src_loc = "96:5"]
    pub type dctcoef = int32_t;
    #[c2rust::src_loc = "97:5"]
    pub type udctcoef = uint32_t;
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "685:5"]
    pub struct C2RustUnnamed_6 {
        pub i_frame_count: [c_int; 3],
        pub i_frame_size: [int64_t; 3],
        pub f_frame_qp: [c_double; 3],
        pub i_consecutive_bframes: [c_int; 17],
        pub f_ssd_global: [c_double; 3],
        pub f_psnr_average: [c_double; 3],
        pub f_psnr_mean_y: [c_double; 3],
        pub f_psnr_mean_u: [c_double; 3],
        pub f_psnr_mean_v: [c_double; 3],
        pub f_ssim_mean_y: [c_double; 3],
        pub f_frame_duration: [c_double; 3],
        pub i_mb_count: [[int64_t; 19]; 3],
        pub i_mb_partition: [[int64_t; 17]; 2],
        pub i_mb_count_8x8dct: [int64_t; 2],
        pub i_mb_count_ref: [[[int64_t; 32]; 2]; 2],
        pub i_mb_cbp: [int64_t; 6],
        pub i_mb_pred_mode: [[int64_t; 13]; 4],
        pub i_mb_field: [int64_t; 3],
        pub i_direct_score: [c_int; 2],
        pub i_direct_frames: [c_int; 2],
        pub i_wpred: [c_int; 2],
        pub frame: x264_frame_stat_t,
    }
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "243:9"]
    pub struct x264_frame_stat_t {
        pub i_mv_bits: c_int,
        pub i_tex_bits: c_int,
        pub i_misc_bits: c_int,
        pub i_mb_count: [c_int; 19],
        pub i_mb_count_i: c_int,
        pub i_mb_count_p: c_int,
        pub i_mb_count_skip: c_int,
        pub i_mb_count_8x8dct: [c_int; 2],
        pub i_mb_count_ref: [[c_int; 32]; 2],
        pub i_mb_partition: [c_int; 17],
        pub i_mb_cbp: [c_int; 6],
        pub i_mb_pred_mode: [[c_int; 13]; 4],
        pub i_mb_field: [c_int; 3],
        pub i_direct_score: [c_int; 2],
        pub i_ssd: [int64_t; 3],
        pub f_ssim: c_double,
        pub i_ssim_cnt: c_int,
    }
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "438:5"]
    pub struct C2RustUnnamed_7 {
        pub i_mb_width: c_int,
        pub i_mb_height: c_int,
        pub i_mb_count: c_int,
        pub chroma_h_shift: c_int,
        pub chroma_v_shift: c_int,
        pub i_mb_stride: c_int,
        pub i_b8_stride: c_int,
        pub i_b4_stride: c_int,
        pub left_b8: [c_int; 2],
        pub left_b4: [c_int; 2],
        pub i_mb_x: c_int,
        pub i_mb_y: c_int,
        pub i_mb_xy: c_int,
        pub i_b8_xy: c_int,
        pub i_b4_xy: c_int,
        pub i_me_method: c_int,
        pub i_subpel_refine: c_int,
        pub b_chroma_me: c_int,
        pub b_trellis: c_int,
        pub b_noise_reduction: c_int,
        pub b_dct_decimate: c_int,
        pub i_psy_rd: c_int,
        pub i_psy_trellis: c_int,
        pub b_interlaced: c_int,
        pub b_adaptive_mbaff: c_int,
        pub mv_min: [c_int; 2],
        pub mv_max: [c_int; 2],
        pub mv_miny_row: [c_int; 3],
        pub mv_maxy_row: [c_int; 3],
        pub mv_min_spel: [c_int; 2],
        pub mv_max_spel: [c_int; 2],
        pub mv_miny_spel_row: [c_int; 3],
        pub mv_maxy_spel_row: [c_int; 3],
        pub mv_limit_fpel: [[int16_t; 2]; 2],
        pub mv_miny_fpel_row: [c_int; 3],
        pub mv_maxy_fpel_row: [c_int; 3],
        pub i_neighbour: c_uint,
        pub i_neighbour8: [c_uint; 4],
        pub i_neighbour4: [c_uint; 16],
        pub i_neighbour_intra: c_uint,
        pub i_neighbour_frame: c_uint,
        pub i_mb_type_top: c_int,
        pub i_mb_type_left: [c_int; 2],
        pub i_mb_type_topleft: c_int,
        pub i_mb_type_topright: c_int,
        pub i_mb_prev_xy: c_int,
        pub i_mb_left_xy: [c_int; 2],
        pub i_mb_top_xy: c_int,
        pub i_mb_topleft_xy: c_int,
        pub i_mb_topright_xy: c_int,
        pub i_mb_top_y: c_int,
        pub i_mb_topleft_y: c_int,
        pub i_mb_topright_y: c_int,
        pub left_index_table: *const x264_left_table_t,
        pub i_mb_top_mbpair_xy: c_int,
        pub topleft_partition: c_int,
        pub b_allow_skip: c_int,
        pub field_decoding_flag: c_int,
        pub base: *mut uint8_t,
        pub type_0: *mut int8_t,
        pub partition: *mut uint8_t,
        pub qp: *mut int8_t,
        pub cbp: *mut int16_t,
        pub intra4x4_pred_mode: *mut [int8_t; 8],
        pub non_zero_count: *mut [uint8_t; 48],
        pub chroma_pred_mode: *mut int8_t,
        pub mv: [*mut [int16_t; 2]; 2],
        pub mvd: [*mut [[uint8_t; 2]; 8]; 2],
        pub ref_0: [*mut int8_t; 2],
        pub mvr: [[*mut [int16_t; 2]; 32]; 2],
        pub skipbp: *mut int8_t,
        pub mb_transform_size: *mut int8_t,
        pub slice_table: *mut int32_t,
        pub field: *mut uint8_t,
        pub p_weight_buf: [*mut pixel; 16],
        pub i_type: c_int,
        pub i_partition: c_int,
        pub i_sub_partition: [uint8_t; 4],
        pub b_transform_8x8: c_int,
        pub i_cbp_luma: c_int,
        pub i_cbp_chroma: c_int,
        pub i_intra16x16_pred_mode: c_int,
        pub i_chroma_pred_mode: c_int,
        pub i_skip_intra: c_int,
        pub b_skip_mc: c_int,
        pub b_reencode_mb: c_int,
        pub ip_offset: c_int,
        pub b_deblock_rdo: c_int,
        pub b_overflow: c_int,
        pub pic: C2RustUnnamed_9,
        pub cache: C2RustUnnamed_8,
        pub i_qp: c_int,
        pub i_chroma_qp: c_int,
        pub i_last_qp: c_int,
        pub i_last_dqp: c_int,
        pub b_variable_qp: c_int,
        pub b_lossless: c_int,
        pub b_direct_auto_read: c_int,
        pub b_direct_auto_write: c_int,
        pub i_trellis_lambda2: [[c_int; 2]; 2],
        pub i_psy_rd_lambda: c_int,
        pub i_chroma_lambda2_offset: c_int,
        pub dist_scale_factor_buf: [[[[int16_t; 4]; 32]; 2]; 2],
        pub dist_scale_factor: *mut [int16_t; 4],
        pub bipred_weight_buf: [[[[int8_t; 4]; 32]; 2]; 2],
        pub bipred_weight: *mut [int8_t; 4],
        pub map_col_to_list0: [int8_t; 18],
        pub ref_blind_dupe: c_int,
        pub deblock_ref_table: [int8_t; 34],
    }
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "614:9"]
    pub struct C2RustUnnamed_8 {
        pub intra4x4_pred_mode: [int8_t; 40],
        pub non_zero_count: [uint8_t; 120],
        pub ref_0: [[int8_t; 40]; 2],
        pub mv: [[[int16_t; 2]; 40]; 2],
        pub mvd: [[[uint8_t; 2]; 40]; 2],
        pub skip: [int8_t; 40],
        pub direct_mv: [[[int16_t; 2]; 4]; 2],
        pub direct_ref: [[int8_t; 4]; 2],
        pub direct_partition: c_int,
        pub pskip_mv: [int16_t; 2],
        pub i_neighbour_transform_size: c_int,
        pub i_neighbour_skip: c_int,
        pub i_cbp_top: c_int,
        pub i_cbp_left: c_int,
        pub topright_mv: [[[int16_t; 2]; 3]; 2],
        pub topright_ref: [[int8_t; 3]; 2],
        pub deblock_strength: *mut [[uint8_t; 4]; 8],
    }
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "567:9"]
    pub struct C2RustUnnamed_9 {
        pub fenc_buf: [pixel; 768],
        pub fdec_buf: [pixel; 1728],
        pub i4x4_fdec_buf: [pixel; 256],
        pub i8x8_fdec_buf: [pixel; 256],
        pub i8x8_dct_buf: [[dctcoef; 64]; 3],
        pub i4x4_dct_buf: [[dctcoef; 16]; 15],
        pub i4x4_nnz_buf: [uint32_t; 4],
        pub i8x8_nnz_buf: [uint32_t; 4],
        pub fenc_dct8: [[dctcoef; 64]; 4],
        pub fenc_dct4: [[dctcoef; 16]; 16],
        pub fenc_satd_cache: [uint32_t; 32],
        pub fenc_hadamard_cache: [uint64_t; 9],
        pub i4x4_cbp: c_int,
        pub i8x8_cbp: c_int,
        pub p_fenc: [*mut pixel; 3],
        pub p_fenc_plane: [*mut pixel; 3],
        pub p_fdec: [*mut pixel; 3],
        pub i_fref: [c_int; 2],
        pub p_fref: [[[*mut pixel; 12]; 32]; 2],
        pub p_fref_w: [*mut pixel; 32],
        pub p_integral: [[*mut uint16_t; 16]; 2],
        pub i_stride: [c_int; 3],
    }
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "233:16"]
    pub struct x264_left_table_t {
        pub intra: [uint8_t; 4],
        pub nnz: [uint8_t; 4],
        pub nnz_chroma: [uint8_t; 4],
        pub mv: [uint8_t; 4],
        pub ref_0: [uint8_t; 4],
    }
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "428:5"]
    pub struct C2RustUnnamed_10 {
        pub luma16x16_dc: [[dctcoef; 16]; 3],
        pub chroma_dc: [[dctcoef; 8]; 2],
        pub luma8x8: [[dctcoef; 64]; 12],
        pub luma4x4: [[dctcoef; 16]; 48],
    }
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "375:5"]
    pub struct C2RustUnnamed_11 {
        pub current: *mut *mut x264_frame_t,
        pub unused: [*mut *mut x264_frame_t; 2],
        pub blank_unused: *mut *mut x264_frame_t,
        pub reference: [*mut x264_frame_t; 18],
        pub i_last_keyframe: c_int,
        pub i_last_idr: c_int,
        pub i_poc_last_open_gop: c_int,
        pub i_input: c_int,
        pub i_max_dpb: c_int,
        pub i_max_ref0: c_int,
        pub i_max_ref1: c_int,
        pub i_delay: c_int,
        pub i_bframe_delay: c_int,
        pub i_bframe_delay_time: int64_t,
        pub i_first_pts: int64_t,
        pub i_prev_reordered_pts: [int64_t; 2],
        pub i_largest_pts: int64_t,
        pub i_second_largest_pts: int64_t,
        pub b_have_lowres: c_int,
        pub b_have_sub8x8_esa: c_int,
    }
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "153:9"]
    pub struct x264_slice_header_t {
        pub sps: *mut x264_sps_t,
        pub pps: *mut x264_pps_t,
        pub i_type: c_int,
        pub i_first_mb: c_int,
        pub i_last_mb: c_int,
        pub i_pps_id: c_int,
        pub i_frame_num: c_int,
        pub b_mbaff: c_int,
        pub b_field_pic: c_int,
        pub b_bottom_field: c_int,
        pub i_idr_pic_id: c_int,
        pub i_poc: c_int,
        pub i_delta_poc_bottom: c_int,
        pub i_delta_poc: [c_int; 2],
        pub i_redundant_pic_cnt: c_int,
        pub b_direct_spatial_mv_pred: c_int,
        pub b_num_ref_idx_override: c_int,
        pub i_num_ref_idx_l0_active: c_int,
        pub i_num_ref_idx_l1_active: c_int,
        pub b_ref_pic_list_reordering: [c_int; 2],
        pub ref_pic_list_order: [[C2RustUnnamed_13; 16]; 2],
        pub b_weighted_pred: c_int,
        pub weight: [[x264_weight_t; 3]; 32],
        pub i_mmco_remove_from_end: c_int,
        pub i_mmco_command_count: c_int,
        pub mmco: [C2RustUnnamed_12; 16],
        pub i_cabac_init_idc: c_int,
        pub i_qp: c_int,
        pub i_qp_delta: c_int,
        pub b_sp_for_swidth: c_int,
        pub i_qs_delta: c_int,
        pub i_disable_deblocking_filter_idc: c_int,
        pub i_alpha_c0_offset: c_int,
        pub i_beta_offset: c_int,
    }
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "197:5"]
    pub struct C2RustUnnamed_12 {
        pub i_difference_of_pic_nums: c_int,
        pub i_poc: c_int,
    }
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "185:5"]
    pub struct C2RustUnnamed_13 {
        pub idc: c_int,
        pub arg: c_int,
    }
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "353:5"]
    pub struct C2RustUnnamed_17 {
        pub ref_0: [[[uint16_t; 33]; 3]; 82],
        pub i4x4_mode: [[uint16_t; 17]; 82],
    }
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "291:5"]
    pub struct C2RustUnnamed_18 {
        pub i_nal: c_int,
        pub i_nals_allocated: c_int,
        pub nal: *mut x264_nal_t,
        pub i_bitstream: c_int,
        pub p_bitstream: *mut uint8_t,
        pub bs: bs_t,
    }
    #[c2rust::src_loc = "95:5"]
    pub type pixel4 = uint64_t;
    #[c2rust::src_loc = "58:9"]
    pub const QP_BD_OFFSET: c_int = 6 as c_int * (BIT_DEPTH - 8 as c_int);
    #[c2rust::src_loc = "59:9"]
    pub const QP_MAX_SPEC: c_int = 51 as c_int + QP_BD_OFFSET;
    #[c2rust::src_loc = "60:9"]
    pub const QP_MAX: c_int = QP_MAX_SPEC + 18 as c_int;
    #[c2rust::src_loc = "63:9"]
    pub const X264_LOOKAHEAD_QP: c_int = 12 as c_int + QP_BD_OFFSET;
    #[c2rust::src_loc = "111:9"]
    pub const SIZEOF_PIXEL: c_int = ::core::mem::size_of::<pixel>() as c_int;
    #[c2rust::src_loc = "570:9"]
    pub const FENC_STRIDE: c_int = 16 as c_int;
    #[c2rust::src_loc = "571:9"]
    pub const FDEC_STRIDE: c_int = 32 as c_int;
    use ::core::ffi::{c_char, c_double, c_int, c_uint, c_void};

    use crate::src::common::quant::x264_quant_function_t;

    use super::bitstream_h::{bs_t, x264_bitstream_function_t};
    use super::cabac_h::x264_cabac_t;
    use super::dct_h::{x264_dct_function_t, x264_zigzag_function_t};
    use super::frame_h::{x264_deblock_function_t, x264_frame_t, x264_sync_frame_list_t};
    use super::internal::BIT_DEPTH;
    use super::mc_h::{x264_mc_functions_t, x264_weight_t};
    use super::pixel_h::x264_pixel_function_t;
    use super::predict_h::{x264_predict8x8_t, x264_predict_8x8_filter_t, x264_predict_t};
    use super::pthreadtypes_h::{pthread_cond_t, pthread_mutex_t, pthread_t};
    use super::set_h::{x264_pps_t, x264_sps_t};
    use super::stdint_intn_h::{int16_t, int32_t, int64_t, int8_t};
    use super::stdint_uintn_h::{uint16_t, uint32_t, uint64_t, uint8_t};
    use super::threadpool_h::x264_threadpool_t;
    use super::x264_h::{x264_nal_t, x264_param_t};
    extern "C" {
        #[c2rust::src_loc = "138:1"]
        pub fn x264_10_log(h: *mut x264_t, i_level: c_int, psz_fmt: *const c_char, ...);
    }
    #[c2rust::src_loc = "61:9"]
    pub const PIXEL_MAX: c_int = ((1 as c_int) << BIT_DEPTH) - 1 as c_int;
    #[c2rust::src_loc = "66:9"]
    pub const NALU_OVERHEAD: c_int = 5 as c_int;
    #[c2rust::src_loc = "67:9"]
    pub const FILLER_OVERHEAD: c_int = NALU_OVERHEAD + 1 as c_int;
    extern "C" {
        #[c2rust::src_loc = "141:1"]
        pub fn x264_10_cavlc_init(h: *mut x264_t);
        #[c2rust::src_loc = "143:1"]
        pub fn x264_10_cabac_init(h: *mut x264_t);
    }

    #[inline(always)]
    #[c2rust::src_loc = "145:1"]
    pub unsafe extern "C" fn x264_clip_pixel(mut x: c_int) -> pixel {
        return (if x & !PIXEL_MAX != 0 {
            -x >> 31 as c_int & PIXEL_MAX
        } else {
            x
        }) as pixel;
    }

    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "765:9"]
    pub struct mvsad_t {
        pub sad: c_int,
        pub mv: [int16_t; 2],
    }

    #[inline(always)]
    #[c2rust::src_loc = "774:1"]
    pub unsafe extern "C" fn x264_predictor_roundclip(
        mut dst: *mut [int16_t; 2],
        mut mvc: *mut [int16_t; 2],
        mut i_mvc: c_int,
        mut mv_limit: *mut [int16_t; 2],
        mut pmv: uint32_t,
    ) -> c_int {
        let mut cnt: c_int = 0 as c_int;
        let mut i: c_int = 0 as c_int;
        while i < i_mvc {
            let mut mx: c_int = (*mvc.offset(i as isize))[0] as c_int + 2 as c_int >> 2 as c_int;
            let mut my: c_int = (*mvc.offset(i as isize))[1] as c_int + 2 as c_int >> 2 as c_int;
            let mut mv: uint32_t = pack16to32_mask(mx, my);
            if !(mv == 0 || mv == pmv) {
                (*dst.offset(cnt as isize))[0] = x264_clip3(
                    mx,
                    (*mv_limit.offset(0))[0] as c_int,
                    (*mv_limit.offset(1))[0] as c_int,
                ) as int16_t;
                (*dst.offset(cnt as isize))[1] = x264_clip3(
                    my,
                    (*mv_limit.offset(0))[1] as c_int,
                    (*mv_limit.offset(1))[1] as c_int,
                ) as int16_t;
                cnt += 1;
            }
            i += 1;
        }
        return cnt;
    }
    #[inline(always)]
    #[c2rust::src_loc = "790:1"]
    pub unsafe extern "C" fn x264_predictor_clip(
        mut dst: *mut [int16_t; 2],
        mut mvc: *mut [int16_t; 2],
        mut i_mvc: c_int,
        mut mv_limit: *mut [int16_t; 2],
        mut pmv: uint32_t,
    ) -> c_int {
        let mut cnt: c_int = 0 as c_int;
        let mut qpel_limit: [c_int; 4] = [
            ((*mv_limit.offset(0))[0] as c_int) << 2 as c_int,
            ((*mv_limit.offset(0))[1] as c_int) << 2 as c_int,
            ((*mv_limit.offset(1))[0] as c_int) << 2 as c_int,
            ((*mv_limit.offset(1))[1] as c_int) << 2 as c_int,
        ];
        let mut i: c_int = 0 as c_int;
        while i < i_mvc {
            let mut mv: uint32_t =
                (*((*mvc.offset(i as isize)).as_mut_ptr() as *mut x264_union32_t)).i;
            let mut mx: c_int = (*mvc.offset(i as isize))[0] as c_int;
            let mut my: c_int = (*mvc.offset(i as isize))[1] as c_int;
            if !(mv == 0 || mv == pmv) {
                (*dst.offset(cnt as isize))[0] =
                    x264_clip3(mx, qpel_limit[0], qpel_limit[2]) as int16_t;
                (*dst.offset(cnt as isize))[1] =
                    x264_clip3(my, qpel_limit[1], qpel_limit[3]) as int16_t;
                cnt += 1;
            }
            i += 1;
        }
        return cnt;
    }
    use super::base_h::{x264_clip3, x264_union32_t};
    use super::macroblock_h::pack16to32_mask;

    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "185:5"]
    pub struct C2RustUnnamed_14 {
        pub idc: c_int,
        pub arg: c_int,
    }
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "291:5"]
    pub struct C2RustUnnamed_19 {
        pub i_nal: c_int,
        pub i_nals_allocated: c_int,
        pub nal: *mut x264_nal_t,
        pub i_bitstream: c_int,
        pub p_bitstream: *mut uint8_t,
        pub bs: bs_t,
    }
}
#[c2rust::header_src = "/home/nwplayer123/Hacks/hex264/x264/common/frame.h:28"]
pub mod frame_h {
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "186:9"]
    pub struct x264_sync_frame_list_t {
        pub list: *mut *mut x264_frame_t,
        pub i_max_size: c_int,
        pub i_size: c_int,
        pub mutex: pthread_mutex_t,
        pub cv_fill: pthread_cond_t,
        pub cv_empty: pthread_cond_t,
    }
    #[c2rust::src_loc = "37:1"]
    pub type x264_frame_t = x264_frame;
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "37:16"]
    pub struct x264_frame {
        pub base: *mut uint8_t,
        pub i_poc: c_int,
        pub i_delta_poc: [c_int; 2],
        pub i_type: c_int,
        pub i_forced_type: c_int,
        pub i_qpplus1: c_int,
        pub i_pts: int64_t,
        pub i_dts: int64_t,
        pub i_reordered_pts: int64_t,
        pub i_duration: int64_t,
        pub f_duration: c_float,
        pub i_cpb_duration: int64_t,
        pub i_cpb_delay: int64_t,
        pub i_dpb_output_delay: int64_t,
        pub param: *mut x264_param_t,
        pub i_frame: c_int,
        pub i_coded: c_int,
        pub i_field_cnt: int64_t,
        pub i_frame_num: c_int,
        pub b_kept_as_ref: c_int,
        pub i_pic_struct: c_int,
        pub b_keyframe: c_int,
        pub b_fdec: uint8_t,
        pub b_last_minigop_bframe: uint8_t,
        pub i_bframes: uint8_t,
        pub f_qp_avg_rc: c_float,
        pub f_qp_avg_aq: c_float,
        pub f_crf_avg: c_float,
        pub i_poc_l0ref0: c_int,
        pub i_csp: c_int,
        pub i_plane: c_int,
        pub i_stride: [c_int; 3],
        pub i_width: [c_int; 3],
        pub i_lines: [c_int; 3],
        pub i_stride_lowres: c_int,
        pub i_width_lowres: c_int,
        pub i_lines_lowres: c_int,
        pub plane: [*mut pixel; 3],
        pub plane_fld: [*mut pixel; 3],
        pub filtered: [[*mut pixel; 4]; 3],
        pub filtered_fld: [[*mut pixel; 4]; 3],
        pub lowres: [*mut pixel; 4],
        pub integral: *mut uint16_t,
        pub buffer: [*mut pixel; 4],
        pub buffer_fld: [*mut pixel; 4],
        pub buffer_lowres: *mut pixel,
        pub weight: [[x264_weight_t; 3]; 16],
        pub weighted: [*mut pixel; 16],
        pub b_duplicate: c_int,
        pub orig: *mut x264_frame,
        pub mb_type: *mut int8_t,
        pub mb_partition: *mut uint8_t,
        pub mv: [*mut [int16_t; 2]; 2],
        pub mv16x16: *mut [int16_t; 2],
        pub lowres_mvs: [[*mut [int16_t; 2]; 17]; 2],
        pub field: *mut uint8_t,
        pub effective_qp: *mut uint8_t,
        pub lowres_costs: [[*mut uint16_t; 18]; 18],
        pub lowres_mv_costs: [[*mut c_int; 17]; 2],
        pub ref_0: [*mut int8_t; 2],
        pub i_ref: [c_int; 2],
        pub ref_poc: [[c_int; 16]; 2],
        pub inv_ref_poc: [int16_t; 2],
        pub i_cost_est: [[c_int; 18]; 18],
        pub i_cost_est_aq: [[c_int; 18]; 18],
        pub i_satd: c_int,
        pub i_intra_mbs: [c_int; 18],
        pub i_row_satds: [[*mut c_int; 18]; 18],
        pub i_row_satd: *mut c_int,
        pub i_row_bits: *mut c_int,
        pub f_row_qp: *mut c_float,
        pub f_row_qscale: *mut c_float,
        pub f_qp_offset: *mut c_float,
        pub f_qp_offset_aq: *mut c_float,
        pub b_intra_calculated: c_int,
        pub i_intra_cost: *mut uint16_t,
        pub i_propagate_cost: *mut uint16_t,
        pub i_inv_qscale_factor: *mut uint16_t,
        pub b_scenecut: c_int,
        pub f_weighted_cost_delta: [c_float; 18],
        pub i_pixel_sum: [uint32_t; 3],
        pub i_pixel_ssd: [uint64_t; 3],
        pub hrd_timing: x264_hrd_t,
        pub i_planned_type: [uint8_t; 251],
        pub i_planned_satd: [c_int; 251],
        pub f_planned_cpb_duration: [c_double; 251],
        pub i_coded_fields_lookahead: int64_t,
        pub i_cpb_delay_lookahead: int64_t,
        pub i_lines_completed: c_int,
        pub i_lines_weighted: c_int,
        pub i_reference_count: c_int,
        pub mutex: pthread_mutex_t,
        pub cv: pthread_cond_t,
        pub i_slice_count: c_int,
        pub f_pir_position: c_float,
        pub i_pir_start_col: c_int,
        pub i_pir_end_col: c_int,
        pub i_frames_since_pir: c_int,
        pub b_corrupt: c_int,
        pub extra_sei: x264_sei_t,
        pub opaque: *mut c_void,
        pub mb_info: *mut uint8_t,
        pub mb_info_free: Option<unsafe extern "C" fn(*mut c_void) -> ()>,
    }
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "198:9"]
    pub struct x264_deblock_function_t {
        pub deblock_luma: [x264_deblock_inter_t; 2],
        pub deblock_chroma: [x264_deblock_inter_t; 2],
        pub deblock_h_chroma_420: x264_deblock_inter_t,
        pub deblock_h_chroma_422: x264_deblock_inter_t,
        pub deblock_luma_intra: [x264_deblock_intra_t; 2],
        pub deblock_chroma_intra: [x264_deblock_intra_t; 2],
        pub deblock_h_chroma_420_intra: x264_deblock_intra_t,
        pub deblock_h_chroma_422_intra: x264_deblock_intra_t,
        pub deblock_luma_mbaff: x264_deblock_inter_t,
        pub deblock_chroma_mbaff: x264_deblock_inter_t,
        pub deblock_chroma_420_mbaff: x264_deblock_inter_t,
        pub deblock_chroma_422_mbaff: x264_deblock_inter_t,
        pub deblock_luma_intra_mbaff: x264_deblock_intra_t,
        pub deblock_chroma_intra_mbaff: x264_deblock_intra_t,
        pub deblock_chroma_420_intra_mbaff: x264_deblock_intra_t,
        pub deblock_chroma_422_intra_mbaff: x264_deblock_intra_t,
        pub deblock_strength: Option<
            unsafe extern "C" fn(
                *mut uint8_t,
                *mut [int8_t; 40],
                *mut [[int16_t; 2]; 40],
                *mut [[uint8_t; 4]; 8],
                c_int,
                c_int,
            ) -> (),
        >,
    }
    #[c2rust::src_loc = "197:1"]
    pub type x264_deblock_intra_t =
        Option<unsafe extern "C" fn(*mut pixel, intptr_t, c_int, c_int) -> ()>;
    #[c2rust::src_loc = "196:1"]
    pub type x264_deblock_inter_t =
        Option<unsafe extern "C" fn(*mut pixel, intptr_t, c_int, c_int, *mut int8_t) -> ()>;
    #[c2rust::src_loc = "32:9"]
    pub const PADH: c_int = 32 as c_int;
    #[c2rust::src_loc = "33:9"]
    pub const PADV: c_int = 32 as c_int;
    #[c2rust::src_loc = "111:13"]
    pub const LOWRES_COST_MASK: c_int = ((1 as c_int) << 14 as c_int) - 1 as c_int;
    #[c2rust::src_loc = "112:13"]
    pub const LOWRES_COST_SHIFT: c_int = 14 as c_int;
    use ::core::ffi::{c_double, c_float, c_int, c_void};

    use super::common_h::{pixel, x264_t};
    use super::mc_h::x264_weight_t;
    use super::pthreadtypes_h::{pthread_cond_t, pthread_mutex_t};
    use super::stdint_h::intptr_t;
    use super::stdint_intn_h::{int16_t, int64_t, int8_t};
    use super::stdint_uintn_h::{uint16_t, uint32_t, uint64_t, uint8_t};
    use super::x264_h::{x264_hrd_t, x264_param_t, x264_sei_t};
    extern "C" {
        #[c2rust::src_loc = "234:1"]
        pub fn x264_10_frame_expand_border_chroma(
            h: *mut x264_t,
            frame: *mut x264_frame_t,
            plane: c_int,
        );
        #[c2rust::src_loc = "243:1"]
        pub fn x264_10_macroblock_deblock(h: *mut x264_t);
        #[c2rust::src_loc = "256:1"]
        pub fn x264_10_frame_cond_wait(frame: *mut x264_frame_t, i_lines_completed: c_int)
            -> c_int;
        #[c2rust::src_loc = "281:1"]
        pub fn x264_10_weight_scale_plane(
            h: *mut x264_t,
            dst: *mut pixel,
            i_dst_stride: intptr_t,
            src: *mut pixel,
            i_src_stride: intptr_t,
            i_width: c_int,
            i_height: c_int,
            w: *mut x264_weight_t,
        );
    }

    use super::x264_h::x264_picture_t;
    extern "C" {
        #[c2rust::src_loc = "222:1"]
        pub fn x264_10_frame_delete(frame: *mut x264_frame_t);
        #[c2rust::src_loc = "225:1"]
        pub fn x264_10_frame_copy_picture(
            h: *mut x264_t,
            dst: *mut x264_frame_t,
            src: *mut x264_picture_t,
        ) -> c_int;
        #[c2rust::src_loc = "228:1"]
        pub fn x264_10_frame_expand_border(h: *mut x264_t, frame: *mut x264_frame_t, mb_y: c_int);
        #[c2rust::src_loc = "230:1"]
        pub fn x264_10_frame_expand_border_filtered(
            h: *mut x264_t,
            frame: *mut x264_frame_t,
            mb_y: c_int,
            b_end: c_int,
        );
        #[c2rust::src_loc = "236:1"]
        pub fn x264_10_frame_expand_border_mod16(h: *mut x264_t, frame: *mut x264_frame_t);
        #[c2rust::src_loc = "238:1"]
        pub fn x264_10_expand_border_mbpair(h: *mut x264_t, mb_x: c_int, mb_y: c_int);
        #[c2rust::src_loc = "241:1"]
        pub fn x264_10_frame_deblock_row(h: *mut x264_t, mb_y: c_int);
        #[c2rust::src_loc = "246:1"]
        pub fn x264_10_frame_filter(
            h: *mut x264_t,
            frame: *mut x264_frame_t,
            mb_y: c_int,
            b_end: c_int,
        );
        #[c2rust::src_loc = "248:1"]
        pub fn x264_10_frame_init_lowres(h: *mut x264_t, frame: *mut x264_frame_t);
        #[c2rust::src_loc = "251:1"]
        pub fn x264_10_deblock_init(
            cpu: uint32_t,
            pf: *mut x264_deblock_function_t,
            b_mbaff: c_int,
        );
        #[c2rust::src_loc = "254:1"]
        pub fn x264_10_frame_cond_broadcast(frame: *mut x264_frame_t, i_lines_completed: c_int);
        #[c2rust::src_loc = "258:1"]
        pub fn x264_10_frame_new_slice(h: *mut x264_t, frame: *mut x264_frame_t) -> c_int;
        #[c2rust::src_loc = "261:1"]
        pub fn x264_10_threadslice_cond_broadcast(h: *mut x264_t, pass: c_int);
        #[c2rust::src_loc = "263:1"]
        pub fn x264_10_threadslice_cond_wait(h: *mut x264_t, pass: c_int);
        #[c2rust::src_loc = "266:10"]
        pub fn x264_10_frame_push(list: *mut *mut x264_frame_t, frame: *mut x264_frame_t);
        #[c2rust::src_loc = "268:10"]
        pub fn x264_10_frame_pop(list: *mut *mut x264_frame_t) -> *mut x264_frame_t;
        #[c2rust::src_loc = "270:10"]
        pub fn x264_10_frame_unshift(list: *mut *mut x264_frame_t, frame: *mut x264_frame_t);
        #[c2rust::src_loc = "272:10"]
        pub fn x264_10_frame_shift(list: *mut *mut x264_frame_t) -> *mut x264_frame_t;
        #[c2rust::src_loc = "275:1"]
        pub fn x264_10_frame_push_unused(h: *mut x264_t, frame: *mut x264_frame_t);
        #[c2rust::src_loc = "277:1"]
        pub fn x264_10_frame_push_blank_unused(h: *mut x264_t, frame: *mut x264_frame_t);
        #[c2rust::src_loc = "279:1"]
        pub fn x264_10_frame_pop_blank_unused(h: *mut x264_t) -> *mut x264_frame_t;
        #[c2rust::src_loc = "284:1"]
        pub fn x264_10_frame_pop_unused(h: *mut x264_t, b_fdec: c_int) -> *mut x264_frame_t;
        #[c2rust::src_loc = "286:1"]
        pub fn x264_10_frame_delete_list(list: *mut *mut x264_frame_t);
    }

    extern "C" {
        #[c2rust::src_loc = "289:1"]
        pub fn x264_10_sync_frame_list_init(
            slist: *mut x264_sync_frame_list_t,
            nelem: c_int,
        ) -> c_int;
        #[c2rust::src_loc = "291:1"]
        pub fn x264_10_sync_frame_list_delete(slist: *mut x264_sync_frame_list_t);
        #[c2rust::src_loc = "293:1"]
        pub fn x264_10_sync_frame_list_push(
            slist: *mut x264_sync_frame_list_t,
            frame: *mut x264_frame_t,
        );
        #[c2rust::src_loc = "295:1"]
        pub fn x264_10_sync_frame_list_pop(slist: *mut x264_sync_frame_list_t)
            -> *mut x264_frame_t;
    }
    extern "C" {
        #[c2rust::src_loc = "232:1"]
        pub fn x264_10_frame_expand_border_lowres(frame: *mut x264_frame_t);
    }
}
#[c2rust::header_src = "/home/nwplayer123/Hacks/hex264/x264/common/mc.h:28"]
pub mod mc_h {
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "235:16"]
    pub struct x264_weight_t {
        pub cachea: [int16_t; 8],
        pub cacheb: [int16_t; 8],
        pub i_denom: int32_t,
        pub i_scale: int32_t,
        pub i_offset: int32_t,
        pub weightfn: *mut weight_fn_t,
    }
    #[c2rust::src_loc = "234:1"]
    pub type weight_fn_t = Option<
        unsafe extern "C" fn(
            *mut pixel,
            intptr_t,
            *mut pixel,
            intptr_t,
            *const x264_weight_t,
            c_int,
        ) -> (),
    >;
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "267:9"]
    pub struct x264_mc_functions_t {
        pub mc_luma: Option<
            unsafe extern "C" fn(
                *mut pixel,
                intptr_t,
                *mut *mut pixel,
                intptr_t,
                c_int,
                c_int,
                c_int,
                c_int,
                *const x264_weight_t,
            ) -> (),
        >,
        pub get_ref: Option<
            unsafe extern "C" fn(
                *mut pixel,
                *mut intptr_t,
                *mut *mut pixel,
                intptr_t,
                c_int,
                c_int,
                c_int,
                c_int,
                *const x264_weight_t,
            ) -> *mut pixel,
        >,
        pub mc_chroma: Option<
            unsafe extern "C" fn(
                *mut pixel,
                *mut pixel,
                intptr_t,
                *mut pixel,
                intptr_t,
                c_int,
                c_int,
                c_int,
                c_int,
            ) -> (),
        >,
        pub avg: [Option<
            unsafe extern "C" fn(
                *mut pixel,
                intptr_t,
                *mut pixel,
                intptr_t,
                *mut pixel,
                intptr_t,
                c_int,
            ) -> (),
        >; 12],
        pub copy: [Option<
            unsafe extern "C" fn(*mut pixel, intptr_t, *mut pixel, intptr_t, c_int) -> (),
        >; 7],
        pub copy_16x16_unaligned:
            Option<unsafe extern "C" fn(*mut pixel, intptr_t, *mut pixel, intptr_t, c_int) -> ()>,
        pub store_interleave_chroma:
            Option<unsafe extern "C" fn(*mut pixel, intptr_t, *mut pixel, *mut pixel, c_int) -> ()>,
        pub load_deinterleave_chroma_fenc:
            Option<unsafe extern "C" fn(*mut pixel, *mut pixel, intptr_t, c_int) -> ()>,
        pub load_deinterleave_chroma_fdec:
            Option<unsafe extern "C" fn(*mut pixel, *mut pixel, intptr_t, c_int) -> ()>,
        pub plane_copy: Option<
            unsafe extern "C" fn(*mut pixel, intptr_t, *mut pixel, intptr_t, c_int, c_int) -> (),
        >,
        pub plane_copy_swap: Option<
            unsafe extern "C" fn(*mut pixel, intptr_t, *mut pixel, intptr_t, c_int, c_int) -> (),
        >,
        pub plane_copy_interleave: Option<
            unsafe extern "C" fn(
                *mut pixel,
                intptr_t,
                *mut pixel,
                intptr_t,
                *mut pixel,
                intptr_t,
                c_int,
                c_int,
            ) -> (),
        >,
        pub plane_copy_deinterleave: Option<
            unsafe extern "C" fn(
                *mut pixel,
                intptr_t,
                *mut pixel,
                intptr_t,
                *mut pixel,
                intptr_t,
                c_int,
                c_int,
            ) -> (),
        >,
        pub plane_copy_deinterleave_yuyv: Option<
            unsafe extern "C" fn(
                *mut pixel,
                intptr_t,
                *mut pixel,
                intptr_t,
                *mut pixel,
                intptr_t,
                c_int,
                c_int,
            ) -> (),
        >,
        pub plane_copy_deinterleave_rgb: Option<
            unsafe extern "C" fn(
                *mut pixel,
                intptr_t,
                *mut pixel,
                intptr_t,
                *mut pixel,
                intptr_t,
                *mut pixel,
                intptr_t,
                c_int,
                c_int,
                c_int,
            ) -> (),
        >,
        pub plane_copy_deinterleave_v210: Option<
            unsafe extern "C" fn(
                *mut pixel,
                intptr_t,
                *mut pixel,
                intptr_t,
                *mut uint32_t,
                intptr_t,
                c_int,
                c_int,
            ) -> (),
        >,
        pub hpel_filter: Option<
            unsafe extern "C" fn(
                *mut pixel,
                *mut pixel,
                *mut pixel,
                *mut pixel,
                intptr_t,
                c_int,
                c_int,
                *mut int16_t,
            ) -> (),
        >,
        pub prefetch_fenc:
            Option<unsafe extern "C" fn(*mut pixel, intptr_t, *mut pixel, intptr_t, c_int) -> ()>,
        pub prefetch_fenc_400:
            Option<unsafe extern "C" fn(*mut pixel, intptr_t, *mut pixel, intptr_t, c_int) -> ()>,
        pub prefetch_fenc_420:
            Option<unsafe extern "C" fn(*mut pixel, intptr_t, *mut pixel, intptr_t, c_int) -> ()>,
        pub prefetch_fenc_422:
            Option<unsafe extern "C" fn(*mut pixel, intptr_t, *mut pixel, intptr_t, c_int) -> ()>,
        pub prefetch_ref: Option<unsafe extern "C" fn(*mut pixel, intptr_t, c_int) -> ()>,
        pub memcpy_aligned:
            Option<unsafe extern "C" fn(*mut c_void, *const c_void, size_t) -> *mut c_void>,
        pub memzero_aligned: Option<unsafe extern "C" fn(*mut c_void, size_t) -> ()>,
        pub integral_init4h:
            Option<unsafe extern "C" fn(*mut uint16_t, *mut pixel, intptr_t) -> ()>,
        pub integral_init8h:
            Option<unsafe extern "C" fn(*mut uint16_t, *mut pixel, intptr_t) -> ()>,
        pub integral_init4v:
            Option<unsafe extern "C" fn(*mut uint16_t, *mut uint16_t, intptr_t) -> ()>,
        pub integral_init8v: Option<unsafe extern "C" fn(*mut uint16_t, intptr_t) -> ()>,
        pub frame_init_lowres_core: Option<
            unsafe extern "C" fn(
                *mut pixel,
                *mut pixel,
                *mut pixel,
                *mut pixel,
                *mut pixel,
                intptr_t,
                intptr_t,
                c_int,
                c_int,
            ) -> (),
        >,
        pub weight: *mut weight_fn_t,
        pub offsetadd: *mut weight_fn_t,
        pub offsetsub: *mut weight_fn_t,
        pub weight_cache: Option<unsafe extern "C" fn(*mut x264_t, *mut x264_weight_t) -> ()>,
        pub mbtree_propagate_cost: Option<
            unsafe extern "C" fn(
                *mut int16_t,
                *mut uint16_t,
                *mut uint16_t,
                *mut uint16_t,
                *mut uint16_t,
                *mut c_float,
                c_int,
            ) -> (),
        >,
        pub mbtree_propagate_list: Option<
            unsafe extern "C" fn(
                *mut x264_t,
                *mut uint16_t,
                *mut [int16_t; 2],
                *mut int16_t,
                *mut uint16_t,
                c_int,
                c_int,
                c_int,
                c_int,
            ) -> (),
        >,
        pub mbtree_fix8_pack:
            Option<unsafe extern "C" fn(*mut uint16_t, *mut c_float, c_int) -> ()>,
        pub mbtree_fix8_unpack:
            Option<unsafe extern "C" fn(*mut c_float, *mut uint16_t, c_int) -> ()>,
    }
    use ::core::ffi::{c_float, c_int, c_void};

    use super::__stddef_size_t_h::size_t;
    use super::common_h::{pixel, x264_t};
    use super::stdint_h::intptr_t;
    use super::stdint_intn_h::{int16_t, int32_t};
    use super::stdint_uintn_h::{uint16_t, uint32_t};
    extern "C" {
        #[c2rust::src_loc = "343:1"]
        pub fn x264_10_mc_init(cpu: uint32_t, pf: *mut x264_mc_functions_t, cpu_independent: c_int);
    }
}
#[c2rust::header_src = "/home/nwplayer123/Hacks/hex264/x264/common/bitstream.h:28"]
pub mod bitstream_h {
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "57:9"]
    pub struct x264_bitstream_function_t {
        pub nal_escape:
            Option<unsafe extern "C" fn(*mut uint8_t, *mut uint8_t, *mut uint8_t) -> *mut uint8_t>,
        pub cabac_block_residual_internal:
            Option<unsafe extern "C" fn(*mut dctcoef, c_int, intptr_t, *mut x264_cabac_t) -> ()>,
        pub cabac_block_residual_rd_internal:
            Option<unsafe extern "C" fn(*mut dctcoef, c_int, intptr_t, *mut x264_cabac_t) -> ()>,
        pub cabac_block_residual_8x8_rd_internal:
            Option<unsafe extern "C" fn(*mut dctcoef, c_int, intptr_t, *mut x264_cabac_t) -> ()>,
    }
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "50:9"]
    pub struct x264_run_level_t {
        pub last: int32_t,
        pub mask: int32_t,
        pub level: [dctcoef; 18],
    }
    #[c2rust::src_loc = "39:1"]
    pub type bs_t = bs_s;
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "39:16"]
    pub struct bs_s {
        pub p_start: *mut uint8_t,
        pub p: *mut uint8_t,
        pub p_end: *mut uint8_t,
        pub cur_bits: uintptr_t,
        pub i_left: c_int,
        pub i_bits_encoded: c_int,
    }
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "31:9"]
    pub struct vlc_large_t {
        pub i_bits: uint16_t,
        pub i_size: uint8_t,
        pub i_next: uint8_t,
    }
    #[c2rust::src_loc = "76:9"]
    pub const LEVEL_TABLE_SIZE: c_int = 128 as c_int;
    #[c2rust::src_loc = "201:22"]
    pub static mut x264_ue_size_tab: [uint8_t; 256] = [
        1 as c_int as uint8_t,
        1 as c_int as uint8_t,
        3 as c_int as uint8_t,
        3 as c_int as uint8_t,
        5 as c_int as uint8_t,
        5 as c_int as uint8_t,
        5 as c_int as uint8_t,
        5 as c_int as uint8_t,
        7 as c_int as uint8_t,
        7 as c_int as uint8_t,
        7 as c_int as uint8_t,
        7 as c_int as uint8_t,
        7 as c_int as uint8_t,
        7 as c_int as uint8_t,
        7 as c_int as uint8_t,
        7 as c_int as uint8_t,
        9 as c_int as uint8_t,
        9 as c_int as uint8_t,
        9 as c_int as uint8_t,
        9 as c_int as uint8_t,
        9 as c_int as uint8_t,
        9 as c_int as uint8_t,
        9 as c_int as uint8_t,
        9 as c_int as uint8_t,
        9 as c_int as uint8_t,
        9 as c_int as uint8_t,
        9 as c_int as uint8_t,
        9 as c_int as uint8_t,
        9 as c_int as uint8_t,
        9 as c_int as uint8_t,
        9 as c_int as uint8_t,
        9 as c_int as uint8_t,
        11 as c_int as uint8_t,
        11 as c_int as uint8_t,
        11 as c_int as uint8_t,
        11 as c_int as uint8_t,
        11 as c_int as uint8_t,
        11 as c_int as uint8_t,
        11 as c_int as uint8_t,
        11 as c_int as uint8_t,
        11 as c_int as uint8_t,
        11 as c_int as uint8_t,
        11 as c_int as uint8_t,
        11 as c_int as uint8_t,
        11 as c_int as uint8_t,
        11 as c_int as uint8_t,
        11 as c_int as uint8_t,
        11 as c_int as uint8_t,
        11 as c_int as uint8_t,
        11 as c_int as uint8_t,
        11 as c_int as uint8_t,
        11 as c_int as uint8_t,
        11 as c_int as uint8_t,
        11 as c_int as uint8_t,
        11 as c_int as uint8_t,
        11 as c_int as uint8_t,
        11 as c_int as uint8_t,
        11 as c_int as uint8_t,
        11 as c_int as uint8_t,
        11 as c_int as uint8_t,
        11 as c_int as uint8_t,
        11 as c_int as uint8_t,
        11 as c_int as uint8_t,
        11 as c_int as uint8_t,
        13 as c_int as uint8_t,
        13 as c_int as uint8_t,
        13 as c_int as uint8_t,
        13 as c_int as uint8_t,
        13 as c_int as uint8_t,
        13 as c_int as uint8_t,
        13 as c_int as uint8_t,
        13 as c_int as uint8_t,
        13 as c_int as uint8_t,
        13 as c_int as uint8_t,
        13 as c_int as uint8_t,
        13 as c_int as uint8_t,
        13 as c_int as uint8_t,
        13 as c_int as uint8_t,
        13 as c_int as uint8_t,
        13 as c_int as uint8_t,
        13 as c_int as uint8_t,
        13 as c_int as uint8_t,
        13 as c_int as uint8_t,
        13 as c_int as uint8_t,
        13 as c_int as uint8_t,
        13 as c_int as uint8_t,
        13 as c_int as uint8_t,
        13 as c_int as uint8_t,
        13 as c_int as uint8_t,
        13 as c_int as uint8_t,
        13 as c_int as uint8_t,
        13 as c_int as uint8_t,
        13 as c_int as uint8_t,
        13 as c_int as uint8_t,
        13 as c_int as uint8_t,
        13 as c_int as uint8_t,
        13 as c_int as uint8_t,
        13 as c_int as uint8_t,
        13 as c_int as uint8_t,
        13 as c_int as uint8_t,
        13 as c_int as uint8_t,
        13 as c_int as uint8_t,
        13 as c_int as uint8_t,
        13 as c_int as uint8_t,
        13 as c_int as uint8_t,
        13 as c_int as uint8_t,
        13 as c_int as uint8_t,
        13 as c_int as uint8_t,
        13 as c_int as uint8_t,
        13 as c_int as uint8_t,
        13 as c_int as uint8_t,
        13 as c_int as uint8_t,
        13 as c_int as uint8_t,
        13 as c_int as uint8_t,
        13 as c_int as uint8_t,
        13 as c_int as uint8_t,
        13 as c_int as uint8_t,
        13 as c_int as uint8_t,
        13 as c_int as uint8_t,
        13 as c_int as uint8_t,
        13 as c_int as uint8_t,
        13 as c_int as uint8_t,
        13 as c_int as uint8_t,
        13 as c_int as uint8_t,
        13 as c_int as uint8_t,
        13 as c_int as uint8_t,
        13 as c_int as uint8_t,
        13 as c_int as uint8_t,
        15 as c_int as uint8_t,
        15 as c_int as uint8_t,
        15 as c_int as uint8_t,
        15 as c_int as uint8_t,
        15 as c_int as uint8_t,
        15 as c_int as uint8_t,
        15 as c_int as uint8_t,
        15 as c_int as uint8_t,
        15 as c_int as uint8_t,
        15 as c_int as uint8_t,
        15 as c_int as uint8_t,
        15 as c_int as uint8_t,
        15 as c_int as uint8_t,
        15 as c_int as uint8_t,
        15 as c_int as uint8_t,
        15 as c_int as uint8_t,
        15 as c_int as uint8_t,
        15 as c_int as uint8_t,
        15 as c_int as uint8_t,
        15 as c_int as uint8_t,
        15 as c_int as uint8_t,
        15 as c_int as uint8_t,
        15 as c_int as uint8_t,
        15 as c_int as uint8_t,
        15 as c_int as uint8_t,
        15 as c_int as uint8_t,
        15 as c_int as uint8_t,
        15 as c_int as uint8_t,
        15 as c_int as uint8_t,
        15 as c_int as uint8_t,
        15 as c_int as uint8_t,
        15 as c_int as uint8_t,
        15 as c_int as uint8_t,
        15 as c_int as uint8_t,
        15 as c_int as uint8_t,
        15 as c_int as uint8_t,
        15 as c_int as uint8_t,
        15 as c_int as uint8_t,
        15 as c_int as uint8_t,
        15 as c_int as uint8_t,
        15 as c_int as uint8_t,
        15 as c_int as uint8_t,
        15 as c_int as uint8_t,
        15 as c_int as uint8_t,
        15 as c_int as uint8_t,
        15 as c_int as uint8_t,
        15 as c_int as uint8_t,
        15 as c_int as uint8_t,
        15 as c_int as uint8_t,
        15 as c_int as uint8_t,
        15 as c_int as uint8_t,
        15 as c_int as uint8_t,
        15 as c_int as uint8_t,
        15 as c_int as uint8_t,
        15 as c_int as uint8_t,
        15 as c_int as uint8_t,
        15 as c_int as uint8_t,
        15 as c_int as uint8_t,
        15 as c_int as uint8_t,
        15 as c_int as uint8_t,
        15 as c_int as uint8_t,
        15 as c_int as uint8_t,
        15 as c_int as uint8_t,
        15 as c_int as uint8_t,
        15 as c_int as uint8_t,
        15 as c_int as uint8_t,
        15 as c_int as uint8_t,
        15 as c_int as uint8_t,
        15 as c_int as uint8_t,
        15 as c_int as uint8_t,
        15 as c_int as uint8_t,
        15 as c_int as uint8_t,
        15 as c_int as uint8_t,
        15 as c_int as uint8_t,
        15 as c_int as uint8_t,
        15 as c_int as uint8_t,
        15 as c_int as uint8_t,
        15 as c_int as uint8_t,
        15 as c_int as uint8_t,
        15 as c_int as uint8_t,
        15 as c_int as uint8_t,
        15 as c_int as uint8_t,
        15 as c_int as uint8_t,
        15 as c_int as uint8_t,
        15 as c_int as uint8_t,
        15 as c_int as uint8_t,
        15 as c_int as uint8_t,
        15 as c_int as uint8_t,
        15 as c_int as uint8_t,
        15 as c_int as uint8_t,
        15 as c_int as uint8_t,
        15 as c_int as uint8_t,
        15 as c_int as uint8_t,
        15 as c_int as uint8_t,
        15 as c_int as uint8_t,
        15 as c_int as uint8_t,
        15 as c_int as uint8_t,
        15 as c_int as uint8_t,
        15 as c_int as uint8_t,
        15 as c_int as uint8_t,
        15 as c_int as uint8_t,
        15 as c_int as uint8_t,
        15 as c_int as uint8_t,
        15 as c_int as uint8_t,
        15 as c_int as uint8_t,
        15 as c_int as uint8_t,
        15 as c_int as uint8_t,
        15 as c_int as uint8_t,
        15 as c_int as uint8_t,
        15 as c_int as uint8_t,
        15 as c_int as uint8_t,
        15 as c_int as uint8_t,
        15 as c_int as uint8_t,
        15 as c_int as uint8_t,
        15 as c_int as uint8_t,
        15 as c_int as uint8_t,
        15 as c_int as uint8_t,
        15 as c_int as uint8_t,
        15 as c_int as uint8_t,
        15 as c_int as uint8_t,
        15 as c_int as uint8_t,
        15 as c_int as uint8_t,
        15 as c_int as uint8_t,
        15 as c_int as uint8_t,
        15 as c_int as uint8_t,
        15 as c_int as uint8_t,
        15 as c_int as uint8_t,
        15 as c_int as uint8_t,
    ];
    #[inline(always)]
    #[c2rust::src_loc = "278:1"]
    pub unsafe extern "C" fn bs_size_ue(mut val: c_uint) -> c_int {
        return x264_ue_size_tab[val.wrapping_add(1 as c_uint) as usize] as c_int;
    }
    #[inline(always)]
    #[c2rust::src_loc = "283:1"]
    pub unsafe extern "C" fn bs_size_ue_big(mut val: c_uint) -> c_int {
        if val < 255 as c_uint {
            return x264_ue_size_tab[val.wrapping_add(1 as c_uint) as usize] as c_int;
        } else {
            return x264_ue_size_tab[(val.wrapping_add(1 as c_uint) >> 8 as c_int) as usize]
                as c_int
                + 16 as c_int;
        };
    }
    #[inline(always)]
    #[c2rust::src_loc = "291:1"]
    pub unsafe extern "C" fn bs_size_se(mut val: c_int) -> c_int {
        let mut tmp: c_int = 1 as c_int - val * 2 as c_int;
        if tmp < 0 as c_int {
            tmp = val * 2 as c_int;
        }
        if tmp < 256 as c_int {
            return x264_ue_size_tab[tmp as usize] as c_int;
        } else {
            return x264_ue_size_tab[(tmp >> 8 as c_int) as usize] as c_int + 16 as c_int;
        };
    }
    #[inline(always)]
    #[c2rust::src_loc = "301:1"]
    pub unsafe extern "C" fn bs_size_te(mut x: c_int, mut val: c_int) -> c_int {
        if x == 1 as c_int {
            return 1 as c_int;
        } else {
            return x264_ue_size_tab[(val + 1 as c_int) as usize] as c_int;
        };
    }
    use ::core::ffi::{c_int, c_long, c_uint, c_void};

    use super::cabac_h::x264_cabac_t;
    use super::common_h::dctcoef;
    use super::stdint_h::{intptr_t, uintptr_t};
    use super::stdint_intn_h::int32_t;
    use super::stdint_uintn_h::{uint16_t, uint32_t, uint8_t};
    extern "C" {
        #[c2rust::src_loc = "78:20"]
        pub static mut x264_10_level_token: [[vlc_large_t; 128]; 7];
        #[c2rust::src_loc = "84:17"]
        pub static mut x264_10_run_before: [uint32_t; 65536];
    }

    #[inline]
    #[c2rust::src_loc = "86:1"]
    pub unsafe extern "C" fn bs_init(mut s: *mut bs_t, mut p_data: *mut c_void, mut i_data: c_int) {
        let mut offset: c_int = (p_data as intptr_t & 3 as intptr_t) as c_int;
        (*s).p_start = (p_data as *mut uint8_t).offset(-(offset as isize));
        (*s).p = (*s).p_start;
        (*s).p_end = (p_data as *mut uint8_t).offset(i_data as isize);
        (*s).i_left = WORD_SIZE
            .wrapping_sub(offset as uint64_t)
            .wrapping_mul(8 as uint64_t) as c_int;
        if offset != 0 {
            (*s).cur_bits = endian_fix32((*((*s).p as *mut x264_union32_t)).i) as uintptr_t;
            (*s).cur_bits >>= (4 as c_int - offset) * 8 as c_int;
        } else {
            (*s).cur_bits = 0 as uintptr_t;
        };
    }
    #[inline]
    #[c2rust::src_loc = "100:1"]
    pub unsafe extern "C" fn bs_pos(mut s: *mut bs_t) -> c_int {
        return ((8 as c_long * (*s).p.offset_from((*s).p_start) as c_long) as uint64_t)
            .wrapping_add(WORD_SIZE.wrapping_mul(8 as uint64_t))
            .wrapping_sub((*s).i_left as uint64_t) as c_int;
    }
    #[inline]
    #[c2rust::src_loc = "106:1"]
    pub unsafe extern "C" fn bs_flush(mut s: *mut bs_t) {
        (*((*s).p as *mut x264_union32_t)).i =
            endian_fix32(((*s).cur_bits << ((*s).i_left & 31 as c_int)) as uint32_t);
        (*s).p = (*s)
            .p
            .offset(WORD_SIZE.wrapping_sub(((*s).i_left >> 3 as c_int) as uint64_t) as isize);
        (*s).i_left = WORD_SIZE.wrapping_mul(8 as uint64_t) as c_int;
    }
    #[inline]
    #[c2rust::src_loc = "113:1"]
    pub unsafe extern "C" fn bs_realign(mut s: *mut bs_t) {
        let mut offset: c_int = ((*s).p as intptr_t & 3 as intptr_t) as c_int;
        if offset != 0 {
            (*s).p = (*s).p.offset(-(offset as isize));
            (*s).i_left = WORD_SIZE
                .wrapping_sub(offset as uint64_t)
                .wrapping_mul(8 as uint64_t) as c_int;
            (*s).cur_bits = endian_fix32((*((*s).p as *mut x264_union32_t)).i) as uintptr_t;
            (*s).cur_bits >>= (4 as c_int - offset) * 8 as c_int;
        }
    }
    #[inline]
    #[c2rust::src_loc = "125:1"]
    pub unsafe extern "C" fn bs_write(mut s: *mut bs_t, mut i_count: c_int, mut i_bits: uint32_t) {
        if WORD_SIZE == 8 as uint64_t {
            (*s).cur_bits = (*s).cur_bits << i_count | i_bits as uintptr_t;
            (*s).i_left -= i_count;
            if (*s).i_left <= 32 as c_int {
                (*((*s).p as *mut x264_union32_t)).i =
                    endian_fix((*s).cur_bits << (*s).i_left) as uint32_t;
                (*s).i_left += 32 as c_int;
                (*s).p = (*s).p.offset(4);
            }
        } else if i_count < (*s).i_left {
            (*s).cur_bits = (*s).cur_bits << i_count | i_bits as uintptr_t;
            (*s).i_left -= i_count;
        } else {
            i_count -= (*s).i_left;
            (*s).cur_bits = (*s).cur_bits << (*s).i_left | (i_bits >> i_count) as uintptr_t;
            (*((*s).p as *mut x264_union32_t)).i = endian_fix((*s).cur_bits) as uint32_t;
            (*s).p = (*s).p.offset(4);
            (*s).cur_bits = i_bits as uintptr_t;
            (*s).i_left = 32 as c_int - i_count;
        };
    }
    #[inline]
    #[c2rust::src_loc = "169:1"]
    pub unsafe extern "C" fn bs_write1(mut s: *mut bs_t, mut i_bit: uint32_t) {
        (*s).cur_bits <<= 1 as c_int;
        (*s).cur_bits |= i_bit as uintptr_t;
        (*s).i_left -= 1;
        if (*s).i_left as uint64_t
            == WORD_SIZE
                .wrapping_mul(8 as uint64_t)
                .wrapping_sub(32 as uint64_t)
        {
            (*((*s).p as *mut x264_union32_t)).i = endian_fix32((*s).cur_bits as uint32_t);
            (*s).p = (*s).p.offset(4);
            (*s).i_left = WORD_SIZE.wrapping_mul(8 as uint64_t) as c_int;
        }
    }
    #[inline]
    #[c2rust::src_loc = "187:1"]
    pub unsafe extern "C" fn bs_align_1(mut s: *mut bs_t) {
        bs_write(
            s,
            (*s).i_left & 7 as c_int,
            (((1 as c_int) << ((*s).i_left & 7 as c_int)) - 1 as c_int) as uint32_t,
        );
        bs_flush(s);
    }
    #[inline]
    #[c2rust::src_loc = "221:1"]
    pub unsafe extern "C" fn bs_write_ue_big(mut s: *mut bs_t, mut val: c_uint) {
        let mut size: c_int = 0 as c_int;
        val = val.wrapping_add(1);
        let mut tmp: c_int = val as c_int;
        if tmp >= 0x10000 as c_int {
            size = 32 as c_int;
            tmp >>= 16 as c_int;
        }
        if tmp >= 0x100 as c_int {
            size += 16 as c_int;
            tmp >>= 8 as c_int;
        }
        size += x264_ue_size_tab[tmp as usize] as c_int;
        bs_write(s, size >> 1 as c_int, 0 as uint32_t);
        bs_write(s, (size >> 1 as c_int) + 1 as c_int, val as uint32_t);
    }
    #[inline]
    #[c2rust::src_loc = "246:1"]
    pub unsafe extern "C" fn bs_write_se(mut s: *mut bs_t, mut val: c_int) {
        let mut size: c_int = 0 as c_int;
        let mut tmp: c_int = 1 as c_int - val * 2 as c_int;
        if tmp < 0 as c_int {
            tmp = val * 2 as c_int;
        }
        val = tmp;
        if tmp >= 0x100 as c_int {
            size = 16 as c_int;
            tmp >>= 8 as c_int;
        }
        size += x264_ue_size_tab[tmp as usize] as c_int;
        bs_write(s, size, val as uint32_t);
    }
    #[inline]
    #[c2rust::src_loc = "272:1"]
    pub unsafe extern "C" fn bs_rbsp_trailing(mut s: *mut bs_t) {
        bs_write1(s, 1 as uint32_t);
        bs_write(s, (*s).i_left & 7 as c_int, 0 as uint32_t);
    }
    use super::base_h::x264_union32_t;
    use super::osdep_h::{endian_fix, endian_fix32, WORD_SIZE};
    use super::stdint_uintn_h::uint64_t;
    extern "C" {
        #[c2rust::src_loc = "69:1"]
        pub fn x264_10_bitstream_init(cpu: uint32_t, pf: *mut x264_bitstream_function_t);
    }

    #[inline]
    #[c2rust::src_loc = "182:1"]
    pub unsafe extern "C" fn bs_align_0(mut s: *mut bs_t) {
        bs_write(s, (*s).i_left & 7 as c_int, 0 as uint32_t);
        bs_flush(s);
    }
    #[inline]
    #[c2rust::src_loc = "241:1"]
    pub unsafe extern "C" fn bs_write_ue(mut s: *mut bs_t, mut val: c_int) {
        bs_write(
            s,
            x264_ue_size_tab[(val + 1 as c_int) as usize] as c_int,
            (val + 1 as c_int) as uint32_t,
        );
    }
    #[inline]
    #[c2rust::src_loc = "264:1"]
    pub unsafe extern "C" fn bs_write_te(mut s: *mut bs_t, mut x: c_int, mut val: c_int) {
        if x == 1 as c_int {
            bs_write1(s, (1 as c_int ^ val) as uint32_t);
        } else {
            bs_write_ue(s, val);
        };
    }

    #[inline]
    #[c2rust::src_loc = "163:1"]
    pub unsafe extern "C" fn bs_write32(mut s: *mut bs_t, mut i_bits: uint32_t) {
        bs_write(s, 16 as c_int, i_bits >> 16 as c_int);
        bs_write(s, 16 as c_int, i_bits);
    }
    #[inline]
    #[c2rust::src_loc = "192:1"]
    pub unsafe extern "C" fn bs_align_10(mut s: *mut bs_t) {
        if (*s).i_left & 7 as c_int != 0 {
            bs_write(
                s,
                (*s).i_left & 7 as c_int,
                ((1 as c_int) << ((*s).i_left & 7 as c_int) - 1 as c_int) as uint32_t,
            );
        }
        bs_flush(s);
    }
}

#[c2rust::header_src = "/home/nwplayer123/Hacks/hex264/x264/common/cabac.h:28"]
pub mod cabac_h {
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "30:9"]
    pub struct x264_cabac_t {
        pub i_low: c_int,
        pub i_range: c_int,
        pub i_queue: c_int,
        pub i_bytes_outstanding: c_int,
        pub p_start: *mut uint8_t,
        pub p: *mut uint8_t,
        pub p_end: *mut uint8_t,
        pub f8_bits_encoded: c_int,
        pub state: [uint8_t; 1024],
        pub padding: [uint8_t; 12],
    }
    #[inline(always)]
    #[c2rust::src_loc = "101:1"]
    pub unsafe extern "C" fn x264_cabac_size_decision(
        mut cb: *mut x264_cabac_t,
        mut i_ctx: c_long,
        mut b: c_long,
    ) {
        let mut i_state: c_int = (*cb).state[i_ctx as usize] as c_int;
        (*cb).state[i_ctx as usize] = x264_cabac_transition[i_state as usize][b as usize];
        (*cb).f8_bits_encoded += x264_cabac_entropy[(i_state as c_long ^ b) as usize] as c_int;
    }
    #[inline(always)]
    #[c2rust::src_loc = "108:1"]
    pub unsafe extern "C" fn x264_cabac_size_decision2(
        mut state: *mut uint8_t,
        mut b: c_long,
    ) -> c_int {
        let mut i_state: c_int = *state as c_int;
        *state = x264_cabac_transition[i_state as usize][b as usize];
        return x264_cabac_entropy[(i_state as c_long ^ b) as usize] as c_int;
    }
    #[inline(always)]
    #[c2rust::src_loc = "115:1"]
    pub unsafe extern "C" fn x264_cabac_size_decision_noup(
        mut cb: *mut x264_cabac_t,
        mut i_ctx: c_long,
        mut b: c_long,
    ) {
        let mut i_state: c_int = (*cb).state[i_ctx as usize] as c_int;
        (*cb).f8_bits_encoded += x264_cabac_entropy[(i_state as c_long ^ b) as usize] as c_int;
    }
    #[inline(always)]
    #[c2rust::src_loc = "121:1"]
    pub unsafe extern "C" fn x264_cabac_size_decision_noup2(
        mut state: *mut uint8_t,
        mut b: c_long,
    ) -> c_int {
        return x264_cabac_entropy[(*state as c_long ^ b) as usize] as c_int;
    }
    use ::core::ffi::{c_int, c_long};

    use super::stdint_uintn_h::{uint16_t, uint8_t};
    use super::tables_h::{x264_cabac_entropy, x264_cabac_transition};
    #[inline(always)]
    #[c2rust::src_loc = "94:1"]
    pub unsafe extern "C" fn x264_cabac_pos(mut cb: *mut x264_cabac_t) -> c_int {
        return (((*cb).p.offset_from((*cb).p_start) as c_long
            + (*cb).i_bytes_outstanding as c_long)
            * 8 as c_long
            + (*cb).i_queue as c_long) as c_int;
    }
    use super::common_h::x264_t;
    extern "C" {
        #[c2rust::src_loc = "56:1"]
        pub fn x264_10_cabac_context_init(
            h: *mut x264_t,
            cb: *mut x264_cabac_t,
            i_slice_type: c_int,
            i_qp: c_int,
            i_model: c_int,
        );
        #[c2rust::src_loc = "61:1"]
        pub fn x264_10_cabac_encode_init(
            cb: *mut x264_cabac_t,
            p_data: *mut uint8_t,
            p_end: *mut uint8_t,
        );
        #[c2rust::src_loc = "71:1"]
        pub fn x264_10_cabac_encode_terminal_c(cb: *mut x264_cabac_t);
        #[c2rust::src_loc = "77:1"]
        pub fn x264_10_cabac_encode_flush(h: *mut x264_t, cb: *mut x264_cabac_t);
    }

    extern "C" {
        #[c2rust::src_loc = "59:1"]
        pub fn x264_10_cabac_encode_init_core(cb: *mut x264_cabac_t);
        #[c2rust::src_loc = "63:1"]
        pub fn x264_10_cabac_encode_decision_c(cb: *mut x264_cabac_t, i_ctx: c_int, b: c_int);
        #[c2rust::src_loc = "67:1"]
        pub fn x264_10_cabac_encode_bypass_c(cb: *mut x264_cabac_t, b: c_int);
        #[c2rust::src_loc = "75:1"]
        pub fn x264_10_cabac_encode_ue_bypass(cb: *mut x264_cabac_t, exp_bits: c_int, val: c_int);
    }
}
#[c2rust::header_src = "/home/nwplayer123/Hacks/hex264/x264/common/dct.h:28"]
pub mod dct_h {
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "61:9"]
    pub struct x264_zigzag_function_t {
        pub scan_8x8: Option<unsafe extern "C" fn(*mut dctcoef, *mut dctcoef) -> ()>,
        pub scan_4x4: Option<unsafe extern "C" fn(*mut dctcoef, *mut dctcoef) -> ()>,
        pub sub_8x8: Option<unsafe extern "C" fn(*mut dctcoef, *const pixel, *mut pixel) -> c_int>,
        pub sub_4x4: Option<unsafe extern "C" fn(*mut dctcoef, *const pixel, *mut pixel) -> c_int>,
        pub sub_4x4ac: Option<
            unsafe extern "C" fn(*mut dctcoef, *const pixel, *mut pixel, *mut dctcoef) -> c_int,
        >,
        pub interleave_8x8_cavlc:
            Option<unsafe extern "C" fn(*mut dctcoef, *mut dctcoef, *mut uint8_t) -> ()>,
    }
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "29:9"]
    pub struct x264_dct_function_t {
        pub sub4x4_dct: Option<unsafe extern "C" fn(*mut dctcoef, *mut pixel, *mut pixel) -> ()>,
        pub add4x4_idct: Option<unsafe extern "C" fn(*mut pixel, *mut dctcoef) -> ()>,
        pub sub8x8_dct:
            Option<unsafe extern "C" fn(*mut [dctcoef; 16], *mut pixel, *mut pixel) -> ()>,
        pub sub8x8_dct_dc: Option<unsafe extern "C" fn(*mut dctcoef, *mut pixel, *mut pixel) -> ()>,
        pub add8x8_idct: Option<unsafe extern "C" fn(*mut pixel, *mut [dctcoef; 16]) -> ()>,
        pub add8x8_idct_dc: Option<unsafe extern "C" fn(*mut pixel, *mut dctcoef) -> ()>,
        pub sub8x16_dct_dc:
            Option<unsafe extern "C" fn(*mut dctcoef, *mut pixel, *mut pixel) -> ()>,
        pub sub16x16_dct:
            Option<unsafe extern "C" fn(*mut [dctcoef; 16], *mut pixel, *mut pixel) -> ()>,
        pub add16x16_idct: Option<unsafe extern "C" fn(*mut pixel, *mut [dctcoef; 16]) -> ()>,
        pub add16x16_idct_dc: Option<unsafe extern "C" fn(*mut pixel, *mut dctcoef) -> ()>,
        pub sub8x8_dct8: Option<unsafe extern "C" fn(*mut dctcoef, *mut pixel, *mut pixel) -> ()>,
        pub add8x8_idct8: Option<unsafe extern "C" fn(*mut pixel, *mut dctcoef) -> ()>,
        pub sub16x16_dct8:
            Option<unsafe extern "C" fn(*mut [dctcoef; 64], *mut pixel, *mut pixel) -> ()>,
        pub add16x16_idct8: Option<unsafe extern "C" fn(*mut pixel, *mut [dctcoef; 64]) -> ()>,
        pub dct4x4dc: Option<unsafe extern "C" fn(*mut dctcoef) -> ()>,
        pub idct4x4dc: Option<unsafe extern "C" fn(*mut dctcoef) -> ()>,
        pub dct2x4dc: Option<unsafe extern "C" fn(*mut dctcoef, *mut [dctcoef; 16]) -> ()>,
    }
    use ::core::ffi::c_int;

    use super::common_h::{dctcoef, pixel};
    use super::stdint_uintn_h::uint32_t;
    use super::stdint_uintn_h::uint8_t;
    extern "C" {
        #[c2rust::src_loc = "73:1"]
        pub fn x264_10_dct_init(cpu: uint32_t, dctf: *mut x264_dct_function_t);
        #[c2rust::src_loc = "75:1"]
        pub fn x264_10_zigzag_init(
            cpu: uint32_t,
            pf_progressive: *mut x264_zigzag_function_t,
            pf_interlaced: *mut x264_zigzag_function_t,
        );
    }
}
#[c2rust::header_src = "/home/nwplayer123/Hacks/hex264/x264/common/pixel.h:28"]
pub mod pixel_h {
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "78:9"]
    pub struct x264_pixel_function_t {
        pub sad: [x264_pixel_cmp_t; 8],
        pub ssd: [x264_pixel_cmp_t; 8],
        pub satd: [x264_pixel_cmp_t; 8],
        pub ssim: [x264_pixel_cmp_t; 7],
        pub sa8d: [x264_pixel_cmp_t; 4],
        pub mbcmp: [x264_pixel_cmp_t; 8],
        pub mbcmp_unaligned: [x264_pixel_cmp_t; 8],
        pub fpelcmp: [x264_pixel_cmp_t; 8],
        pub fpelcmp_x3: [x264_pixel_cmp_x3_t; 7],
        pub fpelcmp_x4: [x264_pixel_cmp_x4_t; 7],
        pub sad_aligned: [x264_pixel_cmp_t; 8],
        pub vsad: Option<unsafe extern "C" fn(*mut pixel, intptr_t, c_int) -> c_int>,
        pub asd8: Option<
            unsafe extern "C" fn(*mut pixel, intptr_t, *mut pixel, intptr_t, c_int) -> c_int,
        >,
        pub sa8d_satd: [Option<
            unsafe extern "C" fn(*mut pixel, intptr_t, *mut pixel, intptr_t) -> uint64_t,
        >; 1],
        pub var: [Option<unsafe extern "C" fn(*mut pixel, intptr_t) -> uint64_t>; 4],
        pub var2: [Option<unsafe extern "C" fn(*mut pixel, *mut pixel, *mut c_int) -> c_int>; 4],
        pub hadamard_ac: [Option<unsafe extern "C" fn(*mut pixel, intptr_t) -> uint64_t>; 4],
        pub ssd_nv12_core: Option<
            unsafe extern "C" fn(
                *mut pixel,
                intptr_t,
                *mut pixel,
                intptr_t,
                c_int,
                c_int,
                *mut uint64_t,
                *mut uint64_t,
            ) -> (),
        >,
        pub ssim_4x4x2_core: Option<
            unsafe extern "C" fn(
                *const pixel,
                intptr_t,
                *const pixel,
                intptr_t,
                *mut [c_int; 4],
            ) -> (),
        >,
        pub ssim_end4:
            Option<unsafe extern "C" fn(*mut [c_int; 4], *mut [c_int; 4], c_int) -> c_float>,
        pub sad_x3: [x264_pixel_cmp_x3_t; 7],
        pub sad_x4: [x264_pixel_cmp_x4_t; 7],
        pub satd_x3: [x264_pixel_cmp_x3_t; 7],
        pub satd_x4: [x264_pixel_cmp_x4_t; 7],
        pub ads: [Option<
            unsafe extern "C" fn(
                *mut c_int,
                *mut uint16_t,
                c_int,
                *mut uint16_t,
                *mut int16_t,
                c_int,
                c_int,
            ) -> c_int,
        >; 7],
        pub intra_mbcmp_x3_16x16:
            Option<unsafe extern "C" fn(*mut pixel, *mut pixel, *mut c_int) -> ()>,
        pub intra_satd_x3_16x16:
            Option<unsafe extern "C" fn(*mut pixel, *mut pixel, *mut c_int) -> ()>,
        pub intra_sad_x3_16x16:
            Option<unsafe extern "C" fn(*mut pixel, *mut pixel, *mut c_int) -> ()>,
        pub intra_mbcmp_x3_4x4:
            Option<unsafe extern "C" fn(*mut pixel, *mut pixel, *mut c_int) -> ()>,
        pub intra_satd_x3_4x4:
            Option<unsafe extern "C" fn(*mut pixel, *mut pixel, *mut c_int) -> ()>,
        pub intra_sad_x3_4x4:
            Option<unsafe extern "C" fn(*mut pixel, *mut pixel, *mut c_int) -> ()>,
        pub intra_mbcmp_x3_chroma:
            Option<unsafe extern "C" fn(*mut pixel, *mut pixel, *mut c_int) -> ()>,
        pub intra_satd_x3_chroma:
            Option<unsafe extern "C" fn(*mut pixel, *mut pixel, *mut c_int) -> ()>,
        pub intra_sad_x3_chroma:
            Option<unsafe extern "C" fn(*mut pixel, *mut pixel, *mut c_int) -> ()>,
        pub intra_mbcmp_x3_8x16c:
            Option<unsafe extern "C" fn(*mut pixel, *mut pixel, *mut c_int) -> ()>,
        pub intra_satd_x3_8x16c:
            Option<unsafe extern "C" fn(*mut pixel, *mut pixel, *mut c_int) -> ()>,
        pub intra_sad_x3_8x16c:
            Option<unsafe extern "C" fn(*mut pixel, *mut pixel, *mut c_int) -> ()>,
        pub intra_mbcmp_x3_8x8c:
            Option<unsafe extern "C" fn(*mut pixel, *mut pixel, *mut c_int) -> ()>,
        pub intra_satd_x3_8x8c:
            Option<unsafe extern "C" fn(*mut pixel, *mut pixel, *mut c_int) -> ()>,
        pub intra_sad_x3_8x8c:
            Option<unsafe extern "C" fn(*mut pixel, *mut pixel, *mut c_int) -> ()>,
        pub intra_mbcmp_x3_8x8:
            Option<unsafe extern "C" fn(*mut pixel, *mut pixel, *mut c_int) -> ()>,
        pub intra_sa8d_x3_8x8:
            Option<unsafe extern "C" fn(*mut pixel, *mut pixel, *mut c_int) -> ()>,
        pub intra_sad_x3_8x8:
            Option<unsafe extern "C" fn(*mut pixel, *mut pixel, *mut c_int) -> ()>,
        pub intra_mbcmp_x9_4x4:
            Option<unsafe extern "C" fn(*mut pixel, *mut pixel, *mut uint16_t) -> c_int>,
        pub intra_satd_x9_4x4:
            Option<unsafe extern "C" fn(*mut pixel, *mut pixel, *mut uint16_t) -> c_int>,
        pub intra_sad_x9_4x4:
            Option<unsafe extern "C" fn(*mut pixel, *mut pixel, *mut uint16_t) -> c_int>,
        pub intra_mbcmp_x9_8x8: Option<
            unsafe extern "C" fn(
                *mut pixel,
                *mut pixel,
                *mut pixel,
                *mut uint16_t,
                *mut uint16_t,
            ) -> c_int,
        >,
        pub intra_sa8d_x9_8x8: Option<
            unsafe extern "C" fn(
                *mut pixel,
                *mut pixel,
                *mut pixel,
                *mut uint16_t,
                *mut uint16_t,
            ) -> c_int,
        >,
        pub intra_sad_x9_8x8: Option<
            unsafe extern "C" fn(
                *mut pixel,
                *mut pixel,
                *mut pixel,
                *mut uint16_t,
                *mut uint16_t,
            ) -> c_int,
        >,
    }
    #[c2rust::src_loc = "35:1"]
    pub type x264_pixel_cmp_x4_t = Option<
        unsafe extern "C" fn(
            *mut pixel,
            *mut pixel,
            *mut pixel,
            *mut pixel,
            *mut pixel,
            intptr_t,
            *mut c_int,
        ) -> (),
    >;
    #[c2rust::src_loc = "34:1"]
    pub type x264_pixel_cmp_x3_t = Option<
        unsafe extern "C" fn(
            *mut pixel,
            *mut pixel,
            *mut pixel,
            *mut pixel,
            intptr_t,
            *mut c_int,
        ) -> (),
    >;
    #[c2rust::src_loc = "33:1"]
    pub type x264_pixel_cmp_t =
        Option<unsafe extern "C" fn(*mut pixel, intptr_t, *mut pixel, intptr_t) -> c_int>;
    #[c2rust::src_loc = "37:1"]
    pub type C2RustUnnamed_19 = c_uint;
    #[c2rust::src_loc = "52:5"]
    pub const PIXEL_2x2: C2RustUnnamed_19 = 11;
    #[c2rust::src_loc = "51:5"]
    pub const PIXEL_2x4: C2RustUnnamed_19 = 10;
    #[c2rust::src_loc = "50:5"]
    pub const PIXEL_2x8: C2RustUnnamed_19 = 9;
    #[c2rust::src_loc = "49:5"]
    pub const PIXEL_4x2: C2RustUnnamed_19 = 8;
    #[c2rust::src_loc = "48:5"]
    pub const PIXEL_4x16: C2RustUnnamed_19 = 7;
    #[c2rust::src_loc = "45:5"]
    pub const PIXEL_4x4: C2RustUnnamed_19 = 6;
    #[c2rust::src_loc = "44:5"]
    pub const PIXEL_4x8: C2RustUnnamed_19 = 5;
    #[c2rust::src_loc = "43:5"]
    pub const PIXEL_8x4: C2RustUnnamed_19 = 4;
    #[c2rust::src_loc = "42:5"]
    pub const PIXEL_8x8: C2RustUnnamed_19 = 3;
    #[c2rust::src_loc = "41:5"]
    pub const PIXEL_8x16: C2RustUnnamed_19 = 2;
    #[c2rust::src_loc = "40:5"]
    pub const PIXEL_16x8: C2RustUnnamed_19 = 1;
    #[c2rust::src_loc = "39:5"]
    pub const PIXEL_16x16: C2RustUnnamed_19 = 0;
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "55:14"]
    pub struct C2RustUnnamed_20 {
        pub w: uint8_t,
        pub h: uint8_t,
    }
    #[c2rust::src_loc = "55:39"]
    pub static mut x264_pixel_size: [C2RustUnnamed_20; 12] = [
        {
            let mut init = C2RustUnnamed_20 {
                w: 16 as uint8_t,
                h: 16 as uint8_t,
            };
            init
        },
        {
            let mut init = C2RustUnnamed_20 {
                w: 16 as uint8_t,
                h: 8 as uint8_t,
            };
            init
        },
        {
            let mut init = C2RustUnnamed_20 {
                w: 8 as uint8_t,
                h: 16 as uint8_t,
            };
            init
        },
        {
            let mut init = C2RustUnnamed_20 {
                w: 8 as uint8_t,
                h: 8 as uint8_t,
            };
            init
        },
        {
            let mut init = C2RustUnnamed_20 {
                w: 8 as uint8_t,
                h: 4 as uint8_t,
            };
            init
        },
        {
            let mut init = C2RustUnnamed_20 {
                w: 4 as uint8_t,
                h: 8 as uint8_t,
            };
            init
        },
        {
            let mut init = C2RustUnnamed_20 {
                w: 4 as uint8_t,
                h: 4 as uint8_t,
            };
            init
        },
        {
            let mut init = C2RustUnnamed_20 {
                w: 4 as uint8_t,
                h: 16 as uint8_t,
            };
            init
        },
        {
            let mut init = C2RustUnnamed_20 {
                w: 4 as uint8_t,
                h: 2 as uint8_t,
            };
            init
        },
        {
            let mut init = C2RustUnnamed_20 {
                w: 2 as uint8_t,
                h: 8 as uint8_t,
            };
            init
        },
        {
            let mut init = C2RustUnnamed_20 {
                w: 2 as uint8_t,
                h: 4 as uint8_t,
            };
            init
        },
        {
            let mut init = C2RustUnnamed_20 {
                w: 2 as uint8_t,
                h: 2 as uint8_t,
            };
            init
        },
    ];
    use ::core::ffi::{c_float, c_int, c_uint, c_void};

    use super::common_h::pixel;
    use super::stdint_h::intptr_t;
    use super::stdint_intn_h::int16_t;
    use super::stdint_uintn_h::{uint16_t, uint64_t, uint8_t};

    #[c2rust::src_loc = "70:22"]
    pub static mut x264_luma2chroma_pixel: [[uint8_t; 7]; 4] = [
        [0 as c_int as uint8_t, 0, 0, 0, 0, 0, 0],
        [
            PIXEL_8x8 as c_int as uint8_t,
            PIXEL_8x4 as c_int as uint8_t,
            PIXEL_4x8 as c_int as uint8_t,
            PIXEL_4x4 as c_int as uint8_t,
            PIXEL_4x2 as c_int as uint8_t,
            PIXEL_2x4 as c_int as uint8_t,
            PIXEL_2x2 as c_int as uint8_t,
        ],
        [
            PIXEL_8x16 as c_int as uint8_t,
            PIXEL_8x8 as c_int as uint8_t,
            PIXEL_4x16 as c_int as uint8_t,
            PIXEL_4x8 as c_int as uint8_t,
            PIXEL_4x4 as c_int as uint8_t,
            PIXEL_2x8 as c_int as uint8_t,
            PIXEL_2x4 as c_int as uint8_t,
        ],
        [
            PIXEL_16x16 as c_int as uint8_t,
            PIXEL_16x8 as c_int as uint8_t,
            PIXEL_8x16 as c_int as uint8_t,
            PIXEL_8x8 as c_int as uint8_t,
            PIXEL_8x4 as c_int as uint8_t,
            PIXEL_4x8 as c_int as uint8_t,
            PIXEL_4x4 as c_int as uint8_t,
        ],
    ];
    use super::common_h::x264_t;
    use super::stdint_uintn_h::uint32_t;
    extern "C" {
        #[c2rust::src_loc = "147:1"]
        pub fn x264_10_pixel_init(cpu: uint32_t, pixf: *mut x264_pixel_function_t);
        #[c2rust::src_loc = "149:1"]
        pub fn x264_10_pixel_ssd_nv12(
            pf: *mut x264_pixel_function_t,
            pix1: *mut pixel,
            i_pix1: intptr_t,
            pix2: *mut pixel,
            i_pix2: intptr_t,
            i_width: c_int,
            i_height: c_int,
            ssd_u: *mut uint64_t,
            ssd_v: *mut uint64_t,
        );
        #[c2rust::src_loc = "152:1"]
        pub fn x264_10_pixel_ssd_wxh(
            pf: *mut x264_pixel_function_t,
            pix1: *mut pixel,
            i_pix1: intptr_t,
            pix2: *mut pixel,
            i_pix2: intptr_t,
            i_width: c_int,
            i_height: c_int,
        ) -> uint64_t;
        #[c2rust::src_loc = "155:1"]
        pub fn x264_10_pixel_ssim_wxh(
            pf: *mut x264_pixel_function_t,
            pix1: *mut pixel,
            i_pix1: intptr_t,
            pix2: *mut pixel,
            i_pix2: intptr_t,
            i_width: c_int,
            i_height: c_int,
            buf: *mut c_void,
            cnt: *mut c_int,
        ) -> c_float;
        #[c2rust::src_loc = "158:1"]
        pub fn x264_10_field_vsad(h: *mut x264_t, mb_x: c_int, mb_y: c_int) -> c_int;
    }

    #[c2rust::src_loc = "61:22"]
    pub static mut x264_size2pixel: [[uint8_t; 5]; 5] = [
        [0 as c_int as uint8_t, 0, 0, 0, 0],
        [
            0 as c_int as uint8_t,
            PIXEL_4x4 as c_int as uint8_t,
            PIXEL_8x4 as c_int as uint8_t,
            0 as c_int as uint8_t,
            0 as c_int as uint8_t,
        ],
        [
            0 as c_int as uint8_t,
            PIXEL_4x8 as c_int as uint8_t,
            PIXEL_8x8 as c_int as uint8_t,
            0 as c_int as uint8_t,
            PIXEL_16x8 as c_int as uint8_t,
        ],
        [0 as c_int as uint8_t, 0, 0, 0, 0],
        [
            0 as c_int as uint8_t,
            0 as c_int as uint8_t,
            PIXEL_8x16 as c_int as uint8_t,
            0 as c_int as uint8_t,
            PIXEL_16x16 as c_int as uint8_t,
        ],
    ];
}
#[c2rust::header_src = "/home/nwplayer123/Hacks/hex264/x264/common/predict.h:28"]
pub mod predict_h {
    #[c2rust::src_loc = "32:1"]
    pub type x264_predict_8x8_filter_t =
        Option<unsafe extern "C" fn(*mut pixel, *mut pixel, c_int, c_int) -> ()>;
    #[c2rust::src_loc = "30:1"]
    pub type x264_predict_t = Option<unsafe extern "C" fn(*mut pixel) -> ()>;
    #[c2rust::src_loc = "31:1"]
    pub type x264_predict8x8_t = Option<unsafe extern "C" fn(*mut pixel, *mut pixel) -> ()>;
    #[c2rust::src_loc = "34:1"]
    pub type intra_chroma_pred_e = c_uint;
    #[c2rust::src_loc = "43:5"]
    pub const I_PRED_CHROMA_DC_128: intra_chroma_pred_e = 6;
    #[c2rust::src_loc = "42:5"]
    pub const I_PRED_CHROMA_DC_TOP: intra_chroma_pred_e = 5;
    #[c2rust::src_loc = "41:5"]
    pub const I_PRED_CHROMA_DC_LEFT: intra_chroma_pred_e = 4;
    #[c2rust::src_loc = "39:5"]
    pub const I_PRED_CHROMA_P: intra_chroma_pred_e = 3;
    #[c2rust::src_loc = "38:5"]
    pub const I_PRED_CHROMA_V: intra_chroma_pred_e = 2;
    #[c2rust::src_loc = "37:5"]
    pub const I_PRED_CHROMA_H: intra_chroma_pred_e = 1;
    #[c2rust::src_loc = "36:5"]
    pub const I_PRED_CHROMA_DC: intra_chroma_pred_e = 0;
    #[c2rust::src_loc = "51:1"]
    pub type intra16x16_pred_e = c_uint;
    #[c2rust::src_loc = "60:5"]
    pub const I_PRED_16x16_DC_128: intra16x16_pred_e = 6;
    #[c2rust::src_loc = "59:5"]
    pub const I_PRED_16x16_DC_TOP: intra16x16_pred_e = 5;
    #[c2rust::src_loc = "58:5"]
    pub const I_PRED_16x16_DC_LEFT: intra16x16_pred_e = 4;
    #[c2rust::src_loc = "56:5"]
    pub const I_PRED_16x16_P: intra16x16_pred_e = 3;
    #[c2rust::src_loc = "55:5"]
    pub const I_PRED_16x16_DC: intra16x16_pred_e = 2;
    #[c2rust::src_loc = "54:5"]
    pub const I_PRED_16x16_H: intra16x16_pred_e = 1;
    #[c2rust::src_loc = "53:5"]
    pub const I_PRED_16x16_V: intra16x16_pred_e = 0;
    #[c2rust::src_loc = "68:1"]
    pub type intra4x4_pred_e = c_uint;
    #[c2rust::src_loc = "82:5"]
    pub const I_PRED_4x4_DC_128: intra4x4_pred_e = 11;
    #[c2rust::src_loc = "81:5"]
    pub const I_PRED_4x4_DC_TOP: intra4x4_pred_e = 10;
    #[c2rust::src_loc = "80:5"]
    pub const I_PRED_4x4_DC_LEFT: intra4x4_pred_e = 9;
    #[c2rust::src_loc = "78:5"]
    pub const I_PRED_4x4_HU: intra4x4_pred_e = 8;
    #[c2rust::src_loc = "77:5"]
    pub const I_PRED_4x4_VL: intra4x4_pred_e = 7;
    #[c2rust::src_loc = "76:5"]
    pub const I_PRED_4x4_HD: intra4x4_pred_e = 6;
    #[c2rust::src_loc = "75:5"]
    pub const I_PRED_4x4_VR: intra4x4_pred_e = 5;
    #[c2rust::src_loc = "74:5"]
    pub const I_PRED_4x4_DDR: intra4x4_pred_e = 4;
    #[c2rust::src_loc = "73:5"]
    pub const I_PRED_4x4_DDL: intra4x4_pred_e = 3;
    #[c2rust::src_loc = "72:5"]
    pub const I_PRED_4x4_DC: intra4x4_pred_e = 2;
    #[c2rust::src_loc = "71:5"]
    pub const I_PRED_4x4_H: intra4x4_pred_e = 1;
    #[c2rust::src_loc = "70:5"]
    pub const I_PRED_4x4_V: intra4x4_pred_e = 0;
    #[c2rust::src_loc = "45:22"]
    pub static mut x264_mb_chroma_pred_mode_fix: [uint8_t; 7] = [
        I_PRED_CHROMA_DC as c_int as uint8_t,
        I_PRED_CHROMA_H as c_int as uint8_t,
        I_PRED_CHROMA_V as c_int as uint8_t,
        I_PRED_CHROMA_P as c_int as uint8_t,
        I_PRED_CHROMA_DC as c_int as uint8_t,
        I_PRED_CHROMA_DC as c_int as uint8_t,
        I_PRED_CHROMA_DC as c_int as uint8_t,
    ];
    #[c2rust::src_loc = "62:22"]
    pub static mut x264_mb_pred_mode16x16_fix: [uint8_t; 7] = [
        I_PRED_16x16_V as c_int as uint8_t,
        I_PRED_16x16_H as c_int as uint8_t,
        I_PRED_16x16_DC as c_int as uint8_t,
        I_PRED_16x16_P as c_int as uint8_t,
        I_PRED_16x16_DC as c_int as uint8_t,
        I_PRED_16x16_DC as c_int as uint8_t,
        I_PRED_16x16_DC as c_int as uint8_t,
    ];
    #[c2rust::src_loc = "84:21"]
    pub static mut x264_mb_pred_mode4x4_fix: [int8_t; 13] = [
        -1 as int8_t,
        I_PRED_4x4_V as c_int as int8_t,
        I_PRED_4x4_H as c_int as int8_t,
        I_PRED_4x4_DC as c_int as int8_t,
        I_PRED_4x4_DDL as c_int as int8_t,
        I_PRED_4x4_DDR as c_int as int8_t,
        I_PRED_4x4_VR as c_int as int8_t,
        I_PRED_4x4_HD as c_int as int8_t,
        I_PRED_4x4_VL as c_int as int8_t,
        I_PRED_4x4_HU as c_int as int8_t,
        I_PRED_4x4_DC as c_int as int8_t,
        I_PRED_4x4_DC as c_int as int8_t,
        I_PRED_4x4_DC as c_int as int8_t,
    ];
    use ::core::ffi::c_int;
    use ::core::ffi::c_uint;

    use super::common_h::pixel;
    use super::stdint_intn_h::int8_t;
    use super::stdint_uintn_h::uint8_t;

    #[c2rust::src_loc = "95:1"]
    pub type intra8x8_pred_e = c_uint;
    #[c2rust::src_loc = "109:5"]
    pub const I_PRED_8x8_DC_128: intra8x8_pred_e = 11;
    #[c2rust::src_loc = "108:5"]
    pub const I_PRED_8x8_DC_TOP: intra8x8_pred_e = 10;
    #[c2rust::src_loc = "107:5"]
    pub const I_PRED_8x8_DC_LEFT: intra8x8_pred_e = 9;
    #[c2rust::src_loc = "105:5"]
    pub const I_PRED_8x8_HU: intra8x8_pred_e = 8;
    #[c2rust::src_loc = "104:5"]
    pub const I_PRED_8x8_VL: intra8x8_pred_e = 7;
    #[c2rust::src_loc = "103:5"]
    pub const I_PRED_8x8_HD: intra8x8_pred_e = 6;
    #[c2rust::src_loc = "102:5"]
    pub const I_PRED_8x8_VR: intra8x8_pred_e = 5;
    #[c2rust::src_loc = "101:5"]
    pub const I_PRED_8x8_DDR: intra8x8_pred_e = 4;
    #[c2rust::src_loc = "100:5"]
    pub const I_PRED_8x8_DDL: intra8x8_pred_e = 3;
    #[c2rust::src_loc = "99:5"]
    pub const I_PRED_8x8_DC: intra8x8_pred_e = 2;
    #[c2rust::src_loc = "98:5"]
    pub const I_PRED_8x8_H: intra8x8_pred_e = 1;
    #[c2rust::src_loc = "97:5"]
    pub const I_PRED_8x8_V: intra8x8_pred_e = 0;
    use super::stdint_uintn_h::uint32_t;
    extern "C" {
        #[c2rust::src_loc = "150:1"]
        pub fn x264_10_predict_16x16_init(cpu: uint32_t, pf: *mut x264_predict_t);
        #[c2rust::src_loc = "152:1"]
        pub fn x264_10_predict_8x8c_init(cpu: uint32_t, pf: *mut x264_predict_t);
        #[c2rust::src_loc = "154:1"]
        pub fn x264_10_predict_8x16c_init(cpu: uint32_t, pf: *mut x264_predict_t);
        #[c2rust::src_loc = "156:1"]
        pub fn x264_10_predict_4x4_init(cpu: uint32_t, pf: *mut x264_predict_t);
    }
    extern "C" {
        #[c2rust::src_loc = "113:1"]
        pub fn x264_10_predict_8x8_dc_c(src: *mut pixel, edge: *mut pixel);
        #[c2rust::src_loc = "115:1"]
        pub fn x264_10_predict_8x8_h_c(src: *mut pixel, edge: *mut pixel);
        #[c2rust::src_loc = "117:1"]
        pub fn x264_10_predict_8x8_v_c(src: *mut pixel, edge: *mut pixel);
        #[c2rust::src_loc = "119:1"]
        pub fn x264_10_predict_4x4_dc_c(src: *mut pixel);
        #[c2rust::src_loc = "121:1"]
        pub fn x264_10_predict_4x4_h_c(src: *mut pixel);
        #[c2rust::src_loc = "123:1"]
        pub fn x264_10_predict_4x4_v_c(src: *mut pixel);
        #[c2rust::src_loc = "125:1"]
        pub fn x264_10_predict_16x16_dc_c(src: *mut pixel);
        #[c2rust::src_loc = "127:1"]
        pub fn x264_10_predict_16x16_h_c(src: *mut pixel);
        #[c2rust::src_loc = "129:1"]
        pub fn x264_10_predict_16x16_v_c(src: *mut pixel);
        #[c2rust::src_loc = "133:1"]
        pub fn x264_10_predict_8x8c_dc_c(src: *mut pixel);
        #[c2rust::src_loc = "135:1"]
        pub fn x264_10_predict_8x8c_h_c(src: *mut pixel);
        #[c2rust::src_loc = "137:1"]
        pub fn x264_10_predict_8x8c_v_c(src: *mut pixel);
        #[c2rust::src_loc = "141:1"]
        pub fn x264_10_predict_8x16c_dc_c(src: *mut pixel);
        #[c2rust::src_loc = "143:1"]
        pub fn x264_10_predict_8x16c_h_c(src: *mut pixel);
        #[c2rust::src_loc = "145:1"]
        pub fn x264_10_predict_8x16c_v_c(src: *mut pixel);
    }
}
#[c2rust::header_src = "/home/nwplayer123/Hacks/hex264/x264/common/set.h:28"]
pub mod set_h {
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "150:9"]
    pub struct x264_pps_t {
        pub i_id: c_int,
        pub i_sps_id: c_int,
        pub b_cabac: c_int,
        pub b_pic_order: c_int,
        pub i_num_slice_groups: c_int,
        pub i_num_ref_idx_l0_default_active: c_int,
        pub i_num_ref_idx_l1_default_active: c_int,
        pub b_weighted_pred: c_int,
        pub b_weighted_bipred: c_int,
        pub i_pic_init_qp: c_int,
        pub i_pic_init_qs: c_int,
        pub i_chroma_qp_index_offset: c_int,
        pub b_deblocking_filter_control: c_int,
        pub b_constrained_intra_pred: c_int,
        pub b_redundant_pic_cnt: c_int,
        pub b_transform_8x8_mode: c_int,
    }
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "45:9"]
    pub struct x264_sps_t {
        pub i_id: c_int,
        pub i_profile_idc: c_int,
        pub i_level_idc: c_int,
        pub b_constraint_set0: c_int,
        pub b_constraint_set1: c_int,
        pub b_constraint_set2: c_int,
        pub b_constraint_set3: c_int,
        pub i_log2_max_frame_num: c_int,
        pub i_poc_type: c_int,
        pub i_log2_max_poc_lsb: c_int,
        pub i_num_ref_frames: c_int,
        pub b_gaps_in_frame_num_value_allowed: c_int,
        pub i_mb_width: c_int,
        pub i_mb_height: c_int,
        pub b_frame_mbs_only: c_int,
        pub b_mb_adaptive_frame_field: c_int,
        pub b_direct8x8_inference: c_int,
        pub b_crop: c_int,
        pub crop: C2RustUnnamed_16,
        pub b_vui: c_int,
        pub vui: C2RustUnnamed_14,
        pub b_qpprime_y_zero_transform_bypass: c_int,
        pub i_chroma_format_idc: c_int,
        pub b_avcintra_hd: c_int,
        pub b_avcintra_4k: c_int,
        pub i_cqm_preset: c_int,
        pub scaling_list: [*const uint8_t; 8],
    }
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "81:5"]
    pub struct C2RustUnnamed_14 {
        pub b_aspect_ratio_info_present: c_int,
        pub i_sar_width: c_int,
        pub i_sar_height: c_int,
        pub b_overscan_info_present: c_int,
        pub b_overscan_info: c_int,
        pub b_signal_type_present: c_int,
        pub i_vidformat: c_int,
        pub b_fullrange: c_int,
        pub b_color_description_present: c_int,
        pub i_colorprim: c_int,
        pub i_transfer: c_int,
        pub i_colmatrix: c_int,
        pub b_chroma_loc_info_present: c_int,
        pub i_chroma_loc_top: c_int,
        pub i_chroma_loc_bottom: c_int,
        pub b_timing_info_present: c_int,
        pub i_num_units_in_tick: uint32_t,
        pub i_time_scale: uint32_t,
        pub b_fixed_frame_rate: c_int,
        pub b_nal_hrd_parameters_present: c_int,
        pub b_vcl_hrd_parameters_present: c_int,
        pub hrd: C2RustUnnamed_15,
        pub b_pic_struct_present: c_int,
        pub b_bitstream_restriction: c_int,
        pub b_motion_vectors_over_pic_boundaries: c_int,
        pub i_max_bytes_per_pic_denom: c_int,
        pub i_max_bits_per_mb_denom: c_int,
        pub i_log2_max_mv_length_horizontal: c_int,
        pub i_log2_max_mv_length_vertical: c_int,
        pub i_num_reorder_frames: c_int,
        pub i_max_dec_frame_buffering: c_int,
    }
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "110:9"]
    pub struct C2RustUnnamed_15 {
        pub i_cpb_cnt: c_int,
        pub i_bit_rate_scale: c_int,
        pub i_cpb_size_scale: c_int,
        pub i_bit_rate_value: c_int,
        pub i_cpb_size_value: c_int,
        pub i_bit_rate_unscaled: c_int,
        pub i_cpb_size_unscaled: c_int,
        pub b_cbr_hrd: c_int,
        pub i_initial_cpb_removal_delay_length: c_int,
        pub i_cpb_removal_delay_length: c_int,
        pub i_dpb_output_delay_length: c_int,
        pub i_time_offset_length: c_int,
    }
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "72:5"]
    pub struct C2RustUnnamed_16 {
        pub i_left: c_int,
        pub i_right: c_int,
        pub i_top: c_int,
        pub i_bottom: c_int,
    }
    #[c2rust::src_loc = "30:1"]
    pub type cqm4_e = c_uint;
    #[c2rust::src_loc = "35:5"]
    pub const CQM_4PC: cqm4_e = 3;
    #[c2rust::src_loc = "34:5"]
    pub const CQM_4IC: cqm4_e = 2;
    #[c2rust::src_loc = "33:5"]
    pub const CQM_4PY: cqm4_e = 1;
    #[c2rust::src_loc = "32:5"]
    pub const CQM_4IY: cqm4_e = 0;
    #[c2rust::src_loc = "37:1"]
    pub type cqm8_e = c_uint;
    #[c2rust::src_loc = "42:5"]
    pub const CQM_8PC: cqm8_e = 3;
    #[c2rust::src_loc = "41:5"]
    pub const CQM_8IC: cqm8_e = 2;
    #[c2rust::src_loc = "40:5"]
    pub const CQM_8PY: cqm8_e = 1;
    #[c2rust::src_loc = "39:5"]
    pub const CQM_8IY: cqm8_e = 0;
    use ::core::ffi::{c_char, c_int, c_uint};

    use super::stdint_uintn_h::{uint32_t, uint8_t};

    use super::common_h::x264_t;
    extern "C" {
        #[c2rust::src_loc = "180:1"]
        pub fn x264_10_cqm_init(h: *mut x264_t) -> c_int;
        #[c2rust::src_loc = "182:1"]
        pub fn x264_10_cqm_delete(h: *mut x264_t);
        #[c2rust::src_loc = "184:1"]
        pub fn x264_10_cqm_parse_file(h: *mut x264_t, filename: *const c_char) -> c_int;
    }

    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "72:5"]
    pub struct C2RustUnnamed_17 {
        pub i_left: c_int,
        pub i_right: c_int,
        pub i_top: c_int,
        pub i_bottom: c_int,
    }
}
#[c2rust::header_src = "/home/nwplayer123/Hacks/hex264/x264/common/threadpool.h:28"]
pub mod threadpool_h {
    use ::core::ffi::{c_int, c_void};

    extern "C" {
        #[c2rust::src_loc = "29:16"]
        pub type x264_threadpool_t;
        #[c2rust::src_loc = "35:10"]
        pub fn x264_10_threadpool_run(
            pool: *mut x264_threadpool_t,
            func: Option<unsafe extern "C" fn(*mut c_void) -> *mut c_void>,
            arg: *mut c_void,
        );
        #[c2rust::src_loc = "37:10"]
        pub fn x264_10_threadpool_wait(
            pool: *mut x264_threadpool_t,
            arg: *mut c_void,
        ) -> *mut c_void;
    }
    extern "C" {
        #[c2rust::src_loc = "33:10"]
        pub fn x264_10_threadpool_init(
            p_pool: *mut *mut x264_threadpool_t,
            threads: c_int,
        ) -> c_int;
        #[c2rust::src_loc = "39:10"]
        pub fn x264_10_threadpool_delete(pool: *mut x264_threadpool_t);
    }
}
#[c2rust::header_src = "/home/nwplayer123/Hacks/hex264/x264/common/tables.h:28"]
pub mod tables_h {
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "30:9"]
    pub struct vlc_t {
        pub i_bits: uint8_t,
        pub i_size: uint8_t,
    }
    use ::core::ffi::{c_float, c_int};

    use super::stdint_uintn_h::{uint16_t, uint32_t, uint8_t};
    extern "C" {
        #[c2rust::src_loc = "38:22"]
        pub static x264_exp2_lut: [uint8_t; 64];
        #[c2rust::src_loc = "39:22"]
        pub static x264_log2_lut: [c_float; 128];
        #[c2rust::src_loc = "40:22"]
        pub static x264_log2_lz_lut: [c_float; 32];
        #[c2rust::src_loc = "43:23"]
        pub static x264_lambda_tab: [uint16_t; 82];
        #[c2rust::src_loc = "44:23"]
        pub static x264_lambda2_tab: [c_int; 82];
        #[c2rust::src_loc = "45:23"]
        pub static x264_trellis_lambda2_tab: [[c_int; 82]; 2];
        #[c2rust::src_loc = "47:23"]
        pub static x264_chroma_lambda2_offset_tab: [uint16_t; 37];
        #[c2rust::src_loc = "73:23"]
        pub static x264_dct4_weight_tab: [uint32_t; 16];
        #[c2rust::src_loc = "74:23"]
        pub static x264_dct8_weight_tab: [uint32_t; 64];
        #[c2rust::src_loc = "75:23"]
        pub static x264_dct4_weight2_tab: [uint32_t; 16];
        #[c2rust::src_loc = "76:23"]
        pub static x264_dct8_weight2_tab: [uint32_t; 64];
        #[c2rust::src_loc = "81:23"]
        pub static x264_cabac_transition: [[uint8_t; 2]; 128];
        #[c2rust::src_loc = "83:23"]
        pub static x264_cabac_entropy: [uint16_t; 128];
        #[c2rust::src_loc = "85:23"]
        pub static x264_significant_coeff_flag_offset_8x8: [[uint8_t; 64]; 2];
        #[c2rust::src_loc = "86:23"]
        pub static x264_last_coeff_flag_offset_8x8: [uint8_t; 63];
        #[c2rust::src_loc = "87:23"]
        pub static x264_coeff_flag_offset_chroma_422_dc: [uint8_t; 7];
        #[c2rust::src_loc = "88:23"]
        pub static x264_significant_coeff_flag_offset: [[uint16_t; 16]; 2];
        #[c2rust::src_loc = "89:23"]
        pub static x264_last_coeff_flag_offset: [[uint16_t; 16]; 2];
        #[c2rust::src_loc = "90:23"]
        pub static x264_coeff_abs_level_m1_offset: [uint16_t; 16];
        #[c2rust::src_loc = "91:23"]
        pub static x264_count_cat_m1: [uint8_t; 14];
        #[c2rust::src_loc = "93:20"]
        pub static x264_coeff0_token: [vlc_t; 6];
        #[c2rust::src_loc = "94:20"]
        pub static x264_coeff_token: [[[vlc_t; 4]; 16]; 6];
        #[c2rust::src_loc = "95:20"]
        pub static x264_total_zeros: [[vlc_t; 16]; 15];
        #[c2rust::src_loc = "96:20"]
        pub static x264_total_zeros_2x2_dc: [[vlc_t; 4]; 3];
        #[c2rust::src_loc = "97:20"]
        pub static x264_total_zeros_2x4_dc: [[vlc_t; 8]; 7];
        #[c2rust::src_loc = "100:16"]
        pub static mut x264_zero: [uint8_t; 1024];
    }
    extern "C" {
        #[c2rust::src_loc = "52:22"]
        pub static x264_cqm_jvt4i: [uint8_t; 16];
        #[c2rust::src_loc = "58:22"]
        pub static x264_cqm_avci50_4ic: [uint8_t; 16];
        #[c2rust::src_loc = "59:22"]
        pub static x264_cqm_avci50_p_8iy: [uint8_t; 64];
        #[c2rust::src_loc = "60:22"]
        pub static x264_cqm_avci50_1080i_8iy: [uint8_t; 64];
        #[c2rust::src_loc = "61:22"]
        pub static x264_cqm_avci100_720p_4ic: [uint8_t; 16];
        #[c2rust::src_loc = "62:22"]
        pub static x264_cqm_avci100_720p_8iy: [uint8_t; 64];
        #[c2rust::src_loc = "63:22"]
        pub static x264_cqm_avci100_1080_4ic: [uint8_t; 16];
        #[c2rust::src_loc = "64:22"]
        pub static x264_cqm_avci100_1080i_8iy: [uint8_t; 64];
        #[c2rust::src_loc = "65:22"]
        pub static x264_cqm_avci100_1080p_8iy: [uint8_t; 64];
        #[c2rust::src_loc = "66:22"]
        pub static x264_cqm_avci300_2160p_4iy: [uint8_t; 16];
        #[c2rust::src_loc = "67:22"]
        pub static x264_cqm_avci300_2160p_4ic: [uint8_t; 16];
        #[c2rust::src_loc = "68:22"]
        pub static x264_cqm_avci300_2160p_8iy: [uint8_t; 64];
    }
    extern "C" {
        #[c2rust::src_loc = "98:20"]
        pub static x264_run_before_init: [[vlc_t; 16]; 7];
    }
    extern "C" {
        #[c2rust::src_loc = "53:22"]
        pub static x264_cqm_jvt4p: [uint8_t; 16];
        #[c2rust::src_loc = "54:22"]
        pub static x264_cqm_jvt8i: [uint8_t; 64];
        #[c2rust::src_loc = "55:22"]
        pub static x264_cqm_jvt8p: [uint8_t; 64];
    }
    extern "C" {
        #[c2rust::src_loc = "70:22"]
        pub static x264_decimate_table4: [uint8_t; 16];
        #[c2rust::src_loc = "71:22"]
        pub static x264_decimate_table8: [uint8_t; 64];
    }
    extern "C" {
        #[c2rust::src_loc = "49:22"]
        pub static x264_hpel_ref0: [uint8_t; 16];
        #[c2rust::src_loc = "50:22"]
        pub static x264_hpel_ref1: [uint8_t; 16];
    }
    use super::stdint_intn_h::int8_t;
    extern "C" {
        #[c2rust::src_loc = "78:23"]
        pub static x264_cabac_context_init_I: [[int8_t; 2]; 1024];
        #[c2rust::src_loc = "79:23"]
        pub static x264_cabac_context_init_PB: [[[int8_t; 2]; 1024]; 3];
        #[c2rust::src_loc = "80:23"]
        pub static x264_cabac_range_lps: [[uint8_t; 4]; 64];
        #[c2rust::src_loc = "82:23"]
        pub static x264_cabac_renorm_shift: [uint8_t; 64];
    }

    extern "C" {
        #[c2rust::src_loc = "56:22"]
        pub static x264_cqm_flat16: [uint8_t; 64];
        #[c2rust::src_loc = "57:30"]
        pub static x264_cqm_jvt: [*const uint8_t; 8];
    }
}
#[c2rust::header_src = "/home/nwplayer123/Hacks/hex264/x264/common/macroblock.h:28"]
pub mod macroblock_h {
    #[c2rust::src_loc = "31:1"]
    pub type macroblock_position_e = c_uint;
    #[c2rust::src_loc = "40:5"]
    pub const ALL_NEIGHBORS: macroblock_position_e = 15;
    #[c2rust::src_loc = "38:5"]
    pub const MB_PRIVATE: macroblock_position_e = 16;
    #[c2rust::src_loc = "36:5"]
    pub const MB_TOPLEFT: macroblock_position_e = 8;
    #[c2rust::src_loc = "35:5"]
    pub const MB_TOPRIGHT: macroblock_position_e = 4;
    #[c2rust::src_loc = "34:5"]
    pub const MB_TOP: macroblock_position_e = 2;
    #[c2rust::src_loc = "33:5"]
    pub const MB_LEFT: macroblock_position_e = 1;
    #[c2rust::src_loc = "64:1"]
    pub type mb_class_e = c_uint;
    #[c2rust::src_loc = "88:5"]
    pub const X264_MBTYPE_MAX: mb_class_e = 19;
    #[c2rust::src_loc = "86:5"]
    pub const B_SKIP: mb_class_e = 18;
    #[c2rust::src_loc = "85:5"]
    pub const B_8x8: mb_class_e = 17;
    #[c2rust::src_loc = "84:5"]
    pub const B_BI_BI: mb_class_e = 16;
    #[c2rust::src_loc = "83:5"]
    pub const B_BI_L1: mb_class_e = 15;
    #[c2rust::src_loc = "82:5"]
    pub const B_BI_L0: mb_class_e = 14;
    #[c2rust::src_loc = "81:5"]
    pub const B_L1_BI: mb_class_e = 13;
    #[c2rust::src_loc = "80:5"]
    pub const B_L1_L1: mb_class_e = 12;
    #[c2rust::src_loc = "79:5"]
    pub const B_L1_L0: mb_class_e = 11;
    #[c2rust::src_loc = "78:5"]
    pub const B_L0_BI: mb_class_e = 10;
    #[c2rust::src_loc = "77:5"]
    pub const B_L0_L1: mb_class_e = 9;
    #[c2rust::src_loc = "76:5"]
    pub const B_L0_L0: mb_class_e = 8;
    #[c2rust::src_loc = "75:5"]
    pub const B_DIRECT: mb_class_e = 7;
    #[c2rust::src_loc = "73:5"]
    pub const P_SKIP: mb_class_e = 6;
    #[c2rust::src_loc = "72:5"]
    pub const P_8x8: mb_class_e = 5;
    #[c2rust::src_loc = "71:5"]
    pub const P_L0: mb_class_e = 4;
    #[c2rust::src_loc = "69:5"]
    pub const I_PCM: mb_class_e = 3;
    #[c2rust::src_loc = "68:5"]
    pub const I_16x16: mb_class_e = 2;
    #[c2rust::src_loc = "67:5"]
    pub const I_8x8: mb_class_e = 1;
    #[c2rust::src_loc = "66:5"]
    pub const I_4x4: mb_class_e = 0;
    #[c2rust::src_loc = "115:1"]
    pub type mb_partition_e = c_uint;
    #[c2rust::src_loc = "140:5"]
    pub const X264_PARTTYPE_MAX: mb_partition_e = 17;
    #[c2rust::src_loc = "139:5"]
    pub const D_16x16: mb_partition_e = 16;
    #[c2rust::src_loc = "138:5"]
    pub const D_8x16: mb_partition_e = 15;
    #[c2rust::src_loc = "137:5"]
    pub const D_16x8: mb_partition_e = 14;
    #[c2rust::src_loc = "136:5"]
    pub const D_8x8: mb_partition_e = 13;
    #[c2rust::src_loc = "133:5"]
    pub const D_DIRECT_8x8: mb_partition_e = 12;
    #[c2rust::src_loc = "132:5"]
    pub const D_BI_8x8: mb_partition_e = 11;
    #[c2rust::src_loc = "131:5"]
    pub const D_BI_4x8: mb_partition_e = 10;
    #[c2rust::src_loc = "130:5"]
    pub const D_BI_8x4: mb_partition_e = 9;
    #[c2rust::src_loc = "129:5"]
    pub const D_BI_4x4: mb_partition_e = 8;
    #[c2rust::src_loc = "127:5"]
    pub const D_L1_8x8: mb_partition_e = 7;
    #[c2rust::src_loc = "126:5"]
    pub const D_L1_4x8: mb_partition_e = 6;
    #[c2rust::src_loc = "125:5"]
    pub const D_L1_8x4: mb_partition_e = 5;
    #[c2rust::src_loc = "124:5"]
    pub const D_L1_4x4: mb_partition_e = 4;
    #[c2rust::src_loc = "121:5"]
    pub const D_L0_8x8: mb_partition_e = 3;
    #[c2rust::src_loc = "120:5"]
    pub const D_L0_4x8: mb_partition_e = 2;
    #[c2rust::src_loc = "119:5"]
    pub const D_L0_8x4: mb_partition_e = 1;
    #[c2rust::src_loc = "118:5"]
    pub const D_L0_4x4: mb_partition_e = 0;
    #[c2rust::src_loc = "273:1"]
    pub type cabac_ctx_block_cat_e = c_uint;
    #[c2rust::src_loc = "288:5"]
    pub const DCT_CHROMAV_8x8: cabac_ctx_block_cat_e = 13;
    #[c2rust::src_loc = "287:5"]
    pub const DCT_CHROMAV_4x4: cabac_ctx_block_cat_e = 12;
    #[c2rust::src_loc = "286:5"]
    pub const DCT_CHROMAV_AC: cabac_ctx_block_cat_e = 11;
    #[c2rust::src_loc = "285:5"]
    pub const DCT_CHROMAV_DC: cabac_ctx_block_cat_e = 10;
    #[c2rust::src_loc = "284:5"]
    pub const DCT_CHROMAU_8x8: cabac_ctx_block_cat_e = 9;
    #[c2rust::src_loc = "283:5"]
    pub const DCT_CHROMAU_4x4: cabac_ctx_block_cat_e = 8;
    #[c2rust::src_loc = "282:5"]
    pub const DCT_CHROMAU_AC: cabac_ctx_block_cat_e = 7;
    #[c2rust::src_loc = "281:5"]
    pub const DCT_CHROMAU_DC: cabac_ctx_block_cat_e = 6;
    #[c2rust::src_loc = "280:5"]
    pub const DCT_LUMA_8x8: cabac_ctx_block_cat_e = 5;
    #[c2rust::src_loc = "279:5"]
    pub const DCT_CHROMA_AC: cabac_ctx_block_cat_e = 4;
    #[c2rust::src_loc = "278:5"]
    pub const DCT_CHROMA_DC: cabac_ctx_block_cat_e = 3;
    #[c2rust::src_loc = "277:5"]
    pub const DCT_LUMA_4x4: cabac_ctx_block_cat_e = 2;
    #[c2rust::src_loc = "276:5"]
    pub const DCT_LUMA_AC: cabac_ctx_block_cat_e = 1;
    #[c2rust::src_loc = "275:5"]
    pub const DCT_LUMA_DC: cabac_ctx_block_cat_e = 0;
    #[c2rust::src_loc = "43:22"]
    pub static mut x264_pred_i4x4_neighbors: [uint8_t; 12] = [
        MB_TOP as c_int as uint8_t,
        MB_LEFT as c_int as uint8_t,
        (MB_LEFT as c_int | MB_TOP as c_int) as uint8_t,
        (MB_TOP as c_int | MB_TOPRIGHT as c_int) as uint8_t,
        (MB_LEFT as c_int | MB_TOPLEFT as c_int | MB_TOP as c_int) as uint8_t,
        (MB_LEFT as c_int | MB_TOPLEFT as c_int | MB_TOP as c_int) as uint8_t,
        (MB_LEFT as c_int | MB_TOPLEFT as c_int | MB_TOP as c_int) as uint8_t,
        (MB_TOP as c_int | MB_TOPRIGHT as c_int) as uint8_t,
        MB_LEFT as c_int as uint8_t,
        MB_LEFT as c_int as uint8_t,
        MB_TOP as c_int as uint8_t,
        0 as c_int as uint8_t,
    ];
    #[c2rust::src_loc = "97:22"]
    pub static mut x264_mb_type_list_table: [[[uint8_t; 2]; 2]; 19] = [
        [
            [0 as c_int as uint8_t, 0 as c_int as uint8_t],
            [0 as c_int as uint8_t, 0 as c_int as uint8_t],
        ],
        [
            [0 as c_int as uint8_t, 0 as c_int as uint8_t],
            [0 as c_int as uint8_t, 0 as c_int as uint8_t],
        ],
        [
            [0 as c_int as uint8_t, 0 as c_int as uint8_t],
            [0 as c_int as uint8_t, 0 as c_int as uint8_t],
        ],
        [
            [0 as c_int as uint8_t, 0 as c_int as uint8_t],
            [0 as c_int as uint8_t, 0 as c_int as uint8_t],
        ],
        [
            [1 as c_int as uint8_t, 1 as c_int as uint8_t],
            [0 as c_int as uint8_t, 0 as c_int as uint8_t],
        ],
        [
            [0 as c_int as uint8_t, 0 as c_int as uint8_t],
            [0 as c_int as uint8_t, 0 as c_int as uint8_t],
        ],
        [
            [1 as c_int as uint8_t, 1 as c_int as uint8_t],
            [0 as c_int as uint8_t, 0 as c_int as uint8_t],
        ],
        [
            [0 as c_int as uint8_t, 0 as c_int as uint8_t],
            [0 as c_int as uint8_t, 0 as c_int as uint8_t],
        ],
        [
            [1 as c_int as uint8_t, 1 as c_int as uint8_t],
            [0 as c_int as uint8_t, 0 as c_int as uint8_t],
        ],
        [
            [1 as c_int as uint8_t, 0 as c_int as uint8_t],
            [0 as c_int as uint8_t, 1 as c_int as uint8_t],
        ],
        [
            [1 as c_int as uint8_t, 1 as c_int as uint8_t],
            [0 as c_int as uint8_t, 1 as c_int as uint8_t],
        ],
        [
            [0 as c_int as uint8_t, 1 as c_int as uint8_t],
            [1 as c_int as uint8_t, 0 as c_int as uint8_t],
        ],
        [
            [0 as c_int as uint8_t, 0 as c_int as uint8_t],
            [1 as c_int as uint8_t, 1 as c_int as uint8_t],
        ],
        [
            [0 as c_int as uint8_t, 1 as c_int as uint8_t],
            [1 as c_int as uint8_t, 1 as c_int as uint8_t],
        ],
        [
            [1 as c_int as uint8_t, 1 as c_int as uint8_t],
            [1 as c_int as uint8_t, 0 as c_int as uint8_t],
        ],
        [
            [1 as c_int as uint8_t, 0 as c_int as uint8_t],
            [1 as c_int as uint8_t, 1 as c_int as uint8_t],
        ],
        [
            [1 as c_int as uint8_t, 1 as c_int as uint8_t],
            [1 as c_int as uint8_t, 1 as c_int as uint8_t],
        ],
        [
            [0 as c_int as uint8_t, 0 as c_int as uint8_t],
            [0 as c_int as uint8_t, 0 as c_int as uint8_t],
        ],
        [
            [0 as c_int as uint8_t, 0 as c_int as uint8_t],
            [0 as c_int as uint8_t, 0 as c_int as uint8_t],
        ],
    ];
    #[c2rust::src_loc = "143:22"]
    pub static mut x264_mb_partition_listX_table: [[uint8_t; 17]; 2] = [
        [
            1 as c_int as uint8_t,
            1 as c_int as uint8_t,
            1 as c_int as uint8_t,
            1 as c_int as uint8_t,
            0 as c_int as uint8_t,
            0 as c_int as uint8_t,
            0 as c_int as uint8_t,
            0 as c_int as uint8_t,
            1 as c_int as uint8_t,
            1 as c_int as uint8_t,
            1 as c_int as uint8_t,
            1 as c_int as uint8_t,
            0 as c_int as uint8_t,
            0 as c_int as uint8_t,
            0 as c_int as uint8_t,
            0 as c_int as uint8_t,
            0 as c_int as uint8_t,
        ],
        [
            0 as c_int as uint8_t,
            0 as c_int as uint8_t,
            0 as c_int as uint8_t,
            0 as c_int as uint8_t,
            1 as c_int as uint8_t,
            1 as c_int as uint8_t,
            1 as c_int as uint8_t,
            1 as c_int as uint8_t,
            1 as c_int as uint8_t,
            1 as c_int as uint8_t,
            1 as c_int as uint8_t,
            1 as c_int as uint8_t,
            0 as c_int as uint8_t,
            0 as c_int as uint8_t,
            0 as c_int as uint8_t,
            0 as c_int as uint8_t,
            0 as c_int as uint8_t,
        ],
    ];
    #[c2rust::src_loc = "181:22"]
    pub static mut x264_zigzag_scan4: [[uint8_t; 16]; 2] = [
        [
            0 as c_int as uint8_t,
            4 as c_int as uint8_t,
            1 as c_int as uint8_t,
            2 as c_int as uint8_t,
            5 as c_int as uint8_t,
            8 as c_int as uint8_t,
            12 as c_int as uint8_t,
            9 as c_int as uint8_t,
            6 as c_int as uint8_t,
            3 as c_int as uint8_t,
            7 as c_int as uint8_t,
            10 as c_int as uint8_t,
            13 as c_int as uint8_t,
            14 as c_int as uint8_t,
            11 as c_int as uint8_t,
            15 as c_int as uint8_t,
        ],
        [
            0 as c_int as uint8_t,
            1 as c_int as uint8_t,
            4 as c_int as uint8_t,
            2 as c_int as uint8_t,
            3 as c_int as uint8_t,
            5 as c_int as uint8_t,
            6 as c_int as uint8_t,
            7 as c_int as uint8_t,
            8 as c_int as uint8_t,
            9 as c_int as uint8_t,
            10 as c_int as uint8_t,
            11 as c_int as uint8_t,
            12 as c_int as uint8_t,
            13 as c_int as uint8_t,
            14 as c_int as uint8_t,
            15 as c_int as uint8_t,
        ],
    ];
    #[c2rust::src_loc = "188:22"]
    pub static mut x264_zigzag_scan8: [[uint8_t; 64]; 2] = [
        [
            0 as c_int as uint8_t,
            8 as c_int as uint8_t,
            1 as c_int as uint8_t,
            2 as c_int as uint8_t,
            9 as c_int as uint8_t,
            16 as c_int as uint8_t,
            24 as c_int as uint8_t,
            17 as c_int as uint8_t,
            10 as c_int as uint8_t,
            3 as c_int as uint8_t,
            4 as c_int as uint8_t,
            11 as c_int as uint8_t,
            18 as c_int as uint8_t,
            25 as c_int as uint8_t,
            32 as c_int as uint8_t,
            40 as c_int as uint8_t,
            33 as c_int as uint8_t,
            26 as c_int as uint8_t,
            19 as c_int as uint8_t,
            12 as c_int as uint8_t,
            5 as c_int as uint8_t,
            6 as c_int as uint8_t,
            13 as c_int as uint8_t,
            20 as c_int as uint8_t,
            27 as c_int as uint8_t,
            34 as c_int as uint8_t,
            41 as c_int as uint8_t,
            48 as c_int as uint8_t,
            56 as c_int as uint8_t,
            49 as c_int as uint8_t,
            42 as c_int as uint8_t,
            35 as c_int as uint8_t,
            28 as c_int as uint8_t,
            21 as c_int as uint8_t,
            14 as c_int as uint8_t,
            7 as c_int as uint8_t,
            15 as c_int as uint8_t,
            22 as c_int as uint8_t,
            29 as c_int as uint8_t,
            36 as c_int as uint8_t,
            43 as c_int as uint8_t,
            50 as c_int as uint8_t,
            57 as c_int as uint8_t,
            58 as c_int as uint8_t,
            51 as c_int as uint8_t,
            44 as c_int as uint8_t,
            37 as c_int as uint8_t,
            30 as c_int as uint8_t,
            23 as c_int as uint8_t,
            31 as c_int as uint8_t,
            38 as c_int as uint8_t,
            45 as c_int as uint8_t,
            52 as c_int as uint8_t,
            59 as c_int as uint8_t,
            60 as c_int as uint8_t,
            53 as c_int as uint8_t,
            46 as c_int as uint8_t,
            39 as c_int as uint8_t,
            47 as c_int as uint8_t,
            54 as c_int as uint8_t,
            61 as c_int as uint8_t,
            62 as c_int as uint8_t,
            55 as c_int as uint8_t,
            63 as c_int as uint8_t,
        ],
        [
            0 as c_int as uint8_t,
            1 as c_int as uint8_t,
            2 as c_int as uint8_t,
            8 as c_int as uint8_t,
            9 as c_int as uint8_t,
            3 as c_int as uint8_t,
            4 as c_int as uint8_t,
            10 as c_int as uint8_t,
            16 as c_int as uint8_t,
            11 as c_int as uint8_t,
            5 as c_int as uint8_t,
            6 as c_int as uint8_t,
            7 as c_int as uint8_t,
            12 as c_int as uint8_t,
            17 as c_int as uint8_t,
            24 as c_int as uint8_t,
            18 as c_int as uint8_t,
            13 as c_int as uint8_t,
            14 as c_int as uint8_t,
            15 as c_int as uint8_t,
            19 as c_int as uint8_t,
            25 as c_int as uint8_t,
            32 as c_int as uint8_t,
            26 as c_int as uint8_t,
            20 as c_int as uint8_t,
            21 as c_int as uint8_t,
            22 as c_int as uint8_t,
            23 as c_int as uint8_t,
            27 as c_int as uint8_t,
            33 as c_int as uint8_t,
            40 as c_int as uint8_t,
            34 as c_int as uint8_t,
            28 as c_int as uint8_t,
            29 as c_int as uint8_t,
            30 as c_int as uint8_t,
            31 as c_int as uint8_t,
            35 as c_int as uint8_t,
            41 as c_int as uint8_t,
            48 as c_int as uint8_t,
            42 as c_int as uint8_t,
            36 as c_int as uint8_t,
            37 as c_int as uint8_t,
            38 as c_int as uint8_t,
            39 as c_int as uint8_t,
            43 as c_int as uint8_t,
            49 as c_int as uint8_t,
            50 as c_int as uint8_t,
            44 as c_int as uint8_t,
            45 as c_int as uint8_t,
            46 as c_int as uint8_t,
            47 as c_int as uint8_t,
            51 as c_int as uint8_t,
            56 as c_int as uint8_t,
            57 as c_int as uint8_t,
            52 as c_int as uint8_t,
            53 as c_int as uint8_t,
            54 as c_int as uint8_t,
            55 as c_int as uint8_t,
            58 as c_int as uint8_t,
            59 as c_int as uint8_t,
            60 as c_int as uint8_t,
            61 as c_int as uint8_t,
            62 as c_int as uint8_t,
            63 as c_int as uint8_t,
        ],
    ];
    #[c2rust::src_loc = "202:22"]
    pub static mut block_idx_x: [uint8_t; 16] = [
        0 as c_int as uint8_t,
        1 as c_int as uint8_t,
        0 as c_int as uint8_t,
        1 as c_int as uint8_t,
        2 as c_int as uint8_t,
        3 as c_int as uint8_t,
        2 as c_int as uint8_t,
        3 as c_int as uint8_t,
        0 as c_int as uint8_t,
        1 as c_int as uint8_t,
        0 as c_int as uint8_t,
        1 as c_int as uint8_t,
        2 as c_int as uint8_t,
        3 as c_int as uint8_t,
        2 as c_int as uint8_t,
        3 as c_int as uint8_t,
    ];
    #[c2rust::src_loc = "206:22"]
    pub static mut block_idx_y: [uint8_t; 16] = [
        0 as c_int as uint8_t,
        0 as c_int as uint8_t,
        1 as c_int as uint8_t,
        1 as c_int as uint8_t,
        0 as c_int as uint8_t,
        0 as c_int as uint8_t,
        1 as c_int as uint8_t,
        1 as c_int as uint8_t,
        2 as c_int as uint8_t,
        2 as c_int as uint8_t,
        3 as c_int as uint8_t,
        3 as c_int as uint8_t,
        2 as c_int as uint8_t,
        2 as c_int as uint8_t,
        3 as c_int as uint8_t,
        3 as c_int as uint8_t,
    ];
    #[c2rust::src_loc = "225:22"]
    pub static mut block_idx_xy_fenc: [uint8_t; 16] = [
        (0 as c_int * 4 as c_int + 0 as c_int * 4 as c_int * FENC_STRIDE) as uint8_t,
        (1 as c_int * 4 as c_int + 0 as c_int * 4 as c_int * FENC_STRIDE) as uint8_t,
        (0 as c_int * 4 as c_int + 1 as c_int * 4 as c_int * FENC_STRIDE) as uint8_t,
        (1 as c_int * 4 as c_int + 1 as c_int * 4 as c_int * FENC_STRIDE) as uint8_t,
        (2 as c_int * 4 as c_int + 0 as c_int * 4 as c_int * FENC_STRIDE) as uint8_t,
        (3 as c_int * 4 as c_int + 0 as c_int * 4 as c_int * FENC_STRIDE) as uint8_t,
        (2 as c_int * 4 as c_int + 1 as c_int * 4 as c_int * FENC_STRIDE) as uint8_t,
        (3 as c_int * 4 as c_int + 1 as c_int * 4 as c_int * FENC_STRIDE) as uint8_t,
        (0 as c_int * 4 as c_int + 2 as c_int * 4 as c_int * FENC_STRIDE) as uint8_t,
        (1 as c_int * 4 as c_int + 2 as c_int * 4 as c_int * FENC_STRIDE) as uint8_t,
        (0 as c_int * 4 as c_int + 3 as c_int * 4 as c_int * FENC_STRIDE) as uint8_t,
        (1 as c_int * 4 as c_int + 3 as c_int * 4 as c_int * FENC_STRIDE) as uint8_t,
        (2 as c_int * 4 as c_int + 2 as c_int * 4 as c_int * FENC_STRIDE) as uint8_t,
        (3 as c_int * 4 as c_int + 2 as c_int * 4 as c_int * FENC_STRIDE) as uint8_t,
        (2 as c_int * 4 as c_int + 3 as c_int * 4 as c_int * FENC_STRIDE) as uint8_t,
        (3 as c_int * 4 as c_int + 3 as c_int * 4 as c_int * FENC_STRIDE) as uint8_t,
    ];
    #[c2rust::src_loc = "236:23"]
    pub static mut block_idx_xy_fdec: [uint16_t; 16] = [
        (0 as c_int * 4 as c_int + 0 as c_int * 4 as c_int * FDEC_STRIDE) as uint16_t,
        (1 as c_int * 4 as c_int + 0 as c_int * 4 as c_int * FDEC_STRIDE) as uint16_t,
        (0 as c_int * 4 as c_int + 1 as c_int * 4 as c_int * FDEC_STRIDE) as uint16_t,
        (1 as c_int * 4 as c_int + 1 as c_int * 4 as c_int * FDEC_STRIDE) as uint16_t,
        (2 as c_int * 4 as c_int + 0 as c_int * 4 as c_int * FDEC_STRIDE) as uint16_t,
        (3 as c_int * 4 as c_int + 0 as c_int * 4 as c_int * FDEC_STRIDE) as uint16_t,
        (2 as c_int * 4 as c_int + 1 as c_int * 4 as c_int * FDEC_STRIDE) as uint16_t,
        (3 as c_int * 4 as c_int + 1 as c_int * 4 as c_int * FDEC_STRIDE) as uint16_t,
        (0 as c_int * 4 as c_int + 2 as c_int * 4 as c_int * FDEC_STRIDE) as uint16_t,
        (1 as c_int * 4 as c_int + 2 as c_int * 4 as c_int * FDEC_STRIDE) as uint16_t,
        (0 as c_int * 4 as c_int + 3 as c_int * 4 as c_int * FDEC_STRIDE) as uint16_t,
        (1 as c_int * 4 as c_int + 3 as c_int * 4 as c_int * FDEC_STRIDE) as uint16_t,
        (2 as c_int * 4 as c_int + 2 as c_int * 4 as c_int * FDEC_STRIDE) as uint16_t,
        (3 as c_int * 4 as c_int + 2 as c_int * 4 as c_int * FDEC_STRIDE) as uint16_t,
        (2 as c_int * 4 as c_int + 3 as c_int * 4 as c_int * FDEC_STRIDE) as uint16_t,
        (3 as c_int * 4 as c_int + 3 as c_int * 4 as c_int * FDEC_STRIDE) as uint16_t,
    ];
    #[c2rust::src_loc = "291:22"]
    pub static mut ctx_cat_plane: [[uint8_t; 3]; 6] = [
        [
            DCT_LUMA_DC as c_int as uint8_t,
            DCT_CHROMAU_DC as c_int as uint8_t,
            DCT_CHROMAV_DC as c_int as uint8_t,
        ],
        [
            DCT_LUMA_AC as c_int as uint8_t,
            DCT_CHROMAU_AC as c_int as uint8_t,
            DCT_CHROMAV_AC as c_int as uint8_t,
        ],
        [
            DCT_LUMA_4x4 as c_int as uint8_t,
            DCT_CHROMAU_4x4 as c_int as uint8_t,
            DCT_CHROMAV_4x4 as c_int as uint8_t,
        ],
        [0 as c_int as uint8_t, 0, 0],
        [0 as c_int as uint8_t, 0, 0],
        [
            DCT_LUMA_8x8 as c_int as uint8_t,
            DCT_CHROMAU_8x8 as c_int as uint8_t,
            DCT_CHROMAV_8x8 as c_int as uint8_t,
        ],
    ];
    #[inline(always)]
    #[c2rust::src_loc = "371:1"]
    pub unsafe extern "C" fn pack16to32(mut a: uint32_t, mut b: uint32_t) -> uint32_t {
        return a.wrapping_add(b << 16 as c_int);
    }
    #[inline(always)]
    #[c2rust::src_loc = "379:1"]
    pub unsafe extern "C" fn pack8to16(mut a: uint32_t, mut b: uint32_t) -> uint32_t {
        return a.wrapping_add(b << 8 as c_int);
    }
    #[inline(always)]
    #[c2rust::src_loc = "420:1"]
    pub unsafe extern "C" fn x264_mb_predict_intra4x4_mode(
        mut h: *mut x264_t,
        mut idx: c_int,
    ) -> c_int {
        let ma: c_int = (*h).mb.cache.intra4x4_pred_mode
            [(x264_scan8[idx as usize] as c_int - 1 as c_int) as usize]
            as c_int;
        let mb: c_int = (*h).mb.cache.intra4x4_pred_mode
            [(x264_scan8[idx as usize] as c_int - 8 as c_int) as usize]
            as c_int;
        let m: c_int = if (x264_mb_pred_mode4x4_fix[(ma + 1 as c_int) as usize] as c_int)
            < x264_mb_pred_mode4x4_fix[(mb + 1 as c_int) as usize] as c_int
        {
            x264_mb_pred_mode4x4_fix[(ma + 1 as c_int) as usize] as c_int
        } else {
            x264_mb_pred_mode4x4_fix[(mb + 1 as c_int) as usize] as c_int
        };
        if m < 0 as c_int {
            return I_PRED_4x4_DC as c_int;
        }
        return m;
    }
    #[inline(always)]
    #[c2rust::src_loc = "432:1"]
    pub unsafe extern "C" fn x264_mb_predict_non_zero_code(
        mut h: *mut x264_t,
        mut idx: c_int,
    ) -> c_int {
        let za: c_int = (*h).mb.cache.non_zero_count
            [(x264_scan8[idx as usize] as c_int - 1 as c_int) as usize]
            as c_int;
        let zb: c_int = (*h).mb.cache.non_zero_count
            [(x264_scan8[idx as usize] as c_int - 8 as c_int) as usize]
            as c_int;
        let mut i_ret: c_int = za + zb;
        if i_ret < 0x80 as c_int {
            i_ret = i_ret + 1 as c_int >> 1 as c_int;
        }
        return i_ret & 0x7f as c_int;
    }
    #[c2rust::src_loc = "445:22"]
    pub static mut x264_transform_allowed: [uint8_t; 19] = [
        0 as c_int as uint8_t,
        0 as c_int as uint8_t,
        0 as c_int as uint8_t,
        0 as c_int as uint8_t,
        1 as c_int as uint8_t,
        2 as c_int as uint8_t,
        0 as c_int as uint8_t,
        1 as c_int as uint8_t,
        1 as c_int as uint8_t,
        1 as c_int as uint8_t,
        1 as c_int as uint8_t,
        1 as c_int as uint8_t,
        1 as c_int as uint8_t,
        1 as c_int as uint8_t,
        1 as c_int as uint8_t,
        1 as c_int as uint8_t,
        1 as c_int as uint8_t,
        1 as c_int as uint8_t,
        0 as c_int as uint8_t,
    ];
    #[inline(always)]
    #[c2rust::src_loc = "454:1"]
    pub unsafe extern "C" fn x264_mb_transform_8x8_allowed(mut h: *mut x264_t) -> c_int {
        if (*(*h).pps.as_mut_ptr()).b_transform_8x8_mode == 0 {
            return 0 as c_int;
        }
        if (*h).mb.i_type != P_8x8 as c_int {
            return x264_transform_allowed[(*h).mb.i_type as usize] as c_int;
        }
        return ((*((*h).mb.i_sub_partition.as_mut_ptr() as *mut x264_union32_t)).i
            == (D_L0_8x8 as c_int * 0x1010101 as c_int) as uint32_t) as c_int;
    }
    use ::core::ffi::{c_int, c_uint};

    use super::base_h::{x264_scan8, x264_union32_t};
    use super::common_h::{x264_t, FDEC_STRIDE, FENC_STRIDE};
    use super::predict_h::{x264_mb_pred_mode4x4_fix, I_PRED_4x4_DC};
    use super::stdint_intn_h::{int16_t, int8_t};
    use super::stdint_uintn_h::{uint16_t, uint32_t, uint8_t};
    extern "C" {
        #[c2rust::src_loc = "339:1"]
        pub fn x264_10_mb_predict_mv_16x16(
            h: *mut x264_t,
            i_list: c_int,
            i_ref: c_int,
            mvp: *mut int16_t,
        );
        #[c2rust::src_loc = "350:1"]
        pub fn x264_10_mb_predict_mv(
            h: *mut x264_t,
            i_list: c_int,
            idx: c_int,
            i_width: c_int,
            mvp: *mut int16_t,
        );
        #[c2rust::src_loc = "358:1"]
        pub fn x264_10_mb_predict_mv_direct16x16(h: *mut x264_t, b_changed: *mut c_int) -> c_int;
        #[c2rust::src_loc = "364:1"]
        pub fn x264_10_mb_predict_mv_ref16x16(
            h: *mut x264_t,
            i_list: c_int,
            i_ref: c_int,
            mvc: *mut [int16_t; 2],
            i_mvc: *mut c_int,
        );
        #[c2rust::src_loc = "367:1"]
        pub fn x264_10_mb_mc(h: *mut x264_t);
    }

    #[c2rust::src_loc = "171:22"]
    pub static mut x264_mb_partition_pixel_table: [uint8_t; 17] = [
        PIXEL_4x4 as c_int as uint8_t,
        PIXEL_8x4 as c_int as uint8_t,
        PIXEL_4x8 as c_int as uint8_t,
        PIXEL_8x8 as c_int as uint8_t,
        PIXEL_4x4 as c_int as uint8_t,
        PIXEL_8x4 as c_int as uint8_t,
        PIXEL_4x8 as c_int as uint8_t,
        PIXEL_8x8 as c_int as uint8_t,
        PIXEL_4x4 as c_int as uint8_t,
        PIXEL_8x4 as c_int as uint8_t,
        PIXEL_4x8 as c_int as uint8_t,
        PIXEL_8x8 as c_int as uint8_t,
        PIXEL_8x8 as c_int as uint8_t,
        PIXEL_8x8 as c_int as uint8_t,
        PIXEL_16x8 as c_int as uint8_t,
        PIXEL_8x16 as c_int as uint8_t,
        PIXEL_16x16 as c_int as uint8_t,
    ];
    #[c2rust::src_loc = "249:22"]
    pub static mut i_chroma_qp_table: [uint8_t; 106] = [
        0 as c_int as uint8_t,
        0 as c_int as uint8_t,
        0 as c_int as uint8_t,
        0 as c_int as uint8_t,
        0 as c_int as uint8_t,
        0 as c_int as uint8_t,
        0 as c_int as uint8_t,
        0 as c_int as uint8_t,
        0 as c_int as uint8_t,
        0 as c_int as uint8_t,
        0 as c_int as uint8_t,
        0 as c_int as uint8_t,
        (-(12 as c_int) + QP_BD_OFFSET) as uint8_t,
        (-(11 as c_int) + QP_BD_OFFSET) as uint8_t,
        (-(10 as c_int) + QP_BD_OFFSET) as uint8_t,
        (-(9 as c_int) + QP_BD_OFFSET) as uint8_t,
        (-(8 as c_int) + QP_BD_OFFSET) as uint8_t,
        (-(7 as c_int) + QP_BD_OFFSET) as uint8_t,
        (-(6 as c_int) + QP_BD_OFFSET) as uint8_t,
        (-(5 as c_int) + QP_BD_OFFSET) as uint8_t,
        (-(4 as c_int) + QP_BD_OFFSET) as uint8_t,
        (-(3 as c_int) + QP_BD_OFFSET) as uint8_t,
        (-(2 as c_int) + QP_BD_OFFSET) as uint8_t,
        (-1 + QP_BD_OFFSET) as uint8_t,
        (0 as c_int + QP_BD_OFFSET) as uint8_t,
        (1 as c_int + QP_BD_OFFSET) as uint8_t,
        (2 as c_int + QP_BD_OFFSET) as uint8_t,
        (3 as c_int + QP_BD_OFFSET) as uint8_t,
        (4 as c_int + QP_BD_OFFSET) as uint8_t,
        (5 as c_int + QP_BD_OFFSET) as uint8_t,
        (6 as c_int + QP_BD_OFFSET) as uint8_t,
        (7 as c_int + QP_BD_OFFSET) as uint8_t,
        (8 as c_int + QP_BD_OFFSET) as uint8_t,
        (9 as c_int + QP_BD_OFFSET) as uint8_t,
        (10 as c_int + QP_BD_OFFSET) as uint8_t,
        (11 as c_int + QP_BD_OFFSET) as uint8_t,
        (12 as c_int + QP_BD_OFFSET) as uint8_t,
        (13 as c_int + QP_BD_OFFSET) as uint8_t,
        (14 as c_int + QP_BD_OFFSET) as uint8_t,
        (15 as c_int + QP_BD_OFFSET) as uint8_t,
        (16 as c_int + QP_BD_OFFSET) as uint8_t,
        (17 as c_int + QP_BD_OFFSET) as uint8_t,
        (18 as c_int + QP_BD_OFFSET) as uint8_t,
        (19 as c_int + QP_BD_OFFSET) as uint8_t,
        (20 as c_int + QP_BD_OFFSET) as uint8_t,
        (21 as c_int + QP_BD_OFFSET) as uint8_t,
        (22 as c_int + QP_BD_OFFSET) as uint8_t,
        (23 as c_int + QP_BD_OFFSET) as uint8_t,
        (24 as c_int + QP_BD_OFFSET) as uint8_t,
        (25 as c_int + QP_BD_OFFSET) as uint8_t,
        (26 as c_int + QP_BD_OFFSET) as uint8_t,
        (27 as c_int + QP_BD_OFFSET) as uint8_t,
        (28 as c_int + QP_BD_OFFSET) as uint8_t,
        (29 as c_int + QP_BD_OFFSET) as uint8_t,
        (29 as c_int + QP_BD_OFFSET) as uint8_t,
        (30 as c_int + QP_BD_OFFSET) as uint8_t,
        (31 as c_int + QP_BD_OFFSET) as uint8_t,
        (32 as c_int + QP_BD_OFFSET) as uint8_t,
        (32 as c_int + QP_BD_OFFSET) as uint8_t,
        (33 as c_int + QP_BD_OFFSET) as uint8_t,
        (34 as c_int + QP_BD_OFFSET) as uint8_t,
        (34 as c_int + QP_BD_OFFSET) as uint8_t,
        (35 as c_int + QP_BD_OFFSET) as uint8_t,
        (35 as c_int + QP_BD_OFFSET) as uint8_t,
        (36 as c_int + QP_BD_OFFSET) as uint8_t,
        (36 as c_int + QP_BD_OFFSET) as uint8_t,
        (37 as c_int + QP_BD_OFFSET) as uint8_t,
        (37 as c_int + QP_BD_OFFSET) as uint8_t,
        (37 as c_int + QP_BD_OFFSET) as uint8_t,
        (38 as c_int + QP_BD_OFFSET) as uint8_t,
        (38 as c_int + QP_BD_OFFSET) as uint8_t,
        (38 as c_int + QP_BD_OFFSET) as uint8_t,
        (39 as c_int + QP_BD_OFFSET) as uint8_t,
        (39 as c_int + QP_BD_OFFSET) as uint8_t,
        (39 as c_int + QP_BD_OFFSET) as uint8_t,
        (39 as c_int + QP_BD_OFFSET) as uint8_t,
        (39 as c_int + QP_BD_OFFSET) as uint8_t,
        (39 as c_int + QP_BD_OFFSET) as uint8_t,
        (39 as c_int + QP_BD_OFFSET) as uint8_t,
        (39 as c_int + QP_BD_OFFSET) as uint8_t,
        (39 as c_int + QP_BD_OFFSET) as uint8_t,
        (39 as c_int + QP_BD_OFFSET) as uint8_t,
        (39 as c_int + QP_BD_OFFSET) as uint8_t,
        (39 as c_int + QP_BD_OFFSET) as uint8_t,
        (39 as c_int + QP_BD_OFFSET) as uint8_t,
        (39 as c_int + QP_BD_OFFSET) as uint8_t,
        (39 as c_int + QP_BD_OFFSET) as uint8_t,
        (39 as c_int + QP_BD_OFFSET) as uint8_t,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
    ];
    use super::common_h::QP_BD_OFFSET;
    use super::pixel_h::{
        PIXEL_16x16, PIXEL_16x8, PIXEL_4x4, PIXEL_4x8, PIXEL_8x16, PIXEL_8x4, PIXEL_8x8,
    };
    extern "C" {
        #[c2rust::src_loc = "303:1"]
        pub fn x264_10_macroblock_cache_allocate(h: *mut x264_t) -> c_int;
        #[c2rust::src_loc = "305:1"]
        pub fn x264_10_macroblock_cache_free(h: *mut x264_t);
        #[c2rust::src_loc = "309:1"]
        pub fn x264_10_macroblock_thread_allocate(h: *mut x264_t, b_lookahead: c_int) -> c_int;
        #[c2rust::src_loc = "311:1"]
        pub fn x264_10_macroblock_thread_free(h: *mut x264_t, b_lookahead: c_int);
        #[c2rust::src_loc = "314:1"]
        pub fn x264_10_macroblock_slice_init(h: *mut x264_t);
        #[c2rust::src_loc = "316:1"]
        pub fn x264_10_macroblock_thread_init(h: *mut x264_t);
        #[c2rust::src_loc = "320:1"]
        pub fn x264_10_macroblock_cache_load_interlaced(h: *mut x264_t, mb_x: c_int, mb_y: c_int);
        #[c2rust::src_loc = "322:1"]
        pub fn x264_10_macroblock_deblock_strength(h: *mut x264_t);
        #[c2rust::src_loc = "324:1"]
        pub fn x264_10_macroblock_cache_save(h: *mut x264_t);
        #[c2rust::src_loc = "327:1"]
        pub fn x264_10_macroblock_bipred_init(h: *mut x264_t);
    }

    #[inline(always)]
    #[c2rust::src_loc = "403:1"]
    pub unsafe extern "C" fn pack32to64(mut a: uint32_t, mut b: uint32_t) -> uint64_t {
        return (a as uint64_t).wrapping_add((b as uint64_t) << 32 as c_int);
    }
    use super::stdint_uintn_h::uint64_t;
    #[inline(always)]
    #[c2rust::src_loc = "395:1"]
    pub unsafe extern "C" fn pack16to32_mask(mut a: c_int, mut b: c_int) -> uint32_t {
        return ((a & 0xffff as c_int) as uint32_t).wrapping_add((b as uint32_t) << 16 as c_int);
    }

    #[c2rust::src_loc = "90:22"]
    pub static mut x264_mb_type_fix: [uint8_t; 19] = [
        I_4x4 as c_int as uint8_t,
        I_4x4 as c_int as uint8_t,
        I_16x16 as c_int as uint8_t,
        I_PCM as c_int as uint8_t,
        P_L0 as c_int as uint8_t,
        P_8x8 as c_int as uint8_t,
        P_SKIP as c_int as uint8_t,
        B_DIRECT as c_int as uint8_t,
        B_L0_L0 as c_int as uint8_t,
        B_L0_L1 as c_int as uint8_t,
        B_L0_BI as c_int as uint8_t,
        B_L1_L0 as c_int as uint8_t,
        B_L1_L1 as c_int as uint8_t,
        B_L1_BI as c_int as uint8_t,
        B_BI_L0 as c_int as uint8_t,
        B_BI_L1 as c_int as uint8_t,
        B_BI_BI as c_int as uint8_t,
        B_8x8 as c_int as uint8_t,
        B_SKIP as c_int as uint8_t,
    ];
    #[inline(always)]
    #[c2rust::src_loc = "387:1"]
    pub unsafe extern "C" fn pack8to32(
        mut a: uint32_t,
        mut b: uint32_t,
        mut c: uint32_t,
        mut d: uint32_t,
    ) -> uint32_t {
        return a
            .wrapping_add(b << 8 as c_int)
            .wrapping_add(c << 16 as c_int)
            .wrapping_add(d << 24 as c_int);
    }
    extern "C" {
        #[c2rust::src_loc = "344:1"]
        pub fn x264_10_mb_predict_mv_pskip(h: *mut x264_t, mv: *mut int16_t);
    }

    use super::frame_h::x264_frame_t;
    extern "C" {
        #[c2rust::src_loc = "330:1"]
        pub fn x264_10_prefetch_fenc(
            h: *mut x264_t,
            fenc: *mut x264_frame_t,
            i_mb_x: c_int,
            i_mb_y: c_int,
        );
    }

    #[c2rust::src_loc = "217:22"]
    pub static mut block_idx_xy_1d: [uint8_t; 16] = [
        0 as c_int as uint8_t,
        1 as c_int as uint8_t,
        4 as c_int as uint8_t,
        5 as c_int as uint8_t,
        2 as c_int as uint8_t,
        3 as c_int as uint8_t,
        6 as c_int as uint8_t,
        7 as c_int as uint8_t,
        8 as c_int as uint8_t,
        9 as c_int as uint8_t,
        12 as c_int as uint8_t,
        13 as c_int as uint8_t,
        10 as c_int as uint8_t,
        11 as c_int as uint8_t,
        14 as c_int as uint8_t,
        15 as c_int as uint8_t,
    ];
    #[c2rust::src_loc = "221:22"]
    pub static mut block_idx_yx_1d: [uint8_t; 16] = [
        0 as c_int as uint8_t,
        4 as c_int as uint8_t,
        1 as c_int as uint8_t,
        5 as c_int as uint8_t,
        8 as c_int as uint8_t,
        12 as c_int as uint8_t,
        9 as c_int as uint8_t,
        13 as c_int as uint8_t,
        2 as c_int as uint8_t,
        6 as c_int as uint8_t,
        3 as c_int as uint8_t,
        7 as c_int as uint8_t,
        10 as c_int as uint8_t,
        14 as c_int as uint8_t,
        11 as c_int as uint8_t,
        15 as c_int as uint8_t,
    ];
    use super::common_h::pixel;
    extern "C" {
        #[c2rust::src_loc = "333:1"]
        pub fn x264_10_copy_column8(dst: *mut pixel, src: *mut pixel);
        #[c2rust::src_loc = "369:1"]
        pub fn x264_10_mb_mc_8x8(h: *mut x264_t, i8: c_int);
    }
}
#[c2rust::header_src = "/usr/lib/clang/21/include/xmmintrin.h:28"]
pub mod xmmintrin_h {
    #[cfg(target_arch = "x86")]
    pub use ::core::arch::x86::__m128;
    #[cfg(target_arch = "x86_64")]
    pub use ::core::arch::x86_64::__m128;
}
#[c2rust::header_src = "/home/nwplayer123/Hacks/hex264/x264/common/x86/util.h:28"]
pub mod util_h {
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "36:9"]
    pub union x264_union128_sse_t {
        pub i: __m128,
        pub q: [uint64_t; 2],
        pub d: [uint32_t; 4],
        pub w: [uint16_t; 8],
        pub b: [uint8_t; 16],
    }
    #[c2rust::src_loc = "34:9"]
    pub const M128_ZERO: __m128 = unsafe { core::mem::transmute([0.0f32, 0.0f32, 0.0f32, 0.0f32]) };
    use super::stdint_uintn_h::{uint16_t, uint32_t, uint64_t, uint8_t};
    use super::xmmintrin_h::__m128;
    #[cfg(target_arch = "x86")]
    pub use ::core::arch::x86::_mm_setr_ps;
    #[cfg(target_arch = "x86_64")]
    pub use ::core::arch::x86_64::_mm_setr_ps;
}
#[c2rust::header_src = "/home/nwplayer123/Hacks/hex264/x264/encoder/rdo.c:28"]
pub mod rdo_c {
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "424:9"]
    pub struct trellis_level_t {
        pub next: uint16_t,
        pub abs_level: uint16_t,
    }
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "417:9"]
    pub struct trellis_node_t {
        pub score: uint64_t,
        pub level_idx: c_int,
        pub cabac_state: [uint8_t; 4],
    }
    #[no_mangle]
    #[c2rust::src_loc = "36:9"]
    pub static mut x264_10_cabac_transition_unary: [[uint8_t; 128]; 15] = [[0; 128]; 15];
    #[no_mangle]
    #[c2rust::src_loc = "38:10"]
    pub static mut x264_10_cabac_size_unary: [[uint16_t; 128]; 15] = [[0; 128]; 15];
    #[c2rust::src_loc = "41:16"]
    pub static mut cabac_transition_5ones: [uint8_t; 128] = [0; 128];
    #[c2rust::src_loc = "42:17"]
    pub static mut cabac_size_5ones: [uint16_t; 128] = [0; 128];
    #[inline(always)]
    #[c2rust::src_loc = "75:1"]
    pub unsafe extern "C" fn cached_hadamard(
        mut h: *mut x264_t,
        mut size: c_int,
        mut x: c_int,
        mut y: c_int,
    ) -> uint64_t {
        pub static mut hadamard_shift_x: [uint8_t; 4] = [
            4 as c_int as uint8_t,
            4 as c_int as uint8_t,
            3 as c_int as uint8_t,
            3 as c_int as uint8_t,
        ];
        pub static mut hadamard_shift_y: [uint8_t; 4] = [
            (4 as c_int - 0 as c_int) as uint8_t,
            (3 as c_int - 0 as c_int) as uint8_t,
            (4 as c_int - 1 as c_int) as uint8_t,
            (3 as c_int - 1 as c_int) as uint8_t,
        ];
        pub static mut hadamard_offset: [uint8_t; 4] = [
            0 as c_int as uint8_t,
            1 as c_int as uint8_t,
            3 as c_int as uint8_t,
            5 as c_int as uint8_t,
        ];
        let mut cache_index: c_int = (x >> hadamard_shift_x[size as usize] as c_int)
            + (y >> hadamard_shift_y[size as usize] as c_int)
            + hadamard_offset[size as usize] as c_int;
        let mut res: uint64_t = (*h).mb.pic.fenc_hadamard_cache[cache_index as usize];
        if res != 0 {
            return res.wrapping_sub(1 as uint64_t);
        } else {
            let mut fenc: *mut pixel = (*h).mb.pic.p_fenc[0]
                .offset(x as isize)
                .offset((y * FENC_STRIDE) as isize);
            res = (*h).pixf.hadamard_ac[size as usize].expect("non-null function pointer")(
                fenc,
                FENC_STRIDE as intptr_t,
            );
            (*h).mb.pic.fenc_hadamard_cache[cache_index as usize] = res.wrapping_add(1 as uint64_t);
            return res;
        };
    }
    #[inline(always)]
    #[c2rust::src_loc = "94:1"]
    pub unsafe extern "C" fn cached_satd(
        mut h: *mut x264_t,
        mut size: c_int,
        mut x: c_int,
        mut y: c_int,
    ) -> c_int {
        pub static mut satd_shift_x: [uint8_t; 3] = [
            3 as c_int as uint8_t,
            2 as c_int as uint8_t,
            2 as c_int as uint8_t,
        ];
        pub static mut satd_shift_y: [uint8_t; 3] = [
            (2 as c_int - 1 as c_int) as uint8_t,
            (3 as c_int - 2 as c_int) as uint8_t,
            (2 as c_int - 2 as c_int) as uint8_t,
        ];
        pub static mut satd_offset: [uint8_t; 3] = [
            0 as c_int as uint8_t,
            8 as c_int as uint8_t,
            16 as c_int as uint8_t,
        ];
        let mut cache_index: c_int = (x
            >> satd_shift_x[(size - PIXEL_8x4 as c_int) as usize] as c_int)
            + (y >> satd_shift_y[(size - PIXEL_8x4 as c_int) as usize] as c_int)
            + satd_offset[(size - PIXEL_8x4 as c_int) as usize] as c_int;
        let mut res: c_int = (*h).mb.pic.fenc_satd_cache[cache_index as usize] as c_int;
        if res != 0 {
            return res - 1 as c_int;
        } else {
            let mut fenc: *mut pixel = (*h).mb.pic.p_fenc[0]
                .offset(x as isize)
                .offset((y * FENC_STRIDE) as isize);
            let mut dc: c_int = (*h).pixf.sad[size as usize].expect("non-null function pointer")(
                fenc,
                FENC_STRIDE as intptr_t,
                x264_zero.as_mut_ptr() as *mut pixel,
                0 as intptr_t,
            ) >> 1 as c_int;
            res = (*h).pixf.satd[size as usize].expect("non-null function pointer")(
                fenc,
                FENC_STRIDE as intptr_t,
                x264_zero.as_mut_ptr() as *mut pixel,
                0 as intptr_t,
            ) - dc;
            (*h).mb.pic.fenc_satd_cache[cache_index as usize] = (res + 1 as c_int) as uint32_t;
            return res;
        };
    }
    #[inline]
    #[c2rust::src_loc = "123:1"]
    pub unsafe extern "C" fn ssd_plane(
        mut h: *mut x264_t,
        mut size: c_int,
        mut p: c_int,
        mut x: c_int,
        mut y: c_int,
    ) -> c_int {
        let mut satd: c_int = 0 as c_int;
        let mut fdec: *mut pixel = (*h).mb.pic.p_fdec[p as usize]
            .offset(x as isize)
            .offset((y * FDEC_STRIDE) as isize);
        let mut fenc: *mut pixel = (*h).mb.pic.p_fenc[p as usize]
            .offset(x as isize)
            .offset((y * FENC_STRIDE) as isize);
        if p == 0 as c_int && (*h).mb.i_psy_rd != 0 {
            if size <= PIXEL_8x8 as c_int {
                let mut fdec_acs: uint64_t = (*h).pixf.hadamard_ac[size as usize]
                    .expect("non-null function pointer")(
                    fdec, FDEC_STRIDE as intptr_t
                );
                let mut fenc_acs: uint64_t = cached_hadamard(h, size, x, y);
                satd = abs(fdec_acs as c_int - fenc_acs as c_int)
                    + abs((fdec_acs >> 32 as c_int) as c_int - (fenc_acs >> 32 as c_int) as c_int);
                satd >>= 1 as c_int;
            } else {
                let mut dc: c_int = (*h).pixf.sad[size as usize]
                    .expect("non-null function pointer")(
                    fdec,
                    FDEC_STRIDE as intptr_t,
                    x264_zero.as_mut_ptr() as *mut pixel,
                    0 as intptr_t,
                ) >> 1 as c_int;
                satd = abs(
                    (*h).pixf.satd[size as usize].expect("non-null function pointer")(
                        fdec,
                        FDEC_STRIDE as intptr_t,
                        x264_zero.as_mut_ptr() as *mut pixel,
                        0 as intptr_t,
                    ) - dc
                        - cached_satd(h, size, x, y),
                );
            }
            let mut tmp: int64_t =
                satd as int64_t * (*h).mb.i_psy_rd as int64_t * (*h).mb.i_psy_rd_lambda as int64_t
                    + 128 as int64_t
                    >> 8 as c_int;
            satd = (if tmp < ((1 as c_int) << 28 as c_int) as int64_t {
                tmp
            } else {
                ((1 as c_int) << 28 as c_int) as int64_t
            }) as c_int;
        }
        return (*h).pixf.ssd[size as usize].expect("non-null function pointer")(
            fenc,
            FENC_STRIDE as intptr_t,
            fdec,
            FDEC_STRIDE as intptr_t,
        ) + satd;
    }
    #[inline]
    #[c2rust::src_loc = "150:1"]
    pub unsafe extern "C" fn ssd_mb(mut h: *mut x264_t) -> c_int {
        let mut i_ssd: c_int =
            ssd_plane(h, PIXEL_16x16 as c_int, 0 as c_int, 0 as c_int, 0 as c_int);
        if (*(*h).sps.as_mut_ptr()).i_chroma_format_idc != 0 {
            let mut chroma_size: c_int =
                (*h).luma2chroma_pixel[PIXEL_16x16 as c_int as usize] as c_int;
            let mut chroma_ssd: c_int =
                ssd_plane(h, chroma_size, 1 as c_int, 0 as c_int, 0 as c_int)
                    + ssd_plane(h, chroma_size, 2 as c_int, 0 as c_int, 0 as c_int);
            i_ssd = (i_ssd as uint64_t).wrapping_add(
                (chroma_ssd as uint64_t)
                    .wrapping_mul((*h).mb.i_chroma_lambda2_offset as uint64_t)
                    .wrapping_add(128 as uint64_t)
                    >> 8 as c_int,
            ) as c_int as c_int;
        }
        return i_ssd;
    }
    #[c2rust::src_loc = "162:1"]
    pub unsafe extern "C" fn rd_cost_mb(mut h: *mut x264_t, mut i_lambda2: c_int) -> c_int {
        let mut b_transform_bak: c_int = (*h).mb.b_transform_8x8;
        let mut i_ssd: c_int = 0;
        let mut i_bits: c_int = 0;
        let mut type_bak: c_int = (*h).mb.i_type;
        x264_10_macroblock_encode(h);
        if (*h).mb.b_deblock_rdo != 0 {
            x264_10_macroblock_deblock(h);
        }
        i_ssd = ssd_mb(h);
        if (*h).mb.i_type == P_SKIP as c_int || (*h).mb.i_type == B_SKIP as c_int {
            i_bits = 1 as c_int * i_lambda2 + 128 as c_int >> 8 as c_int;
        } else if (*h).param.b_cabac != 0 {
            let mut cabac_tmp: x264_cabac_t = x264_cabac_t {
                i_low: 0,
                i_range: 0,
                i_queue: 0,
                i_bytes_outstanding: 0,
                p_start: 0 as *mut uint8_t,
                p: 0 as *mut uint8_t,
                p_end: 0 as *mut uint8_t,
                f8_bits_encoded: 0,
                state: [0; 1024],
                padding: [0; 12],
            };
            (*h).mc.memcpy_aligned.expect("non-null function pointer")(
                &mut cabac_tmp.f8_bits_encoded as *mut c_int as *mut c_void,
                &mut (*h).cabac.f8_bits_encoded as *mut c_int as *const c_void,
                (::core::mem::size_of::<c_int>() as size_t).wrapping_add(
                    (if (*(*h).sps.as_mut_ptr()).i_chroma_format_idc == CHROMA_444 as c_int {
                        1024 as c_int + 12 as c_int
                    } else {
                        460 as c_int
                    }) as size_t,
                ),
            );
            macroblock_size_cabac(h, &mut cabac_tmp);
            i_bits = ((cabac_tmp.f8_bits_encoded as uint64_t)
                .wrapping_mul(i_lambda2 as uint64_t)
                .wrapping_add(32768 as uint64_t)
                >> 16 as c_int) as c_int;
        } else {
            macroblock_size_cavlc(h);
            i_bits = (((*h).out.bs.i_bits_encoded as uint64_t)
                .wrapping_mul(i_lambda2 as uint64_t)
                .wrapping_add(128 as uint64_t)
                >> 8 as c_int) as c_int;
        }
        (*h).mb.b_transform_8x8 = b_transform_bak;
        (*h).mb.i_type = type_bak;
        return if i_ssd + i_bits < (1 as c_int) << 28 as c_int {
            i_ssd + i_bits
        } else {
            (1 as c_int) << 28 as c_int
        };
    }
    #[c2rust::src_loc = "201:1"]
    pub unsafe extern "C" fn rd_cost_subpart(
        mut h: *mut x264_t,
        mut i_lambda2: c_int,
        mut i4: c_int,
        mut i_pixel: c_int,
    ) -> uint64_t {
        let mut i_ssd: uint64_t = 0;
        let mut i_bits: uint64_t = 0;
        x264_10_macroblock_encode_p4x4(h, i4);
        if i_pixel == PIXEL_8x4 as c_int {
            x264_10_macroblock_encode_p4x4(h, i4 + 1 as c_int);
        }
        if i_pixel == PIXEL_4x8 as c_int {
            x264_10_macroblock_encode_p4x4(h, i4 + 2 as c_int);
        }
        i_ssd = ssd_plane(
            h,
            i_pixel,
            0 as c_int,
            block_idx_x[i4 as usize] as c_int * 4 as c_int,
            block_idx_y[i4 as usize] as c_int * 4 as c_int,
        ) as uint64_t;
        if (*(*h).sps.as_mut_ptr()).i_chroma_format_idc == CHROMA_444 as c_int {
            let mut chromassd: c_int = ssd_plane(
                h,
                i_pixel,
                1 as c_int,
                block_idx_x[i4 as usize] as c_int * 4 as c_int,
                block_idx_y[i4 as usize] as c_int * 4 as c_int,
            ) + ssd_plane(
                h,
                i_pixel,
                2 as c_int,
                block_idx_x[i4 as usize] as c_int * 4 as c_int,
                block_idx_y[i4 as usize] as c_int * 4 as c_int,
            );
            chromassd = ((chromassd as uint64_t)
                .wrapping_mul((*h).mb.i_chroma_lambda2_offset as uint64_t)
                .wrapping_add(128 as uint64_t)
                >> 8 as c_int) as c_int;
            i_ssd = i_ssd.wrapping_add(chromassd as uint64_t);
        }
        if (*h).param.b_cabac != 0 {
            let mut cabac_tmp: x264_cabac_t = x264_cabac_t {
                i_low: 0,
                i_range: 0,
                i_queue: 0,
                i_bytes_outstanding: 0,
                p_start: 0 as *mut uint8_t,
                p: 0 as *mut uint8_t,
                p_end: 0 as *mut uint8_t,
                f8_bits_encoded: 0,
                state: [0; 1024],
                padding: [0; 12],
            };
            (*h).mc.memcpy_aligned.expect("non-null function pointer")(
                &mut cabac_tmp.f8_bits_encoded as *mut c_int as *mut c_void,
                &mut (*h).cabac.f8_bits_encoded as *mut c_int as *const c_void,
                (::core::mem::size_of::<c_int>() as size_t).wrapping_add(
                    (if (*(*h).sps.as_mut_ptr()).i_chroma_format_idc == CHROMA_444 as c_int {
                        1024 as c_int + 12 as c_int
                    } else {
                        460 as c_int
                    }) as size_t,
                ),
            );
            subpartition_size_cabac(h, &mut cabac_tmp, i4, i_pixel);
            i_bits = (cabac_tmp.f8_bits_encoded as uint64_t)
                .wrapping_mul(i_lambda2 as uint64_t)
                .wrapping_add(128 as uint64_t)
                >> 8 as c_int;
        } else {
            i_bits = subpartition_size_cavlc(h, i4, i_pixel) as uint64_t;
        }
        return (i_ssd << 8 as c_int).wrapping_add(i_bits);
    }
    #[no_mangle]
    #[c2rust::src_loc = "233:1"]
    pub unsafe extern "C" fn x264_10_rd_cost_part(
        mut h: *mut x264_t,
        mut i_lambda2: c_int,
        mut i4: c_int,
        mut i_pixel: c_int,
    ) -> uint64_t {
        let mut i_ssd: uint64_t = 0;
        let mut i_bits: uint64_t = 0;
        let mut i8: c_int = i4 >> 2 as c_int;
        if i_pixel == PIXEL_16x16 as c_int {
            let mut i_cost: c_int = rd_cost_mb(h, i_lambda2);
            return i_cost as uint64_t;
        }
        if i_pixel > PIXEL_8x8 as c_int {
            return rd_cost_subpart(h, i_lambda2, i4, i_pixel);
        }
        (*h).mb.i_cbp_luma = 0 as c_int;
        x264_10_macroblock_encode_p8x8(h, i8);
        if i_pixel == PIXEL_16x8 as c_int {
            x264_10_macroblock_encode_p8x8(h, i8 + 1 as c_int);
        }
        if i_pixel == PIXEL_8x16 as c_int {
            x264_10_macroblock_encode_p8x8(h, i8 + 2 as c_int);
        }
        let mut ssd_x: c_int = 8 as c_int * (i8 & 1 as c_int);
        let mut ssd_y: c_int = 8 as c_int * (i8 >> 1 as c_int);
        i_ssd = ssd_plane(h, i_pixel, 0 as c_int, ssd_x, ssd_y) as uint64_t;
        if (*(*h).sps.as_mut_ptr()).i_chroma_format_idc != 0 {
            let mut chroma_size: c_int = (*h).luma2chroma_pixel[i_pixel as usize] as c_int;
            let mut chroma_ssd: c_int = ssd_plane(
                h,
                chroma_size,
                1 as c_int,
                ssd_x >> (*h).mb.chroma_h_shift,
                ssd_y >> (*h).mb.chroma_v_shift,
            ) + ssd_plane(
                h,
                chroma_size,
                2 as c_int,
                ssd_x >> (*h).mb.chroma_h_shift,
                ssd_y >> (*h).mb.chroma_v_shift,
            );
            i_ssd = i_ssd.wrapping_add(
                (chroma_ssd as uint64_t)
                    .wrapping_mul((*h).mb.i_chroma_lambda2_offset as uint64_t)
                    .wrapping_add(128 as uint64_t)
                    >> 8 as c_int,
            );
        }
        if (*h).param.b_cabac != 0 {
            let mut cabac_tmp: x264_cabac_t = x264_cabac_t {
                i_low: 0,
                i_range: 0,
                i_queue: 0,
                i_bytes_outstanding: 0,
                p_start: 0 as *mut uint8_t,
                p: 0 as *mut uint8_t,
                p_end: 0 as *mut uint8_t,
                f8_bits_encoded: 0,
                state: [0; 1024],
                padding: [0; 12],
            };
            (*h).mc.memcpy_aligned.expect("non-null function pointer")(
                &mut cabac_tmp.f8_bits_encoded as *mut c_int as *mut c_void,
                &mut (*h).cabac.f8_bits_encoded as *mut c_int as *const c_void,
                (::core::mem::size_of::<c_int>() as size_t).wrapping_add(
                    (if (*(*h).sps.as_mut_ptr()).i_chroma_format_idc == CHROMA_444 as c_int {
                        1024 as c_int + 12 as c_int
                    } else {
                        460 as c_int
                    }) as size_t,
                ),
            );
            partition_size_cabac(h, &mut cabac_tmp, i8, i_pixel);
            i_bits = (cabac_tmp.f8_bits_encoded as uint64_t)
                .wrapping_mul(i_lambda2 as uint64_t)
                .wrapping_add(128 as uint64_t)
                >> 8 as c_int;
        } else {
            i_bits = (partition_size_cavlc(h, i8, i_pixel) as uint64_t)
                .wrapping_mul(i_lambda2 as uint64_t);
        }
        return (i_ssd << 8 as c_int).wrapping_add(i_bits);
    }
    #[c2rust::src_loc = "279:1"]
    pub unsafe extern "C" fn rd_cost_i8x8(
        mut h: *mut x264_t,
        mut i_lambda2: c_int,
        mut i8: c_int,
        mut i_mode: c_int,
        mut edge: *mut [pixel; 32],
    ) -> uint64_t {
        let mut i_ssd: uint64_t = 0;
        let mut i_bits: uint64_t = 0;
        let mut plane_count: c_int =
            if (*(*h).sps.as_mut_ptr()).i_chroma_format_idc == CHROMA_444 as c_int {
                3 as c_int
            } else {
                1 as c_int
            };
        let mut i_qp: c_int = (*h).mb.i_qp;
        (*h).mb.i_cbp_luma &= !((1 as c_int) << i8);
        (*h).mb.b_transform_8x8 = 1 as c_int;
        let mut p: c_int = 0 as c_int;
        while p < plane_count {
            x264_mb_encode_i8x8(
                h,
                p,
                i8,
                i_qp,
                i_mode,
                (*edge.offset(p as isize)).as_mut_ptr(),
                1 as c_int,
            );
            i_qp = (*h).mb.i_chroma_qp;
            p += 1;
        }
        i_ssd = ssd_plane(
            h,
            PIXEL_8x8 as c_int,
            0 as c_int,
            (i8 & 1 as c_int) * 8 as c_int,
            (i8 >> 1 as c_int) * 8 as c_int,
        ) as uint64_t;
        if (*(*h).sps.as_mut_ptr()).i_chroma_format_idc == CHROMA_444 as c_int {
            let mut chromassd: c_int = ssd_plane(
                h,
                PIXEL_8x8 as c_int,
                1 as c_int,
                (i8 & 1 as c_int) * 8 as c_int,
                (i8 >> 1 as c_int) * 8 as c_int,
            ) + ssd_plane(
                h,
                PIXEL_8x8 as c_int,
                2 as c_int,
                (i8 & 1 as c_int) * 8 as c_int,
                (i8 >> 1 as c_int) * 8 as c_int,
            );
            chromassd = ((chromassd as uint64_t)
                .wrapping_mul((*h).mb.i_chroma_lambda2_offset as uint64_t)
                .wrapping_add(128 as uint64_t)
                >> 8 as c_int) as c_int;
            i_ssd = i_ssd.wrapping_add(chromassd as uint64_t);
        }
        if (*h).param.b_cabac != 0 {
            let mut cabac_tmp: x264_cabac_t = x264_cabac_t {
                i_low: 0,
                i_range: 0,
                i_queue: 0,
                i_bytes_outstanding: 0,
                p_start: 0 as *mut uint8_t,
                p: 0 as *mut uint8_t,
                p_end: 0 as *mut uint8_t,
                f8_bits_encoded: 0,
                state: [0; 1024],
                padding: [0; 12],
            };
            (*h).mc.memcpy_aligned.expect("non-null function pointer")(
                &mut cabac_tmp.f8_bits_encoded as *mut c_int as *mut c_void,
                &mut (*h).cabac.f8_bits_encoded as *mut c_int as *const c_void,
                (::core::mem::size_of::<c_int>() as size_t).wrapping_add(
                    (if (*(*h).sps.as_mut_ptr()).i_chroma_format_idc == CHROMA_444 as c_int {
                        1024 as c_int + 12 as c_int
                    } else {
                        460 as c_int
                    }) as size_t,
                ),
            );
            partition_i8x8_size_cabac(h, &mut cabac_tmp, i8, i_mode);
            i_bits = (cabac_tmp.f8_bits_encoded as uint64_t)
                .wrapping_mul(i_lambda2 as uint64_t)
                .wrapping_add(128 as uint64_t)
                >> 8 as c_int;
        } else {
            i_bits = (partition_i8x8_size_cavlc(h, i8, i_mode) as uint64_t)
                .wrapping_mul(i_lambda2 as uint64_t);
        }
        return (i_ssd << 8 as c_int).wrapping_add(i_bits);
    }
    #[c2rust::src_loc = "315:1"]
    pub unsafe extern "C" fn rd_cost_i4x4(
        mut h: *mut x264_t,
        mut i_lambda2: c_int,
        mut i4: c_int,
        mut i_mode: c_int,
    ) -> uint64_t {
        let mut i_ssd: uint64_t = 0;
        let mut i_bits: uint64_t = 0;
        let mut plane_count: c_int =
            if (*(*h).sps.as_mut_ptr()).i_chroma_format_idc == CHROMA_444 as c_int {
                3 as c_int
            } else {
                1 as c_int
            };
        let mut i_qp: c_int = (*h).mb.i_qp;
        let mut p: c_int = 0 as c_int;
        while p < plane_count {
            x264_mb_encode_i4x4(h, p, i4, i_qp, i_mode, 1 as c_int);
            i_qp = (*h).mb.i_chroma_qp;
            p += 1;
        }
        i_ssd = ssd_plane(
            h,
            PIXEL_4x4 as c_int,
            0 as c_int,
            block_idx_x[i4 as usize] as c_int * 4 as c_int,
            block_idx_y[i4 as usize] as c_int * 4 as c_int,
        ) as uint64_t;
        if (*(*h).sps.as_mut_ptr()).i_chroma_format_idc == CHROMA_444 as c_int {
            let mut chromassd: c_int = ssd_plane(
                h,
                PIXEL_4x4 as c_int,
                1 as c_int,
                block_idx_x[i4 as usize] as c_int * 4 as c_int,
                block_idx_y[i4 as usize] as c_int * 4 as c_int,
            ) + ssd_plane(
                h,
                PIXEL_4x4 as c_int,
                2 as c_int,
                block_idx_x[i4 as usize] as c_int * 4 as c_int,
                block_idx_y[i4 as usize] as c_int * 4 as c_int,
            );
            chromassd = ((chromassd as uint64_t)
                .wrapping_mul((*h).mb.i_chroma_lambda2_offset as uint64_t)
                .wrapping_add(128 as uint64_t)
                >> 8 as c_int) as c_int;
            i_ssd = i_ssd.wrapping_add(chromassd as uint64_t);
        }
        if (*h).param.b_cabac != 0 {
            let mut cabac_tmp: x264_cabac_t = x264_cabac_t {
                i_low: 0,
                i_range: 0,
                i_queue: 0,
                i_bytes_outstanding: 0,
                p_start: 0 as *mut uint8_t,
                p: 0 as *mut uint8_t,
                p_end: 0 as *mut uint8_t,
                f8_bits_encoded: 0,
                state: [0; 1024],
                padding: [0; 12],
            };
            (*h).mc.memcpy_aligned.expect("non-null function pointer")(
                &mut cabac_tmp.f8_bits_encoded as *mut c_int as *mut c_void,
                &mut (*h).cabac.f8_bits_encoded as *mut c_int as *const c_void,
                (::core::mem::size_of::<c_int>() as size_t).wrapping_add(
                    (if (*(*h).sps.as_mut_ptr()).i_chroma_format_idc == CHROMA_444 as c_int {
                        1024 as c_int + 12 as c_int
                    } else {
                        460 as c_int
                    }) as size_t,
                ),
            );
            partition_i4x4_size_cabac(h, &mut cabac_tmp, i4, i_mode);
            i_bits = (cabac_tmp.f8_bits_encoded as uint64_t)
                .wrapping_mul(i_lambda2 as uint64_t)
                .wrapping_add(128 as uint64_t)
                >> 8 as c_int;
        } else {
            i_bits = (partition_i4x4_size_cavlc(h, i4, i_mode) as uint64_t)
                .wrapping_mul(i_lambda2 as uint64_t);
        }
        return (i_ssd << 8 as c_int).wrapping_add(i_bits);
    }
    #[c2rust::src_loc = "349:1"]
    pub unsafe extern "C" fn rd_cost_chroma(
        mut h: *mut x264_t,
        mut i_lambda2: c_int,
        mut i_mode: c_int,
        mut b_dct: c_int,
    ) -> uint64_t {
        let mut i_ssd: uint64_t = 0;
        let mut i_bits: uint64_t = 0;
        if b_dct != 0 {
            x264_10_mb_encode_chroma(h, 0 as c_int, (*h).mb.i_chroma_qp);
        }
        let mut chromapix: c_int = (*h).luma2chroma_pixel[PIXEL_16x16 as c_int as usize] as c_int;
        i_ssd = (ssd_plane(h, chromapix, 1 as c_int, 0 as c_int, 0 as c_int)
            + ssd_plane(h, chromapix, 2 as c_int, 0 as c_int, 0 as c_int))
            as uint64_t;
        (*h).mb.i_chroma_pred_mode = i_mode;
        if (*h).param.b_cabac != 0 {
            let mut cabac_tmp: x264_cabac_t = x264_cabac_t {
                i_low: 0,
                i_range: 0,
                i_queue: 0,
                i_bytes_outstanding: 0,
                p_start: 0 as *mut uint8_t,
                p: 0 as *mut uint8_t,
                p_end: 0 as *mut uint8_t,
                f8_bits_encoded: 0,
                state: [0; 1024],
                padding: [0; 12],
            };
            (*h).mc.memcpy_aligned.expect("non-null function pointer")(
                &mut cabac_tmp.f8_bits_encoded as *mut c_int as *mut c_void,
                &mut (*h).cabac.f8_bits_encoded as *mut c_int as *const c_void,
                (::core::mem::size_of::<c_int>() as size_t).wrapping_add(
                    (if (*(*h).sps.as_mut_ptr()).i_chroma_format_idc == CHROMA_444 as c_int {
                        1024 as c_int + 12 as c_int
                    } else {
                        460 as c_int
                    }) as size_t,
                ),
            );
            chroma_size_cabac(h, &mut cabac_tmp);
            i_bits = (cabac_tmp.f8_bits_encoded as uint64_t)
                .wrapping_mul(i_lambda2 as uint64_t)
                .wrapping_add(128 as uint64_t)
                >> 8 as c_int;
        } else {
            i_bits = (chroma_size_cavlc(h) as uint64_t).wrapping_mul(i_lambda2 as uint64_t);
        }
        return (i_ssd << 8 as c_int).wrapping_add(i_bits);
    }
    #[c2rust::src_loc = "378:9"]
    pub const TRELLIS_SCORE_MAX: c_ulonglong = !(0 as c_ulonglong);
    #[c2rust::src_loc = "379:9"]
    pub const TRELLIS_SCORE_BIAS: c_ulonglong = (1 as c_ulonglong) << 60 as c_int;
    #[c2rust::src_loc = "380:9"]
    pub const CABAC_SIZE_BITS: c_int = 8 as c_int;
    #[c2rust::src_loc = "381:9"]
    pub const LAMBDA_BITS: c_int = 4 as c_int;
    #[no_mangle]
    #[c2rust::src_loc = "384:1"]
    pub unsafe extern "C" fn x264_10_rdo_init() {
        let mut i_prefix: c_int = 0 as c_int;
        while i_prefix < 15 as c_int {
            let mut i_ctx: c_int = 0 as c_int;
            while i_ctx < 128 as c_int {
                let mut f8_bits: c_int = 0 as c_int;
                let mut ctx: uint8_t = i_ctx as uint8_t;
                let mut i: c_int = 1 as c_int;
                while i < i_prefix {
                    f8_bits += x264_cabac_size_decision2(&mut ctx, 1 as c_long);
                    i += 1;
                }
                if i_prefix > 0 as c_int && i_prefix < 14 as c_int {
                    f8_bits += x264_cabac_size_decision2(&mut ctx, 0 as c_long);
                }
                f8_bits += (1 as c_int) << CABAC_SIZE_BITS;
                x264_10_cabac_size_unary[i_prefix as usize][i_ctx as usize] = f8_bits as uint16_t;
                x264_10_cabac_transition_unary[i_prefix as usize][i_ctx as usize] = ctx;
                i_ctx += 1;
            }
            i_prefix += 1;
        }
        let mut i_ctx_0: c_int = 0 as c_int;
        while i_ctx_0 < 128 as c_int {
            let mut f8_bits_0: c_int = 0 as c_int;
            let mut ctx_0: uint8_t = i_ctx_0 as uint8_t;
            let mut i_0: c_int = 0 as c_int;
            while i_0 < 5 as c_int {
                f8_bits_0 += x264_cabac_size_decision2(&mut ctx_0, 1 as c_long);
                i_0 += 1;
            }
            f8_bits_0 += (1 as c_int) << CABAC_SIZE_BITS;
            cabac_size_5ones[i_ctx_0 as usize] = f8_bits_0 as uint16_t;
            cabac_transition_5ones[i_ctx_0 as usize] = ctx_0;
            i_ctx_0 += 1;
        }
    }
    #[inline(never)]
    #[c2rust::src_loc = "462:1"]
    pub unsafe extern "C" fn trellis_dc_shortcut(
        mut sign_coef: c_int,
        mut quant_coef: c_int,
        mut unquant_mf: c_int,
        mut coef_weight: c_int,
        mut lambda2: c_int,
        mut cabac_state: *mut uint8_t,
        mut cost_sig: c_int,
    ) -> c_int {
        let mut bscore: uint64_t = TRELLIS_SCORE_MAX as uint64_t;
        let mut ret: c_int = 0 as c_int;
        let mut q: c_int = abs(quant_coef);
        let mut abs_level: c_int = q - 1 as c_int;
        while abs_level <= q {
            let mut unquant_abs_level: c_int = unquant_mf * abs_level + 128 as c_int >> 8 as c_int;
            let mut d: c_int = sign_coef
                - ((unquant_abs_level ^ sign_coef >> 31 as c_int) - (sign_coef >> 31 as c_int)
                    + 8 as c_int
                    & !(15 as c_int));
            let mut score: uint64_t =
                (d as int64_t * d as int64_t * coef_weight as int64_t) as uint64_t;
            if abs_level != 0 {
                let mut f8_bits: c_uint = cost_sig as c_uint;
                let mut prefix: c_int = if (abs_level - 1 as c_int) < 14 as c_int {
                    abs_level - 1 as c_int
                } else {
                    14 as c_int
                };
                f8_bits = f8_bits.wrapping_add(x264_cabac_size_decision_noup2(
                    cabac_state.offset(1),
                    (prefix > 0 as c_int) as c_int as c_long,
                ) as c_uint);
                f8_bits = f8_bits.wrapping_add(
                    x264_10_cabac_size_unary[prefix as usize][*cabac_state.offset(5) as usize]
                        as c_uint,
                );
                if abs_level >= 15 as c_int {
                    f8_bits = f8_bits.wrapping_add(
                        (bs_size_ue_big((abs_level - 15 as c_int) as c_uint) << CABAC_SIZE_BITS)
                            as c_uint,
                    );
                }
                score = score.wrapping_add(
                    (f8_bits as uint64_t).wrapping_mul(lambda2 as uint64_t)
                        >> CABAC_SIZE_BITS - LAMBDA_BITS,
                );
            }
            if score < bscore {
                bscore = score;
                ret = abs_level;
            }
            abs_level += 1;
        }
        return (ret ^ sign_coef >> 31 as c_int) - (sign_coef >> 31 as c_int);
    }
    #[inline(always)]
    #[c2rust::src_loc = "494:1"]
    pub unsafe extern "C" fn trellis_coef(
        mut j: c_int,
        mut const_level: c_int,
        mut abs_level: c_int,
        mut prefix: c_int,
        mut suffix_cost: c_int,
        mut node_ctx: c_int,
        mut level1_ctx: c_int,
        mut levelgt1_ctx: c_int,
        mut ssd: uint64_t,
        mut cost_siglast: *mut c_int,
        mut nodes_cur: *mut trellis_node_t,
        mut nodes_prev: *mut trellis_node_t,
        mut level_tree: *mut trellis_level_t,
        mut levels_used: c_int,
        mut lambda2: c_int,
        mut level_state: *mut uint8_t,
    ) -> c_int {
        let mut score: uint64_t = (*nodes_prev.offset(j as isize)).score.wrapping_add(ssd);
        let mut f8_bits: c_uint =
            *cost_siglast.offset((if j != 0 { 1 as c_int } else { 2 as c_int }) as isize) as c_uint;
        let mut level1_state: uint8_t = (if j >= 3 as c_int {
            (*nodes_prev.offset(j as isize)).cabac_state[(level1_ctx >> 2 as c_int) as usize]
                as c_int
        } else {
            *level_state.offset(level1_ctx as isize) as c_int
        }) as uint8_t;
        f8_bits = f8_bits.wrapping_add(
            x264_cabac_entropy
                [(level1_state as c_int ^ (const_level > 1 as c_int) as c_int) as usize]
                as c_uint,
        );
        let mut levelgt1_state: uint8_t = 0;
        if const_level > 1 as c_int {
            levelgt1_state = (if j >= 6 as c_int {
                (*nodes_prev.offset(j as isize)).cabac_state[(levelgt1_ctx - 6 as c_int) as usize]
                    as c_int
            } else {
                *level_state.offset(levelgt1_ctx as isize) as c_int
            }) as uint8_t;
            f8_bits = f8_bits.wrapping_add(
                (x264_10_cabac_size_unary[prefix as usize][levelgt1_state as usize] as c_int
                    + suffix_cost) as c_uint,
            );
        } else {
            f8_bits = f8_bits.wrapping_add(((1 as c_int) << CABAC_SIZE_BITS) as c_uint);
        }
        score = score.wrapping_add(
            (f8_bits as uint64_t).wrapping_mul(lambda2 as uint64_t)
                >> CABAC_SIZE_BITS - LAMBDA_BITS,
        );
        if score < (*nodes_cur.offset(node_ctx as isize)).score {
            (*nodes_cur.offset(node_ctx as isize)).score = score;
            if j == 2 as c_int || j <= 3 as c_int && node_ctx == 4 as c_int {
                (*((*nodes_cur.offset(node_ctx as isize))
                    .cabac_state
                    .as_mut_ptr() as *mut x264_union32_t))
                    .i = (*(level_state.offset(12 as c_int as isize) as *mut x264_union32_t)).i;
            } else if j >= 3 as c_int {
                (*((*nodes_cur.offset(node_ctx as isize))
                    .cabac_state
                    .as_mut_ptr() as *mut x264_union32_t))
                    .i = (*((*nodes_prev.offset(j as isize)).cabac_state.as_mut_ptr()
                    as *mut x264_union32_t))
                    .i;
            }
            if j >= 3 as c_int {
                (*nodes_cur.offset(node_ctx as isize)).cabac_state
                    [(level1_ctx >> 2 as c_int) as usize] = x264_cabac_transition
                    [level1_state as usize][(const_level > 1 as c_int) as c_int as usize];
            }
            if const_level > 1 as c_int && node_ctx == 7 as c_int {
                (*nodes_cur.offset(node_ctx as isize)).cabac_state
                    [(levelgt1_ctx - 6 as c_int) as usize] =
                    x264_10_cabac_transition_unary[prefix as usize][levelgt1_state as usize];
            }
            (*nodes_cur.offset(node_ctx as isize)).level_idx =
                (*nodes_prev.offset(j as isize)).level_idx;
            if ::core::mem::size_of::<trellis_level_t>() as usize
                == ::core::mem::size_of::<uint32_t>() as usize
            {
                (*(&mut *level_tree.offset(levels_used as isize) as *mut trellis_level_t
                    as *mut x264_union32_t))
                    .i = pack16to32(
                    (*nodes_prev.offset(j as isize)).level_idx as uint32_t,
                    abs_level as uint32_t,
                );
            } else {
                *level_tree.offset(levels_used as isize) = {
                    let mut init = trellis_level_t {
                        next: (*nodes_prev.offset(j as isize)).level_idx as uint16_t,
                        abs_level: abs_level as uint16_t,
                    };
                    init
                };
            }
            (*nodes_cur.offset(node_ctx as isize)).level_idx = levels_used;
            levels_used += 1;
        }
        return levels_used;
    }
    #[inline(never)]
    #[c2rust::src_loc = "537:1"]
    pub unsafe extern "C" fn trellis_coef0_0(
        mut ssd0: uint64_t,
        mut nodes_cur: *mut trellis_node_t,
        mut nodes_prev: *mut trellis_node_t,
        mut level_tree: *mut trellis_level_t,
        mut levels_used: c_int,
    ) -> c_int {
        (*nodes_cur.offset(0)).score = (*nodes_prev.offset(0)).score.wrapping_add(ssd0);
        (*nodes_cur.offset(0)).level_idx = (*nodes_prev.offset(0)).level_idx;
        let mut j: c_int = 1 as c_int;
        while j < 4 as c_int && (*nodes_prev.offset(j as isize)).score as int64_t >= 0 as int64_t {
            (*nodes_cur.offset(j as isize)).score = (*nodes_prev.offset(j as isize)).score;
            if j >= 3 as c_int {
                (*((*nodes_cur.offset(j as isize)).cabac_state.as_mut_ptr()
                    as *mut x264_union32_t))
                    .i = (*((*nodes_prev.offset(j as isize)).cabac_state.as_mut_ptr()
                    as *mut x264_union32_t))
                    .i;
            }
            if ::core::mem::size_of::<trellis_level_t>() as usize
                == ::core::mem::size_of::<uint32_t>() as usize
            {
                (*(&mut *level_tree.offset(levels_used as isize) as *mut trellis_level_t
                    as *mut x264_union32_t))
                    .i = pack16to32(
                    (*nodes_prev.offset(j as isize)).level_idx as uint32_t,
                    0 as uint32_t,
                );
            } else {
                *level_tree.offset(levels_used as isize) = {
                    let mut init = trellis_level_t {
                        next: (*nodes_prev.offset(j as isize)).level_idx as uint16_t,
                        abs_level: 0 as uint16_t,
                    };
                    init
                };
            }
            (*nodes_cur.offset(j as isize)).level_idx = levels_used;
            levels_used += 1;
            j += 1;
        }
        return levels_used;
    }
    #[inline(never)]
    #[c2rust::src_loc = "553:1"]
    pub unsafe extern "C" fn trellis_coef0_1(
        mut ssd0: uint64_t,
        mut nodes_cur: *mut trellis_node_t,
        mut nodes_prev: *mut trellis_node_t,
        mut level_tree: *mut trellis_level_t,
        mut levels_used: c_int,
    ) -> c_int {
        let mut j: c_int = 1 as c_int;
        while j < 8 as c_int {
            if (*nodes_prev.offset(j as isize)).score as int64_t >= 0 as int64_t {
                (*nodes_cur.offset(j as isize)).score = (*nodes_prev.offset(j as isize)).score;
                if j >= 3 as c_int {
                    (*((*nodes_cur.offset(j as isize)).cabac_state.as_mut_ptr()
                        as *mut x264_union32_t))
                        .i = (*((*nodes_prev.offset(j as isize)).cabac_state.as_mut_ptr()
                        as *mut x264_union32_t))
                        .i;
                }
                if ::core::mem::size_of::<trellis_level_t>() as usize
                    == ::core::mem::size_of::<uint32_t>() as usize
                {
                    (*(&mut *level_tree.offset(levels_used as isize) as *mut trellis_level_t
                        as *mut x264_union32_t))
                        .i = pack16to32(
                        (*nodes_prev.offset(j as isize)).level_idx as uint32_t,
                        0 as uint32_t,
                    );
                } else {
                    *level_tree.offset(levels_used as isize) = {
                        let mut init = trellis_level_t {
                            next: (*nodes_prev.offset(j as isize)).level_idx as uint16_t,
                            abs_level: 0 as uint16_t,
                        };
                        init
                    };
                }
                (*nodes_cur.offset(j as isize)).level_idx = levels_used;
                levels_used += 1;
            }
            j += 1;
        }
        return levels_used;
    }
    #[inline(never)]
    #[c2rust::src_loc = "577:1"]
    pub unsafe extern "C" fn trellis_coef1_0(
        mut ssd0: uint64_t,
        mut ssd1: uint64_t,
        mut cost_siglast: *mut c_int,
        mut nodes_cur: *mut trellis_node_t,
        mut nodes_prev: *mut trellis_node_t,
        mut level_tree: *mut trellis_level_t,
        mut levels_used: c_int,
        mut lambda2: c_int,
        mut level_state: *mut uint8_t,
    ) -> c_int {
        let mut abs_level: c_int = 1 as c_int;
        let mut prefix: c_int = 1 as c_int;
        let mut suffix_cost: c_int = 0 as c_int;
        if 0 as c_int == 0 || (*nodes_prev.offset(0)).score as int64_t >= 0 as int64_t {
            levels_used = trellis_coef(
                0 as c_int,
                1 as c_int,
                abs_level,
                prefix,
                suffix_cost,
                1 as c_int,
                1 as c_int,
                0 as c_int,
                if 0 as c_int != 0 { ssd1 } else { ssd0 },
                cost_siglast,
                nodes_cur,
                nodes_prev,
                level_tree,
                levels_used,
                lambda2,
                level_state,
            );
        } else if 0 as c_int == 0 {
            return levels_used;
        }
        if 1 as c_int == 0 || (*nodes_prev.offset(1)).score as int64_t >= 0 as int64_t {
            levels_used = trellis_coef(
                1 as c_int,
                1 as c_int,
                abs_level,
                prefix,
                suffix_cost,
                2 as c_int,
                2 as c_int,
                0 as c_int,
                if 1 as c_int != 0 { ssd1 } else { ssd0 },
                cost_siglast,
                nodes_cur,
                nodes_prev,
                level_tree,
                levels_used,
                lambda2,
                level_state,
            );
        } else if 0 as c_int == 0 {
            return levels_used;
        }
        if 2 as c_int == 0 || (*nodes_prev.offset(2)).score as int64_t >= 0 as int64_t {
            levels_used = trellis_coef(
                2 as c_int,
                1 as c_int,
                abs_level,
                prefix,
                suffix_cost,
                3 as c_int,
                3 as c_int,
                0 as c_int,
                if 2 as c_int != 0 { ssd1 } else { ssd0 },
                cost_siglast,
                nodes_cur,
                nodes_prev,
                level_tree,
                levels_used,
                lambda2,
                level_state,
            );
        } else if 0 as c_int == 0 {
            return levels_used;
        }
        if 3 as c_int == 0 || (*nodes_prev.offset(3)).score as int64_t >= 0 as int64_t {
            levels_used = trellis_coef(
                3 as c_int,
                1 as c_int,
                abs_level,
                prefix,
                suffix_cost,
                3 as c_int,
                4 as c_int,
                0 as c_int,
                if 3 as c_int != 0 { ssd1 } else { ssd0 },
                cost_siglast,
                nodes_cur,
                nodes_prev,
                level_tree,
                levels_used,
                lambda2,
                level_state,
            );
        } else if 0 as c_int == 0 {
            return levels_used;
        }
        return levels_used;
    }
    #[inline(never)]
    #[c2rust::src_loc = "591:1"]
    pub unsafe extern "C" fn trellis_coef1_1(
        mut ssd0: uint64_t,
        mut ssd1: uint64_t,
        mut cost_siglast: *mut c_int,
        mut nodes_cur: *mut trellis_node_t,
        mut nodes_prev: *mut trellis_node_t,
        mut level_tree: *mut trellis_level_t,
        mut levels_used: c_int,
        mut lambda2: c_int,
        mut level_state: *mut uint8_t,
    ) -> c_int {
        let mut abs_level: c_int = 1 as c_int;
        let mut prefix: c_int = 1 as c_int;
        let mut suffix_cost: c_int = 0 as c_int;
        if 1 as c_int == 0 || (*nodes_prev.offset(1)).score as int64_t >= 0 as int64_t {
            levels_used = trellis_coef(
                1 as c_int,
                1 as c_int,
                abs_level,
                prefix,
                suffix_cost,
                2 as c_int,
                2 as c_int,
                0 as c_int,
                if 1 as c_int != 0 { ssd1 } else { ssd0 },
                cost_siglast,
                nodes_cur,
                nodes_prev,
                level_tree,
                levels_used,
                lambda2,
                level_state,
            );
        } else if 1 as c_int == 0 {
            return levels_used;
        }
        if 2 as c_int == 0 || (*nodes_prev.offset(2)).score as int64_t >= 0 as int64_t {
            levels_used = trellis_coef(
                2 as c_int,
                1 as c_int,
                abs_level,
                prefix,
                suffix_cost,
                3 as c_int,
                3 as c_int,
                0 as c_int,
                if 2 as c_int != 0 { ssd1 } else { ssd0 },
                cost_siglast,
                nodes_cur,
                nodes_prev,
                level_tree,
                levels_used,
                lambda2,
                level_state,
            );
        } else if 1 as c_int == 0 {
            return levels_used;
        }
        if 3 as c_int == 0 || (*nodes_prev.offset(3)).score as int64_t >= 0 as int64_t {
            levels_used = trellis_coef(
                3 as c_int,
                1 as c_int,
                abs_level,
                prefix,
                suffix_cost,
                3 as c_int,
                4 as c_int,
                0 as c_int,
                if 3 as c_int != 0 { ssd1 } else { ssd0 },
                cost_siglast,
                nodes_cur,
                nodes_prev,
                level_tree,
                levels_used,
                lambda2,
                level_state,
            );
        } else if 1 as c_int == 0 {
            return levels_used;
        }
        if 4 as c_int == 0 || (*nodes_prev.offset(4)).score as int64_t >= 0 as int64_t {
            levels_used = trellis_coef(
                4 as c_int,
                1 as c_int,
                abs_level,
                prefix,
                suffix_cost,
                4 as c_int,
                0 as c_int,
                0 as c_int,
                if 4 as c_int != 0 { ssd1 } else { ssd0 },
                cost_siglast,
                nodes_cur,
                nodes_prev,
                level_tree,
                levels_used,
                lambda2,
                level_state,
            );
        } else if 1 as c_int == 0 {
            return levels_used;
        }
        if 5 as c_int == 0 || (*nodes_prev.offset(5)).score as int64_t >= 0 as int64_t {
            levels_used = trellis_coef(
                5 as c_int,
                1 as c_int,
                abs_level,
                prefix,
                suffix_cost,
                5 as c_int,
                0 as c_int,
                0 as c_int,
                if 5 as c_int != 0 { ssd1 } else { ssd0 },
                cost_siglast,
                nodes_cur,
                nodes_prev,
                level_tree,
                levels_used,
                lambda2,
                level_state,
            );
        } else if 1 as c_int == 0 {
            return levels_used;
        }
        if 6 as c_int == 0 || (*nodes_prev.offset(6)).score as int64_t >= 0 as int64_t {
            levels_used = trellis_coef(
                6 as c_int,
                1 as c_int,
                abs_level,
                prefix,
                suffix_cost,
                6 as c_int,
                0 as c_int,
                0 as c_int,
                if 6 as c_int != 0 { ssd1 } else { ssd0 },
                cost_siglast,
                nodes_cur,
                nodes_prev,
                level_tree,
                levels_used,
                lambda2,
                level_state,
            );
        } else if 1 as c_int == 0 {
            return levels_used;
        }
        if 7 as c_int == 0 || (*nodes_prev.offset(7)).score as int64_t >= 0 as int64_t {
            levels_used = trellis_coef(
                7 as c_int,
                1 as c_int,
                abs_level,
                prefix,
                suffix_cost,
                7 as c_int,
                0 as c_int,
                0 as c_int,
                if 7 as c_int != 0 { ssd1 } else { ssd0 },
                cost_siglast,
                nodes_cur,
                nodes_prev,
                level_tree,
                levels_used,
                lambda2,
                level_state,
            );
        } else if 1 as c_int == 0 {
            return levels_used;
        }
        return levels_used;
    }
    #[inline(never)]
    #[c2rust::src_loc = "608:1"]
    pub unsafe extern "C" fn trellis_coefn_0(
        mut abs_level: c_int,
        mut ssd0: uint64_t,
        mut ssd1: uint64_t,
        mut cost_siglast: *mut c_int,
        mut nodes_cur: *mut trellis_node_t,
        mut nodes_prev: *mut trellis_node_t,
        mut level_tree: *mut trellis_level_t,
        mut levels_used: c_int,
        mut lambda2: c_int,
        mut level_state: *mut uint8_t,
        mut levelgt1_ctx: c_int,
    ) -> c_int {
        let mut prefix: c_int = if (abs_level - 1 as c_int) < 14 as c_int {
            abs_level - 1 as c_int
        } else {
            14 as c_int
        };
        let mut suffix_cost: c_int = if abs_level >= 15 as c_int {
            bs_size_ue_big((abs_level - 15 as c_int) as c_uint) << CABAC_SIZE_BITS
        } else {
            0 as c_int
        };
        if 0 as c_int == 0 || (*nodes_prev.offset(0)).score as int64_t >= 0 as int64_t {
            levels_used = trellis_coef(
                0 as c_int,
                2 as c_int,
                abs_level,
                prefix,
                suffix_cost,
                4 as c_int,
                1 as c_int,
                5 as c_int,
                if 0 as c_int != 0 { ssd1 } else { ssd0 },
                cost_siglast,
                nodes_cur,
                nodes_prev,
                level_tree,
                levels_used,
                lambda2,
                level_state,
            );
        } else if 0 as c_int == 0 {
            return levels_used;
        }
        if 1 as c_int == 0 || (*nodes_prev.offset(1)).score as int64_t >= 0 as int64_t {
            levels_used = trellis_coef(
                1 as c_int,
                2 as c_int,
                abs_level,
                prefix,
                suffix_cost,
                4 as c_int,
                2 as c_int,
                5 as c_int,
                if 1 as c_int != 0 { ssd1 } else { ssd0 },
                cost_siglast,
                nodes_cur,
                nodes_prev,
                level_tree,
                levels_used,
                lambda2,
                level_state,
            );
        } else if 0 as c_int == 0 {
            return levels_used;
        }
        if 2 as c_int == 0 || (*nodes_prev.offset(2)).score as int64_t >= 0 as int64_t {
            levels_used = trellis_coef(
                2 as c_int,
                2 as c_int,
                abs_level,
                prefix,
                suffix_cost,
                4 as c_int,
                3 as c_int,
                5 as c_int,
                if 2 as c_int != 0 { ssd1 } else { ssd0 },
                cost_siglast,
                nodes_cur,
                nodes_prev,
                level_tree,
                levels_used,
                lambda2,
                level_state,
            );
        } else if 0 as c_int == 0 {
            return levels_used;
        }
        if 3 as c_int == 0 || (*nodes_prev.offset(3)).score as int64_t >= 0 as int64_t {
            levels_used = trellis_coef(
                3 as c_int,
                2 as c_int,
                abs_level,
                prefix,
                suffix_cost,
                4 as c_int,
                4 as c_int,
                5 as c_int,
                if 3 as c_int != 0 { ssd1 } else { ssd0 },
                cost_siglast,
                nodes_cur,
                nodes_prev,
                level_tree,
                levels_used,
                lambda2,
                level_state,
            );
        } else if 0 as c_int == 0 {
            return levels_used;
        }
        return levels_used;
    }
    #[inline(never)]
    #[c2rust::src_loc = "623:1"]
    pub unsafe extern "C" fn trellis_coefn_1(
        mut abs_level: c_int,
        mut ssd0: uint64_t,
        mut ssd1: uint64_t,
        mut cost_siglast: *mut c_int,
        mut nodes_cur: *mut trellis_node_t,
        mut nodes_prev: *mut trellis_node_t,
        mut level_tree: *mut trellis_level_t,
        mut levels_used: c_int,
        mut lambda2: c_int,
        mut level_state: *mut uint8_t,
        mut levelgt1_ctx: c_int,
    ) -> c_int {
        let mut prefix: c_int = if (abs_level - 1 as c_int) < 14 as c_int {
            abs_level - 1 as c_int
        } else {
            14 as c_int
        };
        let mut suffix_cost: c_int = if abs_level >= 15 as c_int {
            bs_size_ue_big((abs_level - 15 as c_int) as c_uint) << CABAC_SIZE_BITS
        } else {
            0 as c_int
        };
        if 1 as c_int == 0 || (*nodes_prev.offset(1)).score as int64_t >= 0 as int64_t {
            levels_used = trellis_coef(
                1 as c_int,
                2 as c_int,
                abs_level,
                prefix,
                suffix_cost,
                4 as c_int,
                2 as c_int,
                5 as c_int,
                if 1 as c_int != 0 { ssd1 } else { ssd0 },
                cost_siglast,
                nodes_cur,
                nodes_prev,
                level_tree,
                levels_used,
                lambda2,
                level_state,
            );
        } else if 1 as c_int == 0 {
            return levels_used;
        }
        if 2 as c_int == 0 || (*nodes_prev.offset(2)).score as int64_t >= 0 as int64_t {
            levels_used = trellis_coef(
                2 as c_int,
                2 as c_int,
                abs_level,
                prefix,
                suffix_cost,
                4 as c_int,
                3 as c_int,
                5 as c_int,
                if 2 as c_int != 0 { ssd1 } else { ssd0 },
                cost_siglast,
                nodes_cur,
                nodes_prev,
                level_tree,
                levels_used,
                lambda2,
                level_state,
            );
        } else if 1 as c_int == 0 {
            return levels_used;
        }
        if 3 as c_int == 0 || (*nodes_prev.offset(3)).score as int64_t >= 0 as int64_t {
            levels_used = trellis_coef(
                3 as c_int,
                2 as c_int,
                abs_level,
                prefix,
                suffix_cost,
                4 as c_int,
                4 as c_int,
                5 as c_int,
                if 3 as c_int != 0 { ssd1 } else { ssd0 },
                cost_siglast,
                nodes_cur,
                nodes_prev,
                level_tree,
                levels_used,
                lambda2,
                level_state,
            );
        } else if 1 as c_int == 0 {
            return levels_used;
        }
        if 4 as c_int == 0 || (*nodes_prev.offset(4)).score as int64_t >= 0 as int64_t {
            levels_used = trellis_coef(
                4 as c_int,
                2 as c_int,
                abs_level,
                prefix,
                suffix_cost,
                5 as c_int,
                0 as c_int,
                6 as c_int,
                if 4 as c_int != 0 { ssd1 } else { ssd0 },
                cost_siglast,
                nodes_cur,
                nodes_prev,
                level_tree,
                levels_used,
                lambda2,
                level_state,
            );
        } else if 1 as c_int == 0 {
            return levels_used;
        }
        if 5 as c_int == 0 || (*nodes_prev.offset(5)).score as int64_t >= 0 as int64_t {
            levels_used = trellis_coef(
                5 as c_int,
                2 as c_int,
                abs_level,
                prefix,
                suffix_cost,
                6 as c_int,
                0 as c_int,
                7 as c_int,
                if 5 as c_int != 0 { ssd1 } else { ssd0 },
                cost_siglast,
                nodes_cur,
                nodes_prev,
                level_tree,
                levels_used,
                lambda2,
                level_state,
            );
        } else if 1 as c_int == 0 {
            return levels_used;
        }
        if 6 as c_int == 0 || (*nodes_prev.offset(6)).score as int64_t >= 0 as int64_t {
            levels_used = trellis_coef(
                6 as c_int,
                2 as c_int,
                abs_level,
                prefix,
                suffix_cost,
                7 as c_int,
                0 as c_int,
                8 as c_int,
                if 6 as c_int != 0 { ssd1 } else { ssd0 },
                cost_siglast,
                nodes_cur,
                nodes_prev,
                level_tree,
                levels_used,
                lambda2,
                level_state,
            );
        } else if 1 as c_int == 0 {
            return levels_used;
        }
        if 7 as c_int == 0 || (*nodes_prev.offset(7)).score as int64_t >= 0 as int64_t {
            levels_used = trellis_coef(
                7 as c_int,
                2 as c_int,
                abs_level,
                prefix,
                suffix_cost,
                7 as c_int,
                0 as c_int,
                levelgt1_ctx,
                if 7 as c_int != 0 { ssd1 } else { ssd0 },
                cost_siglast,
                nodes_cur,
                nodes_prev,
                level_tree,
                levels_used,
                lambda2,
                level_state,
            );
        } else if 1 as c_int == 0 {
            return levels_used;
        }
        return levels_used;
    }
    #[inline(always)]
    #[c2rust::src_loc = "641:1"]
    pub unsafe extern "C" fn quant_trellis_cabac(
        mut h: *mut x264_t,
        mut dct: *mut dctcoef,
        mut quant_mf: *mut udctcoef,
        mut quant_bias: *mut udctcoef,
        mut unquant_mf: *const c_int,
        mut zigzag: *const uint8_t,
        mut ctx_block_cat: c_int,
        mut lambda2: c_int,
        mut b_ac: c_int,
        mut b_chroma: c_int,
        mut dc: c_int,
        mut num_coefs: c_int,
        mut idx: c_int,
    ) -> c_int {
        let mut current_block: u64;
        let mut orig_coefs: [dctcoef; 64] = [0; 64];
        let mut quant_coefs: [dctcoef; 64] = [0; 64];
        let mut coef_weight1: *const uint32_t = if num_coefs == 64 as c_int {
            x264_dct8_weight_tab.as_ptr()
        } else {
            x264_dct4_weight_tab.as_ptr()
        };
        let mut coef_weight2: *const uint32_t = if num_coefs == 64 as c_int {
            x264_dct8_weight2_tab.as_ptr()
        } else {
            x264_dct4_weight2_tab.as_ptr()
        };
        let b_interlaced: c_int = (*h).mb.b_interlaced;
        let mut cabac_state_sig: *mut uint8_t = &mut *(*h).cabac.state.as_mut_ptr().offset(
            *(*x264_significant_coeff_flag_offset
                .as_ptr()
                .offset(b_interlaced as isize))
            .as_ptr()
            .offset(ctx_block_cat as isize) as isize,
        ) as *mut uint8_t;
        let mut cabac_state_last: *mut uint8_t = &mut *(*h).cabac.state.as_mut_ptr().offset(
            *(*x264_last_coeff_flag_offset
                .as_ptr()
                .offset(b_interlaced as isize))
            .as_ptr()
            .offset(ctx_block_cat as isize) as isize,
        ) as *mut uint8_t;
        let mut levelgt1_ctx: c_int = if b_chroma != 0 && dc != 0 {
            8 as c_int
        } else {
            9 as c_int
        };
        if dc != 0 {
            if num_coefs == 16 as c_int {
                memcpy(
                    orig_coefs.as_mut_ptr() as *mut c_void,
                    dct as *const c_void,
                    (::core::mem::size_of::<dctcoef>() as size_t).wrapping_mul(16 as size_t),
                );
                if (*h).quantf.quant_4x4_dc.expect("non-null function pointer")(
                    dct as *mut dctcoef,
                    (*quant_mf.offset(0) >> 1 as c_int) as c_int,
                    (*quant_bias.offset(0) << 1 as c_int) as c_int,
                ) == 0
                {
                    return 0 as c_int;
                }
                (*h).zigzagf.scan_4x4.expect("non-null function pointer")(
                    quant_coefs.as_mut_ptr(),
                    dct as *mut dctcoef,
                );
            } else {
                memcpy(
                    orig_coefs.as_mut_ptr() as *mut c_void,
                    dct as *const c_void,
                    (::core::mem::size_of::<dctcoef>() as size_t).wrapping_mul(num_coefs as size_t),
                );
                let mut nz: c_int = (*h).quantf.quant_2x2_dc.expect("non-null function pointer")(
                    &mut *dct.offset(0),
                    (*quant_mf.offset(0) >> 1 as c_int) as c_int,
                    (*quant_bias.offset(0) << 1 as c_int) as c_int,
                );
                if num_coefs == 8 as c_int {
                    nz |= (*h).quantf.quant_2x2_dc.expect("non-null function pointer")(
                        &mut *dct.offset(4),
                        (*quant_mf.offset(0) >> 1 as c_int) as c_int,
                        (*quant_bias.offset(0) << 1 as c_int) as c_int,
                    );
                }
                if nz == 0 {
                    return 0 as c_int;
                }
                let mut i: c_int = 0 as c_int;
                while i < num_coefs {
                    quant_coefs[i as usize] = *dct.offset(*zigzag.offset(i as isize) as isize);
                    i += 1;
                }
            }
        } else if num_coefs == 64 as c_int {
            (*h).mc.memcpy_aligned.expect("non-null function pointer")(
                orig_coefs.as_mut_ptr() as *mut c_void,
                dct as *const c_void,
                (::core::mem::size_of::<dctcoef>() as size_t).wrapping_mul(64 as size_t),
            );
            if (*h).quantf.quant_8x8.expect("non-null function pointer")(
                dct as *mut dctcoef,
                quant_mf as *mut udctcoef,
                quant_bias as *mut udctcoef,
            ) == 0
            {
                return 0 as c_int;
            }
            (*h).zigzagf.scan_8x8.expect("non-null function pointer")(
                quant_coefs.as_mut_ptr(),
                dct as *mut dctcoef,
            );
        } else {
            memcpy(
                orig_coefs.as_mut_ptr() as *mut c_void,
                dct as *const c_void,
                (::core::mem::size_of::<dctcoef>() as size_t).wrapping_mul(16 as size_t),
            );
            if (*h).quantf.quant_4x4.expect("non-null function pointer")(
                dct as *mut dctcoef,
                quant_mf as *mut udctcoef,
                quant_bias as *mut udctcoef,
            ) == 0
            {
                return 0 as c_int;
            }
            (*h).zigzagf.scan_4x4.expect("non-null function pointer")(
                quant_coefs.as_mut_ptr(),
                dct as *mut dctcoef,
            );
        }
        let mut last_nnz: c_int = (*h).quantf.coeff_last[ctx_block_cat as usize]
            .expect("non-null function pointer")(
            quant_coefs.as_mut_ptr().offset(b_ac as isize)
        ) + b_ac;
        let mut cabac_state: *mut uint8_t = &mut *(*h).cabac.state.as_mut_ptr().offset(
            *x264_coeff_abs_level_m1_offset
                .as_ptr()
                .offset(ctx_block_cat as isize) as isize,
        ) as *mut uint8_t;
        if last_nnz == 0 as c_int && dc == 0 {
            let mut cost_sig: c_int =
                x264_cabac_size_decision_noup2(&mut *cabac_state_sig.offset(0), 1 as c_long)
                    + x264_cabac_size_decision_noup2(&mut *cabac_state_last.offset(0), 1 as c_long);
            *dct.offset(0) = trellis_dc_shortcut(
                orig_coefs[0],
                quant_coefs[0],
                *unquant_mf.offset(0),
                *coef_weight2.offset(0) as c_int,
                lambda2,
                cabac_state,
                cost_sig,
            ) as dctcoef;
            return (*dct.offset(0) != 0) as c_int;
        }
        let mut level_tree: [trellis_level_t; 1024] = [trellis_level_t {
            next: 0,
            abs_level: 0,
        }; 1024];
        let mut levels_used: c_int = 1 as c_int;
        let mut nodes: [[trellis_node_t; 8]; 2] = [
            [
                {
                    let mut init = trellis_node_t {
                        score: 0 as uint64_t,
                        level_idx: 0,
                        cabac_state: [0; 4],
                    };
                    init
                },
                trellis_node_t {
                    score: 0,
                    level_idx: 0,
                    cabac_state: [0; 4],
                },
                trellis_node_t {
                    score: 0,
                    level_idx: 0,
                    cabac_state: [0; 4],
                },
                trellis_node_t {
                    score: 0,
                    level_idx: 0,
                    cabac_state: [0; 4],
                },
                trellis_node_t {
                    score: 0,
                    level_idx: 0,
                    cabac_state: [0; 4],
                },
                trellis_node_t {
                    score: 0,
                    level_idx: 0,
                    cabac_state: [0; 4],
                },
                trellis_node_t {
                    score: 0,
                    level_idx: 0,
                    cabac_state: [0; 4],
                },
                trellis_node_t {
                    score: 0,
                    level_idx: 0,
                    cabac_state: [0; 4],
                },
            ],
            [trellis_node_t {
                score: 0,
                level_idx: 0,
                cabac_state: [0; 4],
            }; 8],
        ];
        let mut nodes_cur: *mut trellis_node_t = (*nodes.as_mut_ptr().offset(0)).as_mut_ptr();
        let mut nodes_prev: *mut trellis_node_t = (*nodes.as_mut_ptr().offset(1)).as_mut_ptr();
        let mut bnode: *mut trellis_node_t = 0 as *mut trellis_node_t;
        let mut j: c_int = 1 as c_int;
        while j < 8 as c_int {
            (*nodes_cur.offset(j as isize)).score = TRELLIS_SCORE_MAX as uint64_t;
            j += 1;
        }
        (*nodes_cur.offset(0)).score = TRELLIS_SCORE_BIAS as uint64_t;
        (*nodes_cur.offset(0)).level_idx = 0 as c_int;
        level_tree[0].abs_level = 0 as uint16_t;
        level_tree[0].next = 0 as uint16_t;
        let mut level_state: [uint8_t; 16] = [0; 16];
        memcpy(
            level_state.as_mut_ptr() as *mut c_void,
            cabac_state as *const c_void,
            10 as size_t,
        );
        level_state[12] = *cabac_state.offset(0);
        level_state[13] = *cabac_state.offset(4);
        level_state[14] = *cabac_state.offset(8);
        level_state[15] = *cabac_state.offset(9 as c_int as isize);
        idx &= if num_coefs == 64 as c_int {
            3 as c_int
        } else {
            15 as c_int
        };
        let mut i_0: c_int = last_nnz;
        loop {
            if !(i_0 >= b_ac) {
                current_block = 10369920510435091891;
                break;
            }
            if quant_coefs[i_0 as usize] == 0 {
                if 0 as c_int == 0 {
                    let mut sigindex: c_int = if dc == 0 && num_coefs == 64 as c_int {
                        x264_significant_coeff_flag_offset_8x8[b_interlaced as usize][i_0 as usize]
                            as c_int
                    } else if b_chroma != 0 && dc != 0 && num_coefs == 8 as c_int {
                        x264_coeff_flag_offset_chroma_422_dc[i_0 as usize] as c_int
                    } else {
                        i_0
                    };
                    let mut cost_sig0: uint64_t = (x264_cabac_size_decision_noup2(
                        &mut *cabac_state_sig.offset(sigindex as isize),
                        0 as c_long,
                    ) as uint64_t)
                        .wrapping_mul(lambda2 as uint64_t)
                        >> CABAC_SIZE_BITS - LAMBDA_BITS;
                    let ref mut fresh0 = (*nodes_cur.offset(0)).score;
                    *fresh0 = (*fresh0).wrapping_sub(cost_sig0);
                }
                let mut j_0: c_int = 1 as c_int;
                while j_0
                    < (if 0 as c_int != 0 {
                        8 as c_int
                    } else {
                        4 as c_int
                    })
                {
                    if ::core::mem::size_of::<trellis_level_t>() as usize
                        == ::core::mem::size_of::<uint32_t>() as usize
                    {
                        (*(&mut *level_tree.as_mut_ptr().offset(levels_used as isize)
                            as *mut trellis_level_t
                            as *mut x264_union32_t))
                            .i = pack16to32(
                            (*nodes_cur.offset(j_0 as isize)).level_idx as uint32_t,
                            0 as uint32_t,
                        );
                    } else {
                        level_tree[levels_used as usize] = {
                            let mut init = trellis_level_t {
                                next: (*nodes_cur.offset(j_0 as isize)).level_idx as uint16_t,
                                abs_level: 0 as uint16_t,
                            };
                            init
                        };
                    }
                    (*nodes_cur.offset(j_0 as isize)).level_idx = levels_used;
                    levels_used += 1;
                    j_0 += 1;
                }
            } else {
                let mut sign_coef: c_int = orig_coefs[*zigzag.offset(i_0 as isize) as usize];
                let mut abs_coef: c_int = abs(sign_coef);
                let mut q: c_int = abs(quant_coefs[i_0 as usize]);
                let mut cost_siglast: [c_int; 3] = [0; 3];
                let mut t: *mut trellis_node_t = nodes_cur;
                nodes_cur = nodes_prev;
                nodes_prev = t;
                let mut j_1: c_int = 0 as c_int;
                while j_1 < 8 as c_int {
                    (*nodes_cur.offset(j_1 as isize)).score = TRELLIS_SCORE_MAX as uint64_t;
                    j_1 += 1;
                }
                if i_0 < num_coefs - 1 as c_int || 0 as c_int != 0 {
                    let mut sigindex_0: c_int = if dc == 0 && num_coefs == 64 as c_int {
                        x264_significant_coeff_flag_offset_8x8[b_interlaced as usize][i_0 as usize]
                            as c_int
                    } else if b_chroma != 0 && dc != 0 && num_coefs == 8 as c_int {
                        x264_coeff_flag_offset_chroma_422_dc[i_0 as usize] as c_int
                    } else {
                        i_0
                    };
                    let mut lastindex: c_int = if dc == 0 && num_coefs == 64 as c_int {
                        x264_last_coeff_flag_offset_8x8[i_0 as usize] as c_int
                    } else if b_chroma != 0 && dc != 0 && num_coefs == 8 as c_int {
                        x264_coeff_flag_offset_chroma_422_dc[i_0 as usize] as c_int
                    } else {
                        i_0
                    };
                    cost_siglast[0] = x264_cabac_size_decision_noup2(
                        &mut *cabac_state_sig.offset(sigindex_0 as isize),
                        0 as c_long,
                    );
                    let mut cost_sig1: c_int = x264_cabac_size_decision_noup2(
                        &mut *cabac_state_sig.offset(sigindex_0 as isize),
                        1 as c_long,
                    );
                    cost_siglast[1] = x264_cabac_size_decision_noup2(
                        &mut *cabac_state_last.offset(lastindex as isize),
                        0 as c_long,
                    ) + cost_sig1;
                    if 0 as c_int == 0 {
                        cost_siglast[2] = x264_cabac_size_decision_noup2(
                            &mut *cabac_state_last.offset(lastindex as isize),
                            1 as c_long,
                        ) + cost_sig1;
                    }
                } else {
                    cost_siglast[2] = 0 as c_int;
                    cost_siglast[1] = cost_siglast[2];
                    cost_siglast[0] = cost_siglast[1];
                }
                let mut ssd0: [uint64_t; 2] = [0; 2];
                let mut ssd1: [uint64_t; 2] = [0; 2];
                let mut k: c_int = 0 as c_int;
                while k < 2 as c_int {
                    let mut abs_level: c_int = q - 1 as c_int + k;
                    let mut unquant_abs_level: c_int = (if dc != 0 {
                        *unquant_mf.offset(0) << 1 as c_int
                    } else {
                        *unquant_mf.offset(*zigzag.offset(i_0 as isize) as isize)
                    }) * abs_level
                        + 128 as c_int
                        >> 8 as c_int;
                    let mut d: c_int = abs_coef - unquant_abs_level;
                    if (*h).mb.i_psy_trellis != 0 && i_0 != 0 && dc == 0 && b_chroma == 0 {
                        let mut orig_coef: c_int = if num_coefs == 64 as c_int {
                            (*h).mb.pic.fenc_dct8[idx as usize]
                                [*zigzag.offset(i_0 as isize) as usize]
                        } else {
                            (*h).mb.pic.fenc_dct4[idx as usize]
                                [*zigzag.offset(i_0 as isize) as usize]
                        };
                        let mut predicted_coef: c_int = orig_coef - sign_coef;
                        let mut psy_value: c_int = abs(unquant_abs_level
                            + ((predicted_coef ^ sign_coef >> 31 as c_int)
                                - (sign_coef >> 31 as c_int)));
                        let mut psy_weight: c_int = (*coef_weight1
                            .offset(*zigzag.offset(i_0 as isize) as isize))
                        .wrapping_mul((*h).mb.i_psy_trellis as uint32_t)
                            as c_int;
                        let mut tmp: int64_t = d as int64_t
                            * d as int64_t
                            * *coef_weight2.offset(*zigzag.offset(i_0 as isize) as isize)
                                as int64_t
                            - psy_weight as int64_t * psy_value as int64_t;
                        ssd1[k as usize] = tmp as uint64_t;
                    } else {
                        ssd1[k as usize] = (d as int64_t
                            * d as int64_t
                            * (if dc != 0 {
                                256 as uint32_t
                            } else {
                                *coef_weight2.offset(*zigzag.offset(i_0 as isize) as isize)
                            }) as int64_t) as uint64_t;
                    }
                    ssd0[k as usize] = ssd1[k as usize];
                    if i_0 == 0 && dc == 0 && 0 as c_int == 0 {
                        d = sign_coef
                            - ((unquant_abs_level ^ sign_coef >> 31 as c_int)
                                - (sign_coef >> 31 as c_int)
                                + 8 as c_int
                                & !(15 as c_int));
                        ssd0[k as usize] = (d as int64_t
                            * d as int64_t
                            * *coef_weight2.offset(*zigzag.offset(i_0 as isize) as isize)
                                as int64_t) as uint64_t;
                    }
                    k += 1;
                }
                match q {
                    1 => {
                        ssd1[0] = ssd1[0].wrapping_add(
                            (cost_siglast[0] as uint64_t).wrapping_mul(lambda2 as uint64_t)
                                >> CABAC_SIZE_BITS - LAMBDA_BITS,
                        );
                        levels_used = trellis_coef0_0(
                            ssd0[0].wrapping_sub(ssd1[0]),
                            nodes_cur,
                            nodes_prev,
                            level_tree.as_mut_ptr(),
                            levels_used,
                        );
                        levels_used = trellis_coef1_0(
                            ssd0[1].wrapping_sub(ssd1[0]),
                            ssd1[1].wrapping_sub(ssd1[0]),
                            cost_siglast.as_mut_ptr(),
                            nodes_cur,
                            nodes_prev,
                            level_tree.as_mut_ptr(),
                            levels_used,
                            lambda2,
                            level_state.as_mut_ptr(),
                        );
                    }
                    2 => {
                        levels_used = trellis_coef1_0(
                            ssd0[0],
                            ssd1[0],
                            cost_siglast.as_mut_ptr(),
                            nodes_cur,
                            nodes_prev,
                            level_tree.as_mut_ptr(),
                            levels_used,
                            lambda2,
                            level_state.as_mut_ptr(),
                        );
                        levels_used = trellis_coefn_0(
                            q,
                            ssd0[1],
                            ssd1[1],
                            cost_siglast.as_mut_ptr(),
                            nodes_cur,
                            nodes_prev,
                            level_tree.as_mut_ptr(),
                            levels_used,
                            lambda2,
                            level_state.as_mut_ptr(),
                            levelgt1_ctx,
                        );
                        current_block = 15622658527355336244;
                        break;
                    }
                    _ => {
                        levels_used = trellis_coefn_0(
                            q - 1 as c_int,
                            ssd0[0],
                            ssd1[0],
                            cost_siglast.as_mut_ptr(),
                            nodes_cur,
                            nodes_prev,
                            level_tree.as_mut_ptr(),
                            levels_used,
                            lambda2,
                            level_state.as_mut_ptr(),
                            levelgt1_ctx,
                        );
                        levels_used = trellis_coefn_0(
                            q,
                            ssd0[1],
                            ssd1[1],
                            cost_siglast.as_mut_ptr(),
                            nodes_cur,
                            nodes_prev,
                            level_tree.as_mut_ptr(),
                            levels_used,
                            lambda2,
                            level_state.as_mut_ptr(),
                            levelgt1_ctx,
                        );
                        current_block = 15622658527355336244;
                        break;
                    }
                }
            }
            i_0 -= 1;
        }
        match current_block {
            15622658527355336244 => {
                loop {
                    i_0 -= 1;
                    if !(i_0 >= b_ac) {
                        break;
                    }
                    if quant_coefs[i_0 as usize] == 0 {
                        if 1 as c_int == 0 {
                            let mut sigindex_1: c_int = if dc == 0 && num_coefs == 64 as c_int {
                                x264_significant_coeff_flag_offset_8x8[b_interlaced as usize]
                                    [i_0 as usize] as c_int
                            } else if b_chroma != 0 && dc != 0 && num_coefs == 8 as c_int {
                                x264_coeff_flag_offset_chroma_422_dc[i_0 as usize] as c_int
                            } else {
                                i_0
                            };
                            let mut cost_sig0_0: uint64_t = (x264_cabac_size_decision_noup2(
                                &mut *cabac_state_sig.offset(sigindex_1 as isize),
                                0 as c_long,
                            )
                                as uint64_t)
                                .wrapping_mul(lambda2 as uint64_t)
                                >> CABAC_SIZE_BITS - LAMBDA_BITS;
                            let ref mut fresh1 = (*nodes_cur.offset(0)).score;
                            *fresh1 = (*fresh1).wrapping_sub(cost_sig0_0);
                        }
                        let mut j_3: c_int = 1 as c_int;
                        while j_3
                            < (if 1 as c_int != 0 {
                                8 as c_int
                            } else {
                                4 as c_int
                            })
                        {
                            if ::core::mem::size_of::<trellis_level_t>() as usize
                                == ::core::mem::size_of::<uint32_t>() as usize
                            {
                                (*(&mut *level_tree.as_mut_ptr().offset(levels_used as isize)
                                    as *mut trellis_level_t
                                    as *mut x264_union32_t))
                                    .i = pack16to32(
                                    (*nodes_cur.offset(j_3 as isize)).level_idx as uint32_t,
                                    0 as uint32_t,
                                );
                            } else {
                                level_tree[levels_used as usize] = {
                                    let mut init = trellis_level_t {
                                        next: (*nodes_cur.offset(j_3 as isize)).level_idx
                                            as uint16_t,
                                        abs_level: 0 as uint16_t,
                                    };
                                    init
                                };
                            }
                            (*nodes_cur.offset(j_3 as isize)).level_idx = levels_used;
                            levels_used += 1;
                            j_3 += 1;
                        }
                    } else {
                        let mut sign_coef_0: c_int =
                            orig_coefs[*zigzag.offset(i_0 as isize) as usize];
                        let mut abs_coef_0: c_int = abs(sign_coef_0);
                        let mut q_0: c_int = abs(quant_coefs[i_0 as usize]);
                        let mut cost_siglast_0: [c_int; 3] = [0; 3];
                        let mut t_0: *mut trellis_node_t = nodes_cur;
                        nodes_cur = nodes_prev;
                        nodes_prev = t_0;
                        let mut j_4: c_int = 1 as c_int;
                        while j_4 < 8 as c_int {
                            (*nodes_cur.offset(j_4 as isize)).score = TRELLIS_SCORE_MAX as uint64_t;
                            j_4 += 1;
                        }
                        if i_0 < num_coefs - 1 as c_int || 1 as c_int != 0 {
                            let mut sigindex_2: c_int = if dc == 0 && num_coefs == 64 as c_int {
                                x264_significant_coeff_flag_offset_8x8[b_interlaced as usize]
                                    [i_0 as usize] as c_int
                            } else if b_chroma != 0 && dc != 0 && num_coefs == 8 as c_int {
                                x264_coeff_flag_offset_chroma_422_dc[i_0 as usize] as c_int
                            } else {
                                i_0
                            };
                            let mut lastindex_0: c_int = if dc == 0 && num_coefs == 64 as c_int {
                                x264_last_coeff_flag_offset_8x8[i_0 as usize] as c_int
                            } else if b_chroma != 0 && dc != 0 && num_coefs == 8 as c_int {
                                x264_coeff_flag_offset_chroma_422_dc[i_0 as usize] as c_int
                            } else {
                                i_0
                            };
                            cost_siglast_0[0] = x264_cabac_size_decision_noup2(
                                &mut *cabac_state_sig.offset(sigindex_2 as isize),
                                0 as c_long,
                            );
                            let mut cost_sig1_0: c_int = x264_cabac_size_decision_noup2(
                                &mut *cabac_state_sig.offset(sigindex_2 as isize),
                                1 as c_long,
                            );
                            cost_siglast_0[1] = x264_cabac_size_decision_noup2(
                                &mut *cabac_state_last.offset(lastindex_0 as isize),
                                0 as c_long,
                            ) + cost_sig1_0;
                            if 1 as c_int == 0 {
                                cost_siglast_0[2] = x264_cabac_size_decision_noup2(
                                    &mut *cabac_state_last.offset(lastindex_0 as isize),
                                    1 as c_long,
                                ) + cost_sig1_0;
                            }
                        } else {
                            cost_siglast_0[2] = 0 as c_int;
                            cost_siglast_0[1] = cost_siglast_0[2];
                            cost_siglast_0[0] = cost_siglast_0[1];
                        }
                        let mut ssd0_0: [uint64_t; 2] = [0; 2];
                        let mut ssd1_0: [uint64_t; 2] = [0; 2];
                        let mut k_0: c_int = 0 as c_int;
                        while k_0 < 2 as c_int {
                            let mut abs_level_0: c_int = q_0 - 1 as c_int + k_0;
                            let mut unquant_abs_level_0: c_int = (if dc != 0 {
                                *unquant_mf.offset(0) << 1 as c_int
                            } else {
                                *unquant_mf.offset(*zigzag.offset(i_0 as isize) as isize)
                            }) * abs_level_0
                                + 128 as c_int
                                >> 8 as c_int;
                            let mut d_0: c_int = abs_coef_0 - unquant_abs_level_0;
                            if (*h).mb.i_psy_trellis != 0 && i_0 != 0 && dc == 0 && b_chroma == 0 {
                                let mut orig_coef_0: c_int = if num_coefs == 64 as c_int {
                                    (*h).mb.pic.fenc_dct8[idx as usize]
                                        [*zigzag.offset(i_0 as isize) as usize]
                                } else {
                                    (*h).mb.pic.fenc_dct4[idx as usize]
                                        [*zigzag.offset(i_0 as isize) as usize]
                                };
                                let mut predicted_coef_0: c_int = orig_coef_0 - sign_coef_0;
                                let mut psy_value_0: c_int = abs(unquant_abs_level_0
                                    + ((predicted_coef_0 ^ sign_coef_0 >> 31 as c_int)
                                        - (sign_coef_0 >> 31 as c_int)));
                                let mut psy_weight_0: c_int = (*coef_weight1
                                    .offset(*zigzag.offset(i_0 as isize) as isize))
                                .wrapping_mul((*h).mb.i_psy_trellis as uint32_t)
                                    as c_int;
                                let mut tmp_0: int64_t = d_0 as int64_t
                                    * d_0 as int64_t
                                    * *coef_weight2.offset(*zigzag.offset(i_0 as isize) as isize)
                                        as int64_t
                                    - psy_weight_0 as int64_t * psy_value_0 as int64_t;
                                ssd1_0[k_0 as usize] = tmp_0 as uint64_t;
                            } else {
                                ssd1_0[k_0 as usize] = (d_0 as int64_t
                                    * d_0 as int64_t
                                    * (if dc != 0 {
                                        256 as uint32_t
                                    } else {
                                        *coef_weight2.offset(*zigzag.offset(i_0 as isize) as isize)
                                    }) as int64_t)
                                    as uint64_t;
                            }
                            ssd0_0[k_0 as usize] = ssd1_0[k_0 as usize];
                            if i_0 == 0 && dc == 0 && 1 as c_int == 0 {
                                d_0 = sign_coef_0
                                    - ((unquant_abs_level_0 ^ sign_coef_0 >> 31 as c_int)
                                        - (sign_coef_0 >> 31 as c_int)
                                        + 8 as c_int
                                        & !(15 as c_int));
                                ssd0_0[k_0 as usize] = (d_0 as int64_t
                                    * d_0 as int64_t
                                    * *coef_weight2.offset(*zigzag.offset(i_0 as isize) as isize)
                                        as int64_t)
                                    as uint64_t;
                            }
                            k_0 += 1;
                        }
                        match q_0 {
                            1 => {
                                ssd1_0[0] = ssd1_0[0].wrapping_add(
                                    (cost_siglast_0[0] as uint64_t)
                                        .wrapping_mul(lambda2 as uint64_t)
                                        >> CABAC_SIZE_BITS - LAMBDA_BITS,
                                );
                                levels_used = trellis_coef0_1(
                                    ssd0_0[0].wrapping_sub(ssd1_0[0]),
                                    nodes_cur,
                                    nodes_prev,
                                    level_tree.as_mut_ptr(),
                                    levels_used,
                                );
                                levels_used = trellis_coef1_1(
                                    ssd0_0[1].wrapping_sub(ssd1_0[0]),
                                    ssd1_0[1].wrapping_sub(ssd1_0[0]),
                                    cost_siglast_0.as_mut_ptr(),
                                    nodes_cur,
                                    nodes_prev,
                                    level_tree.as_mut_ptr(),
                                    levels_used,
                                    lambda2,
                                    level_state.as_mut_ptr(),
                                );
                            }
                            2 => {
                                levels_used = trellis_coef1_1(
                                    ssd0_0[0],
                                    ssd1_0[0],
                                    cost_siglast_0.as_mut_ptr(),
                                    nodes_cur,
                                    nodes_prev,
                                    level_tree.as_mut_ptr(),
                                    levels_used,
                                    lambda2,
                                    level_state.as_mut_ptr(),
                                );
                                levels_used = trellis_coefn_1(
                                    q_0,
                                    ssd0_0[1],
                                    ssd1_0[1],
                                    cost_siglast_0.as_mut_ptr(),
                                    nodes_cur,
                                    nodes_prev,
                                    level_tree.as_mut_ptr(),
                                    levels_used,
                                    lambda2,
                                    level_state.as_mut_ptr(),
                                    levelgt1_ctx,
                                );
                            }
                            _ => {
                                levels_used = trellis_coefn_1(
                                    q_0 - 1 as c_int,
                                    ssd0_0[0],
                                    ssd1_0[0],
                                    cost_siglast_0.as_mut_ptr(),
                                    nodes_cur,
                                    nodes_prev,
                                    level_tree.as_mut_ptr(),
                                    levels_used,
                                    lambda2,
                                    level_state.as_mut_ptr(),
                                    levelgt1_ctx,
                                );
                                levels_used = trellis_coefn_1(
                                    q_0,
                                    ssd0_0[1],
                                    ssd1_0[1],
                                    cost_siglast_0.as_mut_ptr(),
                                    nodes_cur,
                                    nodes_prev,
                                    level_tree.as_mut_ptr(),
                                    levels_used,
                                    lambda2,
                                    level_state.as_mut_ptr(),
                                    levelgt1_ctx,
                                );
                            }
                        }
                    }
                }
                bnode = &mut *nodes_cur.offset(1) as *mut trellis_node_t;
                let mut j_5: c_int = 1 as c_int + 1 as c_int;
                while j_5
                    < (if 1 as c_int != 0 {
                        8 as c_int
                    } else {
                        4 as c_int
                    })
                {
                    if (*nodes_cur.offset(j_5 as isize)).score < (*bnode).score {
                        bnode = &mut *nodes_cur.offset(j_5 as isize) as *mut trellis_node_t;
                    }
                    j_5 += 1;
                }
            }
            _ => {
                bnode = &mut *nodes_cur.offset(0) as *mut trellis_node_t;
                let mut j_2: c_int = 0 as c_int + 1 as c_int;
                while j_2
                    < (if 0 as c_int != 0 {
                        8 as c_int
                    } else {
                        4 as c_int
                    })
                {
                    if (*nodes_cur.offset(j_2 as isize)).score < (*bnode).score {
                        bnode = &mut *nodes_cur.offset(j_2 as isize) as *mut trellis_node_t;
                    }
                    j_2 += 1;
                }
                if bnode == &mut *nodes_cur.offset(0) as *mut trellis_node_t {
                    if num_coefs == 16 as c_int && dc == 0 {
                        memset(
                            dct as *mut c_void,
                            0 as c_int,
                            (16 as size_t)
                                .wrapping_mul(::core::mem::size_of::<dctcoef>() as size_t),
                        );
                    }
                    return 0 as c_int;
                }
            }
        }
        let mut level: c_int = (*bnode).level_idx;
        i_0 = b_ac;
        while i_0 <= last_nnz {
            *dct.offset(*zigzag.offset(i_0 as isize) as isize) =
                (level_tree[level as usize].abs_level as dctcoef
                    ^ *dct.offset(*zigzag.offset(i_0 as isize) as isize) >> 31 as c_int)
                    - (*dct.offset(*zigzag.offset(i_0 as isize) as isize) >> 31 as c_int);
            level = level_tree[level as usize].next as c_int;
            i_0 += 1;
        }
        return 1 as c_int;
    }
    #[inline(always)]
    #[c2rust::src_loc = "920:1"]
    pub unsafe extern "C" fn quant_trellis_cavlc(
        mut h: *mut x264_t,
        mut dct: *mut dctcoef,
        mut quant_mf: *const udctcoef,
        mut unquant_mf: *const c_int,
        mut zigzag: *const uint8_t,
        mut ctx_block_cat: c_int,
        mut lambda2: c_int,
        mut b_ac: c_int,
        mut b_chroma: c_int,
        mut dc: c_int,
        mut num_coefs: c_int,
        mut idx: c_int,
        mut b_8x8: c_int,
    ) -> c_int {
        let mut last_nnz: c_int = 0;
        let mut coef_mask: c_int = 0;
        let mut round_mask: c_int = 0;
        let mut quant_coefs: [[dctcoef; 16]; 2] = [[0; 16]; 2];
        let mut coefs: [dctcoef; 16] = [0; 16];
        let mut coef_weight1: *const uint32_t = if b_8x8 != 0 {
            x264_dct8_weight_tab.as_ptr()
        } else {
            x264_dct4_weight_tab.as_ptr()
        };
        let mut coef_weight2: *const uint32_t = if b_8x8 != 0 {
            x264_dct8_weight2_tab.as_ptr()
        } else {
            x264_dct4_weight2_tab.as_ptr()
        };
        let mut delta_distortion: [int64_t; 16] = [0; 16];
        let mut score: int64_t = ((1 as c_ulonglong) << 62 as c_int) as int64_t;
        let mut i: c_int = 0;
        let mut j: c_int = 0;
        let f: c_int = (1 as c_int) << 15 as c_int;
        let mut nC: c_int = if b_chroma != 0 && dc != 0 {
            3 as c_int + (num_coefs >> 2 as c_int)
        } else {
            ct_index[x264_mb_predict_non_zero_code(
                h,
                if b_chroma == 0 && dc != 0 {
                    (idx - LUMA_DC) * 16 as c_int
                } else {
                    idx
                },
            ) as usize] as c_int
        };
        i = 0 as c_int;
        while i < 16 as c_int {
            (*(&mut *coefs.as_mut_ptr().offset(i as isize) as *mut dctcoef
                as *mut x264_union128_sse_t))
                .i = M128_ZERO;
            i = (i as c_ulong).wrapping_add(
                (16 as usize).wrapping_div(::core::mem::size_of::<dctcoef>() as usize) as c_ulong,
            ) as c_int as c_int;
        }
        let mut step: c_int = 1 as c_int;
        let mut start: c_int = b_ac;
        let mut end: c_int = num_coefs - 1 as c_int;
        if b_8x8 != 0 {
            start = idx & 3 as c_int;
            end = 60 as c_int + start;
            step = 4 as c_int;
        }
        idx &= 15 as c_int;
        lambda2 <<= LAMBDA_BITS;
        i = end;
        while i >= start {
            if (abs(*dct.offset(*zigzag.offset(i as isize) as isize)) as udctcoef).wrapping_mul(
                (if dc != 0 {
                    *quant_mf.offset(0) >> 1 as c_int
                } else {
                    *quant_mf.offset(*zigzag.offset(i as isize) as isize)
                }),
            ) >= f as udctcoef
            {
                break;
            }
            i -= step;
        }
        if !(i < start) {
            last_nnz = if b_8x8 != 0 { i >> 2 as c_int } else { i };
            coef_mask = 0 as c_int;
            round_mask = 0 as c_int;
            i = b_ac;
            j = start;
            while i <= last_nnz {
                let mut coef: c_int = *dct.offset(*zigzag.offset(j as isize) as isize);
                let mut abs_coef: c_int = abs(coef);
                let mut sign: c_int = if coef < 0 as c_int { -1 } else { 1 as c_int };
                let mut nearest_quant: c_int =
                    ((f as udctcoef).wrapping_add((abs_coef as udctcoef).wrapping_mul(
                        (if dc != 0 {
                            *quant_mf.offset(0) >> 1 as c_int
                        } else {
                            *quant_mf.offset(*zigzag.offset(j as isize) as isize)
                        }),
                    )) >> 16 as c_int) as c_int;
                quant_coefs[0][i as usize] = (sign * nearest_quant) as dctcoef;
                quant_coefs[1][i as usize] = quant_coefs[0][i as usize];
                coefs[i as usize] = quant_coefs[1][i as usize];
                if nearest_quant != 0 {
                    let mut deadzone_quant: c_int = (((f / 2 as c_int) as udctcoef).wrapping_add(
                        (abs_coef as udctcoef).wrapping_mul(
                            (if dc != 0 {
                                *quant_mf.offset(0) >> 1 as c_int
                            } else {
                                *quant_mf.offset(*zigzag.offset(j as isize) as isize)
                            }),
                        ),
                    ) >> 16 as c_int) as c_int;
                    let mut unquant1: c_int = (if dc != 0 {
                        *unquant_mf.offset(0) << 1 as c_int
                    } else {
                        *unquant_mf.offset(*zigzag.offset(j as isize) as isize)
                    }) * (nearest_quant - 0 as c_int)
                        + 128 as c_int
                        >> 8 as c_int;
                    let mut unquant0: c_int = (if dc != 0 {
                        *unquant_mf.offset(0) << 1 as c_int
                    } else {
                        *unquant_mf.offset(*zigzag.offset(j as isize) as isize)
                    }) * (nearest_quant - 1 as c_int)
                        + 128 as c_int
                        >> 8 as c_int;
                    let mut d1: c_int = abs_coef - unquant1;
                    let mut d0: c_int = abs_coef - unquant0;
                    delta_distortion[i as usize] = (d0 * d0 - d1 * d1) as int64_t
                        * (if dc != 0 {
                            256 as uint32_t
                        } else {
                            *coef_weight2.offset(*zigzag.offset(j as isize) as isize)
                        }) as int64_t;
                    if (*h).mb.i_psy_trellis != 0 && j != 0 && dc == 0 && b_chroma == 0 {
                        let mut orig_coef: c_int = if b_8x8 != 0 {
                            (*h).mb.pic.fenc_dct8[(idx >> 2 as c_int) as usize]
                                [*zigzag.offset(j as isize) as usize]
                        } else {
                            (*h).mb.pic.fenc_dct4[idx as usize][*zigzag.offset(j as isize) as usize]
                        };
                        let mut predicted_coef: c_int = orig_coef - coef;
                        let mut psy_weight: c_int =
                            *coef_weight1.offset(*zigzag.offset(j as isize) as isize) as c_int;
                        let mut psy_value0: c_int =
                            (*h).mb.i_psy_trellis * abs(predicted_coef + unquant0 * sign);
                        let mut psy_value1: c_int =
                            (*h).mb.i_psy_trellis * abs(predicted_coef + unquant1 * sign);
                        delta_distortion[i as usize] +=
                            ((psy_value0 - psy_value1) * psy_weight) as int64_t;
                    }
                    quant_coefs[0][i as usize] = (sign * (nearest_quant - 1 as c_int)) as dctcoef;
                    if deadzone_quant != nearest_quant {
                        coefs[i as usize] = quant_coefs[0][i as usize];
                    } else {
                        round_mask |= (1 as c_int) << i;
                    }
                } else {
                    delta_distortion[i as usize] = 0 as int64_t;
                }
                coef_mask |= ((coefs[i as usize] != 0) as c_int) << i;
                i += 1;
                j += step;
            }
            (*h).out.bs.i_bits_encoded = 0 as c_int;
            if coef_mask == 0 {
                (*h).out.bs.i_bits_encoded += x264_coeff0_token[nC as usize].i_size as c_int;
            } else {
                cavlc_block_residual_internal(
                    h,
                    ctx_block_cat,
                    coefs.as_mut_ptr().offset(b_ac as isize),
                    nC,
                );
            }
            score = (*h).out.bs.i_bits_encoded as int64_t * lambda2 as int64_t;
            loop {
                let mut iter_score: int64_t = score;
                let mut iter_distortion_delta: int64_t = 0 as int64_t;
                let mut iter_coef: c_int = -1;
                let mut iter_mask: c_int = coef_mask;
                let mut iter_round: c_int = round_mask;
                i = b_ac;
                while i <= last_nnz {
                    if !(delta_distortion[i as usize] == 0) {
                        let mut cur_round: c_int = round_mask ^ (1 as c_int) << i;
                        let mut round_change: c_int = cur_round >> i & 1 as c_int;
                        let mut old_coef: c_int = coefs[i as usize];
                        let mut new_coef: c_int = quant_coefs[round_change as usize][i as usize];
                        let mut cur_mask: c_int =
                            coef_mask & !((1 as c_int) << i) | ((new_coef != 0) as c_int) << i;
                        let mut cur_distortion_delta: int64_t = delta_distortion[i as usize]
                            * (if round_change != 0 { -1 } else { 1 as c_int }) as int64_t;
                        let mut cur_score: int64_t = cur_distortion_delta;
                        coefs[i as usize] = new_coef as dctcoef;
                        (*h).out.bs.i_bits_encoded = 0 as c_int;
                        if cur_mask == 0 {
                            (*h).out.bs.i_bits_encoded +=
                                x264_coeff0_token[nC as usize].i_size as c_int;
                        } else {
                            cavlc_block_residual_internal(
                                h,
                                ctx_block_cat,
                                coefs.as_mut_ptr().offset(b_ac as isize),
                                nC,
                            );
                        }
                        cur_score += (*h).out.bs.i_bits_encoded as int64_t * lambda2 as int64_t;
                        coefs[i as usize] = old_coef as dctcoef;
                        if cur_score < iter_score {
                            iter_score = cur_score;
                            iter_coef = i;
                            iter_mask = cur_mask;
                            iter_round = cur_round;
                            iter_distortion_delta = cur_distortion_delta;
                        }
                    }
                    i += 1;
                }
                if !(iter_coef >= 0 as c_int) {
                    break;
                }
                score = iter_score - iter_distortion_delta;
                coef_mask = iter_mask;
                round_mask = iter_round;
                coefs[iter_coef as usize] = quant_coefs
                    [(round_mask >> iter_coef & 1 as c_int) as usize][iter_coef as usize];
                delta_distortion[iter_coef as usize] = 0 as int64_t;
            }
            if coef_mask != 0 {
                i = b_ac;
                j = start;
                while i < num_coefs {
                    *dct.offset(*zigzag.offset(j as isize) as isize) = coefs[i as usize];
                    i += 1;
                    j += step;
                }
                return 1 as c_int;
            }
        }
        if dc == 0 {
            if b_8x8 != 0 {
                i = start;
                while i <= end {
                    *dct.offset(*zigzag.offset(i as isize) as isize) = 0 as c_int as dctcoef;
                    i += step;
                }
            } else {
                memset(
                    dct as *mut c_void,
                    0 as c_int,
                    (16 as size_t).wrapping_mul(::core::mem::size_of::<dctcoef>() as size_t),
                );
            }
        }
        return 0 as c_int;
    }
    #[no_mangle]
    #[c2rust::src_loc = "1098:1"]
    pub unsafe extern "C" fn x264_10_quant_luma_dc_trellis(
        mut h: *mut x264_t,
        mut dct: *mut dctcoef,
        mut i_quant_cat: c_int,
        mut i_qp: c_int,
        mut ctx_block_cat: c_int,
        mut b_intra: c_int,
        mut idx: c_int,
    ) -> c_int {
        if (*h).param.b_cabac != 0 {
            return quant_trellis_cabac(
                h,
                dct,
                (*(*(*h).quant4_mf.as_mut_ptr().offset(i_quant_cat as isize))
                    .offset(i_qp as isize))
                .as_mut_ptr(),
                (*(*(*h).quant4_bias0.as_mut_ptr().offset(i_quant_cat as isize))
                    .offset(i_qp as isize))
                .as_mut_ptr(),
                (*(*(*h).unquant4_mf.as_mut_ptr().offset(i_quant_cat as isize))
                    .offset(i_qp as isize))
                .as_mut_ptr(),
                (*x264_zigzag_scan4
                    .as_ptr()
                    .offset((*h).mb.b_interlaced as isize))
                .as_ptr(),
                ctx_block_cat,
                (*h).mb.i_trellis_lambda2[0][b_intra as usize],
                0 as c_int,
                0 as c_int,
                1 as c_int,
                16 as c_int,
                idx,
            );
        }
        return quant_trellis_cavlc(
            h,
            dct,
            (*(*(*h).quant4_mf.as_mut_ptr().offset(i_quant_cat as isize)).offset(i_qp as isize))
                .as_mut_ptr(),
            (*(*(*h).unquant4_mf.as_mut_ptr().offset(i_quant_cat as isize)).offset(i_qp as isize))
                .as_mut_ptr(),
            (*x264_zigzag_scan4
                .as_ptr()
                .offset((*h).mb.b_interlaced as isize))
            .as_ptr(),
            DCT_LUMA_DC as c_int,
            (*h).mb.i_trellis_lambda2[0][b_intra as usize],
            0 as c_int,
            0 as c_int,
            1 as c_int,
            16 as c_int,
            idx,
            0 as c_int,
        );
    }
    #[c2rust::src_loc = "1111:22"]
    pub static mut zigzag_scan2x2: [uint8_t; 4] = [
        0 as c_int as uint8_t,
        1 as c_int as uint8_t,
        2 as c_int as uint8_t,
        3 as c_int as uint8_t,
    ];
    #[c2rust::src_loc = "1112:22"]
    pub static mut zigzag_scan2x4: [uint8_t; 8] = [
        0 as c_int as uint8_t,
        2 as c_int as uint8_t,
        1 as c_int as uint8_t,
        4 as c_int as uint8_t,
        6 as c_int as uint8_t,
        3 as c_int as uint8_t,
        5 as c_int as uint8_t,
        7 as c_int as uint8_t,
    ];
    #[no_mangle]
    #[c2rust::src_loc = "1114:1"]
    pub unsafe extern "C" fn x264_10_quant_chroma_dc_trellis(
        mut h: *mut x264_t,
        mut dct: *mut dctcoef,
        mut i_qp: c_int,
        mut b_intra: c_int,
        mut idx: c_int,
    ) -> c_int {
        let mut zigzag: *const uint8_t = 0 as *const uint8_t;
        let mut num_coefs: c_int = 0;
        let mut quant_cat: c_int = CQM_4IC as c_int + 1 as c_int - b_intra;
        if (*(*h).sps.as_mut_ptr()).i_chroma_format_idc == CHROMA_422 as c_int {
            zigzag = zigzag_scan2x4.as_ptr();
            num_coefs = 8 as c_int;
        } else {
            zigzag = zigzag_scan2x2.as_ptr();
            num_coefs = 4 as c_int;
        }
        if (*h).param.b_cabac != 0 {
            return quant_trellis_cabac(
                h,
                dct,
                (*(*(*h).quant4_mf.as_mut_ptr().offset(quant_cat as isize)).offset(i_qp as isize))
                    .as_mut_ptr(),
                (*(*(*h).quant4_bias0.as_mut_ptr().offset(quant_cat as isize))
                    .offset(i_qp as isize))
                .as_mut_ptr(),
                (*(*(*h).unquant4_mf.as_mut_ptr().offset(quant_cat as isize))
                    .offset(i_qp as isize))
                .as_mut_ptr(),
                zigzag,
                DCT_CHROMA_DC as c_int,
                (*h).mb.i_trellis_lambda2[1][b_intra as usize],
                0 as c_int,
                1 as c_int,
                1 as c_int,
                num_coefs,
                idx,
            );
        }
        return quant_trellis_cavlc(
            h,
            dct,
            (*(*(*h).quant4_mf.as_mut_ptr().offset(quant_cat as isize)).offset(i_qp as isize))
                .as_mut_ptr(),
            (*(*(*h).unquant4_mf.as_mut_ptr().offset(quant_cat as isize)).offset(i_qp as isize))
                .as_mut_ptr(),
            zigzag,
            DCT_CHROMA_DC as c_int,
            (*h).mb.i_trellis_lambda2[1][b_intra as usize],
            0 as c_int,
            1 as c_int,
            1 as c_int,
            num_coefs,
            idx,
            0 as c_int,
        );
    }
    #[no_mangle]
    #[c2rust::src_loc = "1142:1"]
    pub unsafe extern "C" fn x264_10_quant_4x4_trellis(
        mut h: *mut x264_t,
        mut dct: *mut dctcoef,
        mut i_quant_cat: c_int,
        mut i_qp: c_int,
        mut ctx_block_cat: c_int,
        mut b_intra: c_int,
        mut b_chroma: c_int,
        mut idx: c_int,
    ) -> c_int {
        pub static mut ctx_ac: [uint8_t; 14] = [
            0 as c_int as uint8_t,
            1 as c_int as uint8_t,
            0 as c_int as uint8_t,
            0 as c_int as uint8_t,
            1 as c_int as uint8_t,
            0 as c_int as uint8_t,
            0 as c_int as uint8_t,
            1 as c_int as uint8_t,
            0 as c_int as uint8_t,
            0 as c_int as uint8_t,
            0 as c_int as uint8_t,
            1 as c_int as uint8_t,
            0 as c_int as uint8_t,
            0 as c_int as uint8_t,
        ];
        let mut b_ac: c_int = ctx_ac[ctx_block_cat as usize] as c_int;
        if (*h).param.b_cabac != 0 {
            return quant_trellis_cabac(
                h,
                dct,
                (*(*(*h).quant4_mf.as_mut_ptr().offset(i_quant_cat as isize))
                    .offset(i_qp as isize))
                .as_mut_ptr(),
                (*(*(*h).quant4_bias0.as_mut_ptr().offset(i_quant_cat as isize))
                    .offset(i_qp as isize))
                .as_mut_ptr(),
                (*(*(*h).unquant4_mf.as_mut_ptr().offset(i_quant_cat as isize))
                    .offset(i_qp as isize))
                .as_mut_ptr(),
                (*x264_zigzag_scan4
                    .as_ptr()
                    .offset((*h).mb.b_interlaced as isize))
                .as_ptr(),
                ctx_block_cat,
                (*h).mb.i_trellis_lambda2[b_chroma as usize][b_intra as usize],
                b_ac,
                b_chroma,
                0 as c_int,
                16 as c_int,
                idx,
            );
        }
        return quant_trellis_cavlc(
            h,
            dct,
            (*(*(*h).quant4_mf.as_mut_ptr().offset(i_quant_cat as isize)).offset(i_qp as isize))
                .as_mut_ptr(),
            (*(*(*h).unquant4_mf.as_mut_ptr().offset(i_quant_cat as isize)).offset(i_qp as isize))
                .as_mut_ptr(),
            (*x264_zigzag_scan4
                .as_ptr()
                .offset((*h).mb.b_interlaced as isize))
            .as_ptr(),
            ctx_block_cat,
            (*h).mb.i_trellis_lambda2[b_chroma as usize][b_intra as usize],
            b_ac,
            b_chroma,
            0 as c_int,
            16 as c_int,
            idx,
            0 as c_int,
        );
    }
    #[no_mangle]
    #[c2rust::src_loc = "1159:1"]
    pub unsafe extern "C" fn x264_10_quant_8x8_trellis(
        mut h: *mut x264_t,
        mut dct: *mut dctcoef,
        mut i_quant_cat: c_int,
        mut i_qp: c_int,
        mut ctx_block_cat: c_int,
        mut b_intra: c_int,
        mut b_chroma: c_int,
        mut idx: c_int,
    ) -> c_int {
        if (*h).param.b_cabac != 0 {
            return quant_trellis_cabac(
                h,
                dct,
                (*(*(*h).quant8_mf.as_mut_ptr().offset(i_quant_cat as isize))
                    .offset(i_qp as isize))
                .as_mut_ptr(),
                (*(*(*h).quant8_bias0.as_mut_ptr().offset(i_quant_cat as isize))
                    .offset(i_qp as isize))
                .as_mut_ptr(),
                (*(*(*h).unquant8_mf.as_mut_ptr().offset(i_quant_cat as isize))
                    .offset(i_qp as isize))
                .as_mut_ptr(),
                (*x264_zigzag_scan8
                    .as_ptr()
                    .offset((*h).mb.b_interlaced as isize))
                .as_ptr(),
                ctx_block_cat,
                (*h).mb.i_trellis_lambda2[b_chroma as usize][b_intra as usize],
                0 as c_int,
                b_chroma,
                0 as c_int,
                64 as c_int,
                idx,
            );
        }
        let mut nzaccum: c_int = 0 as c_int;
        let mut i: c_int = 0 as c_int;
        while i < 4 as c_int {
            let mut nz: c_int = quant_trellis_cavlc(
                h,
                dct,
                (*(*(*h).quant8_mf.as_mut_ptr().offset(i_quant_cat as isize))
                    .offset(i_qp as isize))
                .as_mut_ptr(),
                (*(*(*h).unquant8_mf.as_mut_ptr().offset(i_quant_cat as isize))
                    .offset(i_qp as isize))
                .as_mut_ptr(),
                (*x264_zigzag_scan8
                    .as_ptr()
                    .offset((*h).mb.b_interlaced as isize))
                .as_ptr(),
                DCT_LUMA_4x4 as c_int,
                (*h).mb.i_trellis_lambda2[b_chroma as usize][b_intra as usize],
                0 as c_int,
                b_chroma,
                0 as c_int,
                16 as c_int,
                idx * 4 as c_int + i,
                1 as c_int,
            );
            (*h).mb.cache.non_zero_count[x264_scan8[(idx * 4 as c_int + i) as usize] as usize] =
                nz as uint8_t;
            nzaccum |= nz;
            i += 1;
        }
        (*(&mut *(*h).mb.cache.non_zero_count.as_mut_ptr().offset(
            (*x264_scan8
                .as_ptr()
                .offset((0 as c_int * 16 as c_int + idx * 4 as c_int) as isize)
                as c_int
                + 0 as c_int) as isize,
        ) as *mut uint8_t as *mut x264_union16_t))
            .i = (0 as c_int * 0x101 as c_int) as uint16_t;
        (*(&mut *(*h).mb.cache.non_zero_count.as_mut_ptr().offset(
            (*x264_scan8
                .as_ptr()
                .offset((0 as c_int * 16 as c_int + idx * 4 as c_int) as isize)
                as c_int
                + 8 as c_int) as isize,
        ) as *mut uint8_t as *mut x264_union16_t))
            .i = (0 as c_int * 0x101 as c_int) as uint16_t;
        return nzaccum;
    }
    use super::__stddef_size_t_h::size_t;
    use super::base_h::{
        x264_scan8, x264_union16_t, x264_union32_t, CHROMA_422, CHROMA_444, LUMA_DC,
    };
    use super::bitstream_h::bs_size_ue_big;
    use super::cabac_c::{
        chroma_size_cabac, macroblock_size_cabac, partition_i4x4_size_cabac,
        partition_i8x8_size_cabac, partition_size_cabac, subpartition_size_cabac,
    };
    use super::cabac_h::{x264_cabac_size_decision2, x264_cabac_size_decision_noup2, x264_cabac_t};
    use super::cavlc_c::{
        cavlc_block_residual_internal, chroma_size_cavlc, ct_index, macroblock_size_cavlc,
        partition_i4x4_size_cavlc, partition_i8x8_size_cavlc, partition_size_cavlc,
        subpartition_size_cavlc,
    };
    use super::common_h::{dctcoef, pixel, udctcoef, x264_t, FDEC_STRIDE, FENC_STRIDE};
    use super::encoder_macroblock_h::{
        x264_10_macroblock_encode, x264_10_macroblock_encode_p4x4, x264_10_macroblock_encode_p8x8,
        x264_10_mb_encode_chroma, x264_mb_encode_i4x4, x264_mb_encode_i8x8,
    };
    use super::frame_h::x264_10_macroblock_deblock;
    use super::macroblock_h::{
        block_idx_x, block_idx_y, pack16to32, x264_mb_predict_non_zero_code, x264_zigzag_scan4,
        x264_zigzag_scan8, DCT_LUMA_4x4, B_SKIP, DCT_CHROMA_DC, DCT_LUMA_DC, P_SKIP,
    };
    use super::pixel_h::{
        PIXEL_16x16, PIXEL_16x8, PIXEL_4x4, PIXEL_4x8, PIXEL_8x16, PIXEL_8x4, PIXEL_8x8,
    };
    use super::set_h::CQM_4IC;
    use super::stdint_h::intptr_t;
    use super::stdint_intn_h::int64_t;
    use super::stdint_uintn_h::{uint16_t, uint32_t, uint64_t, uint8_t};
    use super::stdlib_h::abs;
    use super::string_h::{memcpy, memset};
    use super::tables_h::{
        x264_cabac_entropy, x264_cabac_transition, x264_coeff0_token,
        x264_coeff_abs_level_m1_offset, x264_coeff_flag_offset_chroma_422_dc,
        x264_dct4_weight2_tab, x264_dct4_weight_tab, x264_dct8_weight2_tab, x264_dct8_weight_tab,
        x264_last_coeff_flag_offset, x264_last_coeff_flag_offset_8x8,
        x264_significant_coeff_flag_offset, x264_significant_coeff_flag_offset_8x8, x264_zero,
    };
    use super::util_h::{x264_union128_sse_t, M128_ZERO};
    use super::xmmintrin_h::__m128;
    #[cfg(target_arch = "x86")]
    pub use ::core::arch::x86::_mm_setr_ps;
    #[cfg(target_arch = "x86_64")]
    pub use ::core::arch::x86_64::_mm_setr_ps;
    use ::core::ffi::{c_int, c_long, c_uint, c_ulong, c_ulonglong, c_void};
}
#[c2rust::header_src = "/home/nwplayer123/Hacks/hex264/x264/encoder/me.h:28"]
pub mod me_h {
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "33:9"]
    pub struct x264_me_t {
        pub i_pixel: c_int,
        pub p_cost_mv: *mut uint16_t,
        pub i_ref_cost: c_int,
        pub i_ref: c_int,
        pub weight: *const x264_weight_t,
        pub p_fref: [*mut pixel; 12],
        pub p_fref_w: *mut pixel,
        pub p_fenc: [*mut pixel; 3],
        pub integral: *mut uint16_t,
        pub i_stride: [c_int; 3],
        pub mvp: [int16_t; 2],
        pub cost_mv: c_int,
        pub cost: c_int,
        pub mv: [int16_t; 2],
    }
    #[c2rust::src_loc = "30:9"]
    pub const COST_MAX: c_int = (1 as c_int) << 28 as c_int;
    #[c2rust::src_loc = "31:9"]
    pub const COST_MAX64: c_ulonglong = (1 as c_ulonglong) << 60 as c_int;
    use ::core::ffi::{c_int, c_ulonglong};

    use super::common_h::{pixel, x264_t};
    use super::mc_h::x264_weight_t;
    use super::stdint_intn_h::int16_t;
    use super::stdint_uintn_h::uint16_t;
    extern "C" {
        #[c2rust::src_loc = "59:1"]
        pub fn x264_10_me_search_ref(
            h: *mut x264_t,
            m: *mut x264_me_t,
            mvc: *mut [int16_t; 2],
            i_mvc: c_int,
            p_fullpel_thresh: *mut c_int,
        );
        #[c2rust::src_loc = "64:1"]
        pub fn x264_10_me_refine_qpel(h: *mut x264_t, m: *mut x264_me_t);
        #[c2rust::src_loc = "66:1"]
        pub fn x264_10_me_refine_qpel_refdupe(
            h: *mut x264_t,
            m: *mut x264_me_t,
            p_halfpel_thresh: *mut c_int,
        );
        #[c2rust::src_loc = "68:1"]
        pub fn x264_10_me_refine_qpel_rd(
            h: *mut x264_t,
            m: *mut x264_me_t,
            i_lambda2: c_int,
            i4: c_int,
            i_list: c_int,
        );
        #[c2rust::src_loc = "70:1"]
        pub fn x264_10_me_refine_bidir_rd(
            h: *mut x264_t,
            m0: *mut x264_me_t,
            m1: *mut x264_me_t,
            i_weight: c_int,
            i8: c_int,
            i_lambda2: c_int,
        );
        #[c2rust::src_loc = "72:1"]
        pub fn x264_10_me_refine_bidir_satd(
            h: *mut x264_t,
            m0: *mut x264_me_t,
            m1: *mut x264_me_t,
            i_weight: c_int,
        );
    }
    use super::stdint_uintn_h::uint64_t;
    extern "C" {
        #[c2rust::src_loc = "74:1"]
        pub fn x264_10_rd_cost_part(
            h: *mut x264_t,
            i_lambda2: c_int,
            i8: c_int,
            i_pixel: c_int,
        ) -> uint64_t;
    }
}
#[c2rust::header_src = "/home/nwplayer123/Hacks/hex264/x264/encoder/slicetype.c:28"]
pub mod slicetype_c {
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "799:9"]
    pub struct x264_slicetype_slice_t {
        pub h: *mut x264_t,
        pub a: *mut x264_mb_analysis_t,
        pub frames: *mut *mut x264_frame_t,
        pub p0: c_int,
        pub p1: c_int,
        pub b: c_int,
        pub dist_scale_factor: c_int,
        pub do_search: *mut c_int,
        pub w: *const x264_weight_t,
        pub output_inter: *mut c_int,
        pub output_intra: *mut c_int,
    }
    #[c2rust::src_loc = "33:22"]
    pub static mut delta_tfi_divisor: [uint8_t; 10] = [
        0 as c_int as uint8_t,
        2 as c_int as uint8_t,
        1 as c_int as uint8_t,
        1 as c_int as uint8_t,
        2 as c_int as uint8_t,
        2 as c_int as uint8_t,
        3 as c_int as uint8_t,
        3 as c_int as uint8_t,
        4 as c_int as uint8_t,
        6 as c_int as uint8_t,
    ];
    #[c2rust::src_loc = "45:1"]
    pub unsafe extern "C" fn lowres_context_init(
        mut h: *mut x264_t,
        mut a: *mut x264_mb_analysis_t,
    ) {
        (*a).i_qp = X264_LOOKAHEAD_QP;
        (*a).i_lambda = x264_lambda_tab[(*a).i_qp as usize] as c_int;
        mb_analyse_load_costs(h, a);
        if (*h).param.analyse.i_subpel_refine > 1 as c_int {
            (*h).mb.i_me_method = if (1 as c_int) < (*h).param.analyse.i_me_method {
                1 as c_int
            } else {
                (*h).param.analyse.i_me_method
            };
            (*h).mb.i_subpel_refine = 4 as c_int;
        } else {
            (*h).mb.i_me_method = X264_ME_DIA;
            (*h).mb.i_subpel_refine = 2 as c_int;
        }
        (*h).mb.b_chroma_me = 0 as c_int;
    }
    #[c2rust::src_loc = "64:1"]
    pub unsafe extern "C" fn weight_get_h264(
        mut weight_nonh264: c_int,
        mut offset: c_int,
        mut w: *mut x264_weight_t,
    ) {
        (*w).i_offset = offset as int32_t;
        (*w).i_denom = 7 as c_int as int32_t;
        (*w).i_scale = weight_nonh264 as int32_t;
        while (*w).i_denom > 0 as int32_t && (*w).i_scale > 127 as int32_t {
            (*w).i_denom -= 1;
            (*w).i_scale >>= 1 as c_int;
        }
        (*w).i_scale = if (*w).i_scale < 127 as int32_t {
            (*w).i_scale
        } else {
            127 as int32_t
        };
    }
    #[inline(never)]
    #[c2rust::src_loc = "77:1"]
    pub unsafe extern "C" fn weight_cost_init_luma(
        mut h: *mut x264_t,
        mut fenc: *mut x264_frame_t,
        mut ref_0: *mut x264_frame_t,
        mut dest: *mut pixel,
    ) -> *mut pixel {
        let mut ref0_distance: c_int = (*fenc).i_frame - (*ref_0).i_frame - 1 as c_int;
        if (*(*fenc).lowres_mvs[0][ref0_distance as usize].offset(0))[0] as c_int != 0x7fff as c_int
        {
            let mut i_stride: c_int = (*fenc).i_stride_lowres;
            let mut i_lines: c_int = (*fenc).i_lines_lowres;
            let mut i_width: c_int = (*fenc).i_width_lowres;
            let mut i_mb_xy: c_int = 0 as c_int;
            let mut p: *mut pixel = dest;
            let mut y: c_int = 0 as c_int;
            while y < i_lines {
                let mut x: c_int = 0 as c_int;
                while x < i_width {
                    let mut mvx: c_int = (*(*fenc).lowres_mvs[0][ref0_distance as usize]
                        .offset(i_mb_xy as isize))[0]
                        as c_int;
                    let mut mvy: c_int = (*(*fenc).lowres_mvs[0][ref0_distance as usize]
                        .offset(i_mb_xy as isize))[1]
                        as c_int;
                    (*h).mc.mc_luma.expect("non-null function pointer")(
                        p.offset(x as isize),
                        i_stride as intptr_t,
                        (*ref_0).lowres.as_mut_ptr(),
                        i_stride as intptr_t,
                        mvx + (x << 2 as c_int),
                        mvy + (y << 2 as c_int),
                        8 as c_int,
                        8 as c_int,
                        x264_zero.as_mut_ptr() as *const x264_weight_t,
                    );
                    x += 8 as c_int;
                    i_mb_xy += 1;
                }
                y += 8 as c_int;
                p = p.offset((i_stride * 8 as c_int) as isize);
            }
            return dest;
        }
        return (*ref_0).lowres[0];
    }
    #[inline(never)]
    #[c2rust::src_loc = "111:1"]
    pub unsafe extern "C" fn weight_cost_init_chroma(
        mut h: *mut x264_t,
        mut fenc: *mut x264_frame_t,
        mut ref_0: *mut x264_frame_t,
        mut dstu: *mut pixel,
        mut dstv: *mut pixel,
    ) {
        let mut ref0_distance: c_int = (*fenc).i_frame - (*ref_0).i_frame - 1 as c_int;
        let mut i_stride: c_int = (*fenc).i_stride[1];
        let mut i_lines: c_int = (*fenc).i_lines[1];
        let mut i_width: c_int = (*fenc).i_width[1];
        let mut v_shift: c_int = (*h).mb.chroma_v_shift;
        let mut cw: c_int = 8 as c_int * (*h).mb.i_mb_width;
        let mut ch: c_int = 16 as c_int * (*h).mb.i_mb_height >> v_shift;
        let mut height: c_int = 16 as c_int >> v_shift;
        if (*(*fenc).lowres_mvs[0][ref0_distance as usize].offset(0))[0] as c_int != 0x7fff as c_int
        {
            x264_10_frame_expand_border_chroma(h, ref_0, 1 as c_int);
            let mut y: c_int = 0 as c_int;
            let mut mb_xy: c_int = 0 as c_int;
            let mut pel_offset_y: c_int = 0 as c_int;
            while y < i_lines {
                let mut x: c_int = 0 as c_int;
                let mut pel_offset_x: c_int = 0 as c_int;
                while x < i_width {
                    let mut pixu: *mut pixel = dstu
                        .offset(pel_offset_y as isize)
                        .offset(pel_offset_x as isize);
                    let mut pixv: *mut pixel = dstv
                        .offset(pel_offset_y as isize)
                        .offset(pel_offset_x as isize);
                    let mut src1: *mut pixel = (*ref_0).plane[1]
                        .offset(pel_offset_y as isize)
                        .offset((pel_offset_x * 2 as c_int) as isize);
                    let mut mvx: c_int = (*(*fenc).lowres_mvs[0][ref0_distance as usize]
                        .offset(mb_xy as isize))[0]
                        as c_int;
                    let mut mvy: c_int = (*(*fenc).lowres_mvs[0][ref0_distance as usize]
                        .offset(mb_xy as isize))[1]
                        as c_int;
                    (*h).mc.mc_chroma.expect("non-null function pointer")(
                        pixu,
                        pixv,
                        i_stride as intptr_t,
                        src1,
                        i_stride as intptr_t,
                        mvx,
                        2 as c_int * mvy >> v_shift,
                        8 as c_int,
                        height,
                    );
                    x += 8 as c_int;
                    mb_xy += 1;
                    pel_offset_x += 8 as c_int;
                }
                y += height;
                pel_offset_y = y * i_stride;
            }
        } else {
            (*h).mc
                .plane_copy_deinterleave
                .expect("non-null function pointer")(
                dstu,
                i_stride as intptr_t,
                dstv,
                i_stride as intptr_t,
                (*ref_0).plane[1],
                i_stride as intptr_t,
                cw,
                ch,
            );
        }
        (*h).mc
            .plane_copy_deinterleave
            .expect("non-null function pointer")(
            dstu.offset(i_width as isize),
            i_stride as intptr_t,
            dstv.offset(i_width as isize),
            i_stride as intptr_t,
            (*fenc).plane[1],
            i_stride as intptr_t,
            cw,
            ch,
        );
    }
    #[inline(never)]
    #[c2rust::src_loc = "142:1"]
    pub unsafe extern "C" fn weight_cost_init_chroma444(
        mut h: *mut x264_t,
        mut fenc: *mut x264_frame_t,
        mut ref_0: *mut x264_frame_t,
        mut dst: *mut pixel,
        mut p: c_int,
    ) -> *mut pixel {
        let mut ref0_distance: c_int = (*fenc).i_frame - (*ref_0).i_frame - 1 as c_int;
        let mut i_stride: c_int = (*fenc).i_stride[p as usize];
        let mut i_lines: c_int = (*fenc).i_lines[p as usize];
        let mut i_width: c_int = (*fenc).i_width[p as usize];
        if (*(*fenc).lowres_mvs[0][ref0_distance as usize].offset(0))[0] as c_int != 0x7fff as c_int
        {
            x264_10_frame_expand_border_chroma(h, ref_0, p);
            let mut y: c_int = 0 as c_int;
            let mut mb_xy: c_int = 0 as c_int;
            let mut pel_offset_y: c_int = 0 as c_int;
            while y < i_lines {
                let mut x: c_int = 0 as c_int;
                let mut pel_offset_x: c_int = 0 as c_int;
                while x < i_width {
                    let mut pix: *mut pixel = dst
                        .offset(pel_offset_y as isize)
                        .offset(pel_offset_x as isize);
                    let mut src: *mut pixel = (*ref_0).plane[p as usize]
                        .offset(pel_offset_y as isize)
                        .offset(pel_offset_x as isize);
                    let mut mvx: c_int = (*(*fenc).lowres_mvs[0][ref0_distance as usize]
                        .offset(mb_xy as isize))[0]
                        as c_int
                        / 2 as c_int;
                    let mut mvy: c_int = (*(*fenc).lowres_mvs[0][ref0_distance as usize]
                        .offset(mb_xy as isize))[1]
                        as c_int
                        / 2 as c_int;
                    (*h).mc
                        .copy_16x16_unaligned
                        .expect("non-null function pointer")(
                        pix,
                        i_stride as intptr_t,
                        src.offset(mvx as isize).offset((mvy * i_stride) as isize),
                        i_stride as intptr_t,
                        16 as c_int,
                    );
                    x += 16 as c_int;
                    mb_xy += 1;
                    pel_offset_x += 16 as c_int;
                }
                y += 16 as c_int;
                pel_offset_y = y * i_stride;
            }
            return dst;
        }
        return (*ref_0).plane[p as usize];
    }
    #[c2rust::src_loc = "170:1"]
    pub unsafe extern "C" fn weight_slice_header_cost(
        mut h: *mut x264_t,
        mut w: *mut x264_weight_t,
        mut b_chroma: c_int,
    ) -> c_int {
        let mut lambda: c_int = x264_lambda_tab[X264_LOOKAHEAD_QP as usize] as c_int;
        if b_chroma != 0 {
            lambda *= 4 as c_int;
        }
        let mut numslices: c_int = 0;
        if (*h).param.i_slice_count != 0 {
            numslices = (*h).param.i_slice_count;
        } else if (*h).param.i_slice_max_mbs != 0 {
            numslices = ((*h).mb.i_mb_width * (*h).mb.i_mb_height + (*h).param.i_slice_max_mbs
                - 1 as c_int)
                / (*h).param.i_slice_max_mbs;
        } else {
            numslices = 1 as c_int;
        }
        let mut denom_cost: c_int =
            bs_size_ue((*w.offset(0)).i_denom as c_uint) * (2 as c_int - b_chroma);
        return lambda
            * numslices
            * (10 as c_int
                + denom_cost
                + 2 as c_int
                    * (bs_size_se((*w.offset(0)).i_scale as c_int)
                        + bs_size_se((*w.offset(0)).i_offset as c_int)));
    }
    #[inline(never)]
    #[c2rust::src_loc = "191:1"]
    pub unsafe extern "C" fn weight_cost_luma(
        mut h: *mut x264_t,
        mut fenc: *mut x264_frame_t,
        mut src: *mut pixel,
        mut w: *mut x264_weight_t,
    ) -> c_uint {
        let mut cost: c_uint = 0 as c_uint;
        let mut i_stride: c_int = (*fenc).i_stride_lowres;
        let mut i_lines: c_int = (*fenc).i_lines_lowres;
        let mut i_width: c_int = (*fenc).i_width_lowres;
        let mut fenc_plane: *mut pixel = (*fenc).lowres[0];
        let mut buf: [pixel; 64] = [0; 64];
        let mut pixoff: c_int = 0 as c_int;
        let mut i_mb: c_int = 0 as c_int;
        if !w.is_null() {
            let mut y: c_int = 0 as c_int;
            while y < i_lines {
                let mut x: c_int = 0 as c_int;
                while x < i_width {
                    (*(*w).weightfn.offset((8 as c_int >> 2 as c_int) as isize))
                        .expect("non-null function pointer")(
                        buf.as_mut_ptr(),
                        8 as intptr_t,
                        &mut *src.offset(pixoff as isize),
                        i_stride as intptr_t,
                        w,
                        8 as c_int,
                    );
                    let mut cmp: c_int = (*h).pixf.mbcmp[PIXEL_8x8 as c_int as usize]
                        .expect("non-null function pointer")(
                        buf.as_mut_ptr(),
                        8 as intptr_t,
                        &mut *fenc_plane.offset(pixoff as isize),
                        i_stride as intptr_t,
                    );
                    cost = cost.wrapping_add(
                        (if cmp < *(*fenc).i_intra_cost.offset(i_mb as isize) as c_int {
                            cmp
                        } else {
                            *(*fenc).i_intra_cost.offset(i_mb as isize) as c_int
                        }) as c_uint,
                    );
                    x += 8 as c_int;
                    i_mb += 1;
                    pixoff += 8 as c_int;
                }
                y += 8 as c_int;
                pixoff = y * i_stride;
            }
            cost = cost.wrapping_add(weight_slice_header_cost(h, w, 0 as c_int) as c_uint);
        } else {
            let mut y_0: c_int = 0 as c_int;
            while y_0 < i_lines {
                let mut x_0: c_int = 0 as c_int;
                while x_0 < i_width {
                    let mut cmp_0: c_int = (*h).pixf.mbcmp[PIXEL_8x8 as c_int as usize]
                        .expect("non-null function pointer")(
                        &mut *src.offset(pixoff as isize),
                        i_stride as intptr_t,
                        &mut *fenc_plane.offset(pixoff as isize),
                        i_stride as intptr_t,
                    );
                    cost = cost.wrapping_add(
                        (if cmp_0 < *(*fenc).i_intra_cost.offset(i_mb as isize) as c_int {
                            cmp_0
                        } else {
                            *(*fenc).i_intra_cost.offset(i_mb as isize) as c_int
                        }) as c_uint,
                    );
                    x_0 += 8 as c_int;
                    i_mb += 1;
                    pixoff += 8 as c_int;
                }
                y_0 += 8 as c_int;
                pixoff = y_0 * i_stride;
            }
        }
        return cost;
    }
    #[inline(never)]
    #[c2rust::src_loc = "224:1"]
    pub unsafe extern "C" fn weight_cost_chroma(
        mut h: *mut x264_t,
        mut fenc: *mut x264_frame_t,
        mut ref_0: *mut pixel,
        mut w: *mut x264_weight_t,
    ) -> c_uint {
        let mut cost: c_uint = 0 as c_uint;
        let mut i_stride: c_int = (*fenc).i_stride[1];
        let mut i_lines: c_int = (*fenc).i_lines[1];
        let mut i_width: c_int = (*fenc).i_width[1];
        let mut src: *mut pixel = ref_0.offset(i_width as isize);
        let mut buf: [pixel; 128] = [0; 128];
        let mut pixoff: c_int = 0 as c_int;
        let mut height: c_int = 16 as c_int >> (*h).mb.chroma_v_shift;
        if !w.is_null() {
            let mut y: c_int = 0 as c_int;
            while y < i_lines {
                let mut x: c_int = 0 as c_int;
                while x < i_width {
                    (*(*w).weightfn.offset((8 as c_int >> 2 as c_int) as isize))
                        .expect("non-null function pointer")(
                        buf.as_mut_ptr(),
                        8 as intptr_t,
                        &mut *ref_0.offset(pixoff as isize),
                        i_stride as intptr_t,
                        w,
                        height,
                    );
                    cost = cost.wrapping_add((*h).pixf.asd8.expect("non-null function pointer")(
                        buf.as_mut_ptr(),
                        8 as intptr_t,
                        &mut *src.offset(pixoff as isize),
                        i_stride as intptr_t,
                        height,
                    ) as c_uint);
                    x += 8 as c_int;
                    pixoff += 8 as c_int;
                }
                y += height;
                pixoff = y * i_stride;
            }
            cost = cost.wrapping_add(weight_slice_header_cost(h, w, 1 as c_int) as c_uint);
        } else {
            let mut y_0: c_int = 0 as c_int;
            while y_0 < i_lines {
                let mut x_0: c_int = 0 as c_int;
                while x_0 < i_width {
                    cost = cost.wrapping_add((*h).pixf.asd8.expect("non-null function pointer")(
                        &mut *ref_0.offset(pixoff as isize),
                        i_stride as intptr_t,
                        &mut *src.offset(pixoff as isize),
                        i_stride as intptr_t,
                        height,
                    ) as c_uint);
                    x_0 += 8 as c_int;
                    pixoff += 8 as c_int;
                }
                y_0 += height;
                pixoff = y_0 * i_stride;
            }
        }
        return cost;
    }
    #[inline(never)]
    #[c2rust::src_loc = "257:1"]
    pub unsafe extern "C" fn weight_cost_chroma444(
        mut h: *mut x264_t,
        mut fenc: *mut x264_frame_t,
        mut ref_0: *mut pixel,
        mut w: *mut x264_weight_t,
        mut p: c_int,
    ) -> c_uint {
        let mut cost: c_uint = 0 as c_uint;
        let mut i_stride: c_int = (*fenc).i_stride[p as usize];
        let mut i_lines: c_int = (*fenc).i_lines[p as usize];
        let mut i_width: c_int = (*fenc).i_width[p as usize];
        let mut src: *mut pixel = (*fenc).plane[p as usize];
        let mut buf: [pixel; 256] = [0; 256];
        let mut pixoff: c_int = 0 as c_int;
        if !w.is_null() {
            let mut y: c_int = 0 as c_int;
            while y < i_lines {
                let mut x: c_int = 0 as c_int;
                while x < i_width {
                    (*(*w).weightfn.offset((16 as c_int >> 2 as c_int) as isize))
                        .expect("non-null function pointer")(
                        buf.as_mut_ptr(),
                        16 as intptr_t,
                        &mut *ref_0.offset(pixoff as isize),
                        i_stride as intptr_t,
                        w,
                        16 as c_int,
                    );
                    cost = cost.wrapping_add((*h).pixf.mbcmp[PIXEL_16x16 as c_int as usize]
                        .expect("non-null function pointer")(
                        buf.as_mut_ptr(),
                        16 as intptr_t,
                        &mut *src.offset(pixoff as isize),
                        i_stride as intptr_t,
                    ) as c_uint);
                    x += 16 as c_int;
                    pixoff += 16 as c_int;
                }
                y += 16 as c_int;
                pixoff = y * i_stride;
            }
            cost = cost.wrapping_add(weight_slice_header_cost(h, w, 1 as c_int) as c_uint);
        } else {
            let mut y_0: c_int = 0 as c_int;
            while y_0 < i_lines {
                let mut x_0: c_int = 0 as c_int;
                while x_0 < i_width {
                    cost = cost.wrapping_add((*h).pixf.mbcmp[PIXEL_16x16 as c_int as usize]
                        .expect("non-null function pointer")(
                        &mut *ref_0.offset(pixoff as isize),
                        i_stride as intptr_t,
                        &mut *src.offset(pixoff as isize),
                        i_stride as intptr_t,
                    ) as c_uint);
                    x_0 += 16 as c_int;
                    pixoff += 16 as c_int;
                }
                y_0 += 16 as c_int;
                pixoff = y_0 * i_stride;
            }
        }
        return cost;
    }
    #[no_mangle]
    #[c2rust::src_loc = "284:1"]
    pub unsafe extern "C" fn x264_10_weights_analyse(
        mut h: *mut x264_t,
        mut fenc: *mut x264_frame_t,
        mut ref_0: *mut x264_frame_t,
        mut b_lookahead: c_int,
    ) {
        let mut i_delta_index: c_int = (*fenc).i_frame - (*ref_0).i_frame - 1 as c_int;
        let epsilon: c_float = 1.0f32 / 128.0f32;
        let mut weights: *mut x264_weight_t = (*(*fenc).weight.as_mut_ptr().offset(0)).as_mut_ptr();
        (*weights.offset(0)).i_scale = 1 as c_int as int32_t;
        (*weights.offset(0)).i_denom = 0 as c_int as int32_t;
        (*weights.offset(0)).i_offset = 0 as c_int as int32_t;
        let ref mut fresh8 = (*weights.offset(0)).weightfn;
        *fresh8 = 0 as *mut weight_fn_t;
        (*weights.offset(1)).i_scale = 1 as c_int as int32_t;
        (*weights.offset(1)).i_denom = 0 as c_int as int32_t;
        (*weights.offset(1)).i_offset = 0 as c_int as int32_t;
        let ref mut fresh9 = (*weights.offset(1)).weightfn;
        *fresh9 = 0 as *mut weight_fn_t;
        (*weights.offset(2)).i_scale = 1 as c_int as int32_t;
        (*weights.offset(2)).i_denom = 0 as c_int as int32_t;
        (*weights.offset(2)).i_offset = 0 as c_int as int32_t;
        let ref mut fresh10 = (*weights.offset(2)).weightfn;
        *fresh10 = 0 as *mut weight_fn_t;
        let mut chroma_initted: c_int = 0 as c_int;
        let mut guess_scale: [c_float; 3] = [0.; 3];
        let mut fenc_mean: [c_float; 3] = [0.; 3];
        let mut ref_mean: [c_float; 3] = [0.; 3];
        let mut plane: c_int = 0 as c_int;
        while plane <= 2 as c_int * (b_lookahead == 0) as c_int {
            if plane == 0 || (*(*h).sps.as_mut_ptr()).i_chroma_format_idc != 0 {
                let mut zero_bias: c_int = ((*ref_0).i_pixel_ssd[plane as usize] == 0) as c_int;
                let mut fenc_var: c_float = (*fenc).i_pixel_ssd[plane as usize]
                    .wrapping_add(zero_bias as uint64_t)
                    as c_float;
                let mut ref_var: c_float = (*ref_0).i_pixel_ssd[plane as usize]
                    .wrapping_add(zero_bias as uint64_t)
                    as c_float;
                guess_scale[plane as usize] = sqrtf(fenc_var / ref_var);
                fenc_mean[plane as usize] = (*fenc).i_pixel_sum[plane as usize]
                    .wrapping_add(zero_bias as uint32_t)
                    as c_float
                    / ((*fenc).i_lines[(plane != 0) as c_int as usize]
                        * (*fenc).i_width[(plane != 0) as c_int as usize])
                        as c_float
                    / ((1 as c_int) << BIT_DEPTH - 8 as c_int) as c_float;
                ref_mean[plane as usize] = (*ref_0).i_pixel_sum[plane as usize]
                    .wrapping_add(zero_bias as uint32_t)
                    as c_float
                    / ((*fenc).i_lines[(plane != 0) as c_int as usize]
                        * (*fenc).i_width[(plane != 0) as c_int as usize])
                        as c_float
                    / ((1 as c_int) << BIT_DEPTH - 8 as c_int) as c_float;
            } else {
                guess_scale[plane as usize] = 1 as c_int as c_float;
                fenc_mean[plane as usize] = 0 as c_int as c_float;
                ref_mean[plane as usize] = 0 as c_int as c_float;
            }
            plane += 1;
        }
        let mut chroma_denom: c_int = 7 as c_int;
        if b_lookahead == 0 {
            while chroma_denom > 0 as c_int {
                let mut thresh: c_float = 127.0f32 / ((1 as c_int) << chroma_denom) as c_float;
                if guess_scale[1] < thresh && guess_scale[2] < thresh {
                    break;
                }
                chroma_denom -= 1;
            }
        }
        let mut plane_0: c_int = 0 as c_int;
        while plane_0
            < (if (*(*h).sps.as_mut_ptr()).i_chroma_format_idc != 0 {
                3 as c_int
            } else {
                1 as c_int
            })
            && !(plane_0 != 0 && ((*weights.offset(0)).weightfn.is_null() || b_lookahead != 0))
        {
            let mut minoff: c_int = 0;
            let mut minscale: c_int = 0;
            let mut mindenom: c_int = 0;
            let mut minscore: c_uint = 0;
            let mut origscore: c_uint = 0;
            let mut found: c_int = 0;
            if fabsf(ref_mean[plane_0 as usize] - fenc_mean[plane_0 as usize]) < 0.5f32
                && fabsf(1.0f32 - guess_scale[plane_0 as usize]) < epsilon
            {
                (*weights.offset(plane_0 as isize)).i_scale = 1 as c_int as int32_t;
                (*weights.offset(plane_0 as isize)).i_denom = 0 as c_int as int32_t;
                (*weights.offset(plane_0 as isize)).i_offset = 0 as c_int as int32_t;
                let ref mut fresh11 = (*weights.offset(plane_0 as isize)).weightfn;
                *fresh11 = 0 as *mut weight_fn_t;
            } else {
                if plane_0 != 0 {
                    (*weights.offset(plane_0 as isize)).i_denom = chroma_denom as int32_t;
                    (*weights.offset(plane_0 as isize)).i_scale = x264_clip3(
                        round(
                            (guess_scale[plane_0 as usize]
                                * ((1 as c_int) << chroma_denom) as c_float)
                                as c_double,
                        ) as c_int,
                        0 as c_int,
                        255 as c_int,
                    ) as int32_t;
                    if (*weights.offset(plane_0 as isize)).i_scale > 127 as int32_t {
                        let ref mut fresh12 = (*weights.offset(2)).weightfn;
                        *fresh12 = 0 as *mut weight_fn_t;
                        let ref mut fresh13 = (*weights.offset(1)).weightfn;
                        *fresh13 = *fresh12;
                        break;
                    }
                } else {
                    weight_get_h264(
                        round((guess_scale[plane_0 as usize] * 128 as c_int as c_float) as c_double)
                            as c_int,
                        0 as c_int,
                        &mut *weights.offset(plane_0 as isize),
                    );
                }
                found = 0 as c_int;
                mindenom = (*weights.offset(plane_0 as isize)).i_denom as c_int;
                minscale = (*weights.offset(plane_0 as isize)).i_scale as c_int;
                minoff = 0 as c_int;
                let mut mcbuf: *mut pixel = 0 as *mut pixel;
                if plane_0 == 0 {
                    if (*fenc).b_intra_calculated == 0 {
                        let mut a: x264_mb_analysis_t = x264_mb_analysis_t {
                            i_lambda: 0,
                            i_lambda2: 0,
                            i_qp: 0,
                            p_cost_mv: 0 as *mut uint16_t,
                            p_cost_ref: [0 as *mut uint16_t; 2],
                            i_mbrd: 0,
                            b_fast_intra: 0,
                            b_force_intra: 0,
                            b_avoid_topright: 0,
                            b_try_skip: 0,
                            i_satd_i16x16: 0,
                            i_satd_i16x16_dir: [0; 7],
                            i_predict16x16: 0,
                            i_satd_i8x8: 0,
                            i_cbp_i8x8_luma: 0,
                            i_satd_i8x8_dir: [[0; 16]; 4],
                            i_predict8x8: [0; 4],
                            i_satd_i4x4: 0,
                            i_predict4x4: [0; 16],
                            i_satd_pcm: 0,
                            i_satd_chroma: 0,
                            i_satd_chroma_dir: [0; 7],
                            i_predict8x8chroma: 0,
                            l0: x264_mb_analysis_list_t {
                                me16x16: x264_me_t {
                                    i_pixel: 0,
                                    p_cost_mv: 0 as *mut uint16_t,
                                    i_ref_cost: 0,
                                    i_ref: 0,
                                    weight: 0 as *const x264_weight_t,
                                    p_fref: [0 as *mut pixel; 12],
                                    p_fref_w: 0 as *mut pixel,
                                    p_fenc: [0 as *mut pixel; 3],
                                    integral: 0 as *mut uint16_t,
                                    i_stride: [0; 3],
                                    mvp: [0; 2],
                                    cost_mv: 0,
                                    cost: 0,
                                    mv: [0; 2],
                                },
                                bi16x16: x264_me_t {
                                    i_pixel: 0,
                                    p_cost_mv: 0 as *mut uint16_t,
                                    i_ref_cost: 0,
                                    i_ref: 0,
                                    weight: 0 as *const x264_weight_t,
                                    p_fref: [0 as *mut pixel; 12],
                                    p_fref_w: 0 as *mut pixel,
                                    p_fenc: [0 as *mut pixel; 3],
                                    integral: 0 as *mut uint16_t,
                                    i_stride: [0; 3],
                                    mvp: [0; 2],
                                    cost_mv: 0,
                                    cost: 0,
                                    mv: [0; 2],
                                },
                                me8x8: [x264_me_t {
                                    i_pixel: 0,
                                    p_cost_mv: 0 as *mut uint16_t,
                                    i_ref_cost: 0,
                                    i_ref: 0,
                                    weight: 0 as *const x264_weight_t,
                                    p_fref: [0 as *mut pixel; 12],
                                    p_fref_w: 0 as *mut pixel,
                                    p_fenc: [0 as *mut pixel; 3],
                                    integral: 0 as *mut uint16_t,
                                    i_stride: [0; 3],
                                    mvp: [0; 2],
                                    cost_mv: 0,
                                    cost: 0,
                                    mv: [0; 2],
                                }; 4],
                                me4x4: [[x264_me_t {
                                    i_pixel: 0,
                                    p_cost_mv: 0 as *mut uint16_t,
                                    i_ref_cost: 0,
                                    i_ref: 0,
                                    weight: 0 as *const x264_weight_t,
                                    p_fref: [0 as *mut pixel; 12],
                                    p_fref_w: 0 as *mut pixel,
                                    p_fenc: [0 as *mut pixel; 3],
                                    integral: 0 as *mut uint16_t,
                                    i_stride: [0; 3],
                                    mvp: [0; 2],
                                    cost_mv: 0,
                                    cost: 0,
                                    mv: [0; 2],
                                }; 4]; 4],
                                me8x4: [[x264_me_t {
                                    i_pixel: 0,
                                    p_cost_mv: 0 as *mut uint16_t,
                                    i_ref_cost: 0,
                                    i_ref: 0,
                                    weight: 0 as *const x264_weight_t,
                                    p_fref: [0 as *mut pixel; 12],
                                    p_fref_w: 0 as *mut pixel,
                                    p_fenc: [0 as *mut pixel; 3],
                                    integral: 0 as *mut uint16_t,
                                    i_stride: [0; 3],
                                    mvp: [0; 2],
                                    cost_mv: 0,
                                    cost: 0,
                                    mv: [0; 2],
                                }; 2]; 4],
                                me4x8: [[x264_me_t {
                                    i_pixel: 0,
                                    p_cost_mv: 0 as *mut uint16_t,
                                    i_ref_cost: 0,
                                    i_ref: 0,
                                    weight: 0 as *const x264_weight_t,
                                    p_fref: [0 as *mut pixel; 12],
                                    p_fref_w: 0 as *mut pixel,
                                    p_fenc: [0 as *mut pixel; 3],
                                    integral: 0 as *mut uint16_t,
                                    i_stride: [0; 3],
                                    mvp: [0; 2],
                                    cost_mv: 0,
                                    cost: 0,
                                    mv: [0; 2],
                                }; 2]; 4],
                                me16x8: [x264_me_t {
                                    i_pixel: 0,
                                    p_cost_mv: 0 as *mut uint16_t,
                                    i_ref_cost: 0,
                                    i_ref: 0,
                                    weight: 0 as *const x264_weight_t,
                                    p_fref: [0 as *mut pixel; 12],
                                    p_fref_w: 0 as *mut pixel,
                                    p_fenc: [0 as *mut pixel; 3],
                                    integral: 0 as *mut uint16_t,
                                    i_stride: [0; 3],
                                    mvp: [0; 2],
                                    cost_mv: 0,
                                    cost: 0,
                                    mv: [0; 2],
                                }; 2],
                                me8x16: [x264_me_t {
                                    i_pixel: 0,
                                    p_cost_mv: 0 as *mut uint16_t,
                                    i_ref_cost: 0,
                                    i_ref: 0,
                                    weight: 0 as *const x264_weight_t,
                                    p_fref: [0 as *mut pixel; 12],
                                    p_fref_w: 0 as *mut pixel,
                                    p_fenc: [0 as *mut pixel; 3],
                                    integral: 0 as *mut uint16_t,
                                    i_stride: [0; 3],
                                    mvp: [0; 2],
                                    cost_mv: 0,
                                    cost: 0,
                                    mv: [0; 2],
                                }; 2],
                                i_rd16x16: 0,
                                i_cost8x8: 0,
                                i_cost4x4: [0; 4],
                                i_cost8x4: [0; 4],
                                i_cost4x8: [0; 4],
                                i_cost16x8: 0,
                                i_cost8x16: 0,
                                mvc: [[[0; 2]; 6]; 32],
                            },
                            l1: x264_mb_analysis_list_t {
                                me16x16: x264_me_t {
                                    i_pixel: 0,
                                    p_cost_mv: 0 as *mut uint16_t,
                                    i_ref_cost: 0,
                                    i_ref: 0,
                                    weight: 0 as *const x264_weight_t,
                                    p_fref: [0 as *mut pixel; 12],
                                    p_fref_w: 0 as *mut pixel,
                                    p_fenc: [0 as *mut pixel; 3],
                                    integral: 0 as *mut uint16_t,
                                    i_stride: [0; 3],
                                    mvp: [0; 2],
                                    cost_mv: 0,
                                    cost: 0,
                                    mv: [0; 2],
                                },
                                bi16x16: x264_me_t {
                                    i_pixel: 0,
                                    p_cost_mv: 0 as *mut uint16_t,
                                    i_ref_cost: 0,
                                    i_ref: 0,
                                    weight: 0 as *const x264_weight_t,
                                    p_fref: [0 as *mut pixel; 12],
                                    p_fref_w: 0 as *mut pixel,
                                    p_fenc: [0 as *mut pixel; 3],
                                    integral: 0 as *mut uint16_t,
                                    i_stride: [0; 3],
                                    mvp: [0; 2],
                                    cost_mv: 0,
                                    cost: 0,
                                    mv: [0; 2],
                                },
                                me8x8: [x264_me_t {
                                    i_pixel: 0,
                                    p_cost_mv: 0 as *mut uint16_t,
                                    i_ref_cost: 0,
                                    i_ref: 0,
                                    weight: 0 as *const x264_weight_t,
                                    p_fref: [0 as *mut pixel; 12],
                                    p_fref_w: 0 as *mut pixel,
                                    p_fenc: [0 as *mut pixel; 3],
                                    integral: 0 as *mut uint16_t,
                                    i_stride: [0; 3],
                                    mvp: [0; 2],
                                    cost_mv: 0,
                                    cost: 0,
                                    mv: [0; 2],
                                }; 4],
                                me4x4: [[x264_me_t {
                                    i_pixel: 0,
                                    p_cost_mv: 0 as *mut uint16_t,
                                    i_ref_cost: 0,
                                    i_ref: 0,
                                    weight: 0 as *const x264_weight_t,
                                    p_fref: [0 as *mut pixel; 12],
                                    p_fref_w: 0 as *mut pixel,
                                    p_fenc: [0 as *mut pixel; 3],
                                    integral: 0 as *mut uint16_t,
                                    i_stride: [0; 3],
                                    mvp: [0; 2],
                                    cost_mv: 0,
                                    cost: 0,
                                    mv: [0; 2],
                                }; 4]; 4],
                                me8x4: [[x264_me_t {
                                    i_pixel: 0,
                                    p_cost_mv: 0 as *mut uint16_t,
                                    i_ref_cost: 0,
                                    i_ref: 0,
                                    weight: 0 as *const x264_weight_t,
                                    p_fref: [0 as *mut pixel; 12],
                                    p_fref_w: 0 as *mut pixel,
                                    p_fenc: [0 as *mut pixel; 3],
                                    integral: 0 as *mut uint16_t,
                                    i_stride: [0; 3],
                                    mvp: [0; 2],
                                    cost_mv: 0,
                                    cost: 0,
                                    mv: [0; 2],
                                }; 2]; 4],
                                me4x8: [[x264_me_t {
                                    i_pixel: 0,
                                    p_cost_mv: 0 as *mut uint16_t,
                                    i_ref_cost: 0,
                                    i_ref: 0,
                                    weight: 0 as *const x264_weight_t,
                                    p_fref: [0 as *mut pixel; 12],
                                    p_fref_w: 0 as *mut pixel,
                                    p_fenc: [0 as *mut pixel; 3],
                                    integral: 0 as *mut uint16_t,
                                    i_stride: [0; 3],
                                    mvp: [0; 2],
                                    cost_mv: 0,
                                    cost: 0,
                                    mv: [0; 2],
                                }; 2]; 4],
                                me16x8: [x264_me_t {
                                    i_pixel: 0,
                                    p_cost_mv: 0 as *mut uint16_t,
                                    i_ref_cost: 0,
                                    i_ref: 0,
                                    weight: 0 as *const x264_weight_t,
                                    p_fref: [0 as *mut pixel; 12],
                                    p_fref_w: 0 as *mut pixel,
                                    p_fenc: [0 as *mut pixel; 3],
                                    integral: 0 as *mut uint16_t,
                                    i_stride: [0; 3],
                                    mvp: [0; 2],
                                    cost_mv: 0,
                                    cost: 0,
                                    mv: [0; 2],
                                }; 2],
                                me8x16: [x264_me_t {
                                    i_pixel: 0,
                                    p_cost_mv: 0 as *mut uint16_t,
                                    i_ref_cost: 0,
                                    i_ref: 0,
                                    weight: 0 as *const x264_weight_t,
                                    p_fref: [0 as *mut pixel; 12],
                                    p_fref_w: 0 as *mut pixel,
                                    p_fenc: [0 as *mut pixel; 3],
                                    integral: 0 as *mut uint16_t,
                                    i_stride: [0; 3],
                                    mvp: [0; 2],
                                    cost_mv: 0,
                                    cost: 0,
                                    mv: [0; 2],
                                }; 2],
                                i_rd16x16: 0,
                                i_cost8x8: 0,
                                i_cost4x4: [0; 4],
                                i_cost8x4: [0; 4],
                                i_cost4x8: [0; 4],
                                i_cost16x8: 0,
                                i_cost8x16: 0,
                                mvc: [[[0; 2]; 6]; 32],
                            },
                            i_cost16x16bi: 0,
                            i_cost16x16direct: 0,
                            i_cost8x8bi: 0,
                            i_cost8x8direct: [0; 4],
                            i_satd8x8: [[0; 4]; 3],
                            i_cost_est16x8: [0; 2],
                            i_cost_est8x16: [0; 2],
                            i_cost16x8bi: 0,
                            i_cost8x16bi: 0,
                            i_rd16x16bi: 0,
                            i_rd16x16direct: 0,
                            i_rd16x8bi: 0,
                            i_rd8x16bi: 0,
                            i_rd8x8bi: 0,
                            i_mb_partition16x8: [0; 2],
                            i_mb_partition8x16: [0; 2],
                            i_mb_type16x8: 0,
                            i_mb_type8x16: 0,
                            b_direct_available: 0,
                            b_early_terminate: 0,
                        };
                        lowres_context_init(h, &mut a);
                        slicetype_frame_cost(
                            h, &mut a, &mut fenc, 0 as c_int, 0 as c_int, 0 as c_int,
                        );
                    }
                    mcbuf = weight_cost_init_luma(h, fenc, ref_0, (*h).mb.p_weight_buf[0]);
                    minscore = weight_cost_luma(h, fenc, mcbuf, 0 as *mut x264_weight_t);
                    origscore = minscore;
                } else if (*(*h).sps.as_mut_ptr()).i_chroma_format_idc == CHROMA_444 as c_int {
                    mcbuf = weight_cost_init_chroma444(
                        h,
                        fenc,
                        ref_0,
                        (*h).mb.p_weight_buf[0],
                        plane_0,
                    );
                    minscore =
                        weight_cost_chroma444(h, fenc, mcbuf, 0 as *mut x264_weight_t, plane_0);
                    origscore = minscore;
                } else {
                    let mut dstu: *mut pixel = (*h).mb.p_weight_buf[0];
                    let mut dstv: *mut pixel = (*h).mb.p_weight_buf[0]
                        .offset(((*fenc).i_stride[1] * (*fenc).i_lines[1]) as isize);
                    let fresh14 = chroma_initted;
                    chroma_initted = chroma_initted + 1;
                    if fresh14 == 0 {
                        weight_cost_init_chroma(h, fenc, ref_0, dstu, dstv);
                    }
                    mcbuf = if plane_0 == 1 as c_int { dstu } else { dstv };
                    minscore = weight_cost_chroma(h, fenc, mcbuf, 0 as *mut x264_weight_t);
                    origscore = minscore;
                }
                if !(minscore == 0) {
                    pub static mut weight_check_distance: [[uint8_t; 2]; 12] = [
                        [0 as c_int as uint8_t, 0 as c_int as uint8_t],
                        [0 as c_int as uint8_t, 0 as c_int as uint8_t],
                        [0 as c_int as uint8_t, 1 as c_int as uint8_t],
                        [0 as c_int as uint8_t, 1 as c_int as uint8_t],
                        [0 as c_int as uint8_t, 1 as c_int as uint8_t],
                        [0 as c_int as uint8_t, 1 as c_int as uint8_t],
                        [0 as c_int as uint8_t, 1 as c_int as uint8_t],
                        [1 as c_int as uint8_t, 1 as c_int as uint8_t],
                        [1 as c_int as uint8_t, 1 as c_int as uint8_t],
                        [2 as c_int as uint8_t, 1 as c_int as uint8_t],
                        [2 as c_int as uint8_t, 1 as c_int as uint8_t],
                        [4 as c_int as uint8_t, 2 as c_int as uint8_t],
                    ];
                    let mut scale_dist: c_int = if b_lookahead != 0 {
                        0 as c_int
                    } else {
                        weight_check_distance[(*h).param.analyse.i_subpel_refine as usize][0]
                            as c_int
                    };
                    let mut offset_dist: c_int = if b_lookahead != 0 {
                        0 as c_int
                    } else {
                        weight_check_distance[(*h).param.analyse.i_subpel_refine as usize][1]
                            as c_int
                    };
                    let mut start_scale: c_int =
                        x264_clip3(minscale - scale_dist, 0 as c_int, 127 as c_int);
                    let mut end_scale: c_int =
                        x264_clip3(minscale + scale_dist, 0 as c_int, 127 as c_int);
                    let mut i_scale: c_int = start_scale;
                    while i_scale <= end_scale {
                        let mut cur_scale: c_int = i_scale;
                        let mut cur_offset: c_int = (fenc_mean[plane_0 as usize]
                            - ref_mean[plane_0 as usize] * cur_scale as c_float
                                / ((1 as c_int) << mindenom) as c_float
                            + 0.5f32 * b_lookahead as c_float)
                            as c_int;
                        if cur_offset < -(128 as c_int) || cur_offset > 127 as c_int {
                            cur_offset = x264_clip3(cur_offset, -(128 as c_int), 127 as c_int);
                            cur_scale = x264_clip3f(
                                (((1 as c_int) << mindenom) as c_float
                                    * (fenc_mean[plane_0 as usize] - cur_offset as c_float)
                                    / ref_mean[plane_0 as usize]
                                    + 0.5f32) as c_double,
                                0 as c_int as c_double,
                                127 as c_int as c_double,
                            ) as c_int;
                        }
                        let mut start_offset: c_int =
                            x264_clip3(cur_offset - offset_dist, -(128 as c_int), 127 as c_int);
                        let mut end_offset: c_int =
                            x264_clip3(cur_offset + offset_dist, -(128 as c_int), 127 as c_int);
                        let mut i_off: c_int = start_offset;
                        while i_off <= end_offset {
                            (*weights.offset(plane_0 as isize)).i_scale = cur_scale as int32_t;
                            (*weights.offset(plane_0 as isize)).i_denom = mindenom as int32_t;
                            (*weights.offset(plane_0 as isize)).i_offset = i_off as int32_t;
                            (*h).mc.weight_cache.expect("non-null function pointer")(
                                h,
                                &mut *weights.offset(plane_0 as isize),
                            );
                            let mut s: c_uint = 0;
                            if plane_0 != 0 {
                                if (*(*h).sps.as_mut_ptr()).i_chroma_format_idc
                                    == CHROMA_444 as c_int
                                {
                                    s = weight_cost_chroma444(
                                        h,
                                        fenc,
                                        mcbuf,
                                        &mut *weights.offset(plane_0 as isize),
                                        plane_0,
                                    );
                                } else {
                                    s = weight_cost_chroma(
                                        h,
                                        fenc,
                                        mcbuf,
                                        &mut *weights.offset(plane_0 as isize),
                                    );
                                }
                            } else {
                                s = weight_cost_luma(
                                    h,
                                    fenc,
                                    mcbuf,
                                    &mut *weights.offset(plane_0 as isize),
                                );
                            }
                            if s < minscore {
                                minscore = s;
                                minscale = cur_scale;
                                minoff = i_off;
                                found = 1 as c_int;
                            }
                            if minoff == start_offset && i_off != start_offset {
                                break;
                            }
                            i_off += 1;
                        }
                        i_scale += 1;
                    }
                    if plane_0 == 0 {
                        while mindenom > 0 as c_int && minscale & 1 as c_int == 0 {
                            mindenom -= 1;
                            minscale >>= 1 as c_int;
                        }
                    }
                    if found == 0
                        || minscale == (1 as c_int) << mindenom && minoff == 0 as c_int
                        || minscore as c_float / origscore as c_float > 0.998f32
                    {
                        (*weights.offset(plane_0 as isize)).i_scale = 1 as c_int as int32_t;
                        (*weights.offset(plane_0 as isize)).i_denom = 0 as c_int as int32_t;
                        (*weights.offset(plane_0 as isize)).i_offset = 0 as c_int as int32_t;
                        let ref mut fresh16 = (*weights.offset(plane_0 as isize)).weightfn;
                        *fresh16 = 0 as *mut weight_fn_t;
                    } else {
                        (*weights.offset(plane_0 as isize)).i_scale = minscale as int32_t;
                        (*weights.offset(plane_0 as isize)).i_denom = mindenom as int32_t;
                        (*weights.offset(plane_0 as isize)).i_offset = minoff as int32_t;
                        (*h).mc.weight_cache.expect("non-null function pointer")(
                            h,
                            &mut *weights.offset(plane_0 as isize),
                        );
                        if (*h).param.analyse.i_weighted_pred == X264_WEIGHTP_FAKE
                            && !(*weights.offset(0)).weightfn.is_null()
                            && plane_0 == 0
                        {
                            (*fenc).f_weighted_cost_delta[i_delta_index as usize] =
                                minscore as c_float / origscore as c_float;
                        }
                    }
                }
            }
            plane_0 += 1;
        }
        if !(*weights.offset(1)).weightfn.is_null() || !(*weights.offset(2)).weightfn.is_null() {
            let mut denom: c_int = if !(*weights.offset(1)).weightfn.is_null() {
                (*weights.offset(1)).i_denom as c_int
            } else {
                (*weights.offset(2)).i_denom as c_int
            };
            let mut both_weighted: c_int = (!(*weights.offset(1)).weightfn.is_null()
                && !(*weights.offset(2)).weightfn.is_null())
                as c_int;
            while both_weighted == 0 && denom == 7 as c_int
                || denom > 0 as c_int
                    && !(!(*weights.offset(1)).weightfn.is_null()
                        && (*weights.offset(1)).i_scale & 1 as int32_t != 0)
                    && !(!(*weights.offset(2)).weightfn.is_null()
                        && (*weights.offset(2)).i_scale & 1 as int32_t != 0)
            {
                denom -= 1;
                let mut i: c_int = 1 as c_int;
                while i <= 2 as c_int {
                    if !(*weights.offset(i as isize)).weightfn.is_null() {
                        (*weights.offset(i as isize)).i_scale >>= 1 as c_int;
                        (*weights.offset(i as isize)).i_denom = denom as int32_t;
                    }
                    i += 1;
                }
            }
        }
        let mut i_0: c_int = 1 as c_int;
        while i_0 <= 2 as c_int {
            if !(*weights.offset(i_0 as isize)).weightfn.is_null() {
                (*h).mc.weight_cache.expect("non-null function pointer")(
                    h,
                    &mut *weights.offset(i_0 as isize),
                );
            }
            i_0 += 1;
        }
        if !(*weights.offset(0)).weightfn.is_null() && b_lookahead != 0 {
            let mut src: *mut pixel = (*ref_0).buffer_lowres;
            let mut dst: *mut pixel = (*h).mb.p_weight_buf[0];
            let mut width: c_int = (*ref_0).i_width_lowres
                + ((if 32 as c_int > 64 as c_int / ::core::mem::size_of::<pixel>() as c_int {
                    32 as c_int
                } else {
                    64 as c_int / ::core::mem::size_of::<pixel>() as c_int
                }) + PADH);
            let mut height: c_int = (*ref_0).i_lines_lowres + PADV * 2 as c_int;
            x264_10_weight_scale_plane(
                h,
                dst,
                (*ref_0).i_stride_lowres as intptr_t,
                src,
                (*ref_0).i_stride_lowres as intptr_t,
                width,
                height,
                &mut *weights.offset(0),
            );
            (*fenc).weighted[0] = (*h).mb.p_weight_buf[0]
                .offset(
                    (if 32 as c_int > 64 as c_int / ::core::mem::size_of::<pixel>() as c_int {
                        32 as c_int
                    } else {
                        64 as c_int / ::core::mem::size_of::<pixel>() as c_int
                    }) as isize,
                )
                .offset(((*ref_0).i_stride_lowres * PADV) as isize);
        }
    }
    #[c2rust::src_loc = "505:9"]
    pub const PAD_SIZE: c_int = 32 as c_int;
    #[c2rust::src_loc = "507:9"]
    pub const NUM_INTS: c_int = 4 as c_int;
    #[c2rust::src_loc = "508:9"]
    pub const COST_EST: c_int = 0 as c_int;
    #[c2rust::src_loc = "509:9"]
    pub const COST_EST_AQ: c_int = 1 as c_int;
    #[c2rust::src_loc = "510:9"]
    pub const INTRA_MBS: c_int = 2 as c_int;
    #[c2rust::src_loc = "511:9"]
    pub const NUM_ROWS: c_int = 3 as c_int;
    #[c2rust::src_loc = "514:1"]
    pub unsafe extern "C" fn slicetype_mb_cost(
        mut h: *mut x264_t,
        mut a: *mut x264_mb_analysis_t,
        mut frames: *mut *mut x264_frame_t,
        mut p0: c_int,
        mut p1: c_int,
        mut b: c_int,
        mut dist_scale_factor: c_int,
        mut do_search: *mut c_int,
        mut w: *const x264_weight_t,
        mut output_inter: *mut c_int,
        mut output_intra: *mut c_int,
    ) {
        let mut mv_range: c_int = 0;
        let mut fref0: *mut x264_frame_t = *frames.offset(p0 as isize);
        let mut fref1: *mut x264_frame_t = *frames.offset(p1 as isize);
        let mut fenc: *mut x264_frame_t = *frames.offset(b as isize);
        let b_bidir: c_int = (b < p1) as c_int;
        let i_mb_x: c_int = (*h).mb.i_mb_x;
        let i_mb_y: c_int = (*h).mb.i_mb_y;
        let i_mb_stride: c_int = (*h).mb.i_mb_width;
        let i_mb_xy: c_int = i_mb_x + i_mb_y * i_mb_stride;
        let i_stride: c_int = (*fenc).i_stride_lowres;
        let i_pel_offset: c_int = 8 as c_int * (i_mb_x + i_mb_y * i_stride);
        let i_bipred_weight: c_int = if (*h).param.analyse.b_weighted_bipred != 0 {
            64 as c_int - (dist_scale_factor >> 2 as c_int)
        } else {
            32 as c_int
        };
        let mut fenc_mvs: [*mut [int16_t; 2]; 2] = [
            if b != p0 {
                &mut *(*(*(*fenc).lowres_mvs.as_mut_ptr().offset(0))
                    .as_mut_ptr()
                    .offset((b - p0 - 1 as c_int) as isize))
                .offset(i_mb_xy as isize) as *mut [int16_t; 2]
            } else {
                0 as *mut [int16_t; 2]
            },
            if b != p1 {
                &mut *(*(*(*fenc).lowres_mvs.as_mut_ptr().offset(1))
                    .as_mut_ptr()
                    .offset((p1 - b - 1 as c_int) as isize))
                .offset(i_mb_xy as isize) as *mut [int16_t; 2]
            } else {
                0 as *mut [int16_t; 2]
            },
        ];
        let mut fenc_costs: [*mut c_int; 2] = [
            if b != p0 {
                &mut *(*(*(*fenc).lowres_mv_costs.as_mut_ptr().offset(0))
                    .as_mut_ptr()
                    .offset((b - p0 - 1 as c_int) as isize))
                .offset(i_mb_xy as isize) as *mut c_int
            } else {
                0 as *mut c_int
            },
            if b != p1 {
                &mut *(*(*(*fenc).lowres_mv_costs.as_mut_ptr().offset(1))
                    .as_mut_ptr()
                    .offset((p1 - b - 1 as c_int) as isize))
                .offset(i_mb_xy as isize) as *mut c_int
            } else {
                0 as *mut c_int
            },
        ];
        let mut b_frame_score_mb: c_int = (i_mb_x > 0 as c_int
            && i_mb_x < (*h).mb.i_mb_width - 1 as c_int
            && i_mb_y > 0 as c_int
            && i_mb_y < (*h).mb.i_mb_height - 1 as c_int
            || (*h).mb.i_mb_width <= 2 as c_int
            || (*h).mb.i_mb_height <= 2 as c_int)
            as c_int;
        let mut pix1: [pixel; 288] = [0; 288];
        let mut pix2: *mut pixel = pix1.as_mut_ptr().offset(8);
        let mut m: [x264_me_t; 2] = [x264_me_t {
            i_pixel: 0,
            p_cost_mv: 0 as *mut uint16_t,
            i_ref_cost: 0,
            i_ref: 0,
            weight: 0 as *const x264_weight_t,
            p_fref: [0 as *mut pixel; 12],
            p_fref_w: 0 as *mut pixel,
            p_fenc: [0 as *mut pixel; 3],
            integral: 0 as *mut uint16_t,
            i_stride: [0; 3],
            mvp: [0; 2],
            cost_mv: 0,
            cost: 0,
            mv: [0; 2],
        }; 2];
        let mut i_bcost: c_int = COST_MAX;
        let mut list_used: c_int = 0 as c_int;
        let mut lowres_penalty: c_int = 4 as c_int;
        (*h).mb.pic.p_fenc[0] = (*h).mb.pic.fenc_buf.as_mut_ptr();
        (*h).mc.copy[PIXEL_8x8 as c_int as usize].expect("non-null function pointer")(
            (*h).mb.pic.p_fenc[0],
            FENC_STRIDE as intptr_t,
            &mut *(*(*fenc).lowres.as_mut_ptr().offset(0)).offset(i_pel_offset as isize),
            i_stride as intptr_t,
            8 as c_int,
        );
        if !(p0 == p1) {
            mv_range = 2 as c_int * (*h).param.analyse.i_mv_range;
            (*h).mb.mv_min_spel[0] =
                if 4 as c_int * (-(8 as c_int) * (*h).mb.i_mb_x - 12 as c_int) > -mv_range {
                    4 as c_int * (-(8 as c_int) * (*h).mb.i_mb_x - 12 as c_int)
                } else {
                    -mv_range
                };
            (*h).mb.mv_max_spel[0] = if 4 as c_int
                * (8 as c_int * ((*h).mb.i_mb_width - (*h).mb.i_mb_x - 1 as c_int) + 12 as c_int)
                < mv_range - 1 as c_int
            {
                4 as c_int
                    * (8 as c_int * ((*h).mb.i_mb_width - (*h).mb.i_mb_x - 1 as c_int)
                        + 12 as c_int)
            } else {
                mv_range - 1 as c_int
            };
            (*h).mb.mv_limit_fpel[0][0] = ((*h).mb.mv_min_spel[0] >> 2 as c_int) as int16_t;
            (*h).mb.mv_limit_fpel[1][0] = ((*h).mb.mv_max_spel[0] >> 2 as c_int) as int16_t;
            if (*h).mb.i_mb_x >= (*h).mb.i_mb_width - 2 as c_int {
                (*h).mb.mv_min_spel[1] =
                    if 4 as c_int * (-(8 as c_int) * (*h).mb.i_mb_y - 12 as c_int) > -mv_range {
                        4 as c_int * (-(8 as c_int) * (*h).mb.i_mb_y - 12 as c_int)
                    } else {
                        -mv_range
                    };
                (*h).mb.mv_max_spel[1] = if 4 as c_int
                    * (8 as c_int * ((*h).mb.i_mb_height - (*h).mb.i_mb_y - 1 as c_int)
                        + 12 as c_int)
                    < mv_range - 1 as c_int
                {
                    4 as c_int
                        * (8 as c_int * ((*h).mb.i_mb_height - (*h).mb.i_mb_y - 1 as c_int)
                            + 12 as c_int)
                } else {
                    mv_range - 1 as c_int
                };
                (*h).mb.mv_limit_fpel[0][1] = ((*h).mb.mv_min_spel[1] >> 2 as c_int) as int16_t;
                (*h).mb.mv_limit_fpel[1][1] = ((*h).mb.mv_max_spel[1] >> 2 as c_int) as int16_t;
            }
            m[0].i_pixel = PIXEL_8x8 as c_int;
            m[0].p_cost_mv = (*a).p_cost_mv;
            m[0].i_stride[0] = i_stride;
            m[0].p_fenc[0] = (*h).mb.pic.p_fenc[0];
            m[0].weight = w;
            m[0].i_ref = 0 as c_int;
            m[0].p_fref[0] = &mut *(*(*fref0).lowres.as_mut_ptr().offset(0))
                .offset(i_pel_offset as isize) as *mut pixel;
            m[0].p_fref[1] = &mut *(*(*fref0).lowres.as_mut_ptr().offset(1))
                .offset(i_pel_offset as isize) as *mut pixel;
            m[0].p_fref[2] = &mut *(*(*fref0).lowres.as_mut_ptr().offset(2))
                .offset(i_pel_offset as isize) as *mut pixel;
            m[0].p_fref[3] = &mut *(*(*fref0).lowres.as_mut_ptr().offset(3))
                .offset(i_pel_offset as isize) as *mut pixel;
            m[0].p_fref_w = m[0].p_fref[0];
            if !(*w.offset(0)).weightfn.is_null() {
                m[0].p_fref_w = &mut *(*(*fenc).weighted.as_mut_ptr().offset(0))
                    .offset(i_pel_offset as isize) as *mut pixel;
            }
            if b_bidir != 0 {
                let mut dmv: [[int16_t; 2]; 2] = [[0; 2]; 2];
                m[1].i_pixel = PIXEL_8x8 as c_int;
                m[1].p_cost_mv = (*a).p_cost_mv;
                m[1].i_stride[0] = i_stride;
                m[1].p_fenc[0] = (*h).mb.pic.p_fenc[0];
                m[1].i_ref = 0 as c_int;
                m[1].weight = x264_zero.as_mut_ptr() as *const x264_weight_t;
                m[1].p_fref[0] = &mut *(*(*fref1).lowres.as_mut_ptr().offset(0))
                    .offset(i_pel_offset as isize) as *mut pixel;
                m[1].p_fref[1] = &mut *(*(*fref1).lowres.as_mut_ptr().offset(1))
                    .offset(i_pel_offset as isize) as *mut pixel;
                m[1].p_fref[2] = &mut *(*(*fref1).lowres.as_mut_ptr().offset(2))
                    .offset(i_pel_offset as isize) as *mut pixel;
                m[1].p_fref[3] = &mut *(*(*fref1).lowres.as_mut_ptr().offset(3))
                    .offset(i_pel_offset as isize) as *mut pixel;
                m[1].p_fref_w = m[1].p_fref[0];
                if (*(*fref1).lowres_mvs[0][(p1 - p0 - 1 as c_int) as usize].offset(0))[0] as c_int
                    != 0x7fff as c_int
                {
                    let mut mvr: *mut int16_t = (*(*(*(*fref1).lowres_mvs.as_mut_ptr().offset(0))
                        .as_mut_ptr()
                        .offset((p1 - p0 - 1 as c_int) as isize))
                    .offset(i_mb_xy as isize))
                    .as_mut_ptr();
                    dmv[0][0] = (*mvr.offset(0) as c_int * dist_scale_factor + 128 as c_int
                        >> 8 as c_int) as int16_t;
                    dmv[0][1] = (*mvr.offset(1) as c_int * dist_scale_factor + 128 as c_int
                        >> 8 as c_int) as int16_t;
                    dmv[1][0] = (dmv[0][0] as c_int - *mvr.offset(0) as c_int) as int16_t;
                    dmv[1][1] = (dmv[0][1] as c_int - *mvr.offset(1) as c_int) as int16_t;
                    dmv[0][0] = x264_clip3(
                        dmv[0][0] as c_int,
                        (*h).mb.mv_min_spel[0],
                        (*h).mb.mv_max_spel[0],
                    ) as int16_t;
                    dmv[0][1] = x264_clip3(
                        dmv[0][1] as c_int,
                        (*h).mb.mv_min_spel[1],
                        (*h).mb.mv_max_spel[1],
                    ) as int16_t;
                    dmv[1][0] = x264_clip3(
                        dmv[1][0] as c_int,
                        (*h).mb.mv_min_spel[0],
                        (*h).mb.mv_max_spel[0],
                    ) as int16_t;
                    dmv[1][1] = x264_clip3(
                        dmv[1][1] as c_int,
                        (*h).mb.mv_min_spel[1],
                        (*h).mb.mv_max_spel[1],
                    ) as int16_t;
                    if (*h).param.analyse.i_subpel_refine <= 1 as c_int {
                        let ref mut fresh20 = (*(dmv.as_mut_ptr() as *mut x264_union64_t)).i;
                        *fresh20 = (*fresh20 as c_ulonglong & !(0x1000100010001 as c_ulonglong))
                            as uint64_t;
                    }
                } else {
                    (*(dmv.as_mut_ptr() as *mut x264_union64_t)).i = 0 as uint64_t;
                }
                let mut i_cost: c_int = 0;
                if (*h).param.analyse.i_subpel_refine <= 1 as c_int {
                    let mut hpel_idx1: c_int = ((dmv[0][0] as c_int & 2 as c_int) >> 1 as c_int)
                        + (dmv[0][1] as c_int & 2 as c_int);
                    let mut hpel_idx2: c_int = ((dmv[1][0] as c_int & 2 as c_int) >> 1 as c_int)
                        + (dmv[1][1] as c_int & 2 as c_int);
                    let mut src1: *mut pixel = m[0].p_fref[hpel_idx1 as usize]
                        .offset((dmv[0][0] as c_int >> 2 as c_int) as isize)
                        .offset(((dmv[0][1] as c_int >> 2 as c_int) * m[0].i_stride[0]) as isize);
                    let mut src2: *mut pixel = m[1].p_fref[hpel_idx2 as usize]
                        .offset((dmv[1][0] as c_int >> 2 as c_int) as isize)
                        .offset(((dmv[1][1] as c_int >> 2 as c_int) * m[1].i_stride[0]) as isize);
                    (*h).mc.avg[PIXEL_8x8 as c_int as usize].expect("non-null function pointer")(
                        pix1.as_mut_ptr(),
                        16 as intptr_t,
                        src1,
                        m[0].i_stride[0] as intptr_t,
                        src2,
                        m[1].i_stride[0] as intptr_t,
                        i_bipred_weight,
                    );
                } else {
                    let mut stride1: intptr_t = 16 as intptr_t;
                    let mut stride2: intptr_t = 16 as intptr_t;
                    let mut src1_0: *mut pixel = 0 as *mut pixel;
                    let mut src2_0: *mut pixel = 0 as *mut pixel;
                    src1_0 = (*h).mc.get_ref.expect("non-null function pointer")(
                        pix1.as_mut_ptr(),
                        &mut stride1,
                        (*m.as_mut_ptr().offset(0)).p_fref.as_mut_ptr(),
                        m[0].i_stride[0] as intptr_t,
                        dmv[0][0] as c_int,
                        dmv[0][1] as c_int,
                        8 as c_int,
                        8 as c_int,
                        w,
                    );
                    src2_0 = (*h).mc.get_ref.expect("non-null function pointer")(
                        pix2,
                        &mut stride2,
                        (*m.as_mut_ptr().offset(1)).p_fref.as_mut_ptr(),
                        m[1].i_stride[0] as intptr_t,
                        dmv[1][0] as c_int,
                        dmv[1][1] as c_int,
                        8 as c_int,
                        8 as c_int,
                        w,
                    );
                    (*h).mc.avg[PIXEL_8x8 as c_int as usize].expect("non-null function pointer")(
                        pix1.as_mut_ptr(),
                        16 as intptr_t,
                        src1_0,
                        stride1,
                        src2_0,
                        stride2,
                        i_bipred_weight,
                    );
                }
                i_cost = 0 as c_int * (*a).i_lambda
                    + (*h).pixf.mbcmp[PIXEL_8x8 as c_int as usize]
                        .expect("non-null function pointer")(
                        m[0].p_fenc[0],
                        FENC_STRIDE as intptr_t,
                        pix1.as_mut_ptr(),
                        16 as intptr_t,
                    );
                if i_cost < i_bcost {
                    i_bcost = i_cost;
                    list_used = 3 as c_int;
                }
                if (*(dmv.as_mut_ptr() as *mut x264_union64_t)).i != 0 {
                    let mut i_cost_0: c_int = 0;
                    (*h).mc.avg[PIXEL_8x8 as c_int as usize].expect("non-null function pointer")(
                        pix1.as_mut_ptr(),
                        16 as intptr_t,
                        m[0].p_fref[0],
                        m[0].i_stride[0] as intptr_t,
                        m[1].p_fref[0],
                        m[1].i_stride[0] as intptr_t,
                        i_bipred_weight,
                    );
                    i_cost_0 = (*h).pixf.mbcmp[PIXEL_8x8 as c_int as usize]
                        .expect("non-null function pointer")(
                        m[0].p_fenc[0],
                        FENC_STRIDE as intptr_t,
                        pix1.as_mut_ptr(),
                        16 as intptr_t,
                    );
                    if i_cost_0 < i_bcost {
                        i_bcost = i_cost_0;
                        list_used = 3 as c_int;
                    }
                }
            }
            let mut l: c_int = 0 as c_int;
            while l < 1 as c_int + b_bidir {
                if *do_search.offset(l as isize) != 0 {
                    let mut current_block_117: u64;
                    let mut i_mvc: c_int = 0 as c_int;
                    let mut fenc_mv: *mut [int16_t; 2] = fenc_mvs[l as usize];
                    let mut mvc: [[int16_t; 2]; 4] = [[0; 2]; 4];
                    (*((*mvc.as_mut_ptr().offset(0)).as_mut_ptr() as *mut x264_union32_t)).i =
                        0 as uint32_t;
                    (*((*mvc.as_mut_ptr().offset(2)).as_mut_ptr() as *mut x264_union32_t)).i =
                        0 as uint32_t;
                    if i_mb_x < (*h).mb.i_mb_width - 1 as c_int {
                        (*((*mvc.as_mut_ptr().offset(i_mvc as isize)).as_mut_ptr()
                            as *mut x264_union32_t))
                            .i = (*((*fenc_mv.offset(1)).as_mut_ptr() as *mut x264_union32_t)).i;
                        i_mvc += 1;
                    }
                    if i_mb_y < (*h).i_threadslice_end - 1 as c_int {
                        (*((*mvc.as_mut_ptr().offset(i_mvc as isize)).as_mut_ptr()
                            as *mut x264_union32_t))
                            .i = (*((*fenc_mv.offset(i_mb_stride as isize)).as_mut_ptr()
                            as *mut x264_union32_t))
                            .i;
                        i_mvc += 1;
                        if i_mb_x > 0 as c_int {
                            (*((*mvc.as_mut_ptr().offset(i_mvc as isize)).as_mut_ptr()
                                as *mut x264_union32_t))
                                .i = (*((*fenc_mv.offset((i_mb_stride - 1 as c_int) as isize))
                                .as_mut_ptr()
                                as *mut x264_union32_t))
                                .i;
                            i_mvc += 1;
                        }
                        if i_mb_x < (*h).mb.i_mb_width - 1 as c_int {
                            (*((*mvc.as_mut_ptr().offset(i_mvc as isize)).as_mut_ptr()
                                as *mut x264_union32_t))
                                .i = (*((*fenc_mv.offset((i_mb_stride + 1 as c_int) as isize))
                                .as_mut_ptr()
                                as *mut x264_union32_t))
                                .i;
                            i_mvc += 1;
                        }
                    }
                    if i_mvc <= 1 as c_int {
                        (*((*m.as_mut_ptr().offset(l as isize)).mvp.as_mut_ptr()
                            as *mut x264_union32_t))
                            .i = (*((*mvc.as_mut_ptr().offset(0)).as_mut_ptr()
                            as *mut x264_union32_t))
                            .i;
                    } else {
                        x264_median_mv(
                            (*m.as_mut_ptr().offset(l as isize)).mvp.as_mut_ptr(),
                            (*mvc.as_mut_ptr().offset(0)).as_mut_ptr(),
                            (*mvc.as_mut_ptr().offset(1)).as_mut_ptr(),
                            (*mvc.as_mut_ptr().offset(2)).as_mut_ptr(),
                        );
                    }
                    if (*((*m.as_mut_ptr().offset(l as isize)).mvp.as_mut_ptr()
                        as *mut x264_union32_t))
                        .i
                        == 0
                    {
                        m[l as usize].cost = (*h).pixf.mbcmp[PIXEL_8x8 as c_int as usize]
                            .expect("non-null function pointer")(
                            m[l as usize].p_fenc[0],
                            FENC_STRIDE as intptr_t,
                            m[l as usize].p_fref[0],
                            m[l as usize].i_stride[0] as intptr_t,
                        );
                        if m[l as usize].cost < 64 as c_int {
                            (*((*m.as_mut_ptr().offset(l as isize)).mv.as_mut_ptr()
                                as *mut x264_union32_t))
                                .i = 0 as uint32_t;
                            current_block_117 = 8572148166097892831;
                        } else {
                            current_block_117 = 17958840340921835115;
                        }
                    } else {
                        current_block_117 = 17958840340921835115;
                    }
                    match current_block_117 {
                        17958840340921835115 => {
                            x264_10_me_search_ref(
                                h,
                                &mut *m.as_mut_ptr().offset(l as isize),
                                mvc.as_mut_ptr() as *mut [int16_t; 2],
                                i_mvc,
                                0 as *mut c_int,
                            );
                            m[l as usize].cost -= *(*a).p_cost_mv.offset(0) as c_int;
                            if (*((*m.as_mut_ptr().offset(l as isize)).mv.as_mut_ptr()
                                as *mut x264_union32_t))
                                .i
                                != 0
                            {
                                m[l as usize].cost += 5 as c_int * (*a).i_lambda;
                            }
                        }
                        _ => {}
                    }
                    (*(fenc_mvs[l as usize] as *mut x264_union32_t)).i =
                        (*((*m.as_mut_ptr().offset(l as isize)).mv.as_mut_ptr()
                            as *mut x264_union32_t))
                            .i;
                    *fenc_costs[l as usize] = m[l as usize].cost as c_int;
                } else {
                    (*((*m.as_mut_ptr().offset(l as isize)).mv.as_mut_ptr()
                        as *mut x264_union32_t))
                        .i = (*(fenc_mvs[l as usize] as *mut x264_union32_t)).i;
                    m[l as usize].cost = *fenc_costs[l as usize] as c_int;
                }
                if m[l as usize].cost < i_bcost {
                    i_bcost = m[l as usize].cost;
                    list_used = l + 1 as c_int;
                }
                l += 1;
            }
            if b_bidir != 0
                && ((*((*m.as_mut_ptr().offset(0)).mv.as_mut_ptr() as *mut x264_union32_t)).i != 0
                    || (*((*m.as_mut_ptr().offset(1)).mv.as_mut_ptr() as *mut x264_union32_t)).i
                        != 0)
            {
                let mut i_cost_1: c_int = 0;
                if (*h).param.analyse.i_subpel_refine <= 1 as c_int {
                    let mut hpel_idx1_0: c_int = ((m[0].mv[0] as c_int & 2 as c_int) >> 1 as c_int)
                        + (m[0].mv[1] as c_int & 2 as c_int);
                    let mut hpel_idx2_0: c_int = ((m[1].mv[0] as c_int & 2 as c_int) >> 1 as c_int)
                        + (m[1].mv[1] as c_int & 2 as c_int);
                    let mut src1_1: *mut pixel = m[0].p_fref[hpel_idx1_0 as usize]
                        .offset((m[0].mv[0] as c_int >> 2 as c_int) as isize)
                        .offset(((m[0].mv[1] as c_int >> 2 as c_int) * m[0].i_stride[0]) as isize);
                    let mut src2_1: *mut pixel = m[1].p_fref[hpel_idx2_0 as usize]
                        .offset((m[1].mv[0] as c_int >> 2 as c_int) as isize)
                        .offset(((m[1].mv[1] as c_int >> 2 as c_int) * m[1].i_stride[0]) as isize);
                    (*h).mc.avg[PIXEL_8x8 as c_int as usize].expect("non-null function pointer")(
                        pix1.as_mut_ptr(),
                        16 as intptr_t,
                        src1_1,
                        m[0].i_stride[0] as intptr_t,
                        src2_1,
                        m[1].i_stride[0] as intptr_t,
                        i_bipred_weight,
                    );
                } else {
                    let mut stride1_0: intptr_t = 16 as intptr_t;
                    let mut stride2_0: intptr_t = 16 as intptr_t;
                    let mut src1_2: *mut pixel = 0 as *mut pixel;
                    let mut src2_2: *mut pixel = 0 as *mut pixel;
                    src1_2 = (*h).mc.get_ref.expect("non-null function pointer")(
                        pix1.as_mut_ptr(),
                        &mut stride1_0,
                        (*m.as_mut_ptr().offset(0)).p_fref.as_mut_ptr(),
                        m[0].i_stride[0] as intptr_t,
                        m[0].mv[0] as c_int,
                        m[0].mv[1] as c_int,
                        8 as c_int,
                        8 as c_int,
                        w,
                    );
                    src2_2 = (*h).mc.get_ref.expect("non-null function pointer")(
                        pix2,
                        &mut stride2_0,
                        (*m.as_mut_ptr().offset(1)).p_fref.as_mut_ptr(),
                        m[1].i_stride[0] as intptr_t,
                        m[1].mv[0] as c_int,
                        m[1].mv[1] as c_int,
                        8 as c_int,
                        8 as c_int,
                        w,
                    );
                    (*h).mc.avg[PIXEL_8x8 as c_int as usize].expect("non-null function pointer")(
                        pix1.as_mut_ptr(),
                        16 as intptr_t,
                        src1_2,
                        stride1_0,
                        src2_2,
                        stride2_0,
                        i_bipred_weight,
                    );
                }
                i_cost_1 = 5 as c_int * (*a).i_lambda
                    + (*h).pixf.mbcmp[PIXEL_8x8 as c_int as usize]
                        .expect("non-null function pointer")(
                        m[0].p_fenc[0],
                        FENC_STRIDE as intptr_t,
                        pix1.as_mut_ptr(),
                        16 as intptr_t,
                    );
                if i_cost_1 < i_bcost {
                    i_bcost = i_cost_1;
                    list_used = 3 as c_int;
                }
            }
        }
        if (*fenc).b_intra_calculated == 0 {
            let mut edge: [pixel; 36] = [0; 36];
            let mut pix: *mut pixel = &mut *pix1
                .as_mut_ptr()
                .offset((8 as c_int + FDEC_STRIDE) as isize)
                as *mut pixel;
            let mut src: *mut pixel = &mut *(*(*fenc).lowres.as_mut_ptr().offset(0))
                .offset(i_pel_offset as isize) as *mut pixel;
            let intra_penalty: c_int = 5 as c_int * (*a).i_lambda;
            let mut satds: [c_int; 3] = [0; 3];
            let mut pixoff: c_int = 4 as c_int / SIZEOF_PIXEL;
            memcpy(
                pix.offset(-(FDEC_STRIDE as isize)) as *mut c_void,
                src.offset(-(i_stride as isize)) as *const c_void,
                (16 as c_int * SIZEOF_PIXEL) as size_t,
            );
            let mut i: c_int = -1;
            while i < 8 as c_int {
                (*(&mut *pix.offset((i * 32 as c_int - pixoff) as isize) as *mut pixel
                    as *mut x264_union32_t))
                    .i = (*(&mut *src.offset((i * i_stride - pixoff) as isize) as *mut pixel
                    as *mut x264_union32_t))
                    .i;
                i += 1;
            }
            (*h).pixf
                .intra_mbcmp_x3_8x8c
                .expect("non-null function pointer")(
                (*h).mb.pic.p_fenc[0],
                pix,
                satds.as_mut_ptr(),
            );
            let mut i_icost: c_int = if satds[0]
                < (if satds[1] < satds[2] {
                    satds[1]
                } else {
                    satds[2]
                }) {
                satds[0]
            } else if satds[1] < satds[2] {
                satds[1]
            } else {
                satds[2]
            };
            if (*h).param.analyse.i_subpel_refine > 1 as c_int {
                (*h).predict_8x8c[I_PRED_CHROMA_P as c_int as usize]
                    .expect("non-null function pointer")(pix);
                let mut satd: c_int = (*h).pixf.mbcmp[PIXEL_8x8 as c_int as usize]
                    .expect("non-null function pointer")(
                    (*h).mb.pic.p_fenc[0],
                    FENC_STRIDE as intptr_t,
                    pix,
                    FDEC_STRIDE as intptr_t,
                );
                i_icost = if i_icost < satd { i_icost } else { satd };
                (*h).predict_8x8_filter.expect("non-null function pointer")(
                    pix,
                    edge.as_mut_ptr(),
                    ALL_NEIGHBORS as c_int,
                    ALL_NEIGHBORS as c_int,
                );
                let mut i_0: c_int = 3 as c_int;
                while i_0 < 9 as c_int {
                    (*h).predict_8x8[i_0 as usize].expect("non-null function pointer")(
                        pix,
                        edge.as_mut_ptr(),
                    );
                    satd = (*h).pixf.mbcmp[PIXEL_8x8 as c_int as usize]
                        .expect("non-null function pointer")(
                        (*h).mb.pic.p_fenc[0],
                        FENC_STRIDE as intptr_t,
                        pix,
                        FDEC_STRIDE as intptr_t,
                    );
                    i_icost = if i_icost < satd { i_icost } else { satd };
                    i_0 += 1;
                }
            }
            i_icost = (i_icost + intra_penalty >> BIT_DEPTH - 8 as c_int) + lowres_penalty;
            *(*fenc).i_intra_cost.offset(i_mb_xy as isize) = i_icost as uint16_t;
            let mut i_icost_aq: c_int = i_icost;
            if (*h).param.rc.i_aq_mode != 0 {
                i_icost_aq = i_icost_aq
                    * *(*fenc).i_inv_qscale_factor.offset(i_mb_xy as isize) as c_int
                    + 128 as c_int
                    >> 8 as c_int;
            }
            *output_intra
                .offset((NUM_INTS + ((*h).mb.i_mb_y - (*h).i_threadslice_start)) as isize) +=
                i_icost_aq;
            if b_frame_score_mb != 0 {
                *output_intra.offset(COST_EST as isize) += i_icost;
                *output_intra.offset(COST_EST_AQ as isize) += i_icost_aq;
            }
        }
        i_bcost = (i_bcost >> BIT_DEPTH - 8 as c_int) + lowres_penalty;
        if b_bidir == 0 {
            let mut i_icost_0: c_int = *(*fenc).i_intra_cost.offset(i_mb_xy as isize) as c_int;
            let mut b_intra: c_int = (i_icost_0 < i_bcost) as c_int;
            if b_intra != 0 {
                i_bcost = i_icost_0;
                list_used = 0 as c_int;
            }
            if b_frame_score_mb != 0 {
                *output_inter.offset(INTRA_MBS as isize) += b_intra;
            }
        }
        if p0 != p1 {
            let mut i_bcost_aq: c_int = i_bcost;
            if (*h).param.rc.i_aq_mode != 0 {
                i_bcost_aq = i_bcost_aq
                    * *(*fenc).i_inv_qscale_factor.offset(i_mb_xy as isize) as c_int
                    + 128 as c_int
                    >> 8 as c_int;
            }
            *output_inter
                .offset((NUM_INTS + ((*h).mb.i_mb_y - (*h).i_threadslice_start)) as isize) +=
                i_bcost_aq;
            if b_frame_score_mb != 0 {
                *output_inter.offset(COST_EST as isize) += i_bcost;
                *output_inter.offset(COST_EST_AQ as isize) += i_bcost_aq;
            }
        }
        *(*fenc).lowres_costs[(b - p0) as usize][(p1 - b) as usize].offset(i_mb_xy as isize) =
            ((if i_bcost < ((1 as c_int) << 14 as c_int) - 1 as c_int {
                i_bcost
            } else {
                ((1 as c_int) << 14 as c_int) - 1 as c_int
            }) + (list_used << LOWRES_COST_SHIFT)) as uint16_t;
    }
    #[c2rust::src_loc = "814:1"]
    pub unsafe extern "C" fn slicetype_slice_cost(mut s: *mut x264_slicetype_slice_t) {
        let mut h: *mut x264_t = (*s).h;
        let mut do_edges: c_int = ((*h).param.rc.b_mb_tree != 0
            || (*h).param.rc.i_vbv_buffer_size != 0
            || (*h).mb.i_mb_width <= 2 as c_int
            || (*h).mb.i_mb_height <= 2 as c_int) as c_int;
        let mut start_y: c_int = if ((*h).i_threadslice_end - 1 as c_int)
            < (*h).mb.i_mb_height - 2 as c_int + do_edges
        {
            (*h).i_threadslice_end - 1 as c_int
        } else {
            (*h).mb.i_mb_height - 2 as c_int + do_edges
        };
        let mut end_y: c_int = if (*h).i_threadslice_start > 1 as c_int - do_edges {
            (*h).i_threadslice_start
        } else {
            1 as c_int - do_edges
        };
        let mut start_x: c_int = (*h).mb.i_mb_width - 2 as c_int + do_edges;
        let mut end_x: c_int = 1 as c_int - do_edges;
        (*h).mb.i_mb_y = start_y;
        while (*h).mb.i_mb_y >= end_y {
            (*h).mb.i_mb_x = start_x;
            while (*h).mb.i_mb_x >= end_x {
                slicetype_mb_cost(
                    h,
                    (*s).a,
                    (*s).frames,
                    (*s).p0,
                    (*s).p1,
                    (*s).b,
                    (*s).dist_scale_factor,
                    (*s).do_search as *mut c_int,
                    (*s).w,
                    (*s).output_inter,
                    (*s).output_intra,
                );
                (*h).mb.i_mb_x -= 1;
            }
            (*h).mb.i_mb_y -= 1;
        }
    }
    #[c2rust::src_loc = "836:1"]
    pub unsafe extern "C" fn slicetype_frame_cost(
        mut h: *mut x264_t,
        mut a: *mut x264_mb_analysis_t,
        mut frames: *mut *mut x264_frame_t,
        mut p0: c_int,
        mut p1: c_int,
        mut b: c_int,
    ) -> c_int {
        let mut i_score: c_int = 0 as c_int;
        let mut do_search: [c_int; 2] = [0; 2];
        let mut w: *const x264_weight_t = x264_zero.as_mut_ptr() as *const x264_weight_t;
        let mut fenc: *mut x264_frame_t = *frames.offset(b as isize);
        if (*fenc).i_cost_est[(b - p0) as usize][(p1 - b) as usize] >= 0 as c_int
            && ((*h).param.rc.i_vbv_buffer_size == 0
                || *(*fenc).i_row_satds[(b - p0) as usize][(p1 - b) as usize].offset(0) != -1)
        {
            i_score = (*fenc).i_cost_est[(b - p0) as usize][(p1 - b) as usize];
        } else {
            let mut dist_scale_factor: c_int = 128 as c_int;
            do_search[0] = (b != p0
                && (*(*fenc).lowres_mvs[0][(b - p0 - 1 as c_int) as usize].offset(0))[0] as c_int
                    == 0x7fff as c_int) as c_int;
            do_search[1] = (b != p1
                && (*(*fenc).lowres_mvs[1][(p1 - b - 1 as c_int) as usize].offset(0))[0] as c_int
                    == 0x7fff as c_int) as c_int;
            if do_search[0] != 0 {
                if (*h).param.analyse.i_weighted_pred != 0 && b == p1 {
                    x264_10_weights_analyse(h, fenc, *frames.offset(p0 as isize), 1 as c_int);
                    w = (*(*fenc).weight.as_mut_ptr().offset(0)).as_mut_ptr();
                }
                (*(*fenc).lowres_mvs[0][(b - p0 - 1 as c_int) as usize].offset(0))[0] =
                    0 as int16_t;
            }
            if do_search[1] != 0 {
                (*(*fenc).lowres_mvs[1][(p1 - b - 1 as c_int) as usize].offset(0))[0] =
                    0 as int16_t;
            }
            if p1 != p0 {
                dist_scale_factor = ((b - p0 << 8 as c_int) + (p1 - p0 >> 1 as c_int)) / (p1 - p0);
            }
            let mut output_buf_size: c_int =
                (*h).mb.i_mb_height + (NUM_INTS + PAD_SIZE) * (*h).param.i_lookahead_threads;
            let mut output_inter: [*mut c_int; 17] = [0 as *mut c_int; 17];
            let mut output_intra: [*mut c_int; 17] = [0 as *mut c_int; 17];
            output_inter[0] = (*h).scratch_buffer2 as *mut c_int;
            output_intra[0] = output_inter[0].offset(output_buf_size as isize);
            if (*h).param.i_lookahead_threads > 1 as c_int {
                let mut s: [x264_slicetype_slice_t; 16] = [x264_slicetype_slice_t {
                    h: 0 as *mut x264_t,
                    a: 0 as *mut x264_mb_analysis_t,
                    frames: 0 as *mut *mut x264_frame_t,
                    p0: 0,
                    p1: 0,
                    b: 0,
                    dist_scale_factor: 0,
                    do_search: 0 as *mut c_int,
                    w: 0 as *const x264_weight_t,
                    output_inter: 0 as *mut c_int,
                    output_intra: 0 as *mut c_int,
                }; 16];
                let mut i: c_int = 0 as c_int;
                while i < (*h).param.i_lookahead_threads {
                    let mut t: *mut x264_t = (*h).lookahead_thread[i as usize];
                    (*t).mb.i_me_method = (*h).mb.i_me_method;
                    (*t).mb.i_subpel_refine = (*h).mb.i_subpel_refine;
                    (*t).mb.b_chroma_me = (*h).mb.b_chroma_me;
                    s[i as usize] = {
                        let mut init = x264_slicetype_slice_t {
                            h: t,
                            a: a,
                            frames: frames,
                            p0: p0,
                            p1: p1,
                            b: b,
                            dist_scale_factor: dist_scale_factor,
                            do_search: do_search.as_mut_ptr(),
                            w: w,
                            output_inter: output_inter[i as usize],
                            output_intra: output_intra[i as usize],
                        };
                        init
                    };
                    (*t).i_threadslice_start = ((*h).mb.i_mb_height * i
                        + (*h).param.i_lookahead_threads / 2 as c_int)
                        / (*h).param.i_lookahead_threads;
                    (*t).i_threadslice_end = ((*h).mb.i_mb_height * (i + 1 as c_int)
                        + (*h).param.i_lookahead_threads / 2 as c_int)
                        / (*h).param.i_lookahead_threads;
                    let mut thread_height: c_int =
                        (*t).i_threadslice_end - (*t).i_threadslice_start;
                    let mut thread_output_size: c_int = thread_height + NUM_INTS;
                    memset(
                        output_inter[i as usize] as *mut c_void,
                        0 as c_int,
                        (thread_output_size as size_t)
                            .wrapping_mul(::core::mem::size_of::<c_int>() as size_t),
                    );
                    memset(
                        output_intra[i as usize] as *mut c_void,
                        0 as c_int,
                        (thread_output_size as size_t)
                            .wrapping_mul(::core::mem::size_of::<c_int>() as size_t),
                    );
                    let ref mut fresh18 = *output_intra[i as usize].offset(NUM_ROWS as isize);
                    *fresh18 = thread_height;
                    *output_inter[i as usize].offset(NUM_ROWS as isize) = *fresh18;
                    output_inter[(i + 1 as c_int) as usize] = output_inter[i as usize]
                        .offset(thread_output_size as isize)
                        .offset(PAD_SIZE as isize);
                    output_intra[(i + 1 as c_int) as usize] = output_intra[i as usize]
                        .offset(thread_output_size as isize)
                        .offset(PAD_SIZE as isize);
                    x264_10_threadpool_run(
                        (*h).lookaheadpool,
                        ::core::mem::transmute::<
                            *mut c_void,
                            Option<unsafe extern "C" fn(*mut c_void) -> *mut c_void>,
                        >(::core::mem::transmute::<
                            Option<unsafe extern "C" fn(*mut x264_slicetype_slice_t) -> ()>,
                            *mut c_void,
                        >(Some(
                            slicetype_slice_cost
                                as unsafe extern "C" fn(*mut x264_slicetype_slice_t) -> (),
                        ))),
                        &mut *s.as_mut_ptr().offset(i as isize) as *mut x264_slicetype_slice_t
                            as *mut c_void,
                    );
                    i += 1;
                }
                let mut i_0: c_int = 0 as c_int;
                while i_0 < (*h).param.i_lookahead_threads {
                    x264_10_threadpool_wait(
                        (*h).lookaheadpool,
                        &mut *s.as_mut_ptr().offset(i_0 as isize) as *mut x264_slicetype_slice_t
                            as *mut c_void,
                    );
                    i_0 += 1;
                }
            } else {
                (*h).i_threadslice_start = 0 as c_int;
                (*h).i_threadslice_end = (*h).mb.i_mb_height;
                memset(
                    output_inter[0] as *mut c_void,
                    0 as c_int,
                    ((output_buf_size - PAD_SIZE) as size_t)
                        .wrapping_mul(::core::mem::size_of::<c_int>() as size_t),
                );
                memset(
                    output_intra[0] as *mut c_void,
                    0 as c_int,
                    ((output_buf_size - PAD_SIZE) as size_t)
                        .wrapping_mul(::core::mem::size_of::<c_int>() as size_t),
                );
                let ref mut fresh19 = *output_intra[0].offset(NUM_ROWS as isize);
                *fresh19 = (*h).mb.i_mb_height;
                *output_inter[0].offset(NUM_ROWS as isize) = *fresh19;
                let mut s_0: x264_slicetype_slice_t = {
                    let mut init = x264_slicetype_slice_t {
                        h: h,
                        a: a,
                        frames: frames,
                        p0: p0,
                        p1: p1,
                        b: b,
                        dist_scale_factor: dist_scale_factor,
                        do_search: do_search.as_mut_ptr(),
                        w: w,
                        output_inter: output_inter[0],
                        output_intra: output_intra[0],
                    };
                    init
                };
                slicetype_slice_cost(&mut s_0);
            }
            if b == p1 {
                (*fenc).i_intra_mbs[(b - p0) as usize] = 0 as c_int;
            }
            if (*fenc).b_intra_calculated == 0 {
                (*fenc).i_cost_est[0][0] = 0 as c_int;
                (*fenc).i_cost_est_aq[0][0] = 0 as c_int;
            }
            (*fenc).i_cost_est[(b - p0) as usize][(p1 - b) as usize] = 0 as c_int;
            (*fenc).i_cost_est_aq[(b - p0) as usize][(p1 - b) as usize] = 0 as c_int;
            let mut row_satd_inter: *mut c_int =
                (*fenc).i_row_satds[(b - p0) as usize][(p1 - b) as usize];
            let mut row_satd_intra: *mut c_int = (*fenc).i_row_satds[0][0];
            let mut i_1: c_int = 0 as c_int;
            while i_1 < (*h).param.i_lookahead_threads {
                if b == p1 {
                    (*fenc).i_intra_mbs[(b - p0) as usize] +=
                        *output_inter[i_1 as usize].offset(INTRA_MBS as isize);
                }
                if (*fenc).b_intra_calculated == 0 {
                    (*fenc).i_cost_est[0][0] +=
                        *output_intra[i_1 as usize].offset(COST_EST as isize);
                    (*fenc).i_cost_est_aq[0][0] +=
                        *output_intra[i_1 as usize].offset(COST_EST_AQ as isize);
                }
                (*fenc).i_cost_est[(b - p0) as usize][(p1 - b) as usize] +=
                    *output_inter[i_1 as usize].offset(COST_EST as isize);
                (*fenc).i_cost_est_aq[(b - p0) as usize][(p1 - b) as usize] +=
                    *output_inter[i_1 as usize].offset(COST_EST_AQ as isize);
                if (*h).param.rc.i_vbv_buffer_size != 0 {
                    let mut row_count: c_int =
                        *output_inter[i_1 as usize].offset(NUM_ROWS as isize);
                    memcpy(
                        row_satd_inter as *mut c_void,
                        output_inter[i_1 as usize].offset(NUM_INTS as isize) as *const c_void,
                        (row_count as size_t)
                            .wrapping_mul(::core::mem::size_of::<c_int>() as size_t),
                    );
                    if (*fenc).b_intra_calculated == 0 {
                        memcpy(
                            row_satd_intra as *mut c_void,
                            output_intra[i_1 as usize].offset(NUM_INTS as isize) as *const c_void,
                            (row_count as size_t)
                                .wrapping_mul(::core::mem::size_of::<c_int>() as size_t),
                        );
                    }
                    row_satd_inter = row_satd_inter.offset(row_count as isize);
                    row_satd_intra = row_satd_intra.offset(row_count as isize);
                }
                i_1 += 1;
            }
            i_score = (*fenc).i_cost_est[(b - p0) as usize][(p1 - b) as usize];
            if b != p1 {
                i_score = (i_score as uint64_t)
                    .wrapping_mul(100 as uint64_t)
                    .wrapping_div((120 as c_int + (*h).param.i_bframe_bias) as uint64_t)
                    as c_int;
            } else {
                (*fenc).b_intra_calculated = 1 as c_int;
            }
            (*fenc).i_cost_est[(b - p0) as usize][(p1 - b) as usize] = i_score;
        }
        return i_score;
    }
    #[c2rust::src_loc = "999:1"]
    pub unsafe extern "C" fn slicetype_frame_cost_recalculate(
        mut h: *mut x264_t,
        mut frames: *mut *mut x264_frame_t,
        mut p0: c_int,
        mut p1: c_int,
        mut b: c_int,
    ) -> c_int {
        let mut i_score: c_int = 0 as c_int;
        let mut row_satd: *mut c_int =
            (**frames.offset(b as isize)).i_row_satds[(b - p0) as usize][(p1 - b) as usize];
        let mut qp_offset: *mut c_float = if (**frames.offset(b as isize)).i_type == X264_TYPE_B
            || (**frames.offset(b as isize)).i_type == X264_TYPE_BREF
        {
            (**frames.offset(b as isize)).f_qp_offset_aq
        } else {
            (**frames.offset(b as isize)).f_qp_offset
        };
        (*h).mb.i_mb_y = (*h).mb.i_mb_height - 1 as c_int;
        while (*h).mb.i_mb_y >= 0 as c_int {
            *row_satd.offset((*h).mb.i_mb_y as isize) = 0 as c_int;
            (*h).mb.i_mb_x = (*h).mb.i_mb_width - 1 as c_int;
            while (*h).mb.i_mb_x >= 0 as c_int {
                let mut i_mb_xy: c_int = (*h).mb.i_mb_x + (*h).mb.i_mb_y * (*h).mb.i_mb_stride;
                let mut i_mb_cost: c_int = *(**frames.offset(b as isize)).lowres_costs
                    [(b - p0) as usize][(p1 - b) as usize]
                    .offset(i_mb_xy as isize) as c_int
                    & LOWRES_COST_MASK;
                let mut qp_adj: c_float = *qp_offset.offset(i_mb_xy as isize);
                i_mb_cost = i_mb_cost * x264_exp2fix8(qp_adj) + 128 as c_int >> 8 as c_int;
                *row_satd.offset((*h).mb.i_mb_y as isize) += i_mb_cost;
                if (*h).mb.i_mb_y > 0 as c_int
                    && (*h).mb.i_mb_y < (*h).mb.i_mb_height - 1 as c_int
                    && (*h).mb.i_mb_x > 0 as c_int
                    && (*h).mb.i_mb_x < (*h).mb.i_mb_width - 1 as c_int
                    || (*h).mb.i_mb_width <= 2 as c_int
                    || (*h).mb.i_mb_height <= 2 as c_int
                {
                    i_score += i_mb_cost;
                }
                (*h).mb.i_mb_x -= 1;
            }
            (*h).mb.i_mb_y -= 1;
        }
        return i_score;
    }
    #[c2rust::src_loc = "1027:9"]
    pub const MBTREE_PRECISION: c_float = 0.5f32;
    #[c2rust::src_loc = "1029:1"]
    pub unsafe extern "C" fn macroblock_tree_finish(
        mut h: *mut x264_t,
        mut frame: *mut x264_frame_t,
        mut average_duration: c_float,
        mut ref0_distance: c_int,
    ) {
        let frame_packing = (*h).param.frame_packing;
        let mut fps_factor: c_int = round(
            x264_clip3f(
                average_duration as c_double,
                FramePacking::min_frame_duration(frame_packing),
                FramePacking::max_frame_duration(frame_packing),
            ) / x264_clip3f(
                (*frame).f_duration as c_double,
                FramePacking::min_frame_duration(frame_packing),
                FramePacking::max_frame_duration(frame_packing),
            ) * 256 as c_int as c_double
                / MBTREE_PRECISION as c_double,
        ) as c_int;
        let mut weightdelta: c_float = 0.0f32;
        if ref0_distance != 0
            && (*frame).f_weighted_cost_delta[(ref0_distance - 1 as c_int) as usize]
                > 0 as c_int as c_float
        {
            weightdelta = (1.0f64
                - (*frame).f_weighted_cost_delta[(ref0_distance - 1 as c_int) as usize] as c_double)
                as c_float;
        }
        let mut strength: c_float = 5.0f32 * (1.0f32 - (*h).param.rc.f_qcompress);
        let mut mb_index: c_int = 0 as c_int;
        while mb_index < (*h).mb.i_mb_count {
            let mut intra_cost: c_int = *(*frame).i_intra_cost.offset(mb_index as isize) as c_int
                * *(*frame).i_inv_qscale_factor.offset(mb_index as isize) as c_int
                + 128 as c_int
                >> 8 as c_int;
            if intra_cost != 0 {
                let mut propagate_cost: c_int =
                    *(*frame).i_propagate_cost.offset(mb_index as isize) as c_int * fps_factor
                        + 128 as c_int
                        >> 8 as c_int;
                let mut log2_ratio: c_float = x264_log2((intra_cost + propagate_cost) as uint32_t)
                    - x264_log2(intra_cost as uint32_t)
                    + weightdelta;
                *(*frame).f_qp_offset.offset(mb_index as isize) =
                    *(*frame).f_qp_offset_aq.offset(mb_index as isize) - strength * log2_ratio;
            }
            mb_index += 1;
        }
    }
    #[c2rust::src_loc = "1051:1"]
    pub unsafe extern "C" fn macroblock_tree_propagate(
        mut h: *mut x264_t,
        mut frames: *mut *mut x264_frame_t,
        mut average_duration: c_float,
        mut p0: c_int,
        mut p1: c_int,
        mut b: c_int,
        mut referenced: c_int,
    ) {
        let mut ref_costs: [*mut uint16_t; 2] = [
            (**frames.offset(p0 as isize)).i_propagate_cost,
            (**frames.offset(p1 as isize)).i_propagate_cost,
        ];
        let mut dist_scale_factor: c_int =
            ((b - p0 << 8 as c_int) + (p1 - p0 >> 1 as c_int)) / (p1 - p0);
        let mut i_bipred_weight: c_int = if (*h).param.analyse.b_weighted_bipred != 0 {
            64 as c_int - (dist_scale_factor >> 2 as c_int)
        } else {
            32 as c_int
        };
        let mut mvs: [*mut [int16_t; 2]; 2] = [
            if b != p0 {
                (**frames.offset(b as isize)).lowres_mvs[0][(b - p0 - 1 as c_int) as usize]
            } else {
                0 as *mut [int16_t; 2]
            },
            if b != p1 {
                (**frames.offset(b as isize)).lowres_mvs[1][(p1 - b - 1 as c_int) as usize]
            } else {
                0 as *mut [int16_t; 2]
            },
        ];
        let mut bipred_weights: [c_int; 2] = [i_bipred_weight, 64 as c_int - i_bipred_weight];
        let mut buf: *mut int16_t = (*h).scratch_buffer as *mut int16_t;
        let mut propagate_cost: *mut uint16_t = (**frames.offset(b as isize)).i_propagate_cost;
        let mut lowres_costs: *mut uint16_t =
            (**frames.offset(b as isize)).lowres_costs[(b - p0) as usize][(p1 - b) as usize];

        let frame_packing = (*h).param.frame_packing;
        let mut fps_factor: c_float = (x264_clip3f(
            (**frames.offset(b as isize)).f_duration as c_double,
            FramePacking::min_frame_duration(frame_packing),
            FramePacking::max_frame_duration(frame_packing),
        ) / (x264_clip3f(
            average_duration as c_double,
            FramePacking::min_frame_duration(frame_packing),
            FramePacking::max_frame_duration(frame_packing),
        ) * 256.0f64)
            * MBTREE_PRECISION as c_double) as c_float;
        if referenced == 0 {
            memset(
                (**frames.offset(b as isize)).i_propagate_cost as *mut c_void,
                0 as c_int,
                ((*h).mb.i_mb_width as size_t)
                    .wrapping_mul(::core::mem::size_of::<uint16_t>() as size_t),
            );
        }
        (*h).mb.i_mb_y = 0 as c_int;
        while (*h).mb.i_mb_y < (*h).mb.i_mb_height {
            let mut mb_index: c_int = (*h).mb.i_mb_y * (*h).mb.i_mb_stride;
            (*h).mc
                .mbtree_propagate_cost
                .expect("non-null function pointer")(
                buf,
                propagate_cost,
                (**frames.offset(b as isize))
                    .i_intra_cost
                    .offset(mb_index as isize),
                lowres_costs.offset(mb_index as isize),
                (**frames.offset(b as isize))
                    .i_inv_qscale_factor
                    .offset(mb_index as isize),
                &mut fps_factor,
                (*h).mb.i_mb_width,
            );
            if referenced != 0 {
                propagate_cost = propagate_cost.offset((*h).mb.i_mb_width as isize);
            }
            (*h).mc
                .mbtree_propagate_list
                .expect("non-null function pointer")(
                h,
                ref_costs[0],
                &mut *(*mvs.as_mut_ptr().offset(0)).offset(mb_index as isize),
                buf,
                &mut *lowres_costs.offset(mb_index as isize),
                bipred_weights[0],
                (*h).mb.i_mb_y,
                (*h).mb.i_mb_width,
                0 as c_int,
            );
            if b != p1 {
                (*h).mc
                    .mbtree_propagate_list
                    .expect("non-null function pointer")(
                    h,
                    ref_costs[1],
                    &mut *(*mvs.as_mut_ptr().offset(1)).offset(mb_index as isize),
                    buf,
                    &mut *lowres_costs.offset(mb_index as isize),
                    bipred_weights[1],
                    (*h).mb.i_mb_y,
                    (*h).mb.i_mb_width,
                    1 as c_int,
                );
            }
            (*h).mb.i_mb_y += 1;
        }
        if (*h).param.rc.i_vbv_buffer_size != 0 && (*h).param.rc.i_lookahead != 0 && referenced != 0
        {
            macroblock_tree_finish(
                h,
                *frames.offset(b as isize),
                average_duration,
                if b == p1 { b - p0 } else { 0 as c_int },
            );
        }
    }
    #[c2rust::src_loc = "1091:1"]
    pub unsafe extern "C" fn macroblock_tree(
        mut h: *mut x264_t,
        mut a: *mut x264_mb_analysis_t,
        mut frames: *mut *mut x264_frame_t,
        mut num_frames: c_int,
        mut b_intra: c_int,
    ) {
        let mut idx: c_int = (b_intra == 0) as c_int;
        let mut last_nonb: c_int = 0;
        let mut cur_nonb: c_int = 1 as c_int;
        let mut bframes: c_int = 0 as c_int;
        let mut total_duration: c_float = 0.0f32;
        let mut j: c_int = 0 as c_int;
        while j <= num_frames {
            total_duration += (**frames.offset(j as isize)).f_duration;
            j += 1;
        }
        let mut average_duration: c_float = total_duration / (num_frames + 1 as c_int) as c_float;
        let mut i: c_int = num_frames;
        if b_intra != 0 {
            slicetype_frame_cost(h, a, frames, 0 as c_int, 0 as c_int, 0 as c_int);
        }
        while i > 0 as c_int
            && ((**frames.offset(i as isize)).i_type == X264_TYPE_B
                || (**frames.offset(i as isize)).i_type == X264_TYPE_BREF)
        {
            i -= 1;
        }
        last_nonb = i;
        if (*h).param.rc.i_lookahead == 0 {
            if b_intra != 0 {
                memset(
                    (**frames.offset(0)).i_propagate_cost as *mut c_void,
                    0 as c_int,
                    ((*h).mb.i_mb_count as size_t)
                        .wrapping_mul(::core::mem::size_of::<uint16_t>() as size_t),
                );
                memcpy(
                    (**frames.offset(0)).f_qp_offset as *mut c_void,
                    (**frames.offset(0)).f_qp_offset_aq as *const c_void,
                    ((*h).mb.i_mb_count as size_t)
                        .wrapping_mul(::core::mem::size_of::<c_float>() as size_t),
                );
                return;
            }
            let mut t: *mut uint16_t = (**frames.offset(last_nonb as isize)).i_propagate_cost;
            let ref mut fresh21 = (**frames.offset(last_nonb as isize)).i_propagate_cost;
            *fresh21 = (**frames.offset(0)).i_propagate_cost;
            let ref mut fresh22 = (**frames.offset(0)).i_propagate_cost;
            *fresh22 = t;
            memset(
                (**frames.offset(0)).i_propagate_cost as *mut c_void,
                0 as c_int,
                ((*h).mb.i_mb_count as size_t)
                    .wrapping_mul(::core::mem::size_of::<uint16_t>() as size_t),
            );
        } else {
            if last_nonb < idx {
                return;
            }
            memset(
                (**frames.offset(last_nonb as isize)).i_propagate_cost as *mut c_void,
                0 as c_int,
                ((*h).mb.i_mb_count as size_t)
                    .wrapping_mul(::core::mem::size_of::<uint16_t>() as size_t),
            );
        }
        loop {
            let fresh23 = i;
            i = i - 1;
            if !(fresh23 > idx) {
                break;
            }
            cur_nonb = i;
            while ((**frames.offset(cur_nonb as isize)).i_type == X264_TYPE_B
                || (**frames.offset(cur_nonb as isize)).i_type == X264_TYPE_BREF)
                && cur_nonb > 0 as c_int
            {
                cur_nonb -= 1;
            }
            if cur_nonb < idx {
                break;
            }
            slicetype_frame_cost(h, a, frames, cur_nonb, last_nonb, last_nonb);
            memset(
                (**frames.offset(cur_nonb as isize)).i_propagate_cost as *mut c_void,
                0 as c_int,
                ((*h).mb.i_mb_count as size_t)
                    .wrapping_mul(::core::mem::size_of::<uint16_t>() as size_t),
            );
            bframes = last_nonb - cur_nonb - 1 as c_int;
            if (*h).param.i_bframe_pyramid != 0 && bframes > 1 as c_int {
                let mut middle: c_int = (bframes + 1 as c_int) / 2 as c_int + cur_nonb;
                slicetype_frame_cost(h, a, frames, cur_nonb, last_nonb, middle);
                memset(
                    (**frames.offset(middle as isize)).i_propagate_cost as *mut c_void,
                    0 as c_int,
                    ((*h).mb.i_mb_count as size_t)
                        .wrapping_mul(::core::mem::size_of::<uint16_t>() as size_t),
                );
                while i > cur_nonb {
                    let mut p0: c_int = if i > middle { middle } else { cur_nonb };
                    let mut p1: c_int = if i < middle { middle } else { last_nonb };
                    if i != middle {
                        slicetype_frame_cost(h, a, frames, p0, p1, i);
                        macroblock_tree_propagate(
                            h,
                            frames,
                            average_duration,
                            p0,
                            p1,
                            i,
                            0 as c_int,
                        );
                    }
                    i -= 1;
                }
                macroblock_tree_propagate(
                    h,
                    frames,
                    average_duration,
                    cur_nonb,
                    last_nonb,
                    middle,
                    1 as c_int,
                );
            } else {
                while i > cur_nonb {
                    slicetype_frame_cost(h, a, frames, cur_nonb, last_nonb, i);
                    macroblock_tree_propagate(
                        h,
                        frames,
                        average_duration,
                        cur_nonb,
                        last_nonb,
                        i,
                        0 as c_int,
                    );
                    i -= 1;
                }
            }
            macroblock_tree_propagate(
                h,
                frames,
                average_duration,
                cur_nonb,
                last_nonb,
                last_nonb,
                1 as c_int,
            );
            last_nonb = cur_nonb;
        }
        if (*h).param.rc.i_lookahead == 0 {
            slicetype_frame_cost(h, a, frames, 0 as c_int, last_nonb, last_nonb);
            macroblock_tree_propagate(
                h,
                frames,
                average_duration,
                0 as c_int,
                last_nonb,
                last_nonb,
                1 as c_int,
            );
            let mut t_0: *mut uint16_t = (**frames.offset(last_nonb as isize)).i_propagate_cost;
            let ref mut fresh24 = (**frames.offset(last_nonb as isize)).i_propagate_cost;
            *fresh24 = (**frames.offset(0)).i_propagate_cost;
            let ref mut fresh25 = (**frames.offset(0)).i_propagate_cost;
            *fresh25 = t_0;
        }
        macroblock_tree_finish(
            h,
            *frames.offset(last_nonb as isize),
            average_duration,
            last_nonb,
        );
        if (*h).param.i_bframe_pyramid != 0
            && bframes > 1 as c_int
            && (*h).param.rc.i_vbv_buffer_size == 0
        {
            macroblock_tree_finish(
                h,
                *frames.offset((last_nonb + (bframes + 1 as c_int) / 2 as c_int) as isize),
                average_duration,
                0 as c_int,
            );
        }
    }
    #[c2rust::src_loc = "1186:1"]
    pub unsafe extern "C" fn vbv_frame_cost(
        mut h: *mut x264_t,
        mut a: *mut x264_mb_analysis_t,
        mut frames: *mut *mut x264_frame_t,
        mut p0: c_int,
        mut p1: c_int,
        mut b: c_int,
    ) -> c_int {
        let mut cost: c_int = slicetype_frame_cost(h, a, frames, p0, p1, b);
        if (*h).param.rc.i_aq_mode != 0 {
            if (*h).param.rc.b_mb_tree != 0 {
                return slicetype_frame_cost_recalculate(h, frames, p0, p1, b);
            } else {
                return (**frames.offset(b as isize)).i_cost_est_aq[(b - p0) as usize]
                    [(p1 - b) as usize];
            }
        }
        return cost;
    }
    #[c2rust::src_loc = "1199:1"]
    pub unsafe extern "C" fn calculate_durations(
        mut h: *mut x264_t,
        mut cur_frame: *mut x264_frame_t,
        mut prev_frame: *mut x264_frame_t,
        mut i_cpb_delay: *mut int64_t,
        mut i_coded_fields: *mut int64_t,
    ) {
        (*cur_frame).i_cpb_delay = *i_cpb_delay;
        (*cur_frame).i_dpb_output_delay = (*cur_frame).i_field_cnt - *i_coded_fields;
        (*cur_frame).i_dpb_output_delay +=
            ((*(*h).sps.as_mut_ptr()).vui.i_num_reorder_frames * 2 as c_int) as int64_t;
        if (*cur_frame).i_dpb_output_delay < 0 as int64_t {
            (*cur_frame).i_cpb_delay += (*cur_frame).i_dpb_output_delay;
            (*cur_frame).i_dpb_output_delay = 0 as int64_t;
            if !prev_frame.is_null() {
                (*prev_frame).i_cpb_duration += (*cur_frame).i_dpb_output_delay;
            }
        }
        if (*cur_frame).b_keyframe != 0 && (*h).param.b_intra_refresh == 0 {
            *i_cpb_delay = 0 as int64_t;
        }
        *i_cpb_delay += (*cur_frame).i_duration;
        *i_coded_fields += (*cur_frame).i_duration;
        (*cur_frame).i_cpb_duration = (*cur_frame).i_duration;
    }
    #[c2rust::src_loc = "1225:1"]
    pub unsafe extern "C" fn vbv_lookahead(
        mut h: *mut x264_t,
        mut a: *mut x264_mb_analysis_t,
        mut frames: *mut *mut x264_frame_t,
        mut num_frames: c_int,
        mut keyframe: c_int,
    ) {
        let mut last_nonb: c_int = 0 as c_int;
        let mut cur_nonb: c_int = 1 as c_int;
        let mut idx: c_int = 0 as c_int;
        let mut prev_frame: *mut x264_frame_t = 0 as *mut x264_frame_t;
        let mut prev_frame_idx: c_int = 0 as c_int;
        while cur_nonb < num_frames
            && ((**frames.offset(cur_nonb as isize)).i_type == X264_TYPE_B
                || (**frames.offset(cur_nonb as isize)).i_type == X264_TYPE_BREF)
        {
            cur_nonb += 1;
        }
        let mut next_nonb: c_int = if keyframe != 0 { last_nonb } else { cur_nonb };
        if (**frames.offset(cur_nonb as isize)).i_coded_fields_lookahead >= 0 as int64_t {
            (*h).i_coded_fields_lookahead =
                (**frames.offset(cur_nonb as isize)).i_coded_fields_lookahead;
            (*h).i_cpb_delay_lookahead = (**frames.offset(cur_nonb as isize)).i_cpb_delay_lookahead;
        }
        while cur_nonb < num_frames {
            if next_nonb != cur_nonb {
                let mut p0: c_int = if (**frames.offset(cur_nonb as isize)).i_type == X264_TYPE_I
                    || (**frames.offset(cur_nonb as isize)).i_type == X264_TYPE_IDR
                    || (**frames.offset(cur_nonb as isize)).i_type == X264_TYPE_KEYFRAME
                {
                    cur_nonb
                } else {
                    last_nonb
                };
                (**frames.offset(next_nonb as isize)).i_planned_satd[idx as usize] =
                    vbv_frame_cost(h, a, frames, p0, cur_nonb, cur_nonb);
                (**frames.offset(next_nonb as isize)).i_planned_type[idx as usize] =
                    (**frames.offset(cur_nonb as isize)).i_type as uint8_t;
                (**frames.offset(cur_nonb as isize)).i_coded_fields_lookahead =
                    (*h).i_coded_fields_lookahead;
                (**frames.offset(cur_nonb as isize)).i_cpb_delay_lookahead =
                    (*h).i_cpb_delay_lookahead;
                calculate_durations(
                    h,
                    *frames.offset(cur_nonb as isize),
                    prev_frame,
                    &mut (*h).i_cpb_delay_lookahead,
                    &mut (*h).i_coded_fields_lookahead,
                );
                if !prev_frame.is_null() {
                    (**frames.offset(next_nonb as isize)).f_planned_cpb_duration
                        [prev_frame_idx as usize] = (*prev_frame).i_cpb_duration as c_double
                        * (*(*h).sps.as_mut_ptr()).vui.i_num_units_in_tick as c_double
                        / (*(*h).sps.as_mut_ptr()).vui.i_time_scale as c_double;
                }
                (**frames.offset(next_nonb as isize)).f_planned_cpb_duration[idx as usize] =
                    (**frames.offset(cur_nonb as isize)).i_cpb_duration as c_double
                        * (*(*h).sps.as_mut_ptr()).vui.i_num_units_in_tick as c_double
                        / (*(*h).sps.as_mut_ptr()).vui.i_time_scale as c_double;
                prev_frame = *frames.offset(cur_nonb as isize);
                prev_frame_idx = idx;
                idx += 1;
            }
            let mut i: c_int = last_nonb + 1 as c_int;
            while i < cur_nonb {
                (**frames.offset(next_nonb as isize)).i_planned_satd[idx as usize] =
                    vbv_frame_cost(h, a, frames, last_nonb, cur_nonb, i);
                (**frames.offset(next_nonb as isize)).i_planned_type[idx as usize] =
                    X264_TYPE_B as uint8_t;
                (**frames.offset(i as isize)).i_coded_fields_lookahead =
                    (*h).i_coded_fields_lookahead;
                (**frames.offset(i as isize)).i_cpb_delay_lookahead = (*h).i_cpb_delay_lookahead;
                calculate_durations(
                    h,
                    *frames.offset(i as isize),
                    prev_frame,
                    &mut (*h).i_cpb_delay_lookahead,
                    &mut (*h).i_coded_fields_lookahead,
                );
                if !prev_frame.is_null() {
                    (**frames.offset(next_nonb as isize)).f_planned_cpb_duration
                        [prev_frame_idx as usize] = (*prev_frame).i_cpb_duration as c_double
                        * (*(*h).sps.as_mut_ptr()).vui.i_num_units_in_tick as c_double
                        / (*(*h).sps.as_mut_ptr()).vui.i_time_scale as c_double;
                }
                (**frames.offset(next_nonb as isize)).f_planned_cpb_duration[idx as usize] =
                    (**frames.offset(i as isize)).i_cpb_duration as c_double
                        * (*(*h).sps.as_mut_ptr()).vui.i_num_units_in_tick as c_double
                        / (*(*h).sps.as_mut_ptr()).vui.i_time_scale as c_double;
                prev_frame = *frames.offset(i as isize);
                prev_frame_idx = idx;
                i += 1;
                idx += 1;
            }
            last_nonb = cur_nonb;
            cur_nonb += 1;
            while cur_nonb <= num_frames
                && ((**frames.offset(cur_nonb as isize)).i_type == X264_TYPE_B
                    || (**frames.offset(cur_nonb as isize)).i_type == X264_TYPE_BREF)
            {
                cur_nonb += 1;
            }
        }
        (**frames.offset(next_nonb as isize)).i_planned_type[idx as usize] =
            X264_TYPE_AUTO as uint8_t;
    }
    #[c2rust::src_loc = "1288:1"]
    pub unsafe extern "C" fn slicetype_path_cost(
        mut h: *mut x264_t,
        mut a: *mut x264_mb_analysis_t,
        mut frames: *mut *mut x264_frame_t,
        mut path: *mut c_char,
        mut threshold: uint64_t,
    ) -> uint64_t {
        let mut cost: uint64_t = 0 as uint64_t;
        let mut loc: c_int = 1 as c_int;
        let mut cur_nonb: c_int = 0 as c_int;
        path = path.offset(-1);
        while *path.offset(loc as isize) != 0 {
            let mut next_nonb: c_int = loc;
            while *path.offset(next_nonb as isize) as c_int == 'B' as i32 {
                next_nonb += 1;
            }
            if *path.offset(next_nonb as isize) as c_int == 'P' as i32 {
                cost = cost.wrapping_add(slicetype_frame_cost(
                    h, a, frames, cur_nonb, next_nonb, next_nonb,
                ) as uint64_t);
            } else {
                cost = cost.wrapping_add(slicetype_frame_cost(
                    h, a, frames, next_nonb, next_nonb, next_nonb,
                ) as uint64_t);
            }
            if cost > threshold {
                break;
            }
            if (*h).param.i_bframe_pyramid != 0 && next_nonb - cur_nonb > 2 as c_int {
                let mut middle: c_int = cur_nonb + (next_nonb - cur_nonb) / 2 as c_int;
                cost = cost.wrapping_add(slicetype_frame_cost(
                    h, a, frames, cur_nonb, next_nonb, middle,
                ) as uint64_t);
                let mut next_b: c_int = loc;
                while next_b < middle && cost < threshold {
                    cost = cost
                        .wrapping_add(slicetype_frame_cost(h, a, frames, cur_nonb, middle, next_b)
                            as uint64_t);
                    next_b += 1;
                }
                let mut next_b_0: c_int = middle + 1 as c_int;
                while next_b_0 < next_nonb && cost < threshold {
                    cost = cost.wrapping_add(slicetype_frame_cost(
                        h, a, frames, middle, next_nonb, next_b_0,
                    ) as uint64_t);
                    next_b_0 += 1;
                }
            } else {
                let mut next_b_1: c_int = loc;
                while next_b_1 < next_nonb && cost < threshold {
                    cost = cost.wrapping_add(slicetype_frame_cost(
                        h, a, frames, cur_nonb, next_nonb, next_b_1,
                    ) as uint64_t);
                    next_b_1 += 1;
                }
            }
            loc = next_nonb + 1 as c_int;
            cur_nonb = next_nonb;
        }
        return cost;
    }
    #[c2rust::src_loc = "1333:1"]
    pub unsafe extern "C" fn slicetype_path(
        mut h: *mut x264_t,
        mut a: *mut x264_mb_analysis_t,
        mut frames: *mut *mut x264_frame_t,
        mut length: c_int,
        mut best_paths: *mut [c_char; 251],
    ) {
        let mut paths: [[c_char; 251]; 2] = [[0; 251]; 2];
        let mut num_paths: c_int = if ((*h).param.i_bframe + 1 as c_int) < length {
            (*h).param.i_bframe + 1 as c_int
        } else {
            length
        };
        let mut best_cost: uint64_t = COST_MAX64 as uint64_t;
        let mut best_possible: c_int = 0 as c_int;
        let mut idx: c_int = 0 as c_int;
        let mut path: c_int = 0 as c_int;
        while path < num_paths {
            let mut len: c_int = length - (path + 1 as c_int);
            memcpy(
                (*paths.as_mut_ptr().offset(idx as isize)).as_mut_ptr() as *mut c_void,
                (*best_paths.offset((len % (X264_BFRAME_MAX + 1 as c_int)) as isize)).as_mut_ptr()
                    as *const c_void,
                len as size_t,
            );
            memset(
                (*paths.as_mut_ptr().offset(idx as isize))
                    .as_mut_ptr()
                    .offset(len as isize) as *mut c_void,
                'B' as i32,
                path as size_t,
            );
            strcpy(
                (*paths.as_mut_ptr().offset(idx as isize))
                    .as_mut_ptr()
                    .offset(len as isize)
                    .offset(path as isize),
                b"P\0" as *const u8 as *const c_char,
            );
            let mut possible: c_int = 1 as c_int;
            let mut i: c_int = 1 as c_int;
            while i <= length {
                let mut i_type: c_int = (**frames.offset(i as isize)).i_type;
                if !(i_type == X264_TYPE_AUTO) {
                    if i_type == X264_TYPE_B || i_type == X264_TYPE_BREF {
                        possible = (possible != 0
                            && (i < len
                                || i == length
                                || paths[idx as usize][(i - 1 as c_int) as usize] as c_int
                                    == 'B' as i32)) as c_int;
                    } else {
                        possible = (possible != 0
                            && (i < len
                                || paths[idx as usize][(i - 1 as c_int) as usize] as c_int
                                    != 'B' as i32)) as c_int;
                        paths[idx as usize][(i - 1 as c_int) as usize] = (if i_type == X264_TYPE_I
                            || i_type == X264_TYPE_IDR
                            || i_type == X264_TYPE_KEYFRAME
                        {
                            'I' as i32
                        } else {
                            'P' as i32
                        })
                            as c_char;
                    }
                }
                i += 1;
            }
            if possible != 0 || best_possible == 0 {
                if possible != 0 && best_possible == 0 {
                    best_cost = COST_MAX64 as uint64_t;
                }
                let mut cost: uint64_t = slicetype_path_cost(
                    h,
                    a,
                    frames,
                    (*paths.as_mut_ptr().offset(idx as isize)).as_mut_ptr(),
                    best_cost,
                );
                if cost < best_cost {
                    best_cost = cost;
                    best_possible = possible;
                    idx ^= 1 as c_int;
                }
            }
            path += 1;
        }
        memcpy(
            (*best_paths.offset((length % (X264_BFRAME_MAX + 1 as c_int)) as isize)).as_mut_ptr()
                as *mut c_void,
            (*paths.as_mut_ptr().offset((idx ^ 1 as c_int) as isize)).as_mut_ptr() as *const c_void,
            length as size_t,
        );
    }
    #[c2rust::src_loc = "1384:1"]
    pub unsafe extern "C" fn scenecut_internal(
        mut h: *mut x264_t,
        mut a: *mut x264_mb_analysis_t,
        mut frames: *mut *mut x264_frame_t,
        mut p0: c_int,
        mut p1: c_int,
        mut real_scenecut: c_int,
    ) -> c_int {
        let mut frame: *mut x264_frame_t = *frames.offset(p1 as isize);
        if real_scenecut != 0
            && (*h).param.frame_packing == Some(FramePacking::TemporalInterleaved)
            && (*frame).i_frame & 1 as c_int != 0
        {
            return 0 as c_int;
        }
        slicetype_frame_cost(h, a, frames, p0, p1, p1);
        let mut icost: c_int = (*frame).i_cost_est[0][0];
        let mut pcost: c_int = (*frame).i_cost_est[(p1 - p0) as usize][0];
        let mut f_bias: c_float = 0.;
        let mut i_gop_size: c_int = (*frame).i_frame - (*(*h).lookahead).i_last_keyframe;
        let mut f_thresh_max: c_float =
            ((*h).param.i_scenecut_threshold as c_double / 100.0f64) as c_float;
        let mut f_thresh_min: c_float = (f_thresh_max as c_double * 0.25f64) as c_float;
        let mut res: c_int = 0;
        if (*h).param.i_keyint_min == (*h).param.i_keyint_max {
            f_thresh_min = f_thresh_max;
        }
        if i_gop_size <= (*h).param.i_keyint_min / 4 as c_int || (*h).param.b_intra_refresh != 0 {
            f_bias = f_thresh_min / 4 as c_int as c_float;
        } else if i_gop_size <= (*h).param.i_keyint_min {
            f_bias = f_thresh_min * i_gop_size as c_float / (*h).param.i_keyint_min as c_float;
        } else {
            f_bias = f_thresh_min
                + (f_thresh_max - f_thresh_min) * (i_gop_size - (*h).param.i_keyint_min) as c_float
                    / ((*h).param.i_keyint_max - (*h).param.i_keyint_min) as c_float;
        }
        res = (pcost as c_double >= (1.0f64 - f_bias as c_double) * icost as c_double) as c_int;
        if res != 0 && real_scenecut != 0 {
            let mut imb: c_int = (*frame).i_intra_mbs[(p1 - p0) as usize];
            let mut pmb: c_int =
                (if (*h).mb.i_mb_width > 2 as c_int && (*h).mb.i_mb_height > 2 as c_int {
                    ((*h).mb.i_mb_width - 2 as c_int) * ((*h).mb.i_mb_height - 2 as c_int)
                } else {
                    (*h).mb.i_mb_width * (*h).mb.i_mb_height
                }) - imb;
            x264_10_log(
                h,
                X264_LOG_DEBUG,
                b"scene cut at %d Icost:%d Pcost:%d ratio:%.4f bias:%.4f gop:%d (imb:%d pmb:%d)\n\0"
                    as *const u8 as *const c_char,
                (*frame).i_frame,
                icost,
                pcost,
                1.0f64 - pcost as c_double / icost as c_double,
                f_bias as c_double,
                i_gop_size,
                imb,
                pmb,
            );
        }
        return res;
    }
    #[c2rust::src_loc = "1430:1"]
    pub unsafe extern "C" fn scenecut(
        mut h: *mut x264_t,
        mut a: *mut x264_mb_analysis_t,
        mut frames: *mut *mut x264_frame_t,
        mut p0: c_int,
        mut p1: c_int,
        mut real_scenecut: c_int,
        mut num_frames: c_int,
        mut i_max_search: c_int,
    ) -> c_int {
        if real_scenecut != 0 && (*h).param.i_bframe != 0 {
            let mut origmaxp1: c_int = p0 + 1 as c_int;
            if (*h).param.i_bframe_adaptive == X264_B_ADAPT_TRELLIS {
                origmaxp1 += (*h).param.i_bframe;
            } else {
                origmaxp1 += 1;
            }
            let mut maxp1: c_int = if origmaxp1 < num_frames {
                origmaxp1
            } else {
                num_frames
            };
            let mut curp1: c_int = p1;
            while curp1 <= maxp1 {
                if scenecut_internal(h, a, frames, p0, curp1, 0 as c_int) == 0 {
                    let mut i: c_int = curp1;
                    while i > p0 {
                        (**frames.offset(i as isize)).b_scenecut = 0 as c_int;
                        i -= 1;
                    }
                }
                curp1 += 1;
            }
            let mut curp0: c_int = p0;
            while curp0 <= maxp1 {
                if origmaxp1 > i_max_search
                    || curp0 < maxp1
                        && scenecut_internal(h, a, frames, curp0, maxp1, 0 as c_int) != 0
                {
                    (**frames.offset(curp0 as isize)).b_scenecut = 0 as c_int;
                }
                curp0 += 1;
            }
        }
        if (**frames.offset(p1 as isize)).b_scenecut == 0 {
            return 0 as c_int;
        }
        return scenecut_internal(h, a, frames, p0, p1, real_scenecut);
    }
    #[no_mangle]
    #[c2rust::src_loc = "1473:1"]
    pub unsafe extern "C" fn x264_10_slicetype_analyse(
        mut h: *mut x264_t,
        mut intra_minigop: c_int,
    ) {
        let mut a: x264_mb_analysis_t = x264_mb_analysis_t {
            i_lambda: 0,
            i_lambda2: 0,
            i_qp: 0,
            p_cost_mv: 0 as *mut uint16_t,
            p_cost_ref: [0 as *mut uint16_t; 2],
            i_mbrd: 0,
            b_fast_intra: 0,
            b_force_intra: 0,
            b_avoid_topright: 0,
            b_try_skip: 0,
            i_satd_i16x16: 0,
            i_satd_i16x16_dir: [0; 7],
            i_predict16x16: 0,
            i_satd_i8x8: 0,
            i_cbp_i8x8_luma: 0,
            i_satd_i8x8_dir: [[0; 16]; 4],
            i_predict8x8: [0; 4],
            i_satd_i4x4: 0,
            i_predict4x4: [0; 16],
            i_satd_pcm: 0,
            i_satd_chroma: 0,
            i_satd_chroma_dir: [0; 7],
            i_predict8x8chroma: 0,
            l0: x264_mb_analysis_list_t {
                me16x16: x264_me_t {
                    i_pixel: 0,
                    p_cost_mv: 0 as *mut uint16_t,
                    i_ref_cost: 0,
                    i_ref: 0,
                    weight: 0 as *const x264_weight_t,
                    p_fref: [0 as *mut pixel; 12],
                    p_fref_w: 0 as *mut pixel,
                    p_fenc: [0 as *mut pixel; 3],
                    integral: 0 as *mut uint16_t,
                    i_stride: [0; 3],
                    mvp: [0; 2],
                    cost_mv: 0,
                    cost: 0,
                    mv: [0; 2],
                },
                bi16x16: x264_me_t {
                    i_pixel: 0,
                    p_cost_mv: 0 as *mut uint16_t,
                    i_ref_cost: 0,
                    i_ref: 0,
                    weight: 0 as *const x264_weight_t,
                    p_fref: [0 as *mut pixel; 12],
                    p_fref_w: 0 as *mut pixel,
                    p_fenc: [0 as *mut pixel; 3],
                    integral: 0 as *mut uint16_t,
                    i_stride: [0; 3],
                    mvp: [0; 2],
                    cost_mv: 0,
                    cost: 0,
                    mv: [0; 2],
                },
                me8x8: [x264_me_t {
                    i_pixel: 0,
                    p_cost_mv: 0 as *mut uint16_t,
                    i_ref_cost: 0,
                    i_ref: 0,
                    weight: 0 as *const x264_weight_t,
                    p_fref: [0 as *mut pixel; 12],
                    p_fref_w: 0 as *mut pixel,
                    p_fenc: [0 as *mut pixel; 3],
                    integral: 0 as *mut uint16_t,
                    i_stride: [0; 3],
                    mvp: [0; 2],
                    cost_mv: 0,
                    cost: 0,
                    mv: [0; 2],
                }; 4],
                me4x4: [[x264_me_t {
                    i_pixel: 0,
                    p_cost_mv: 0 as *mut uint16_t,
                    i_ref_cost: 0,
                    i_ref: 0,
                    weight: 0 as *const x264_weight_t,
                    p_fref: [0 as *mut pixel; 12],
                    p_fref_w: 0 as *mut pixel,
                    p_fenc: [0 as *mut pixel; 3],
                    integral: 0 as *mut uint16_t,
                    i_stride: [0; 3],
                    mvp: [0; 2],
                    cost_mv: 0,
                    cost: 0,
                    mv: [0; 2],
                }; 4]; 4],
                me8x4: [[x264_me_t {
                    i_pixel: 0,
                    p_cost_mv: 0 as *mut uint16_t,
                    i_ref_cost: 0,
                    i_ref: 0,
                    weight: 0 as *const x264_weight_t,
                    p_fref: [0 as *mut pixel; 12],
                    p_fref_w: 0 as *mut pixel,
                    p_fenc: [0 as *mut pixel; 3],
                    integral: 0 as *mut uint16_t,
                    i_stride: [0; 3],
                    mvp: [0; 2],
                    cost_mv: 0,
                    cost: 0,
                    mv: [0; 2],
                }; 2]; 4],
                me4x8: [[x264_me_t {
                    i_pixel: 0,
                    p_cost_mv: 0 as *mut uint16_t,
                    i_ref_cost: 0,
                    i_ref: 0,
                    weight: 0 as *const x264_weight_t,
                    p_fref: [0 as *mut pixel; 12],
                    p_fref_w: 0 as *mut pixel,
                    p_fenc: [0 as *mut pixel; 3],
                    integral: 0 as *mut uint16_t,
                    i_stride: [0; 3],
                    mvp: [0; 2],
                    cost_mv: 0,
                    cost: 0,
                    mv: [0; 2],
                }; 2]; 4],
                me16x8: [x264_me_t {
                    i_pixel: 0,
                    p_cost_mv: 0 as *mut uint16_t,
                    i_ref_cost: 0,
                    i_ref: 0,
                    weight: 0 as *const x264_weight_t,
                    p_fref: [0 as *mut pixel; 12],
                    p_fref_w: 0 as *mut pixel,
                    p_fenc: [0 as *mut pixel; 3],
                    integral: 0 as *mut uint16_t,
                    i_stride: [0; 3],
                    mvp: [0; 2],
                    cost_mv: 0,
                    cost: 0,
                    mv: [0; 2],
                }; 2],
                me8x16: [x264_me_t {
                    i_pixel: 0,
                    p_cost_mv: 0 as *mut uint16_t,
                    i_ref_cost: 0,
                    i_ref: 0,
                    weight: 0 as *const x264_weight_t,
                    p_fref: [0 as *mut pixel; 12],
                    p_fref_w: 0 as *mut pixel,
                    p_fenc: [0 as *mut pixel; 3],
                    integral: 0 as *mut uint16_t,
                    i_stride: [0; 3],
                    mvp: [0; 2],
                    cost_mv: 0,
                    cost: 0,
                    mv: [0; 2],
                }; 2],
                i_rd16x16: 0,
                i_cost8x8: 0,
                i_cost4x4: [0; 4],
                i_cost8x4: [0; 4],
                i_cost4x8: [0; 4],
                i_cost16x8: 0,
                i_cost8x16: 0,
                mvc: [[[0; 2]; 6]; 32],
            },
            l1: x264_mb_analysis_list_t {
                me16x16: x264_me_t {
                    i_pixel: 0,
                    p_cost_mv: 0 as *mut uint16_t,
                    i_ref_cost: 0,
                    i_ref: 0,
                    weight: 0 as *const x264_weight_t,
                    p_fref: [0 as *mut pixel; 12],
                    p_fref_w: 0 as *mut pixel,
                    p_fenc: [0 as *mut pixel; 3],
                    integral: 0 as *mut uint16_t,
                    i_stride: [0; 3],
                    mvp: [0; 2],
                    cost_mv: 0,
                    cost: 0,
                    mv: [0; 2],
                },
                bi16x16: x264_me_t {
                    i_pixel: 0,
                    p_cost_mv: 0 as *mut uint16_t,
                    i_ref_cost: 0,
                    i_ref: 0,
                    weight: 0 as *const x264_weight_t,
                    p_fref: [0 as *mut pixel; 12],
                    p_fref_w: 0 as *mut pixel,
                    p_fenc: [0 as *mut pixel; 3],
                    integral: 0 as *mut uint16_t,
                    i_stride: [0; 3],
                    mvp: [0; 2],
                    cost_mv: 0,
                    cost: 0,
                    mv: [0; 2],
                },
                me8x8: [x264_me_t {
                    i_pixel: 0,
                    p_cost_mv: 0 as *mut uint16_t,
                    i_ref_cost: 0,
                    i_ref: 0,
                    weight: 0 as *const x264_weight_t,
                    p_fref: [0 as *mut pixel; 12],
                    p_fref_w: 0 as *mut pixel,
                    p_fenc: [0 as *mut pixel; 3],
                    integral: 0 as *mut uint16_t,
                    i_stride: [0; 3],
                    mvp: [0; 2],
                    cost_mv: 0,
                    cost: 0,
                    mv: [0; 2],
                }; 4],
                me4x4: [[x264_me_t {
                    i_pixel: 0,
                    p_cost_mv: 0 as *mut uint16_t,
                    i_ref_cost: 0,
                    i_ref: 0,
                    weight: 0 as *const x264_weight_t,
                    p_fref: [0 as *mut pixel; 12],
                    p_fref_w: 0 as *mut pixel,
                    p_fenc: [0 as *mut pixel; 3],
                    integral: 0 as *mut uint16_t,
                    i_stride: [0; 3],
                    mvp: [0; 2],
                    cost_mv: 0,
                    cost: 0,
                    mv: [0; 2],
                }; 4]; 4],
                me8x4: [[x264_me_t {
                    i_pixel: 0,
                    p_cost_mv: 0 as *mut uint16_t,
                    i_ref_cost: 0,
                    i_ref: 0,
                    weight: 0 as *const x264_weight_t,
                    p_fref: [0 as *mut pixel; 12],
                    p_fref_w: 0 as *mut pixel,
                    p_fenc: [0 as *mut pixel; 3],
                    integral: 0 as *mut uint16_t,
                    i_stride: [0; 3],
                    mvp: [0; 2],
                    cost_mv: 0,
                    cost: 0,
                    mv: [0; 2],
                }; 2]; 4],
                me4x8: [[x264_me_t {
                    i_pixel: 0,
                    p_cost_mv: 0 as *mut uint16_t,
                    i_ref_cost: 0,
                    i_ref: 0,
                    weight: 0 as *const x264_weight_t,
                    p_fref: [0 as *mut pixel; 12],
                    p_fref_w: 0 as *mut pixel,
                    p_fenc: [0 as *mut pixel; 3],
                    integral: 0 as *mut uint16_t,
                    i_stride: [0; 3],
                    mvp: [0; 2],
                    cost_mv: 0,
                    cost: 0,
                    mv: [0; 2],
                }; 2]; 4],
                me16x8: [x264_me_t {
                    i_pixel: 0,
                    p_cost_mv: 0 as *mut uint16_t,
                    i_ref_cost: 0,
                    i_ref: 0,
                    weight: 0 as *const x264_weight_t,
                    p_fref: [0 as *mut pixel; 12],
                    p_fref_w: 0 as *mut pixel,
                    p_fenc: [0 as *mut pixel; 3],
                    integral: 0 as *mut uint16_t,
                    i_stride: [0; 3],
                    mvp: [0; 2],
                    cost_mv: 0,
                    cost: 0,
                    mv: [0; 2],
                }; 2],
                me8x16: [x264_me_t {
                    i_pixel: 0,
                    p_cost_mv: 0 as *mut uint16_t,
                    i_ref_cost: 0,
                    i_ref: 0,
                    weight: 0 as *const x264_weight_t,
                    p_fref: [0 as *mut pixel; 12],
                    p_fref_w: 0 as *mut pixel,
                    p_fenc: [0 as *mut pixel; 3],
                    integral: 0 as *mut uint16_t,
                    i_stride: [0; 3],
                    mvp: [0; 2],
                    cost_mv: 0,
                    cost: 0,
                    mv: [0; 2],
                }; 2],
                i_rd16x16: 0,
                i_cost8x8: 0,
                i_cost4x4: [0; 4],
                i_cost8x4: [0; 4],
                i_cost4x8: [0; 4],
                i_cost16x8: 0,
                i_cost8x16: 0,
                mvc: [[[0; 2]; 6]; 32],
            },
            i_cost16x16bi: 0,
            i_cost16x16direct: 0,
            i_cost8x8bi: 0,
            i_cost8x8direct: [0; 4],
            i_satd8x8: [[0; 4]; 3],
            i_cost_est16x8: [0; 2],
            i_cost_est8x16: [0; 2],
            i_cost16x8bi: 0,
            i_cost8x16bi: 0,
            i_rd16x16bi: 0,
            i_rd16x16direct: 0,
            i_rd16x8bi: 0,
            i_rd8x16bi: 0,
            i_rd8x8bi: 0,
            i_mb_partition16x8: [0; 2],
            i_mb_partition8x16: [0; 2],
            i_mb_type16x8: 0,
            i_mb_type8x16: 0,
            b_direct_available: 0,
            b_early_terminate: 0,
        };
        let mut frames: [*mut x264_frame_t; 253] = [
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
        ];
        let mut num_frames: c_int = 0;
        let mut orig_num_frames: c_int = 0;
        let mut keyint_limit: c_int = 0;
        let mut framecnt: c_int = 0;
        let mut i_max_search: c_int = if (*(*h).lookahead).next.i_size < 250 as c_int {
            (*(*h).lookahead).next.i_size
        } else {
            250 as c_int
        };
        let mut b_vbv_lookahead: c_int =
            ((*h).param.rc.i_vbv_buffer_size != 0 && (*h).param.rc.i_lookahead != 0) as c_int;
        if (*h).param.b_deterministic != 0 {
            i_max_search = if i_max_search
                < (*(*h).lookahead).i_slicetype_length + 1 as c_int - intra_minigop
            {
                i_max_search
            } else {
                (*(*h).lookahead).i_slicetype_length + 1 as c_int - intra_minigop
            };
        }
        let mut keyframe: c_int = (intra_minigop != 0) as c_int;
        if (*h).frames.b_have_lowres != 0 {
        } else {
            __assert_fail(
                b"h->frames.b_have_lowres\0" as *const u8 as *const c_char,
                b"encoder/slicetype.c\0" as *const u8 as *const c_char,
                1488 as c_uint,
                ::core::mem::transmute::<[u8; 46], [c_char; 46]>(
                    *b"void x264_10_slicetype_analyse(x264_t *, int)\0",
                )
                .as_ptr(),
            );
        }
        'c_125261: {
            if (*h).frames.b_have_lowres != 0 {
            } else {
                __assert_fail(
                    b"h->frames.b_have_lowres\0" as *const u8 as *const c_char,
                    b"encoder/slicetype.c\0" as *const u8 as *const c_char,
                    1488 as c_uint,
                    ::core::mem::transmute::<[u8; 46], [c_char; 46]>(
                        *b"void x264_10_slicetype_analyse(x264_t *, int)\0",
                    )
                    .as_ptr(),
                );
            }
        };
        if (*(*h).lookahead).last_nonb.is_null() {
            return;
        }
        frames[0] = (*(*h).lookahead).last_nonb;
        framecnt = 0 as c_int;
        while framecnt < i_max_search {
            frames[(framecnt + 1 as c_int) as usize] =
                *(*(*h).lookahead).next.list.offset(framecnt as isize);
            framecnt += 1;
        }
        lowres_context_init(h, &mut a);
        if framecnt == 0 {
            if (*h).param.rc.b_mb_tree != 0 {
                macroblock_tree(h, &mut a, frames.as_mut_ptr(), 0 as c_int, keyframe);
            }
            return;
        }
        keyint_limit = (*h).param.i_keyint_max - (*frames[0]).i_frame
            + (*(*h).lookahead).i_last_keyframe
            - 1 as c_int;
        num_frames = if (*h).param.b_intra_refresh != 0 {
            framecnt
        } else if framecnt < keyint_limit {
            framecnt
        } else {
            keyint_limit
        };
        orig_num_frames = num_frames;
        if (*h).param.analyse.b_psy != 0 && (*h).param.rc.b_mb_tree != 0 || b_vbv_lookahead != 0 {
            num_frames = framecnt;
        } else if (*h).param.b_open_gop != 0 && num_frames < framecnt {
            num_frames += 1;
        } else if num_frames == 0 as c_int {
            (*frames[1]).i_type = X264_TYPE_I;
            return;
        }
        if ((*frames[1]).i_type == X264_TYPE_AUTO
            || ((*frames[1]).i_type == X264_TYPE_I
                || (*frames[1]).i_type == X264_TYPE_IDR
                || (*frames[1]).i_type == X264_TYPE_KEYFRAME))
            && (*h).param.i_scenecut_threshold != 0
            && scenecut(
                h,
                &mut a,
                frames.as_mut_ptr(),
                0 as c_int,
                1 as c_int,
                1 as c_int,
                orig_num_frames,
                i_max_search,
            ) != 0
        {
            if (*frames[1]).i_type == X264_TYPE_AUTO {
                (*frames[1]).i_type = X264_TYPE_I;
            }
            return;
        }
        let mut j: c_int = 1 as c_int;
        while j <= num_frames {
            if (*frames[j as usize]).i_type == X264_TYPE_KEYFRAME {
                (*frames[j as usize]).i_type = if (*h).param.b_open_gop != 0 {
                    X264_TYPE_I
                } else {
                    X264_TYPE_IDR
                };
            }
            j += 1;
        }
        let mut j_0: c_int = 2 as c_int;
        while j_0 <= num_frames {
            if (*frames[j_0 as usize]).i_type == X264_TYPE_IDR
                && ((*frames[(j_0 - 1 as c_int) as usize]).i_type == X264_TYPE_AUTO
                    || ((*frames[(j_0 - 1 as c_int) as usize]).i_type == X264_TYPE_B
                        || (*frames[(j_0 - 1 as c_int) as usize]).i_type == X264_TYPE_BREF))
            {
                (*frames[(j_0 - 1 as c_int) as usize]).i_type = X264_TYPE_P;
            }
            j_0 += 1;
        }
        let mut num_analysed_frames: c_int = num_frames;
        let mut reset_start: c_int = 0;
        if (*h).param.i_bframe != 0 {
            if (*h).param.i_bframe_adaptive == X264_B_ADAPT_TRELLIS {
                if num_frames > 1 as c_int {
                    let mut best_paths: [[c_char; 251]; 17] = [
                        ::core::mem::transmute::<
                            [u8; 251],
                            [c_char; 251],
                        >(
                            *b"\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0",
                        ),
                        ::core::mem::transmute::<
                            [u8; 251],
                            [c_char; 251],
                        >(
                            *b"P\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0",
                        ),
                        [0; 251],
                        [0; 251],
                        [0; 251],
                        [0; 251],
                        [0; 251],
                        [0; 251],
                        [0; 251],
                        [0; 251],
                        [0; 251],
                        [0; 251],
                        [0; 251],
                        [0; 251],
                        [0; 251],
                        [0; 251],
                        [0; 251],
                    ];
                    let mut best_path_index: c_int = num_frames % (X264_BFRAME_MAX + 1 as c_int);
                    let mut j_1: c_int = 2 as c_int;
                    while j_1 <= num_frames {
                        slicetype_path(
                            h,
                            &mut a,
                            frames.as_mut_ptr(),
                            j_1,
                            best_paths.as_mut_ptr() as *mut [c_char; 251],
                        );
                        j_1 += 1;
                    }
                    let mut j_2: c_int = 1 as c_int;
                    while j_2 < num_frames {
                        if best_paths[best_path_index as usize][(j_2 - 1 as c_int) as usize]
                            as c_int
                            != 'B' as i32
                        {
                            if (*frames[j_2 as usize]).i_type == X264_TYPE_AUTO
                                || ((*frames[j_2 as usize]).i_type == X264_TYPE_B
                                    || (*frames[j_2 as usize]).i_type == X264_TYPE_BREF)
                            {
                                (*frames[j_2 as usize]).i_type = X264_TYPE_P;
                            }
                        } else if (*frames[j_2 as usize]).i_type == X264_TYPE_AUTO {
                            (*frames[j_2 as usize]).i_type = X264_TYPE_B;
                        }
                        j_2 += 1;
                    }
                }
            } else if (*h).param.i_bframe_adaptive == X264_B_ADAPT_FAST {
                let mut last_nonb: c_int = 0 as c_int;
                let mut num_bframes: c_int = (*h).param.i_bframe;
                let mut path: [c_char; 251] = [0; 251];
                let mut j_3: c_int = 1 as c_int;
                while j_3 < num_frames {
                    if j_3 - 1 as c_int > 0 as c_int
                        && ((*frames[(j_3 - 1 as c_int) as usize]).i_type == X264_TYPE_B
                            || (*frames[(j_3 - 1 as c_int) as usize]).i_type == X264_TYPE_BREF)
                    {
                        num_bframes -= 1;
                    } else {
                        last_nonb = j_3 - 1 as c_int;
                        num_bframes = (*h).param.i_bframe;
                    }
                    if num_bframes == 0 {
                        if (*frames[j_3 as usize]).i_type == X264_TYPE_AUTO
                            || ((*frames[j_3 as usize]).i_type == X264_TYPE_B
                                || (*frames[j_3 as usize]).i_type == X264_TYPE_BREF)
                        {
                            (*frames[j_3 as usize]).i_type = X264_TYPE_P;
                        }
                    } else if !((*frames[j_3 as usize]).i_type != X264_TYPE_AUTO) {
                        if (*frames[(j_3 + 1 as c_int) as usize]).i_type == X264_TYPE_B
                            || (*frames[(j_3 + 1 as c_int) as usize]).i_type == X264_TYPE_BREF
                        {
                            (*frames[j_3 as usize]).i_type = X264_TYPE_P;
                        } else {
                            let mut bframes: c_int = j_3 - last_nonb - 1 as c_int;
                            memset(
                                path.as_mut_ptr() as *mut c_void,
                                'B' as i32,
                                bframes as size_t,
                            );
                            strcpy(
                                path.as_mut_ptr().offset(bframes as isize),
                                b"PP\0" as *const u8 as *const c_char,
                            );
                            let mut cost_p: uint64_t = slicetype_path_cost(
                                h,
                                &mut a,
                                frames.as_mut_ptr().offset(last_nonb as isize),
                                path.as_mut_ptr(),
                                COST_MAX64 as uint64_t,
                            );
                            strcpy(
                                path.as_mut_ptr().offset(bframes as isize),
                                b"BP\0" as *const u8 as *const c_char,
                            );
                            let mut cost_b: uint64_t = slicetype_path_cost(
                                h,
                                &mut a,
                                frames.as_mut_ptr().offset(last_nonb as isize),
                                path.as_mut_ptr(),
                                cost_p,
                            );
                            if cost_b < cost_p {
                                (*frames[j_3 as usize]).i_type = X264_TYPE_B;
                            } else {
                                (*frames[j_3 as usize]).i_type = X264_TYPE_P;
                            }
                        }
                    }
                    j_3 += 1;
                }
            } else {
                let mut num_bframes_0: c_int = (*h).param.i_bframe;
                let mut j_4: c_int = 1 as c_int;
                while j_4 < num_frames {
                    if num_bframes_0 == 0 {
                        if (*frames[j_4 as usize]).i_type == X264_TYPE_AUTO
                            || ((*frames[j_4 as usize]).i_type == X264_TYPE_B
                                || (*frames[j_4 as usize]).i_type == X264_TYPE_BREF)
                        {
                            (*frames[j_4 as usize]).i_type = X264_TYPE_P;
                        }
                    } else if (*frames[j_4 as usize]).i_type == X264_TYPE_AUTO {
                        if (*frames[(j_4 + 1 as c_int) as usize]).i_type == X264_TYPE_B
                            || (*frames[(j_4 + 1 as c_int) as usize]).i_type == X264_TYPE_BREF
                        {
                            (*frames[j_4 as usize]).i_type = X264_TYPE_P;
                        } else {
                            (*frames[j_4 as usize]).i_type = X264_TYPE_B;
                        }
                    }
                    if (*frames[j_4 as usize]).i_type == X264_TYPE_B
                        || (*frames[j_4 as usize]).i_type == X264_TYPE_BREF
                    {
                        num_bframes_0 -= 1;
                    } else {
                        num_bframes_0 = (*h).param.i_bframe;
                    }
                    j_4 += 1;
                }
            }
            if (*frames[num_frames as usize]).i_type == X264_TYPE_AUTO
                || ((*frames[num_frames as usize]).i_type == X264_TYPE_B
                    || (*frames[num_frames as usize]).i_type == X264_TYPE_BREF)
            {
                (*frames[num_frames as usize]).i_type = X264_TYPE_P;
            }
            let mut num_bframes_1: c_int = 0 as c_int;
            while num_bframes_1 < num_frames
                && ((*frames[(num_bframes_1 + 1 as c_int) as usize]).i_type == X264_TYPE_B
                    || (*frames[(num_bframes_1 + 1 as c_int) as usize]).i_type == X264_TYPE_BREF)
            {
                num_bframes_1 += 1;
            }
            let mut j_5: c_int = 1 as c_int;
            while j_5 < num_bframes_1 + 1 as c_int {
                if (*frames[j_5 as usize]).i_forced_type == X264_TYPE_AUTO
                    && ((*frames[(j_5 + 1 as c_int) as usize]).i_forced_type == X264_TYPE_AUTO
                        || ((*frames[(j_5 + 1 as c_int) as usize]).i_forced_type == X264_TYPE_I
                            || (*frames[(j_5 + 1 as c_int) as usize]).i_forced_type
                                == X264_TYPE_IDR
                            || (*frames[(j_5 + 1 as c_int) as usize]).i_forced_type
                                == X264_TYPE_KEYFRAME))
                    && (*h).param.i_scenecut_threshold != 0
                    && scenecut(
                        h,
                        &mut a,
                        frames.as_mut_ptr(),
                        j_5,
                        j_5 + 1 as c_int,
                        0 as c_int,
                        orig_num_frames,
                        i_max_search,
                    ) != 0
                {
                    (*frames[j_5 as usize]).i_type = X264_TYPE_P;
                    num_analysed_frames = j_5;
                    break;
                } else {
                    j_5 += 1;
                }
            }
            reset_start = if keyframe != 0 {
                1 as c_int
            } else if (num_bframes_1 + 2 as c_int) < num_analysed_frames + 1 as c_int {
                num_bframes_1 + 2 as c_int
            } else {
                num_analysed_frames + 1 as c_int
            };
        } else {
            let mut j_6: c_int = 1 as c_int;
            while j_6 <= num_frames {
                if (*frames[j_6 as usize]).i_type == X264_TYPE_AUTO
                    || ((*frames[j_6 as usize]).i_type == X264_TYPE_B
                        || (*frames[j_6 as usize]).i_type == X264_TYPE_BREF)
                {
                    (*frames[j_6 as usize]).i_type = X264_TYPE_P;
                }
                j_6 += 1;
            }
            reset_start = (keyframe == 0) as c_int + 1 as c_int;
        }
        if (*h).param.rc.b_mb_tree != 0 {
            macroblock_tree(
                h,
                &mut a,
                frames.as_mut_ptr(),
                if num_frames < (*h).param.i_keyint_max {
                    num_frames
                } else {
                    (*h).param.i_keyint_max
                },
                keyframe,
            );
        }
        if (*h).param.b_intra_refresh == 0 {
            let mut last_keyframe: c_int = (*(*h).lookahead).i_last_keyframe;
            let mut last_possible: c_int = 0 as c_int;
            let mut j_7: c_int = 1 as c_int;
            while j_7 <= num_frames {
                let mut frm: *mut x264_frame_t = frames[j_7 as usize];
                let mut keyframe_dist: c_int = (*frm).i_frame - last_keyframe;
                if (*frm).i_forced_type == X264_TYPE_AUTO
                    || ((*frm).i_forced_type == X264_TYPE_I
                        || (*frm).i_forced_type == X264_TYPE_IDR
                        || (*frm).i_forced_type == X264_TYPE_KEYFRAME)
                {
                    if (*h).param.b_open_gop != 0
                        || !((*frames[(j_7 - 1 as c_int) as usize]).i_forced_type == X264_TYPE_B
                            || (*frames[(j_7 - 1 as c_int) as usize]).i_forced_type
                                == X264_TYPE_BREF)
                    {
                        last_possible = j_7;
                    }
                }
                if keyframe_dist >= (*h).param.i_keyint_max {
                    if last_possible != 0 as c_int && last_possible != j_7 {
                        j_7 = last_possible;
                        frm = frames[j_7 as usize];
                        keyframe_dist = (*frm).i_frame - last_keyframe;
                    }
                    last_possible = 0 as c_int;
                    if (*frm).i_type != X264_TYPE_IDR {
                        (*frm).i_type = if (*h).param.b_open_gop != 0 {
                            X264_TYPE_I
                        } else {
                            X264_TYPE_IDR
                        };
                    }
                }
                if (*frm).i_type == X264_TYPE_I && keyframe_dist >= (*h).param.i_keyint_min {
                    if (*h).param.b_open_gop != 0 {
                        last_keyframe = (*frm).i_frame;
                        if (*h).param.b_bluray_compat != 0 {
                            let mut bframes_0: c_int = 0 as c_int;
                            while bframes_0 < j_7 - 1 as c_int
                                && ((*frames[(j_7 - 1 as c_int - bframes_0) as usize]).i_type
                                    == X264_TYPE_B
                                    || (*frames[(j_7 - 1 as c_int - bframes_0) as usize]).i_type
                                        == X264_TYPE_BREF)
                            {
                                bframes_0 += 1;
                            }
                            last_keyframe -= bframes_0;
                        }
                    } else if (*frm).i_forced_type != X264_TYPE_I {
                        (*frm).i_type = X264_TYPE_IDR;
                    }
                }
                if (*frm).i_type == X264_TYPE_IDR {
                    last_keyframe = (*frm).i_frame;
                    if j_7 > 1 as c_int
                        && ((*frames[(j_7 - 1 as c_int) as usize]).i_type == X264_TYPE_B
                            || (*frames[(j_7 - 1 as c_int) as usize]).i_type == X264_TYPE_BREF)
                    {
                        (*frames[(j_7 - 1 as c_int) as usize]).i_type = X264_TYPE_P;
                    }
                }
                j_7 += 1;
            }
        }
        if b_vbv_lookahead != 0 {
            vbv_lookahead(h, &mut a, frames.as_mut_ptr(), num_frames, keyframe);
        }
        let mut j_8: c_int = reset_start;
        while j_8 <= num_frames {
            (*frames[j_8 as usize]).i_type = (*frames[j_8 as usize]).i_forced_type;
            j_8 += 1;
        }
    }
    use ::core::ffi::{c_char, c_double, c_float, c_int, c_uint, c_ulonglong, c_void};

    use crate::src::encoder::analyse::x264_mb_analysis_list_t;
    use crate::x264_h::FramePacking;
    #[no_mangle]
    #[c2rust::src_loc = "1745:1"]
    pub unsafe extern "C" fn x264_10_slicetype_decide(mut h: *mut x264_t) {
        let mut frames: [*mut x264_frame_t; 18] = [0 as *mut x264_frame_t; 18];
        let mut frm: *mut x264_frame_t = 0 as *mut x264_frame_t;
        let mut bframes: c_int = 0;
        let mut brefs: c_int = 0;
        if (*(*h).lookahead).next.i_size == 0 {
            return;
        }
        let mut lookahead_size: c_int = (*(*h).lookahead).next.i_size;
        let mut i: c_int = 0 as c_int;
        while i < (*(*h).lookahead).next.i_size {
            if (*h).param.b_vfr_input != 0 {
                let fresh5 = lookahead_size;
                lookahead_size = lookahead_size - 1;
                if fresh5 > 1 as c_int {
                    (**(*(*h).lookahead).next.list.offset(i as isize)).i_duration = 2 as int64_t
                        * ((**(*(*h).lookahead)
                            .next
                            .list
                            .offset((i + 1 as c_int) as isize))
                        .i_pts
                            - (**(*(*h).lookahead).next.list.offset(i as isize)).i_pts);
                } else {
                    (**(*(*h).lookahead).next.list.offset(i as isize)).i_duration =
                        (*h).i_prev_duration;
                }
            } else {
                (**(*(*h).lookahead).next.list.offset(i as isize)).i_duration = delta_tfi_divisor
                    [(**(*(*h).lookahead).next.list.offset(i as isize)).i_pic_struct as usize]
                    as int64_t;
            }
            (*h).i_prev_duration = (**(*(*h).lookahead).next.list.offset(i as isize)).i_duration;
            (**(*(*h).lookahead).next.list.offset(i as isize)).f_duration =
                ((**(*(*h).lookahead).next.list.offset(i as isize)).i_duration as c_double
                    * (*(*h).sps.as_mut_ptr()).vui.i_num_units_in_tick as c_double
                    / (*(*h).sps.as_mut_ptr()).vui.i_time_scale as c_double)
                    as c_float;
            if (**(*(*h).lookahead).next.list.offset(i as isize)).i_frame
                > (*h).i_disp_fields_last_frame
                && lookahead_size > 0 as c_int
            {
                (**(*(*h).lookahead).next.list.offset(i as isize)).i_field_cnt = (*h).i_disp_fields;
                (*h).i_disp_fields += (**(*(*h).lookahead).next.list.offset(i as isize)).i_duration;
                (*h).i_disp_fields_last_frame =
                    (**(*(*h).lookahead).next.list.offset(i as isize)).i_frame;
            } else if lookahead_size == 0 as c_int {
                (**(*(*h).lookahead).next.list.offset(i as isize)).i_field_cnt = (*h).i_disp_fields;
                (**(*(*h).lookahead).next.list.offset(i as isize)).i_duration =
                    (*h).i_prev_duration;
            }
            i += 1;
        }
        if (*h).param.rc.b_stat_read != 0 {
            let mut i_0: c_int = 0 as c_int;
            while i_0 < (*(*h).lookahead).next.i_size {
                (**(*(*h).lookahead).next.list.offset(i_0 as isize)).i_type =
                    x264_10_ratecontrol_slice_type(
                        h,
                        (**(*(*h).lookahead).next.list.offset(i_0 as isize)).i_frame,
                    );
                i_0 += 1;
            }
        } else if (*h).param.i_bframe != 0 && (*h).param.i_bframe_adaptive != 0
            || (*h).param.i_scenecut_threshold != 0
            || (*h).param.rc.b_mb_tree != 0
            || (*h).param.rc.i_vbv_buffer_size != 0 && (*h).param.rc.i_lookahead != 0
        {
            x264_10_slicetype_analyse(h, 0 as c_int);
        }
        bframes = 0 as c_int;
        brefs = 0 as c_int;
        loop {
            frm = *(*(*h).lookahead).next.list.offset(bframes as isize);
            if (*frm).i_forced_type != X264_TYPE_AUTO
                && (*frm).i_type != (*frm).i_forced_type
                && !((*frm).i_forced_type == X264_TYPE_KEYFRAME
                    && ((*frm).i_type == X264_TYPE_I
                        || (*frm).i_type == X264_TYPE_IDR
                        || (*frm).i_type == X264_TYPE_KEYFRAME))
            {
                x264_10_log(
                    h,
                    X264_LOG_WARNING,
                    b"forced frame type (%d) at %d was changed to frame type (%d)\n\0" as *const u8
                        as *const c_char,
                    (*frm).i_forced_type,
                    (*frm).i_frame,
                    (*frm).i_type,
                );
            }
            if (*frm).i_type == X264_TYPE_BREF
                && (*h).param.i_bframe_pyramid < X264_B_PYRAMID_NORMAL
                && brefs == (*h).param.i_bframe_pyramid
            {
                (*frm).i_type = X264_TYPE_B;
                x264_10_log(
                    h,
                    X264_LOG_WARNING,
                    b"B-ref at frame %d incompatible with B-pyramid %s \n\0" as *const u8
                        as *const c_char,
                    (*frm).i_frame,
                    x264_b_pyramid_names[(*h).param.i_bframe_pyramid as usize],
                );
            } else if (*frm).i_type == X264_TYPE_BREF
                && (*h).param.i_bframe_pyramid == X264_B_PYRAMID_NORMAL
                && brefs != 0
                && (*h).param.i_frame_reference <= brefs + 3 as c_int
            {
                (*frm).i_type = X264_TYPE_B;
                x264_10_log(
                    h,
                    X264_LOG_WARNING,
                    b"B-ref at frame %d incompatible with B-pyramid %s and %d reference frames\n\0"
                        as *const u8 as *const c_char,
                    (*frm).i_frame,
                    x264_b_pyramid_names[(*h).param.i_bframe_pyramid as usize],
                    (*h).param.i_frame_reference,
                );
            }
            if (*frm).i_type == X264_TYPE_KEYFRAME {
                (*frm).i_type = if (*h).param.b_open_gop != 0 {
                    X264_TYPE_I
                } else {
                    X264_TYPE_IDR
                };
            }
            if ((*h).param.b_intra_refresh == 0 || (*frm).i_frame == 0 as c_int)
                && (*frm).i_frame - (*(*h).lookahead).i_last_keyframe >= (*h).param.i_keyint_max
            {
                if (*frm).i_type == X264_TYPE_AUTO || (*frm).i_type == X264_TYPE_I {
                    (*frm).i_type = if (*h).param.b_open_gop != 0
                        && (*(*h).lookahead).i_last_keyframe >= 0 as c_int
                    {
                        X264_TYPE_I
                    } else {
                        X264_TYPE_IDR
                    };
                }
                let mut warn: c_int = ((*frm).i_type != X264_TYPE_IDR) as c_int;
                if warn != 0 && (*h).param.b_open_gop != 0 {
                    warn &= ((*frm).i_type != X264_TYPE_I) as c_int;
                }
                if warn != 0 {
                    x264_10_log(
                        h,
                        X264_LOG_WARNING,
                        b"specified frame type (%d) at %d is not compatible with keyframe interval\n\0"
                            as *const u8 as *const c_char,
                        (*frm).i_type,
                        (*frm).i_frame,
                    );
                    (*frm).i_type = if (*h).param.b_open_gop != 0
                        && (*(*h).lookahead).i_last_keyframe >= 0 as c_int
                    {
                        X264_TYPE_I
                    } else {
                        X264_TYPE_IDR
                    };
                }
            }
            if (*frm).i_type == X264_TYPE_I
                && (*frm).i_frame - (*(*h).lookahead).i_last_keyframe >= (*h).param.i_keyint_min
            {
                if (*h).param.b_open_gop != 0 {
                    (*(*h).lookahead).i_last_keyframe = (*frm).i_frame;
                    if (*h).param.b_bluray_compat != 0 {
                        (*(*h).lookahead).i_last_keyframe -= bframes;
                    }
                    (*frm).b_keyframe = 1 as c_int;
                } else {
                    (*frm).i_type = X264_TYPE_IDR;
                }
            }
            if (*frm).i_type == X264_TYPE_IDR {
                (*(*h).lookahead).i_last_keyframe = (*frm).i_frame;
                (*frm).b_keyframe = 1 as c_int;
                if bframes > 0 as c_int {
                    bframes -= 1;
                    (**(*(*h).lookahead).next.list.offset(bframes as isize)).i_type = X264_TYPE_P;
                }
            }
            if bframes == (*h).param.i_bframe
                || (*(*(*h).lookahead)
                    .next
                    .list
                    .offset((bframes + 1 as c_int) as isize))
                .is_null()
            {
                if (*frm).i_type == X264_TYPE_B || (*frm).i_type == X264_TYPE_BREF {
                    x264_10_log(
                        h,
                        X264_LOG_WARNING,
                        b"specified frame type is not compatible with max B-frames\n\0" as *const u8
                            as *const c_char,
                    );
                }
                if (*frm).i_type == X264_TYPE_AUTO
                    || ((*frm).i_type == X264_TYPE_B || (*frm).i_type == X264_TYPE_BREF)
                {
                    (*frm).i_type = X264_TYPE_P;
                }
            }
            if (*frm).i_type == X264_TYPE_BREF {
                brefs += 1;
            }
            if (*frm).i_type == X264_TYPE_AUTO {
                (*frm).i_type = X264_TYPE_B;
            } else if !((*frm).i_type == X264_TYPE_B || (*frm).i_type == X264_TYPE_BREF) {
                break;
            }
            bframes += 1;
        }
        if bframes != 0 {
            (**(*(*h).lookahead)
                .next
                .list
                .offset((bframes - 1 as c_int) as isize))
            .b_last_minigop_bframe = 1 as uint8_t;
        }
        (**(*(*h).lookahead).next.list.offset(bframes as isize)).i_bframes = bframes as uint8_t;
        if (*h).param.i_bframe_pyramid != 0 && bframes > 1 as c_int && brefs == 0 {
            (**(*(*h).lookahead)
                .next
                .list
                .offset(((bframes - 1 as c_int) / 2 as c_int) as isize))
            .i_type = X264_TYPE_BREF;
            brefs += 1;
        }
        if (*h).param.rc.i_rc_method != X264_RC_CQP {
            let mut a: x264_mb_analysis_t = x264_mb_analysis_t {
                i_lambda: 0,
                i_lambda2: 0,
                i_qp: 0,
                p_cost_mv: 0 as *mut uint16_t,
                p_cost_ref: [0 as *mut uint16_t; 2],
                i_mbrd: 0,
                b_fast_intra: 0,
                b_force_intra: 0,
                b_avoid_topright: 0,
                b_try_skip: 0,
                i_satd_i16x16: 0,
                i_satd_i16x16_dir: [0; 7],
                i_predict16x16: 0,
                i_satd_i8x8: 0,
                i_cbp_i8x8_luma: 0,
                i_satd_i8x8_dir: [[0; 16]; 4],
                i_predict8x8: [0; 4],
                i_satd_i4x4: 0,
                i_predict4x4: [0; 16],
                i_satd_pcm: 0,
                i_satd_chroma: 0,
                i_satd_chroma_dir: [0; 7],
                i_predict8x8chroma: 0,
                l0: x264_mb_analysis_list_t {
                    me16x16: x264_me_t {
                        i_pixel: 0,
                        p_cost_mv: 0 as *mut uint16_t,
                        i_ref_cost: 0,
                        i_ref: 0,
                        weight: 0 as *const x264_weight_t,
                        p_fref: [0 as *mut pixel; 12],
                        p_fref_w: 0 as *mut pixel,
                        p_fenc: [0 as *mut pixel; 3],
                        integral: 0 as *mut uint16_t,
                        i_stride: [0; 3],
                        mvp: [0; 2],
                        cost_mv: 0,
                        cost: 0,
                        mv: [0; 2],
                    },
                    bi16x16: x264_me_t {
                        i_pixel: 0,
                        p_cost_mv: 0 as *mut uint16_t,
                        i_ref_cost: 0,
                        i_ref: 0,
                        weight: 0 as *const x264_weight_t,
                        p_fref: [0 as *mut pixel; 12],
                        p_fref_w: 0 as *mut pixel,
                        p_fenc: [0 as *mut pixel; 3],
                        integral: 0 as *mut uint16_t,
                        i_stride: [0; 3],
                        mvp: [0; 2],
                        cost_mv: 0,
                        cost: 0,
                        mv: [0; 2],
                    },
                    me8x8: [x264_me_t {
                        i_pixel: 0,
                        p_cost_mv: 0 as *mut uint16_t,
                        i_ref_cost: 0,
                        i_ref: 0,
                        weight: 0 as *const x264_weight_t,
                        p_fref: [0 as *mut pixel; 12],
                        p_fref_w: 0 as *mut pixel,
                        p_fenc: [0 as *mut pixel; 3],
                        integral: 0 as *mut uint16_t,
                        i_stride: [0; 3],
                        mvp: [0; 2],
                        cost_mv: 0,
                        cost: 0,
                        mv: [0; 2],
                    }; 4],
                    me4x4: [[x264_me_t {
                        i_pixel: 0,
                        p_cost_mv: 0 as *mut uint16_t,
                        i_ref_cost: 0,
                        i_ref: 0,
                        weight: 0 as *const x264_weight_t,
                        p_fref: [0 as *mut pixel; 12],
                        p_fref_w: 0 as *mut pixel,
                        p_fenc: [0 as *mut pixel; 3],
                        integral: 0 as *mut uint16_t,
                        i_stride: [0; 3],
                        mvp: [0; 2],
                        cost_mv: 0,
                        cost: 0,
                        mv: [0; 2],
                    }; 4]; 4],
                    me8x4: [[x264_me_t {
                        i_pixel: 0,
                        p_cost_mv: 0 as *mut uint16_t,
                        i_ref_cost: 0,
                        i_ref: 0,
                        weight: 0 as *const x264_weight_t,
                        p_fref: [0 as *mut pixel; 12],
                        p_fref_w: 0 as *mut pixel,
                        p_fenc: [0 as *mut pixel; 3],
                        integral: 0 as *mut uint16_t,
                        i_stride: [0; 3],
                        mvp: [0; 2],
                        cost_mv: 0,
                        cost: 0,
                        mv: [0; 2],
                    }; 2]; 4],
                    me4x8: [[x264_me_t {
                        i_pixel: 0,
                        p_cost_mv: 0 as *mut uint16_t,
                        i_ref_cost: 0,
                        i_ref: 0,
                        weight: 0 as *const x264_weight_t,
                        p_fref: [0 as *mut pixel; 12],
                        p_fref_w: 0 as *mut pixel,
                        p_fenc: [0 as *mut pixel; 3],
                        integral: 0 as *mut uint16_t,
                        i_stride: [0; 3],
                        mvp: [0; 2],
                        cost_mv: 0,
                        cost: 0,
                        mv: [0; 2],
                    }; 2]; 4],
                    me16x8: [x264_me_t {
                        i_pixel: 0,
                        p_cost_mv: 0 as *mut uint16_t,
                        i_ref_cost: 0,
                        i_ref: 0,
                        weight: 0 as *const x264_weight_t,
                        p_fref: [0 as *mut pixel; 12],
                        p_fref_w: 0 as *mut pixel,
                        p_fenc: [0 as *mut pixel; 3],
                        integral: 0 as *mut uint16_t,
                        i_stride: [0; 3],
                        mvp: [0; 2],
                        cost_mv: 0,
                        cost: 0,
                        mv: [0; 2],
                    }; 2],
                    me8x16: [x264_me_t {
                        i_pixel: 0,
                        p_cost_mv: 0 as *mut uint16_t,
                        i_ref_cost: 0,
                        i_ref: 0,
                        weight: 0 as *const x264_weight_t,
                        p_fref: [0 as *mut pixel; 12],
                        p_fref_w: 0 as *mut pixel,
                        p_fenc: [0 as *mut pixel; 3],
                        integral: 0 as *mut uint16_t,
                        i_stride: [0; 3],
                        mvp: [0; 2],
                        cost_mv: 0,
                        cost: 0,
                        mv: [0; 2],
                    }; 2],
                    i_rd16x16: 0,
                    i_cost8x8: 0,
                    i_cost4x4: [0; 4],
                    i_cost8x4: [0; 4],
                    i_cost4x8: [0; 4],
                    i_cost16x8: 0,
                    i_cost8x16: 0,
                    mvc: [[[0; 2]; 6]; 32],
                },
                l1: x264_mb_analysis_list_t {
                    me16x16: x264_me_t {
                        i_pixel: 0,
                        p_cost_mv: 0 as *mut uint16_t,
                        i_ref_cost: 0,
                        i_ref: 0,
                        weight: 0 as *const x264_weight_t,
                        p_fref: [0 as *mut pixel; 12],
                        p_fref_w: 0 as *mut pixel,
                        p_fenc: [0 as *mut pixel; 3],
                        integral: 0 as *mut uint16_t,
                        i_stride: [0; 3],
                        mvp: [0; 2],
                        cost_mv: 0,
                        cost: 0,
                        mv: [0; 2],
                    },
                    bi16x16: x264_me_t {
                        i_pixel: 0,
                        p_cost_mv: 0 as *mut uint16_t,
                        i_ref_cost: 0,
                        i_ref: 0,
                        weight: 0 as *const x264_weight_t,
                        p_fref: [0 as *mut pixel; 12],
                        p_fref_w: 0 as *mut pixel,
                        p_fenc: [0 as *mut pixel; 3],
                        integral: 0 as *mut uint16_t,
                        i_stride: [0; 3],
                        mvp: [0; 2],
                        cost_mv: 0,
                        cost: 0,
                        mv: [0; 2],
                    },
                    me8x8: [x264_me_t {
                        i_pixel: 0,
                        p_cost_mv: 0 as *mut uint16_t,
                        i_ref_cost: 0,
                        i_ref: 0,
                        weight: 0 as *const x264_weight_t,
                        p_fref: [0 as *mut pixel; 12],
                        p_fref_w: 0 as *mut pixel,
                        p_fenc: [0 as *mut pixel; 3],
                        integral: 0 as *mut uint16_t,
                        i_stride: [0; 3],
                        mvp: [0; 2],
                        cost_mv: 0,
                        cost: 0,
                        mv: [0; 2],
                    }; 4],
                    me4x4: [[x264_me_t {
                        i_pixel: 0,
                        p_cost_mv: 0 as *mut uint16_t,
                        i_ref_cost: 0,
                        i_ref: 0,
                        weight: 0 as *const x264_weight_t,
                        p_fref: [0 as *mut pixel; 12],
                        p_fref_w: 0 as *mut pixel,
                        p_fenc: [0 as *mut pixel; 3],
                        integral: 0 as *mut uint16_t,
                        i_stride: [0; 3],
                        mvp: [0; 2],
                        cost_mv: 0,
                        cost: 0,
                        mv: [0; 2],
                    }; 4]; 4],
                    me8x4: [[x264_me_t {
                        i_pixel: 0,
                        p_cost_mv: 0 as *mut uint16_t,
                        i_ref_cost: 0,
                        i_ref: 0,
                        weight: 0 as *const x264_weight_t,
                        p_fref: [0 as *mut pixel; 12],
                        p_fref_w: 0 as *mut pixel,
                        p_fenc: [0 as *mut pixel; 3],
                        integral: 0 as *mut uint16_t,
                        i_stride: [0; 3],
                        mvp: [0; 2],
                        cost_mv: 0,
                        cost: 0,
                        mv: [0; 2],
                    }; 2]; 4],
                    me4x8: [[x264_me_t {
                        i_pixel: 0,
                        p_cost_mv: 0 as *mut uint16_t,
                        i_ref_cost: 0,
                        i_ref: 0,
                        weight: 0 as *const x264_weight_t,
                        p_fref: [0 as *mut pixel; 12],
                        p_fref_w: 0 as *mut pixel,
                        p_fenc: [0 as *mut pixel; 3],
                        integral: 0 as *mut uint16_t,
                        i_stride: [0; 3],
                        mvp: [0; 2],
                        cost_mv: 0,
                        cost: 0,
                        mv: [0; 2],
                    }; 2]; 4],
                    me16x8: [x264_me_t {
                        i_pixel: 0,
                        p_cost_mv: 0 as *mut uint16_t,
                        i_ref_cost: 0,
                        i_ref: 0,
                        weight: 0 as *const x264_weight_t,
                        p_fref: [0 as *mut pixel; 12],
                        p_fref_w: 0 as *mut pixel,
                        p_fenc: [0 as *mut pixel; 3],
                        integral: 0 as *mut uint16_t,
                        i_stride: [0; 3],
                        mvp: [0; 2],
                        cost_mv: 0,
                        cost: 0,
                        mv: [0; 2],
                    }; 2],
                    me8x16: [x264_me_t {
                        i_pixel: 0,
                        p_cost_mv: 0 as *mut uint16_t,
                        i_ref_cost: 0,
                        i_ref: 0,
                        weight: 0 as *const x264_weight_t,
                        p_fref: [0 as *mut pixel; 12],
                        p_fref_w: 0 as *mut pixel,
                        p_fenc: [0 as *mut pixel; 3],
                        integral: 0 as *mut uint16_t,
                        i_stride: [0; 3],
                        mvp: [0; 2],
                        cost_mv: 0,
                        cost: 0,
                        mv: [0; 2],
                    }; 2],
                    i_rd16x16: 0,
                    i_cost8x8: 0,
                    i_cost4x4: [0; 4],
                    i_cost8x4: [0; 4],
                    i_cost4x8: [0; 4],
                    i_cost16x8: 0,
                    i_cost8x16: 0,
                    mvc: [[[0; 2]; 6]; 32],
                },
                i_cost16x16bi: 0,
                i_cost16x16direct: 0,
                i_cost8x8bi: 0,
                i_cost8x8direct: [0; 4],
                i_satd8x8: [[0; 4]; 3],
                i_cost_est16x8: [0; 2],
                i_cost_est8x16: [0; 2],
                i_cost16x8bi: 0,
                i_cost8x16bi: 0,
                i_rd16x16bi: 0,
                i_rd16x16direct: 0,
                i_rd16x8bi: 0,
                i_rd8x16bi: 0,
                i_rd8x8bi: 0,
                i_mb_partition16x8: [0; 2],
                i_mb_partition8x16: [0; 2],
                i_mb_type16x8: 0,
                i_mb_type8x16: 0,
                b_direct_available: 0,
                b_early_terminate: 0,
            };
            let mut p0: c_int = 0;
            let mut p1: c_int = 0;
            let mut b: c_int = 0;
            b = bframes + 1 as c_int;
            p1 = b;
            lowres_context_init(h, &mut a);
            frames[0] = (*(*h).lookahead).last_nonb;
            memcpy(
                &mut *frames.as_mut_ptr().offset(1) as *mut *mut x264_frame_t as *mut c_void,
                (*(*h).lookahead).next.list as *const c_void,
                ((bframes + 1 as c_int) as size_t)
                    .wrapping_mul(::core::mem::size_of::<*mut x264_frame_t>() as size_t),
            );
            if (**(*(*h).lookahead).next.list.offset(bframes as isize)).i_type == X264_TYPE_I
                || (**(*(*h).lookahead).next.list.offset(bframes as isize)).i_type == X264_TYPE_IDR
                || (**(*(*h).lookahead).next.list.offset(bframes as isize)).i_type
                    == X264_TYPE_KEYFRAME
            {
                p0 = bframes + 1 as c_int;
            } else {
                p0 = 0 as c_int;
            }
            slicetype_frame_cost(h, &mut a, frames.as_mut_ptr(), p0, p1, b);
            if (p0 != p1 || bframes != 0) && (*h).param.rc.i_vbv_buffer_size != 0 {
                slicetype_frame_cost(h, &mut a, frames.as_mut_ptr(), b, b, b);
                p0 = 0 as c_int;
                b = 1 as c_int;
                while b <= bframes {
                    if (*frames[b as usize]).i_type == X264_TYPE_B {
                        p1 = b;
                        while (*frames[p1 as usize]).i_type == X264_TYPE_B {
                            p1 += 1;
                        }
                    } else {
                        p1 = bframes + 1 as c_int;
                    }
                    slicetype_frame_cost(h, &mut a, frames.as_mut_ptr(), p0, p1, b);
                    if (*frames[b as usize]).i_type == X264_TYPE_BREF {
                        p0 = b;
                    }
                    b += 1;
                }
            }
        }
        if (*h).param.rc.b_stat_read == 0
            && (**(*(*h).lookahead).next.list.offset(bframes as isize)).i_type == X264_TYPE_P
            && (*h).param.analyse.i_weighted_pred >= X264_WEIGHTP_SIMPLE
        {
            x264_10_weights_analyse(
                h,
                *(*(*h).lookahead).next.list.offset(bframes as isize),
                (*(*h).lookahead).last_nonb,
                0 as c_int,
            );
        }
        let mut i_coded: c_int = (**(*(*h).lookahead).next.list.offset(0)).i_frame;
        if bframes != 0 {
            let mut idx_list: [c_int; 2] = [brefs + 1 as c_int, 1 as c_int];
            let mut i_1: c_int = 0 as c_int;
            while i_1 < bframes {
                let fresh6 = idx_list[((**(*(*h).lookahead).next.list.offset(i_1 as isize)).i_type
                    == X264_TYPE_BREF) as c_int as usize];
                idx_list[((**(*(*h).lookahead).next.list.offset(i_1 as isize)).i_type
                    == X264_TYPE_BREF) as c_int as usize] =
                    idx_list[((**(*(*h).lookahead).next.list.offset(i_1 as isize)).i_type
                        == X264_TYPE_BREF) as c_int as usize]
                        + 1;
                let mut idx: c_int = fresh6;
                frames[idx as usize] = *(*(*h).lookahead).next.list.offset(i_1 as isize);
                (*frames[idx as usize]).i_reordered_pts =
                    (**(*(*h).lookahead).next.list.offset(idx as isize)).i_pts;
                i_1 += 1;
            }
            frames[0] = *(*(*h).lookahead).next.list.offset(bframes as isize);
            (*frames[0]).i_reordered_pts = (**(*(*h).lookahead).next.list.offset(0)).i_pts;
            memcpy(
                (*(*h).lookahead).next.list as *mut c_void,
                frames.as_mut_ptr() as *const c_void,
                ((bframes + 1 as c_int) as size_t)
                    .wrapping_mul(::core::mem::size_of::<*mut x264_frame_t>() as size_t),
            );
        }
        let mut i_2: c_int = 0 as c_int;
        while i_2 <= bframes {
            let fresh7 = i_coded;
            i_coded = i_coded + 1;
            (**(*(*h).lookahead).next.list.offset(i_2 as isize)).i_coded = fresh7;
            if i_2 != 0 {
                calculate_durations(
                    h,
                    *(*(*h).lookahead).next.list.offset(i_2 as isize),
                    *(*(*h).lookahead)
                        .next
                        .list
                        .offset((i_2 - 1 as c_int) as isize),
                    &mut (*h).i_cpb_delay,
                    &mut (*h).i_coded_fields,
                );
                (**(*(*h).lookahead).next.list.offset(0)).f_planned_cpb_duration
                    [(i_2 - 1 as c_int) as usize] =
                    (**(*(*h).lookahead).next.list.offset(i_2 as isize)).i_cpb_duration as c_double
                        * (*(*h).sps.as_mut_ptr()).vui.i_num_units_in_tick as c_double
                        / (*(*h).sps.as_mut_ptr()).vui.i_time_scale as c_double;
            } else {
                calculate_durations(
                    h,
                    *(*(*h).lookahead).next.list.offset(i_2 as isize),
                    0 as *mut x264_frame_t,
                    &mut (*h).i_cpb_delay,
                    &mut (*h).i_coded_fields,
                );
            }
            i_2 += 1;
        }
    }
    #[no_mangle]
    #[c2rust::src_loc = "1976:1"]
    pub unsafe extern "C" fn x264_10_rc_analyse_slice(mut h: *mut x264_t) -> c_int {
        let mut p0: c_int = 0 as c_int;
        let mut p1: c_int = 0;
        let mut b: c_int = 0;
        let mut cost: c_int = 0;
        if (*(*h).fenc).i_type == X264_TYPE_I
            || (*(*h).fenc).i_type == X264_TYPE_IDR
            || (*(*h).fenc).i_type == X264_TYPE_KEYFRAME
        {
            b = 0 as c_int;
            p1 = b;
        } else if (*(*h).fenc).i_type == X264_TYPE_P {
            b = (*(*h).fenc).i_bframes as c_int + 1 as c_int;
            p1 = b;
        } else {
            p1 = ((*(*h).fref_nearest[1]).i_poc - (*(*h).fref_nearest[0]).i_poc) / 2 as c_int;
            b = ((*(*h).fenc).i_poc - (*(*h).fref_nearest[0]).i_poc) / 2 as c_int;
        }
        let mut frames: *mut *mut x264_frame_t =
            (&mut (*h).fenc as *mut *mut x264_frame_t).offset(-(b as isize));
        cost = (**frames.offset(b as isize)).i_cost_est[(b - p0) as usize][(p1 - b) as usize];
        if cost >= 0 as c_int {
        } else {
            __assert_fail(
                b"cost >= 0\0" as *const u8 as *const c_char,
                b"encoder/slicetype.c\0" as *const u8 as *const c_char,
                1996 as c_uint,
                ::core::mem::transmute::<[u8; 39], [c_char; 39]>(
                    *b"int x264_10_rc_analyse_slice(x264_t *)\0",
                )
                .as_ptr(),
            );
        }
        'c_55672: {
            if cost >= 0 as c_int {
            } else {
                __assert_fail(
                    b"cost >= 0\0" as *const u8 as *const c_char,
                    b"encoder/slicetype.c\0" as *const u8 as *const c_char,
                    1996 as c_uint,
                    ::core::mem::transmute::<[u8; 39], [c_char; 39]>(
                        *b"int x264_10_rc_analyse_slice(x264_t *)\0",
                    )
                    .as_ptr(),
                );
            }
        };
        if (*h).param.rc.b_mb_tree != 0 && (*h).param.rc.b_stat_read == 0 {
            cost = slicetype_frame_cost_recalculate(h, frames, p0, p1, b);
            if b != 0 && (*h).param.rc.i_vbv_buffer_size != 0 {
                slicetype_frame_cost_recalculate(h, frames, b, b, b);
            }
        } else if (*h).param.rc.i_aq_mode != 0 {
            cost =
                (**frames.offset(b as isize)).i_cost_est_aq[(b - p0) as usize][(p1 - b) as usize];
        }
        (*(*h).fenc).i_row_satd = (*(*h).fenc).i_row_satds[(b - p0) as usize][(p1 - b) as usize];
        (*(*h).fdec).i_row_satd = (*(*h).fdec).i_row_satds[(b - p0) as usize][(p1 - b) as usize];
        (*(*h).fdec).i_satd = cost;
        memcpy(
            (*(*h).fdec).i_row_satd as *mut c_void,
            (*(*h).fenc).i_row_satd as *const c_void,
            ((*h).mb.i_mb_height as size_t).wrapping_mul(::core::mem::size_of::<c_int>() as size_t),
        );
        if !((*(*h).fenc).i_type == X264_TYPE_I
            || (*(*h).fenc).i_type == X264_TYPE_IDR
            || (*(*h).fenc).i_type == X264_TYPE_KEYFRAME)
        {
            memcpy(
                (*(*h).fdec).i_row_satds[0][0] as *mut c_void,
                (*(*h).fenc).i_row_satds[0][0] as *const c_void,
                ((*h).mb.i_mb_height as size_t)
                    .wrapping_mul(::core::mem::size_of::<c_int>() as size_t),
            );
        }
        if (*h).param.b_intra_refresh != 0
            && (*h).param.rc.i_vbv_buffer_size != 0
            && (*(*h).fenc).i_type == X264_TYPE_P
        {
            let mut ip_factor: c_int =
                (256 as c_int as c_float * (*h).param.rc.f_ip_factor) as c_int;
            let mut y: c_int = 0 as c_int;
            while y < (*h).mb.i_mb_height {
                let mut mb_xy: c_int = y * (*h).mb.i_mb_stride + (*(*h).fdec).i_pir_start_col;
                let mut x: c_int = (*(*h).fdec).i_pir_start_col;
                while x <= (*(*h).fdec).i_pir_end_col {
                    let mut intra_cost: c_int =
                        *(*(*h).fenc).i_intra_cost.offset(mb_xy as isize) as c_int * ip_factor
                            + 128 as c_int
                            >> 8 as c_int;
                    let mut inter_cost: c_int =
                        *(*(*h).fenc).lowres_costs[(b - p0) as usize][(p1 - b) as usize]
                            .offset(mb_xy as isize) as c_int
                            & LOWRES_COST_MASK;
                    let mut diff: c_int = intra_cost - inter_cost;
                    if (*h).param.rc.i_aq_mode != 0 {
                        *(*(*h).fdec).i_row_satd.offset(y as isize) += diff
                            * *(**frames.offset(b as isize))
                                .i_inv_qscale_factor
                                .offset(mb_xy as isize) as c_int
                            + 128 as c_int
                            >> 8 as c_int;
                    } else {
                        *(*(*h).fdec).i_row_satd.offset(y as isize) += diff;
                    }
                    cost += diff;
                    x += 1;
                    mb_xy += 1;
                }
                y += 1;
            }
        }
        return cost;
    }
    use super::__stddef_null_h::NULL;
    use super::__stddef_size_t_h::size_t;
    use super::assert_h::__assert_fail;
    use super::base_h::{
        x264_clip3, x264_clip3f, x264_exp2fix8, x264_log2, x264_median_mv, x264_union32_t,
        x264_union64_t, CHROMA_444, X264_BFRAME_MAX, X264_WEIGHTP_FAKE,
    };
    use super::bitstream_h::{bs_size_se, bs_size_ue};
    use super::common_h::{
        pixel, x264_10_log, x264_t, FDEC_STRIDE, FENC_STRIDE, SIZEOF_PIXEL, X264_LOOKAHEAD_QP,
    };
    use super::frame_h::{
        x264_10_frame_expand_border_chroma, x264_10_weight_scale_plane, x264_frame_t,
        LOWRES_COST_MASK, LOWRES_COST_SHIFT, PADH, PADV,
    };
    use super::internal::BIT_DEPTH;
    use super::macroblock_h::ALL_NEIGHBORS;
    use super::mathcalls_h::{fabsf, round, sqrtf};
    use super::mc_h::{weight_fn_t, x264_weight_t};
    use super::me_h::{x264_10_me_search_ref, x264_me_t, COST_MAX, COST_MAX64};
    use super::pixel_h::{PIXEL_16x16, PIXEL_8x8};
    use super::predict_h::I_PRED_CHROMA_P;
    use super::ratecontrol_h::x264_10_ratecontrol_slice_type;
    use super::stdint_h::intptr_t;
    use super::stdint_intn_h::{int16_t, int32_t, int64_t};
    use super::stdint_uintn_h::{uint16_t, uint32_t, uint64_t, uint8_t};
    use super::string_h::{memcpy, memset, strcpy};
    use super::tables_h::{x264_lambda_tab, x264_zero};
    use super::threadpool_h::{x264_10_threadpool_run, x264_10_threadpool_wait};
    use super::x264_h::{
        x264_b_pyramid_names, X264_B_ADAPT_FAST, X264_B_ADAPT_TRELLIS, X264_B_PYRAMID_NORMAL,
        X264_LOG_DEBUG, X264_LOG_WARNING, X264_ME_DIA, X264_RC_CQP, X264_TYPE_AUTO, X264_TYPE_B,
        X264_TYPE_BREF, X264_TYPE_I, X264_TYPE_IDR, X264_TYPE_KEYFRAME, X264_TYPE_P,
        X264_WEIGHTP_SIMPLE,
    };
    use crate::src::encoder::analyse::{mb_analyse_load_costs, x264_mb_analysis_t};
}
#[c2rust::header_src = "/home/nwplayer123/Hacks/hex264/x264/common/rectangle.h:28"]
pub mod rectangle_h {
    #[inline(always)]
    #[c2rust::src_loc = "28:1"]
    pub unsafe extern "C" fn x264_macroblock_cache_rect(
        mut dst: *mut c_void,
        mut w: c_int,
        mut h: c_int,
        mut s: c_int,
        mut v: uint32_t,
    ) {
        let mut d: *mut uint8_t = dst as *mut uint8_t;
        let mut v2: uint16_t = (if s >= 2 as c_int {
            v
        } else {
            v.wrapping_mul(0x101 as uint32_t)
        }) as uint16_t;
        let mut v4: uint32_t = if s >= 4 as c_int {
            v
        } else if s >= 2 as c_int {
            v.wrapping_mul(0x10001 as uint32_t)
        } else {
            v.wrapping_mul(0x1010101 as uint32_t)
        };
        let mut v8: uint64_t = (v4 as uint64_t).wrapping_add((v4 as uint64_t) << 32 as c_int);
        s *= 8 as c_int;
        if w == 2 as c_int {
            (*(d.offset((s * 0 as c_int) as isize) as *mut x264_union16_t)).i = v2;
            if h == 1 as c_int {
                return;
            }
            (*(d.offset((s * 1 as c_int) as isize) as *mut x264_union16_t)).i = v2;
            if h == 2 as c_int {
                return;
            }
            (*(d.offset((s * 2 as c_int) as isize) as *mut x264_union16_t)).i = v2;
            (*(d.offset((s * 3 as c_int) as isize) as *mut x264_union16_t)).i = v2;
        } else if w == 4 as c_int {
            (*(d.offset((s * 0 as c_int) as isize) as *mut x264_union32_t)).i = v4;
            if h == 1 as c_int {
                return;
            }
            (*(d.offset((s * 1 as c_int) as isize) as *mut x264_union32_t)).i = v4;
            if h == 2 as c_int {
                return;
            }
            (*(d.offset((s * 2 as c_int) as isize) as *mut x264_union32_t)).i = v4;
            (*(d.offset((s * 3 as c_int) as isize) as *mut x264_union32_t)).i = v4;
        } else if w == 8 as c_int {
            if WORD_SIZE == 8 as uint64_t {
                (*(d.offset((s * 0 as c_int) as isize) as *mut x264_union64_t)).i = v8;
                if h == 1 as c_int {
                    return;
                }
                (*(d.offset((s * 1 as c_int) as isize) as *mut x264_union64_t)).i = v8;
                if h == 2 as c_int {
                    return;
                }
                (*(d.offset((s * 2 as c_int) as isize) as *mut x264_union64_t)).i = v8;
                (*(d.offset((s * 3 as c_int) as isize) as *mut x264_union64_t)).i = v8;
            } else {
                (*(d.offset((s * 0 as c_int) as isize).offset(0) as *mut x264_union32_t)).i = v4;
                (*(d.offset((s * 0 as c_int) as isize).offset(4) as *mut x264_union32_t)).i = v4;
                if h == 1 as c_int {
                    return;
                }
                (*(d.offset((s * 1 as c_int) as isize).offset(0) as *mut x264_union32_t)).i = v4;
                (*(d.offset((s * 1 as c_int) as isize).offset(4) as *mut x264_union32_t)).i = v4;
                if h == 2 as c_int {
                    return;
                }
                (*(d.offset((s * 2 as c_int) as isize).offset(0) as *mut x264_union32_t)).i = v4;
                (*(d.offset((s * 2 as c_int) as isize).offset(4) as *mut x264_union32_t)).i = v4;
                (*(d.offset((s * 3 as c_int) as isize).offset(0) as *mut x264_union32_t)).i = v4;
                (*(d.offset((s * 3 as c_int) as isize).offset(4) as *mut x264_union32_t)).i = v4;
            }
        } else if w == 16 as c_int {
            if h != 1 as c_int {
            } else {
                __assert_fail(
                    b"h != 1\0" as *const u8 as *const c_char,
                    b"./common/rectangle.h\0" as *const u8 as *const c_char,
                    82 as c_uint,
                    ::core::mem::transmute::<[u8; 65], [c_char; 65]>(
                        *b"void x264_macroblock_cache_rect(void *, int, int, int, uint32_t)\0",
                    )
                    .as_ptr(),
                );
            }
            if WORD_SIZE == 8 as uint64_t {
                loop {
                    (*(d.offset((s * 0 as c_int) as isize).offset(0) as *mut x264_union64_t)).i =
                        v8;
                    (*(d.offset((s * 0 as c_int) as isize).offset(8) as *mut x264_union64_t)).i =
                        v8;
                    (*(d.offset((s * 1 as c_int) as isize).offset(0) as *mut x264_union64_t)).i =
                        v8;
                    (*(d.offset((s * 1 as c_int) as isize).offset(8) as *mut x264_union64_t)).i =
                        v8;
                    h -= 2 as c_int;
                    d = d.offset((s * 2 as c_int) as isize);
                    if !(h != 0) {
                        break;
                    }
                }
            } else {
                loop {
                    (*(d.offset(0) as *mut x264_union32_t)).i = v4;
                    (*(d.offset(4) as *mut x264_union32_t)).i = v4;
                    (*(d.offset(8) as *mut x264_union32_t)).i = v4;
                    (*(d.offset(12 as c_int as isize) as *mut x264_union32_t)).i = v4;
                    d = d.offset(s as isize);
                    h -= 1;
                    if !(h != 0) {
                        break;
                    }
                }
            }
        } else {
            __assert_fail(
                b"0\0" as *const u8 as *const c_char,
                b"./common/rectangle.h\0" as *const u8 as *const c_char,
                108 as c_uint,
                ::core::mem::transmute::<[u8; 65], [c_char; 65]>(
                    *b"void x264_macroblock_cache_rect(void *, int, int, int, uint32_t)\0",
                )
                .as_ptr(),
            );
            'c_27015: {
                __assert_fail(
                    b"0\0" as *const u8 as *const c_char,
                    b"./common/rectangle.h\0" as *const u8 as *const c_char,
                    108 as c_uint,
                    ::core::mem::transmute::<[u8; 65], [c_char; 65]>(
                        *b"void x264_macroblock_cache_rect(void *, int, int, int, uint32_t)\0",
                    )
                    .as_ptr(),
                );
            };
        };
    }
    #[inline(always)]
    #[c2rust::src_loc = "119:1"]
    pub unsafe extern "C" fn x264_macroblock_cache_mv(
        mut h: *mut x264_t,
        mut x: c_int,
        mut y: c_int,
        mut width: c_int,
        mut height: c_int,
        mut i_list: c_int,
        mut mv: uint32_t,
    ) {
        let mut mv_cache: *mut c_void =
            &mut *(*(*h).mb.cache.mv.as_mut_ptr().offset(i_list as isize))
                .as_mut_ptr()
                .offset((X264_SCAN8_0 + x + 8 as c_int * y) as isize)
                as *mut [int16_t; 2] as *mut c_void;
        if 0 == 0 || 0 == 0 {
            x264_10_cache_mv_func_table[(width + (height << 1 as c_int) - 3 as c_int) as usize]
                .expect("non-null function pointer")(mv_cache, mv);
        } else {
            x264_macroblock_cache_rect(mv_cache, width * 4 as c_int, height, 4 as c_int, mv);
        };
    }
    #[inline(always)]
    #[c2rust::src_loc = "127:1"]
    pub unsafe extern "C" fn x264_macroblock_cache_mvd(
        mut h: *mut x264_t,
        mut x: c_int,
        mut y: c_int,
        mut width: c_int,
        mut height: c_int,
        mut i_list: c_int,
        mut mvd: uint16_t,
    ) {
        let mut mvd_cache: *mut c_void =
            &mut *(*(*h).mb.cache.mvd.as_mut_ptr().offset(i_list as isize))
                .as_mut_ptr()
                .offset((X264_SCAN8_0 + x + 8 as c_int * y) as isize)
                as *mut [uint8_t; 2] as *mut c_void;
        if 0 == 0 || 0 == 0 {
            x264_10_cache_mvd_func_table[(width + (height << 1 as c_int) - 3 as c_int) as usize]
                .expect("non-null function pointer")(mvd_cache, mvd as uint32_t);
        } else {
            x264_macroblock_cache_rect(
                mvd_cache,
                width * 2 as c_int,
                height,
                2 as c_int,
                mvd as uint32_t,
            );
        };
    }
    #[inline(always)]
    #[c2rust::src_loc = "135:1"]
    pub unsafe extern "C" fn x264_macroblock_cache_ref(
        mut h: *mut x264_t,
        mut x: c_int,
        mut y: c_int,
        mut width: c_int,
        mut height: c_int,
        mut i_list: c_int,
        mut ref_0: int8_t,
    ) {
        let mut ref_cache: *mut c_void =
            &mut *(*(*h).mb.cache.ref_0.as_mut_ptr().offset(i_list as isize))
                .as_mut_ptr()
                .offset((X264_SCAN8_0 + x + 8 as c_int * y) as isize) as *mut int8_t
                as *mut c_void;
        if 0 == 0 || 0 == 0 {
            x264_10_cache_ref_func_table[(width + (height << 1 as c_int) - 3 as c_int) as usize]
                .expect("non-null function pointer")(
                ref_cache, ref_0 as uint8_t as uint32_t
            );
        } else {
            x264_macroblock_cache_rect(
                ref_cache,
                width,
                height,
                1 as c_int,
                ref_0 as uint8_t as uint32_t,
            );
        };
    }
    #[inline(always)]
    #[c2rust::src_loc = "143:1"]
    pub unsafe extern "C" fn x264_macroblock_cache_skip(
        mut h: *mut x264_t,
        mut x: c_int,
        mut y: c_int,
        mut width: c_int,
        mut height: c_int,
        mut b_skip: c_int,
    ) {
        x264_macroblock_cache_rect(
            &mut *(*h)
                .mb
                .cache
                .skip
                .as_mut_ptr()
                .offset((X264_SCAN8_0 + x + 8 as c_int * y) as isize) as *mut int8_t
                as *mut c_void,
            width,
            height,
            1 as c_int,
            b_skip as uint32_t,
        );
    }
    #[inline(always)]
    #[c2rust::src_loc = "147:1"]
    pub unsafe extern "C" fn x264_macroblock_cache_intra8x8_pred(
        mut h: *mut x264_t,
        mut x: c_int,
        mut y: c_int,
        mut i_mode: c_int,
    ) {
        x264_macroblock_cache_rect(
            &mut *(*h)
                .mb
                .cache
                .intra4x4_pred_mode
                .as_mut_ptr()
                .offset((X264_SCAN8_0 + x + 8 as c_int * y) as isize) as *mut int8_t
                as *mut c_void,
            2 as c_int,
            2 as c_int,
            1 as c_int,
            i_mode as uint32_t,
        );
    }
    use ::core::ffi::{c_char, c_int, c_uint, c_void};

    use super::assert_h::__assert_fail;
    use super::base_h::{x264_union16_t, x264_union32_t, x264_union64_t, X264_SCAN8_0};
    use super::common_h::x264_t;
    use super::osdep_h::WORD_SIZE;
    use super::stdint_intn_h::{int16_t, int8_t};
    use super::stdint_uintn_h::{uint16_t, uint32_t, uint64_t, uint8_t};
    extern "C" {
        #[c2rust::src_loc = "112:15"]
        pub static mut x264_10_cache_mv_func_table:
            [Option<unsafe extern "C" fn(*mut c_void, uint32_t) -> ()>; 10];
        #[c2rust::src_loc = "114:15"]
        pub static mut x264_10_cache_mvd_func_table:
            [Option<unsafe extern "C" fn(*mut c_void, uint32_t) -> ()>; 10];
        #[c2rust::src_loc = "116:15"]
        pub static mut x264_10_cache_ref_func_table:
            [Option<unsafe extern "C" fn(*mut c_void, uint32_t) -> ()>; 10];
    }
}
#[c2rust::header_src = "/home/nwplayer123/Hacks/hex264/x264/encoder/macroblock.h:28"]
pub mod encoder_macroblock_h {
    #[inline(always)]
    #[c2rust::src_loc = "90:1"]
    pub unsafe extern "C" fn x264_quant_4x4(
        mut h: *mut x264_t,
        mut dct: *mut dctcoef,
        mut i_qp: c_int,
        mut ctx_block_cat: c_int,
        mut b_intra: c_int,
        mut p: c_int,
        mut idx: c_int,
    ) -> c_int {
        let mut i_quant_cat: c_int = if b_intra != 0 {
            if p != 0 {
                CQM_4IC as c_int
            } else {
                CQM_4IY as c_int
            }
        } else if p != 0 {
            CQM_4PC as c_int
        } else {
            CQM_4PY as c_int
        };
        if (*h).mb.b_noise_reduction != 0 {
            (*h).quantf.denoise_dct.expect("non-null function pointer")(
                dct as *mut dctcoef,
                (*(*h)
                    .nr_residual_sum
                    .offset((0 as c_int + (p != 0) as c_int * 2 as c_int) as isize))
                .as_mut_ptr(),
                (*(*h)
                    .nr_offset
                    .offset((0 as c_int + (p != 0) as c_int * 2 as c_int) as isize))
                .as_mut_ptr(),
                16 as c_int,
            );
        }
        if (*h).mb.b_trellis != 0 {
            return x264_10_quant_4x4_trellis(
                h,
                dct as *mut dctcoef,
                i_quant_cat,
                i_qp,
                ctx_block_cat,
                b_intra,
                (p != 0) as c_int,
                idx + p * 16 as c_int,
            );
        } else {
            return (*h).quantf.quant_4x4.expect("non-null function pointer")(
                dct,
                (*(*(*h).quant4_mf.as_mut_ptr().offset(i_quant_cat as isize))
                    .offset(i_qp as isize))
                .as_mut_ptr(),
                (*(*(*h).quant4_bias.as_mut_ptr().offset(i_quant_cat as isize))
                    .offset(i_qp as isize))
                .as_mut_ptr(),
            );
        };
    }
    #[inline(always)]
    #[c2rust::src_loc = "101:1"]
    pub unsafe extern "C" fn x264_quant_8x8(
        mut h: *mut x264_t,
        mut dct: *mut dctcoef,
        mut i_qp: c_int,
        mut ctx_block_cat: c_int,
        mut b_intra: c_int,
        mut p: c_int,
        mut idx: c_int,
    ) -> c_int {
        let mut i_quant_cat: c_int = if b_intra != 0 {
            if p != 0 {
                CQM_8IC as c_int
            } else {
                CQM_8IY as c_int
            }
        } else if p != 0 {
            CQM_8PC as c_int
        } else {
            CQM_8PY as c_int
        };
        if (*h).mb.b_noise_reduction != 0 {
            (*h).quantf.denoise_dct.expect("non-null function pointer")(
                dct as *mut dctcoef,
                (*(*h)
                    .nr_residual_sum
                    .offset((1 as c_int + (p != 0) as c_int * 2 as c_int) as isize))
                .as_mut_ptr(),
                (*(*h)
                    .nr_offset
                    .offset((1 as c_int + (p != 0) as c_int * 2 as c_int) as isize))
                .as_mut_ptr(),
                64 as c_int,
            );
        }
        if (*h).mb.b_trellis != 0 {
            return x264_10_quant_8x8_trellis(
                h,
                dct as *mut dctcoef,
                i_quant_cat,
                i_qp,
                ctx_block_cat,
                b_intra,
                (p != 0) as c_int,
                idx + p * 4 as c_int,
            );
        } else {
            return (*h).quantf.quant_8x8.expect("non-null function pointer")(
                dct,
                (*(*(*h).quant8_mf.as_mut_ptr().offset(i_quant_cat as isize))
                    .offset(i_qp as isize))
                .as_mut_ptr(),
                (*(*(*h).quant8_bias.as_mut_ptr().offset(i_quant_cat as isize))
                    .offset(i_qp as isize))
                .as_mut_ptr(),
            );
        };
    }
    #[inline(always)]
    #[c2rust::src_loc = "132:1"]
    pub unsafe extern "C" fn x264_mb_encode_i4x4(
        mut h: *mut x264_t,
        mut p: c_int,
        mut idx: c_int,
        mut i_qp: c_int,
        mut i_mode: c_int,
        mut b_predict: c_int,
    ) {
        let mut nz: c_int = 0;
        let mut p_src: *mut pixel = &mut *(*(*h).mb.pic.p_fenc.as_mut_ptr().offset(p as isize))
            .offset(*block_idx_xy_fenc.as_ptr().offset(idx as isize) as isize)
            as *mut pixel;
        let mut p_dst: *mut pixel = &mut *(*(*h).mb.pic.p_fdec.as_mut_ptr().offset(p as isize))
            .offset(*block_idx_xy_fdec.as_ptr().offset(idx as isize) as isize)
            as *mut pixel;
        let mut dct4x4: [dctcoef; 16] = [0; 16];
        if b_predict != 0 {
            if (*h).mb.b_lossless != 0 {
                x264_10_predict_lossless_4x4(h, p_dst, p, idx, i_mode);
            } else {
                (*h).predict_4x4[i_mode as usize].expect("non-null function pointer")(p_dst);
            }
        }
        if (*h).mb.b_lossless != 0 {
            nz = (*h).zigzagf.sub_4x4.expect("non-null function pointer")(
                (*(*h)
                    .dct
                    .luma4x4
                    .as_mut_ptr()
                    .offset((p * 16 as c_int + idx) as isize))
                .as_mut_ptr(),
                p_src,
                p_dst,
            );
            (*h).mb.cache.non_zero_count[x264_scan8[(p * 16 as c_int + idx) as usize] as usize] =
                nz as uint8_t;
            (*h).mb.i_cbp_luma |= nz << (idx >> 2 as c_int);
            return;
        }
        (*h).dctf.sub4x4_dct.expect("non-null function pointer")(dct4x4.as_mut_ptr(), p_src, p_dst);
        nz = x264_quant_4x4(
            h,
            dct4x4.as_mut_ptr(),
            i_qp,
            ctx_cat_plane[DCT_LUMA_4x4 as c_int as usize][p as usize] as c_int,
            1 as c_int,
            p,
            idx,
        );
        (*h).mb.cache.non_zero_count[x264_scan8[(p * 16 as c_int + idx) as usize] as usize] =
            nz as uint8_t;
        if nz != 0 {
            (*h).mb.i_cbp_luma |= (1 as c_int) << (idx >> 2 as c_int);
            (*h).zigzagf.scan_4x4.expect("non-null function pointer")(
                (*(*h)
                    .dct
                    .luma4x4
                    .as_mut_ptr()
                    .offset((p * 16 as c_int + idx) as isize))
                .as_mut_ptr(),
                dct4x4.as_mut_ptr(),
            );
            (*h).quantf.dequant_4x4.expect("non-null function pointer")(
                dct4x4.as_mut_ptr(),
                (*h).dequant4_mf[(if p != 0 {
                    CQM_4IC as c_int
                } else {
                    CQM_4IY as c_int
                }) as usize],
                i_qp,
            );
            (*h).dctf.add4x4_idct.expect("non-null function pointer")(p_dst, dct4x4.as_mut_ptr());
        }
    }
    #[inline(always)]
    #[c2rust::src_loc = "168:1"]
    pub unsafe extern "C" fn x264_mb_encode_i8x8(
        mut h: *mut x264_t,
        mut p: c_int,
        mut idx: c_int,
        mut i_qp: c_int,
        mut i_mode: c_int,
        mut edge: *mut pixel,
        mut b_predict: c_int,
    ) {
        let mut x: c_int = idx & 1 as c_int;
        let mut y: c_int = idx >> 1 as c_int;
        let mut nz: c_int = 0;
        let mut p_src: *mut pixel = &mut *(*(*h).mb.pic.p_fenc.as_mut_ptr().offset(p as isize))
            .offset((8 as c_int * x + 8 as c_int * y * FENC_STRIDE) as isize)
            as *mut pixel;
        let mut p_dst: *mut pixel = &mut *(*(*h).mb.pic.p_fdec.as_mut_ptr().offset(p as isize))
            .offset((8 as c_int * x + 8 as c_int * y * FDEC_STRIDE) as isize)
            as *mut pixel;
        let mut dct8x8: [dctcoef; 64] = [0; 64];
        let mut edge_buf: [pixel; 36] = [0; 36];
        if b_predict != 0 {
            if edge.is_null() {
                (*h).predict_8x8_filter.expect("non-null function pointer")(
                    p_dst,
                    edge_buf.as_mut_ptr(),
                    (*h).mb.i_neighbour8[idx as usize] as c_int,
                    x264_pred_i4x4_neighbors[i_mode as usize] as c_int,
                );
                edge = edge_buf.as_mut_ptr();
            }
            if (*h).mb.b_lossless != 0 {
                x264_10_predict_lossless_8x8(h, p_dst, p, idx, i_mode, edge as *mut pixel);
            } else {
                (*h).predict_8x8[i_mode as usize].expect("non-null function pointer")(
                    p_dst,
                    edge as *mut pixel,
                );
            }
        }
        if (*h).mb.b_lossless != 0 {
            nz = (*h).zigzagf.sub_8x8.expect("non-null function pointer")(
                (*(*h)
                    .dct
                    .luma8x8
                    .as_mut_ptr()
                    .offset((p * 4 as c_int + idx) as isize))
                .as_mut_ptr(),
                p_src,
                p_dst,
            );
            (*(&mut *(*h).mb.cache.non_zero_count.as_mut_ptr().offset(
                (*x264_scan8
                    .as_ptr()
                    .offset((p * 16 as c_int + idx * 4 as c_int) as isize)
                    as c_int
                    + 0 as c_int) as isize,
            ) as *mut uint8_t as *mut x264_union16_t))
                .i = (nz * 0x101 as c_int) as uint16_t;
            (*(&mut *(*h).mb.cache.non_zero_count.as_mut_ptr().offset(
                (*x264_scan8
                    .as_ptr()
                    .offset((p * 16 as c_int + idx * 4 as c_int) as isize)
                    as c_int
                    + 8 as c_int) as isize,
            ) as *mut uint8_t as *mut x264_union16_t))
                .i = (nz * 0x101 as c_int) as uint16_t;
            (*h).mb.i_cbp_luma |= nz << idx;
            return;
        }
        (*h).dctf.sub8x8_dct8.expect("non-null function pointer")(
            dct8x8.as_mut_ptr(),
            p_src,
            p_dst,
        );
        nz = x264_quant_8x8(
            h,
            dct8x8.as_mut_ptr(),
            i_qp,
            ctx_cat_plane[DCT_LUMA_8x8 as c_int as usize][p as usize] as c_int,
            1 as c_int,
            p,
            idx,
        );
        if nz != 0 {
            (*h).mb.i_cbp_luma |= (1 as c_int) << idx;
            (*h).zigzagf.scan_8x8.expect("non-null function pointer")(
                (*(*h)
                    .dct
                    .luma8x8
                    .as_mut_ptr()
                    .offset((p * 4 as c_int + idx) as isize))
                .as_mut_ptr(),
                dct8x8.as_mut_ptr(),
            );
            (*h).quantf.dequant_8x8.expect("non-null function pointer")(
                dct8x8.as_mut_ptr(),
                (*h).dequant8_mf[(if p != 0 {
                    CQM_8IC as c_int
                } else {
                    CQM_8IY as c_int
                }) as usize],
                i_qp,
            );
            (*h).dctf.add8x8_idct8.expect("non-null function pointer")(p_dst, dct8x8.as_mut_ptr());
            (*(&mut *(*h).mb.cache.non_zero_count.as_mut_ptr().offset(
                (*x264_scan8
                    .as_ptr()
                    .offset((p * 16 as c_int + idx * 4 as c_int) as isize)
                    as c_int
                    + 0 as c_int) as isize,
            ) as *mut uint8_t as *mut x264_union16_t))
                .i = (1 as c_int * 0x101 as c_int) as uint16_t;
            (*(&mut *(*h).mb.cache.non_zero_count.as_mut_ptr().offset(
                (*x264_scan8
                    .as_ptr()
                    .offset((p * 16 as c_int + idx * 4 as c_int) as isize)
                    as c_int
                    + 8 as c_int) as isize,
            ) as *mut uint8_t as *mut x264_union16_t))
                .i = (1 as c_int * 0x101 as c_int) as uint16_t;
        } else {
            (*(&mut *(*h).mb.cache.non_zero_count.as_mut_ptr().offset(
                (*x264_scan8
                    .as_ptr()
                    .offset((p * 16 as c_int + idx * 4 as c_int) as isize)
                    as c_int
                    + 0 as c_int) as isize,
            ) as *mut uint8_t as *mut x264_union16_t))
                .i = (0 as c_int * 0x101 as c_int) as uint16_t;
            (*(&mut *(*h).mb.cache.non_zero_count.as_mut_ptr().offset(
                (*x264_scan8
                    .as_ptr()
                    .offset((p * 16 as c_int + idx * 4 as c_int) as isize)
                    as c_int
                    + 8 as c_int) as isize,
            ) as *mut uint8_t as *mut x264_union16_t))
                .i = (0 as c_int * 0x101 as c_int) as uint16_t;
        };
    }
    use ::core::ffi::c_int;

    use super::base_h::{x264_scan8, x264_union16_t};
    use super::common_h::{dctcoef, pixel, x264_t, FDEC_STRIDE, FENC_STRIDE};
    use super::macroblock_h::{
        block_idx_xy_fdec, block_idx_xy_fenc, ctx_cat_plane, x264_pred_i4x4_neighbors,
        DCT_LUMA_4x4, DCT_LUMA_8x8,
    };
    //use super::rdo_c::{x264_10_quant_4x4_trellis, x264_10_quant_8x8_trellis};
    use super::set_h::{CQM_4IC, CQM_4IY, CQM_4PC, CQM_4PY, CQM_8IC, CQM_8IY, CQM_8PC, CQM_8PY};
    use super::stdint_uintn_h::{uint16_t, uint8_t};
    extern "C" {
        #[c2rust::src_loc = "36:1"]
        pub fn x264_10_macroblock_probe_skip(h: *mut x264_t, b_bidir: c_int) -> c_int;
        #[c2rust::src_loc = "44:1"]
        pub fn x264_10_predict_lossless_4x4(
            h: *mut x264_t,
            p_dst: *mut pixel,
            p: c_int,
            idx: c_int,
            i_mode: c_int,
        );
        #[c2rust::src_loc = "46:1"]
        pub fn x264_10_predict_lossless_8x8(
            h: *mut x264_t,
            p_dst: *mut pixel,
            p: c_int,
            idx: c_int,
            i_mode: c_int,
            edge: *mut pixel,
        );
        #[c2rust::src_loc = "48:1"]
        pub fn x264_10_predict_lossless_16x16(h: *mut x264_t, p: c_int, i_mode: c_int);
        #[c2rust::src_loc = "50:1"]
        pub fn x264_10_predict_lossless_chroma(h: *mut x264_t, i_mode: c_int);
        #[c2rust::src_loc = "53:1"]
        pub fn x264_10_macroblock_encode(h: *mut x264_t);
        #[c2rust::src_loc = "60:1"]
        pub fn x264_10_macroblock_encode_p8x8(h: *mut x264_t, i8: c_int);
        #[c2rust::src_loc = "62:1"]
        pub fn x264_10_macroblock_encode_p4x4(h: *mut x264_t, i4: c_int);
        #[c2rust::src_loc = "64:1"]
        pub fn x264_10_mb_encode_chroma(h: *mut x264_t, b_inter: c_int, i_qp: c_int);
    }
    use super::cabac_h::x264_cabac_t;
    extern "C" {
        #[c2rust::src_loc = "33:1"]
        pub fn x264_10_rdo_init();
        #[c2rust::src_loc = "55:1"]
        pub fn x264_10_macroblock_write_cabac(h: *mut x264_t, cb: *mut x264_cabac_t);
        #[c2rust::src_loc = "57:1"]
        pub fn x264_10_macroblock_write_cavlc(h: *mut x264_t);
        #[c2rust::src_loc = "67:1"]
        pub fn x264_10_cabac_mb_skip(h: *mut x264_t, b_skip: c_int);
        #[c2rust::src_loc = "88:1"]
        pub fn x264_10_noise_reduction_update(h: *mut x264_t);
    }

    extern "C" {
        #[c2rust::src_loc = "76:1"]
        pub fn x264_10_quant_luma_dc_trellis(
            h: *mut x264_t,
            dct: *mut dctcoef,
            i_quant_cat: c_int,
            i_qp: c_int,
            ctx_block_cat: c_int,
            b_intra: c_int,
            idx: c_int,
        ) -> c_int;
        #[c2rust::src_loc = "79:1"]
        pub fn x264_10_quant_chroma_dc_trellis(
            h: *mut x264_t,
            dct: *mut dctcoef,
            i_qp: c_int,
            b_intra: c_int,
            idx: c_int,
        ) -> c_int;
        #[c2rust::src_loc = "81:1"]
        pub fn x264_10_quant_4x4_trellis(
            h: *mut x264_t,
            dct: *mut dctcoef,
            i_quant_cat: c_int,
            i_qp: c_int,
            ctx_block_cat: c_int,
            b_intra: c_int,
            b_chroma: c_int,
            idx: c_int,
        ) -> c_int;
        #[c2rust::src_loc = "84:1"]
        pub fn x264_10_quant_8x8_trellis(
            h: *mut x264_t,
            dct: *mut dctcoef,
            i_quant_cat: c_int,
            i_qp: c_int,
            ctx_block_cat: c_int,
            b_intra: c_int,
            b_chroma: c_int,
            idx: c_int,
        ) -> c_int;
    }
}
#[c2rust::header_src = "/home/nwplayer123/Hacks/hex264/x264/encoder/cabac.c:28"]
pub mod cabac_c {
    #[inline]
    #[c2rust::src_loc = "35:1"]
    pub unsafe extern "C" fn cabac_mb_type_intra(
        mut h: *mut x264_t,
        mut cb: *mut x264_cabac_t,
        mut i_mb_type: c_int,
        mut ctx0: c_int,
        mut ctx1: c_int,
        mut ctx2: c_int,
        mut ctx3: c_int,
        mut ctx4: c_int,
        mut ctx5: c_int,
    ) {
        if i_mb_type == I_4x4 as c_int || i_mb_type == I_8x8 as c_int {
            x264_cabac_size_decision_noup(cb, ctx0 as c_long, 0 as c_long);
        } else {
            let mut i_pred: c_int =
                x264_mb_pred_mode16x16_fix[(*h).mb.i_intra16x16_pred_mode as usize] as c_int;
            x264_cabac_size_decision_noup(cb, ctx0 as c_long, 1 as c_long);
            (*cb).f8_bits_encoded += 7 as c_int;
            x264_cabac_size_decision_noup(
                cb,
                ctx1 as c_long,
                ((*h).mb.i_cbp_luma != 0) as c_int as c_long,
            );
            if (*h).mb.i_cbp_chroma == 0 as c_int {
                x264_cabac_size_decision_noup(cb, ctx2 as c_long, 0 as c_long);
            } else {
                x264_cabac_size_decision(cb, ctx2 as c_long, 1 as c_long);
                x264_cabac_size_decision_noup(
                    cb,
                    ctx3 as c_long,
                    ((*h).mb.i_cbp_chroma >> 1 as c_int) as c_long,
                );
            }
            x264_cabac_size_decision(cb, ctx4 as c_long, (i_pred >> 1 as c_int) as c_long);
            x264_cabac_size_decision_noup(cb, ctx5 as c_long, (i_pred & 1 as c_int) as c_long);
        };
    }
    #[c2rust::src_loc = "83:1"]
    pub unsafe extern "C" fn cabac_intra4x4_pred_mode(
        mut cb: *mut x264_cabac_t,
        mut i_pred: c_int,
        mut i_mode: c_int,
    ) {
        if i_pred == i_mode {
            x264_cabac_size_decision(cb, 68 as c_long, 1 as c_long);
        } else {
            x264_cabac_size_decision(cb, 68 as c_long, 0 as c_long);
            if i_mode > i_pred {
                i_mode -= 1;
            }
            x264_cabac_size_decision(cb, 69 as c_long, (i_mode & 0x1 as c_int) as c_long);
            x264_cabac_size_decision(
                cb,
                69 as c_long,
                (i_mode >> 1 as c_int & 0x1 as c_int) as c_long,
            );
            x264_cabac_size_decision(cb, 69 as c_long, (i_mode >> 2 as c_int) as c_long);
        };
    }
    #[c2rust::src_loc = "98:1"]
    pub unsafe extern "C" fn cabac_intra_chroma_pred_mode(
        mut h: *mut x264_t,
        mut cb: *mut x264_cabac_t,
    ) {
        let mut i_mode: c_int =
            x264_mb_chroma_pred_mode_fix[(*h).mb.i_chroma_pred_mode as usize] as c_int;
        let mut ctx: c_int = 0 as c_int;
        if (*h).mb.i_neighbour & MB_LEFT as c_int as c_uint != 0
            && *(*h)
                .mb
                .chroma_pred_mode
                .offset((*h).mb.i_mb_left_xy[0] as isize) as c_int
                != 0 as c_int
        {
            ctx += 1;
        }
        if (*h).mb.i_neighbour & MB_TOP as c_int as c_uint != 0
            && *(*h)
                .mb
                .chroma_pred_mode
                .offset((*h).mb.i_mb_top_xy as isize) as c_int
                != 0 as c_int
        {
            ctx += 1;
        }
        x264_cabac_size_decision_noup(
            cb,
            (64 as c_int + ctx) as c_long,
            (i_mode > 0 as c_int) as c_int as c_long,
        );
        if i_mode > 0 as c_int {
            x264_cabac_size_decision(
                cb,
                (64 as c_int + 3 as c_int) as c_long,
                (i_mode > 1 as c_int) as c_int as c_long,
            );
            if i_mode > 1 as c_int {
                x264_cabac_size_decision_noup(
                    cb,
                    (64 as c_int + 3 as c_int) as c_long,
                    (i_mode > 2 as c_int) as c_int as c_long,
                );
            }
        }
    }
    #[c2rust::src_loc = "118:1"]
    pub unsafe extern "C" fn cabac_cbp_luma(mut h: *mut x264_t, mut cb: *mut x264_cabac_t) {
        let mut cbp: c_int = (*h).mb.i_cbp_luma;
        let mut cbp_l: c_int = (*h).mb.cache.i_cbp_left;
        let mut cbp_t: c_int = (*h).mb.cache.i_cbp_top;
        x264_cabac_size_decision(
            cb,
            (76 as c_int - (cbp_l >> 1 as c_int & 1 as c_int) - (cbp_t >> 1 as c_int & 2 as c_int))
                as c_long,
            (cbp >> 0 as c_int & 1 as c_int) as c_long,
        );
        x264_cabac_size_decision(
            cb,
            (76 as c_int - (cbp >> 0 as c_int & 1 as c_int) - (cbp_t >> 2 as c_int & 2 as c_int))
                as c_long,
            (cbp >> 1 as c_int & 1 as c_int) as c_long,
        );
        x264_cabac_size_decision(
            cb,
            (76 as c_int - (cbp_l >> 3 as c_int & 1 as c_int) - (cbp << 1 as c_int & 2 as c_int))
                as c_long,
            (cbp >> 2 as c_int & 1 as c_int) as c_long,
        );
        x264_cabac_size_decision_noup(
            cb,
            (76 as c_int - (cbp >> 2 as c_int & 1 as c_int) - (cbp >> 0 as c_int & 2 as c_int))
                as c_long,
            (cbp >> 3 as c_int & 1 as c_int) as c_long,
        );
    }
    #[c2rust::src_loc = "129:1"]
    pub unsafe extern "C" fn cabac_cbp_chroma(mut h: *mut x264_t, mut cb: *mut x264_cabac_t) {
        let mut cbp_a: c_int = (*h).mb.cache.i_cbp_left & 0x30 as c_int;
        let mut cbp_b: c_int = (*h).mb.cache.i_cbp_top & 0x30 as c_int;
        let mut ctx: c_int = 0 as c_int;
        if cbp_a != 0 && (*h).mb.cache.i_cbp_left != -1 {
            ctx += 1;
        }
        if cbp_b != 0 && (*h).mb.cache.i_cbp_top != -1 {
            ctx += 2 as c_int;
        }
        if (*h).mb.i_cbp_chroma == 0 as c_int {
            x264_cabac_size_decision_noup(cb, (77 as c_int + ctx) as c_long, 0 as c_long);
        } else {
            x264_cabac_size_decision_noup(cb, (77 as c_int + ctx) as c_long, 1 as c_long);
            ctx = 4 as c_int;
            if cbp_a == 0x20 as c_int {
                ctx += 1;
            }
            if cbp_b == 0x20 as c_int {
                ctx += 2 as c_int;
            }
            x264_cabac_size_decision_noup(
                cb,
                (77 as c_int + ctx) as c_long,
                ((*h).mb.i_cbp_chroma >> 1 as c_int) as c_long,
            );
        };
    }
    #[c2rust::src_loc = "150:1"]
    pub unsafe extern "C" fn cabac_qp_delta(mut h: *mut x264_t, mut cb: *mut x264_cabac_t) {
        let mut i_dqp: c_int = (*h).mb.i_qp - (*h).mb.i_last_qp;
        let mut ctx: c_int = 0;
        if (*h).mb.i_type == I_16x16 as c_int
            && *(*h).mb.cbp.offset((*h).mb.i_mb_xy as isize) == 0
            && (*h).mb.i_qp > (*h).mb.i_last_qp
        {
            i_dqp = 0 as c_int;
        }
        ctx = ((*h).mb.i_last_dqp != 0
            && (*(*h).mb.type_0.offset((*h).mb.i_mb_prev_xy as isize) as c_int == I_16x16 as c_int
                || *(*h).mb.cbp.offset((*h).mb.i_mb_prev_xy as isize) as c_int & 0x3f as c_int
                    != 0)) as c_int;
        if i_dqp != 0 as c_int {
            i_dqp *= 2 as c_int;
            let mut val: c_int = 1 as c_int - i_dqp;
            if val < 0 as c_int {
                val = i_dqp;
            }
            val -= 1;
            if val >= QP_MAX_SPEC && val != QP_MAX_SPEC + 1 as c_int {
                val = 2 as c_int * QP_MAX_SPEC + 1 as c_int - val;
            }
            loop {
                x264_cabac_size_decision(cb, (60 as c_int + ctx) as c_long, 1 as c_long);
                ctx = 2 as c_int + (ctx >> 1 as c_int);
                val -= 1;
                if !(val != 0) {
                    break;
                }
            }
        }
        x264_cabac_size_decision_noup(cb, (60 as c_int + ctx) as c_long, 0 as c_long);
    }
    #[inline]
    #[c2rust::src_loc = "198:1"]
    pub unsafe extern "C" fn cabac_subpartition_p(mut cb: *mut x264_cabac_t, mut i_sub: c_int) {
        if i_sub == D_L0_8x8 as c_int {
            x264_cabac_size_decision(cb, 21 as c_long, 1 as c_long);
            return;
        }
        x264_cabac_size_decision(cb, 21 as c_long, 0 as c_long);
        if i_sub == D_L0_8x4 as c_int {
            x264_cabac_size_decision(cb, 22 as c_long, 0 as c_long);
        } else {
            x264_cabac_size_decision(cb, 22 as c_long, 1 as c_long);
            x264_cabac_size_decision(
                cb,
                23 as c_long,
                (i_sub == D_L0_4x8 as c_int) as c_int as c_long,
            );
        };
    }
    #[inline(always)]
    #[c2rust::src_loc = "215:1"]
    pub unsafe extern "C" fn cabac_subpartition_b(mut cb: *mut x264_cabac_t, mut i_sub: c_int) {
        if i_sub == D_DIRECT_8x8 as c_int {
            x264_cabac_size_decision(cb, 36 as c_long, 0 as c_long);
            return;
        }
        x264_cabac_size_decision(cb, 36 as c_long, 1 as c_long);
        if i_sub == D_BI_8x8 as c_int {
            x264_cabac_size_decision(cb, 37 as c_long, 1 as c_long);
            x264_cabac_size_decision(cb, 38 as c_long, 0 as c_long);
            x264_cabac_size_decision(cb, 39 as c_long, 0 as c_long);
            x264_cabac_size_decision(cb, 39 as c_long, 0 as c_long);
            return;
        }
        x264_cabac_size_decision(cb, 37 as c_long, 0 as c_long);
        x264_cabac_size_decision(
            cb,
            39 as c_long,
            (i_sub == D_L1_8x8 as c_int) as c_int as c_long,
        );
    }
    #[inline(always)]
    #[c2rust::src_loc = "235:1"]
    pub unsafe extern "C" fn cabac_transform_size(mut h: *mut x264_t, mut cb: *mut x264_cabac_t) {
        let mut ctx: c_int = 399 as c_int + (*h).mb.cache.i_neighbour_transform_size;
        x264_cabac_size_decision_noup(cb, ctx as c_long, (*h).mb.b_transform_8x8 as c_long);
    }
    #[inline(always)]
    #[c2rust::src_loc = "241:1"]
    pub unsafe extern "C" fn cabac_ref_internal(
        mut h: *mut x264_t,
        mut cb: *mut x264_cabac_t,
        mut i_list: c_int,
        mut idx: c_int,
        mut bframe: c_int,
    ) {
        let i8: c_int = x264_scan8[idx as usize] as c_int;
        let i_refa: c_int =
            (*h).mb.cache.ref_0[i_list as usize][(i8 - 1 as c_int) as usize] as c_int;
        let i_refb: c_int =
            (*h).mb.cache.ref_0[i_list as usize][(i8 - 8 as c_int) as usize] as c_int;
        let mut ctx: c_int = 0 as c_int;
        if i_refa > 0 as c_int
            && (bframe == 0 || (*h).mb.cache.skip[(i8 - 1 as c_int) as usize] == 0)
        {
            ctx += 1;
        }
        if i_refb > 0 as c_int
            && (bframe == 0 || (*h).mb.cache.skip[(i8 - 8 as c_int) as usize] == 0)
        {
            ctx += 2 as c_int;
        }
        let mut i_ref: c_int = (*h).mb.cache.ref_0[i_list as usize][i8 as usize] as c_int;
        while i_ref > 0 as c_int {
            x264_cabac_size_decision(cb, (54 as c_int + ctx) as c_long, 1 as c_long);
            ctx = (ctx >> 2 as c_int) + 4 as c_int;
            i_ref -= 1;
        }
        x264_cabac_size_decision(cb, (54 as c_int + ctx) as c_long, 0 as c_long);
    }
    #[inline(never)]
    #[c2rust::src_loc = "261:1"]
    pub unsafe extern "C" fn cabac_ref_p(
        mut h: *mut x264_t,
        mut cb: *mut x264_cabac_t,
        mut idx: c_int,
    ) {
        cabac_ref_internal(h, cb, 0 as c_int, idx, 0 as c_int);
    }
    #[inline(never)]
    #[c2rust::src_loc = "265:1"]
    pub unsafe extern "C" fn cabac_ref_b(
        mut h: *mut x264_t,
        mut cb: *mut x264_cabac_t,
        mut i_list: c_int,
        mut idx: c_int,
    ) {
        cabac_ref_internal(h, cb, i_list, idx, 1 as c_int);
    }
    #[inline(always)]
    #[c2rust::src_loc = "270:1"]
    pub unsafe extern "C" fn cabac_mvd_cpn(
        mut h: *mut x264_t,
        mut cb: *mut x264_cabac_t,
        mut i_list: c_int,
        mut idx: c_int,
        mut l: c_int,
        mut mvd: c_int,
        mut ctx: c_int,
    ) -> c_int {
        let mut ctxbase: c_int = if l != 0 { 47 as c_int } else { 40 as c_int };
        if mvd == 0 as c_int {
            x264_cabac_size_decision(cb, (ctxbase + ctx) as c_long, 0 as c_long);
            return 0 as c_int;
        }
        let mut i_abs: c_int = abs(mvd);
        x264_cabac_size_decision(cb, (ctxbase + ctx) as c_long, 1 as c_long);
        if i_abs <= 3 as c_int {
            let mut i: c_int = 1 as c_int;
            while i < i_abs {
                x264_cabac_size_decision(cb, (ctxbase + i + 2 as c_int) as c_long, 1 as c_long);
                i += 1;
            }
            x264_cabac_size_decision(cb, (ctxbase + i_abs + 2 as c_int) as c_long, 0 as c_long);
            (*cb).f8_bits_encoded += 256 as c_int;
        } else {
            x264_cabac_size_decision(cb, (ctxbase + 3 as c_int) as c_long, 1 as c_long);
            x264_cabac_size_decision(cb, (ctxbase + 4 as c_int) as c_long, 1 as c_long);
            x264_cabac_size_decision(cb, (ctxbase + 5 as c_int) as c_long, 1 as c_long);
            if i_abs < 9 as c_int {
                (*cb).f8_bits_encoded += x264_10_cabac_size_unary[(i_abs - 3 as c_int) as usize]
                    [(*cb).state[(ctxbase + 6 as c_int) as usize] as usize]
                    as c_int;
                (*cb).state[(ctxbase + 6 as c_int) as usize] = x264_10_cabac_transition_unary
                    [(i_abs - 3 as c_int) as usize]
                    [(*cb).state[(ctxbase + 6 as c_int) as usize] as usize];
            } else {
                (*cb).f8_bits_encoded += cabac_size_5ones
                    [(*cb).state[(ctxbase + 6 as c_int) as usize] as usize]
                    as c_int;
                (*cb).state[(ctxbase + 6 as c_int) as usize] =
                    cabac_transition_5ones[(*cb).state[(ctxbase + 6 as c_int) as usize] as usize];
                (*cb).f8_bits_encoded += (bs_size_ue_big(
                    (i_abs - 9 as c_int + ((1 as c_int) << 3 as c_int) - 1 as c_int) as c_uint,
                ) - 3 as c_int)
                    << 8 as c_int;
            }
        }
        return if i_abs < 66 as c_int {
            i_abs
        } else {
            66 as c_int
        };
    }
    #[inline(never)]
    #[c2rust::src_loc = "329:1"]
    pub unsafe extern "C" fn cabac_mvd(
        mut h: *mut x264_t,
        mut cb: *mut x264_cabac_t,
        mut i_list: c_int,
        mut idx: c_int,
        mut width: c_int,
    ) -> uint16_t {
        let mut mvp: [int16_t; 2] = [0; 2];
        let mut mdx: c_int = 0;
        let mut mdy: c_int = 0;
        x264_10_mb_predict_mv(h, i_list, idx, width, mvp.as_mut_ptr());
        mdx = (*h).mb.cache.mv[i_list as usize][x264_scan8[idx as usize] as usize][0] as c_int
            - mvp[0] as c_int;
        mdy = (*h).mb.cache.mv[i_list as usize][x264_scan8[idx as usize] as usize][1] as c_int
            - mvp[1] as c_int;
        let mut amvd: uint16_t = x264_cabac_mvd_sum(
            (*(*(*h).mb.cache.mvd.as_mut_ptr().offset(i_list as isize))
                .as_mut_ptr()
                .offset(
                    (*x264_scan8.as_ptr().offset(idx as isize) as c_int - 1 as c_int) as isize,
                ))
            .as_mut_ptr(),
            (*(*(*h).mb.cache.mvd.as_mut_ptr().offset(i_list as isize))
                .as_mut_ptr()
                .offset(
                    (*x264_scan8.as_ptr().offset(idx as isize) as c_int - 8 as c_int) as isize,
                ))
            .as_mut_ptr(),
        );
        mdx = cabac_mvd_cpn(
            h,
            cb,
            i_list,
            idx,
            0 as c_int,
            mdx,
            amvd as c_int & 0xff as c_int,
        );
        mdy = cabac_mvd_cpn(
            h,
            cb,
            i_list,
            idx,
            1 as c_int,
            mdy,
            amvd as c_int >> 8 as c_int,
        );
        return pack8to16(mdx as uint32_t, mdy as uint32_t) as uint16_t;
    }
    #[inline]
    #[c2rust::src_loc = "355:1"]
    pub unsafe extern "C" fn cabac_8x8_mvd(
        mut h: *mut x264_t,
        mut cb: *mut x264_cabac_t,
        mut i: c_int,
    ) {
        match (*h).mb.i_sub_partition[i as usize] as c_int {
            3 => {
                let mut mvd: uint16_t = cabac_mvd(h, cb, 0 as c_int, 4 as c_int * i, 2 as c_int);
                x264_macroblock_cache_mvd(
                    h,
                    block_idx_x[(4 as c_int * i) as usize] as c_int,
                    block_idx_y[(4 as c_int * i) as usize] as c_int,
                    2 as c_int,
                    2 as c_int,
                    0 as c_int,
                    mvd,
                );
            }
            1 => {
                let mut mvd_0: uint16_t =
                    cabac_mvd(h, cb, 0 as c_int, 4 as c_int * i + 0 as c_int, 2 as c_int);
                x264_macroblock_cache_mvd(
                    h,
                    block_idx_x[(4 as c_int * i + 0 as c_int) as usize] as c_int,
                    block_idx_y[(4 as c_int * i + 0 as c_int) as usize] as c_int,
                    2 as c_int,
                    1 as c_int,
                    0 as c_int,
                    mvd_0,
                );
                let mut mvd_1: uint16_t =
                    cabac_mvd(h, cb, 0 as c_int, 4 as c_int * i + 2 as c_int, 2 as c_int);
                x264_macroblock_cache_mvd(
                    h,
                    block_idx_x[(4 as c_int * i + 2 as c_int) as usize] as c_int,
                    block_idx_y[(4 as c_int * i + 2 as c_int) as usize] as c_int,
                    2 as c_int,
                    1 as c_int,
                    0 as c_int,
                    mvd_1,
                );
            }
            2 => {
                let mut mvd_2: uint16_t =
                    cabac_mvd(h, cb, 0 as c_int, 4 as c_int * i + 0 as c_int, 1 as c_int);
                x264_macroblock_cache_mvd(
                    h,
                    block_idx_x[(4 as c_int * i + 0 as c_int) as usize] as c_int,
                    block_idx_y[(4 as c_int * i + 0 as c_int) as usize] as c_int,
                    1 as c_int,
                    2 as c_int,
                    0 as c_int,
                    mvd_2,
                );
                let mut mvd_3: uint16_t =
                    cabac_mvd(h, cb, 0 as c_int, 4 as c_int * i + 1 as c_int, 1 as c_int);
                x264_macroblock_cache_mvd(
                    h,
                    block_idx_x[(4 as c_int * i + 1 as c_int) as usize] as c_int,
                    block_idx_y[(4 as c_int * i + 1 as c_int) as usize] as c_int,
                    1 as c_int,
                    2 as c_int,
                    0 as c_int,
                    mvd_3,
                );
            }
            0 => {
                let mut mvd_4: uint16_t =
                    cabac_mvd(h, cb, 0 as c_int, 4 as c_int * i + 0 as c_int, 1 as c_int);
                x264_macroblock_cache_mvd(
                    h,
                    block_idx_x[(4 as c_int * i + 0 as c_int) as usize] as c_int,
                    block_idx_y[(4 as c_int * i + 0 as c_int) as usize] as c_int,
                    1 as c_int,
                    1 as c_int,
                    0 as c_int,
                    mvd_4,
                );
                let mut mvd_5: uint16_t =
                    cabac_mvd(h, cb, 0 as c_int, 4 as c_int * i + 1 as c_int, 1 as c_int);
                x264_macroblock_cache_mvd(
                    h,
                    block_idx_x[(4 as c_int * i + 1 as c_int) as usize] as c_int,
                    block_idx_y[(4 as c_int * i + 1 as c_int) as usize] as c_int,
                    1 as c_int,
                    1 as c_int,
                    0 as c_int,
                    mvd_5,
                );
                let mut mvd_6: uint16_t =
                    cabac_mvd(h, cb, 0 as c_int, 4 as c_int * i + 2 as c_int, 1 as c_int);
                x264_macroblock_cache_mvd(
                    h,
                    block_idx_x[(4 as c_int * i + 2 as c_int) as usize] as c_int,
                    block_idx_y[(4 as c_int * i + 2 as c_int) as usize] as c_int,
                    1 as c_int,
                    1 as c_int,
                    0 as c_int,
                    mvd_6,
                );
                let mut mvd_7: uint16_t =
                    cabac_mvd(h, cb, 0 as c_int, 4 as c_int * i + 3 as c_int, 1 as c_int);
                x264_macroblock_cache_mvd(
                    h,
                    block_idx_x[(4 as c_int * i + 3 as c_int) as usize] as c_int,
                    block_idx_y[(4 as c_int * i + 3 as c_int) as usize] as c_int,
                    1 as c_int,
                    1 as c_int,
                    0 as c_int,
                    mvd_7,
                );
            }
            _ => {
                __assert_fail(
                    b"0\0" as *const u8 as *const c_char,
                    b"encoder/cabac.c\0" as *const u8 as *const c_char,
                    377 as c_uint,
                    ::core::mem::transmute::<[u8; 50], [c_char; 50]>(
                        *b"void cabac_8x8_mvd(x264_t *, x264_cabac_t *, int)\0",
                    )
                    .as_ptr(),
                );
            }
        };
    }
    #[inline(always)]
    #[c2rust::src_loc = "381:1"]
    pub unsafe extern "C" fn cabac_mb_header_i(
        mut h: *mut x264_t,
        mut cb: *mut x264_cabac_t,
        mut i_mb_type: c_int,
        mut slice_type: c_int,
        mut chroma: c_int,
    ) {
        if slice_type == SLICE_TYPE_I as c_int {
            let mut ctx: c_int = 0 as c_int;
            if (*h).mb.i_neighbour & MB_LEFT as c_int as c_uint != 0
                && (*h).mb.i_mb_type_left[0] != I_4x4 as c_int
            {
                ctx += 1;
            }
            if (*h).mb.i_neighbour & MB_TOP as c_int as c_uint != 0
                && (*h).mb.i_mb_type_top != I_4x4 as c_int
            {
                ctx += 1;
            }
            cabac_mb_type_intra(
                h,
                cb,
                i_mb_type,
                3 as c_int + ctx,
                3 as c_int + 3 as c_int,
                3 as c_int + 4 as c_int,
                3 as c_int + 5 as c_int,
                3 as c_int + 6 as c_int,
                3 as c_int + 7 as c_int,
            );
        } else if slice_type == SLICE_TYPE_P as c_int {
            x264_cabac_size_decision_noup(cb, 14 as c_long, 1 as c_long);
            cabac_mb_type_intra(
                h,
                cb,
                i_mb_type,
                17 as c_int + 0 as c_int,
                17 as c_int + 1 as c_int,
                17 as c_int + 2 as c_int,
                17 as c_int + 2 as c_int,
                17 as c_int + 3 as c_int,
                17 as c_int + 3 as c_int,
            );
        } else if slice_type == SLICE_TYPE_B as c_int {
            x264_cabac_size_decision_noup(cb, (27 as c_int + 3 as c_int) as c_long, 1 as c_long);
            x264_cabac_size_decision_noup(cb, (27 as c_int + 4 as c_int) as c_long, 1 as c_long);
            x264_cabac_size_decision(cb, (27 as c_int + 5 as c_int) as c_long, 1 as c_long);
            x264_cabac_size_decision(cb, (27 as c_int + 5 as c_int) as c_long, 0 as c_long);
            x264_cabac_size_decision(cb, (27 as c_int + 5 as c_int) as c_long, 1 as c_long);
            cabac_mb_type_intra(
                h,
                cb,
                i_mb_type,
                32 as c_int + 0 as c_int,
                32 as c_int + 1 as c_int,
                32 as c_int + 2 as c_int,
                32 as c_int + 2 as c_int,
                32 as c_int + 3 as c_int,
                32 as c_int + 3 as c_int,
            );
        }
        if i_mb_type == I_PCM as c_int {
            return;
        }
        if i_mb_type != I_16x16 as c_int {
            if (*(*h).pps.as_mut_ptr()).b_transform_8x8_mode != 0 {
                cabac_transform_size(h, cb);
            }
            let mut di: c_int = if (*h).mb.b_transform_8x8 != 0 {
                4 as c_int
            } else {
                1 as c_int
            };
            let mut i: c_int = 0 as c_int;
            while i < 16 as c_int {
                let i_pred: c_int = x264_mb_predict_intra4x4_mode(h, i) as c_int;
                let i_mode: c_int = x264_mb_pred_mode4x4_fix[((*h).mb.cache.intra4x4_pred_mode
                    [x264_scan8[i as usize] as usize]
                    as c_int
                    + 1 as c_int)
                    as usize] as c_int;
                cabac_intra4x4_pred_mode(cb, i_pred, i_mode);
                i += di;
            }
        }
        if chroma != 0 {
            cabac_intra_chroma_pred_mode(h, cb);
        }
    }
    #[inline(always)]
    #[c2rust::src_loc = "435:1"]
    pub unsafe extern "C" fn cabac_mb_header_p(
        mut h: *mut x264_t,
        mut cb: *mut x264_cabac_t,
        mut i_mb_type: c_int,
        mut chroma: c_int,
    ) {
        if i_mb_type == P_L0 as c_int {
            x264_cabac_size_decision_noup(cb, 14 as c_long, 0 as c_long);
            if (*h).mb.i_partition == D_16x16 as c_int {
                x264_cabac_size_decision_noup(cb, 15 as c_long, 0 as c_long);
                x264_cabac_size_decision_noup(cb, 16 as c_long, 0 as c_long);
                if (*h).mb.pic.i_fref[0] > 1 as c_int {
                    cabac_ref_p(h, cb, 0 as c_int);
                }
                let mut mvd: uint16_t = cabac_mvd(h, cb, 0 as c_int, 0 as c_int, 4 as c_int);
                x264_macroblock_cache_mvd(
                    h,
                    block_idx_x[0] as c_int,
                    block_idx_y[0] as c_int,
                    4 as c_int,
                    4 as c_int,
                    0 as c_int,
                    mvd,
                );
            } else if (*h).mb.i_partition == D_16x8 as c_int {
                x264_cabac_size_decision_noup(cb, 15 as c_long, 1 as c_long);
                x264_cabac_size_decision_noup(cb, 17 as c_long, 1 as c_long);
                if (*h).mb.pic.i_fref[0] > 1 as c_int {
                    cabac_ref_p(h, cb, 0 as c_int);
                    cabac_ref_p(h, cb, 8 as c_int);
                }
                let mut mvd_0: uint16_t = cabac_mvd(h, cb, 0 as c_int, 0 as c_int, 4 as c_int);
                x264_macroblock_cache_mvd(
                    h,
                    block_idx_x[0] as c_int,
                    block_idx_y[0] as c_int,
                    4 as c_int,
                    2 as c_int,
                    0 as c_int,
                    mvd_0,
                );
                let mut mvd_1: uint16_t = cabac_mvd(h, cb, 0 as c_int, 8 as c_int, 4 as c_int);
                x264_macroblock_cache_mvd(
                    h,
                    block_idx_x[8] as c_int,
                    block_idx_y[8] as c_int,
                    4 as c_int,
                    2 as c_int,
                    0 as c_int,
                    mvd_1,
                );
            } else {
                x264_cabac_size_decision_noup(cb, 15 as c_long, 1 as c_long);
                x264_cabac_size_decision_noup(cb, 17 as c_long, 0 as c_long);
                if (*h).mb.pic.i_fref[0] > 1 as c_int {
                    cabac_ref_p(h, cb, 0 as c_int);
                    cabac_ref_p(h, cb, 4 as c_int);
                }
                let mut mvd_2: uint16_t = cabac_mvd(h, cb, 0 as c_int, 0 as c_int, 2 as c_int);
                x264_macroblock_cache_mvd(
                    h,
                    block_idx_x[0] as c_int,
                    block_idx_y[0] as c_int,
                    2 as c_int,
                    4 as c_int,
                    0 as c_int,
                    mvd_2,
                );
                let mut mvd_3: uint16_t = cabac_mvd(h, cb, 0 as c_int, 4 as c_int, 2 as c_int);
                x264_macroblock_cache_mvd(
                    h,
                    block_idx_x[4] as c_int,
                    block_idx_y[4] as c_int,
                    2 as c_int,
                    4 as c_int,
                    0 as c_int,
                    mvd_3,
                );
            }
        } else if i_mb_type == P_8x8 as c_int {
            x264_cabac_size_decision_noup(cb, 14 as c_long, 0 as c_long);
            x264_cabac_size_decision_noup(cb, 15 as c_long, 0 as c_long);
            x264_cabac_size_decision_noup(cb, 16 as c_long, 1 as c_long);
            let mut i: c_int = 0 as c_int;
            while i < 4 as c_int {
                cabac_subpartition_p(cb, (*h).mb.i_sub_partition[i as usize] as c_int);
                i += 1;
            }
            if (*h).mb.pic.i_fref[0] > 1 as c_int {
                cabac_ref_p(h, cb, 0 as c_int);
                cabac_ref_p(h, cb, 4 as c_int);
                cabac_ref_p(h, cb, 8 as c_int);
                cabac_ref_p(h, cb, 12 as c_int);
            }
            let mut i_0: c_int = 0 as c_int;
            while i_0 < 4 as c_int {
                cabac_8x8_mvd(h, cb, i_0);
                i_0 += 1;
            }
        } else {
            cabac_mb_header_i(h, cb, i_mb_type, SLICE_TYPE_P as c_int, chroma);
        };
    }
    #[inline(always)]
    #[c2rust::src_loc = "499:1"]
    pub unsafe extern "C" fn cabac_mb_header_b(
        mut h: *mut x264_t,
        mut cb: *mut x264_cabac_t,
        mut i_mb_type: c_int,
        mut chroma: c_int,
    ) {
        let mut ctx: c_int = 0 as c_int;
        if (*h).mb.i_neighbour & MB_LEFT as c_int as c_uint != 0
            && (*h).mb.i_mb_type_left[0] != B_SKIP as c_int
            && (*h).mb.i_mb_type_left[0] != B_DIRECT as c_int
        {
            ctx += 1;
        }
        if (*h).mb.i_neighbour & MB_TOP as c_int as c_uint != 0
            && (*h).mb.i_mb_type_top != B_SKIP as c_int
            && (*h).mb.i_mb_type_top != B_DIRECT as c_int
        {
            ctx += 1;
        }
        if i_mb_type == B_DIRECT as c_int {
            x264_cabac_size_decision_noup(cb, (27 as c_int + ctx) as c_long, 0 as c_long);
            return;
        }
        x264_cabac_size_decision_noup(cb, (27 as c_int + ctx) as c_long, 1 as c_long);
        if i_mb_type == B_8x8 as c_int {
            x264_cabac_size_decision_noup(cb, (27 as c_int + 3 as c_int) as c_long, 1 as c_long);
            x264_cabac_size_decision_noup(cb, (27 as c_int + 4 as c_int) as c_long, 1 as c_long);
            x264_cabac_size_decision(cb, (27 as c_int + 5 as c_int) as c_long, 1 as c_long);
            x264_cabac_size_decision(cb, (27 as c_int + 5 as c_int) as c_long, 1 as c_long);
            x264_cabac_size_decision_noup(cb, (27 as c_int + 5 as c_int) as c_long, 1 as c_long);
            let mut i: c_int = 0 as c_int;
            while i < 4 as c_int {
                cabac_subpartition_b(cb, (*h).mb.i_sub_partition[i as usize] as c_int);
                i += 1;
            }
            if (*h).mb.pic.i_fref[0] > 1 as c_int {
                let mut i_0: c_int = 0 as c_int;
                while i_0 < 4 as c_int {
                    if x264_mb_partition_listX_table[0]
                        [(*h).mb.i_sub_partition[i_0 as usize] as usize]
                        != 0
                    {
                        cabac_ref_b(h, cb, 0 as c_int, 4 as c_int * i_0);
                    }
                    i_0 += 1;
                }
            }
            if (*h).mb.pic.i_fref[1] > 1 as c_int {
                let mut i_1: c_int = 0 as c_int;
                while i_1 < 4 as c_int {
                    if x264_mb_partition_listX_table[1]
                        [(*h).mb.i_sub_partition[i_1 as usize] as usize]
                        != 0
                    {
                        cabac_ref_b(h, cb, 1 as c_int, 4 as c_int * i_1);
                    }
                    i_1 += 1;
                }
            }
            let mut i_2: c_int = 0 as c_int;
            while i_2 < 4 as c_int {
                if x264_mb_partition_listX_table[0][(*h).mb.i_sub_partition[i_2 as usize] as usize]
                    != 0
                {
                    let mut mvd: uint16_t =
                        cabac_mvd(h, cb, 0 as c_int, 4 as c_int * i_2, 2 as c_int);
                    x264_macroblock_cache_mvd(
                        h,
                        block_idx_x[(4 as c_int * i_2) as usize] as c_int,
                        block_idx_y[(4 as c_int * i_2) as usize] as c_int,
                        2 as c_int,
                        2 as c_int,
                        0 as c_int,
                        mvd,
                    );
                }
                i_2 += 1;
            }
            let mut i_3: c_int = 0 as c_int;
            while i_3 < 4 as c_int {
                if x264_mb_partition_listX_table[1][(*h).mb.i_sub_partition[i_3 as usize] as usize]
                    != 0
                {
                    let mut mvd_0: uint16_t =
                        cabac_mvd(h, cb, 1 as c_int, 4 as c_int * i_3, 2 as c_int);
                    x264_macroblock_cache_mvd(
                        h,
                        block_idx_x[(4 as c_int * i_3) as usize] as c_int,
                        block_idx_y[(4 as c_int * i_3) as usize] as c_int,
                        2 as c_int,
                        2 as c_int,
                        1 as c_int,
                        mvd_0,
                    );
                }
                i_3 += 1;
            }
        } else if i_mb_type >= B_L0_L0 as c_int && i_mb_type <= B_BI_BI as c_int {
            pub static mut i_mb_bits: [uint8_t; 27] = [
                0x31 as c_int as uint8_t,
                0x29 as c_int as uint8_t,
                0x4 as c_int as uint8_t,
                0x35 as c_int as uint8_t,
                0x2d as c_int as uint8_t,
                0 as c_int as uint8_t,
                0x43 as c_int as uint8_t,
                0x63 as c_int as uint8_t,
                0 as c_int as uint8_t,
                0x3d as c_int as uint8_t,
                0x2f as c_int as uint8_t,
                0 as c_int as uint8_t,
                0x39 as c_int as uint8_t,
                0x25 as c_int as uint8_t,
                0x6 as c_int as uint8_t,
                0x53 as c_int as uint8_t,
                0x73 as c_int as uint8_t,
                0 as c_int as uint8_t,
                0x4b as c_int as uint8_t,
                0x6b as c_int as uint8_t,
                0 as c_int as uint8_t,
                0x5b as c_int as uint8_t,
                0x7b as c_int as uint8_t,
                0 as c_int as uint8_t,
                0x47 as c_int as uint8_t,
                0x67 as c_int as uint8_t,
                0x21 as c_int as uint8_t,
            ];
            let idx: c_int = (i_mb_type - B_L0_L0 as c_int as c_int) * 3 as c_int
                + ((*h).mb.i_partition - D_16x8 as c_int as c_int);
            let mut bits: c_int = i_mb_bits[idx as usize] as c_int;
            x264_cabac_size_decision_noup(
                cb,
                (27 as c_int + 3 as c_int) as c_long,
                (bits & 1 as c_int) as c_long,
            );
            x264_cabac_size_decision(
                cb,
                (27 as c_int + 5 as c_int - (bits & 1 as c_int)) as c_long,
                (bits >> 1 as c_int & 1 as c_int) as c_long,
            );
            bits >>= 2 as c_int;
            if bits != 1 as c_int {
                x264_cabac_size_decision(
                    cb,
                    (27 as c_int + 5 as c_int) as c_long,
                    (bits & 1 as c_int) as c_long,
                );
                bits >>= 1 as c_int;
                x264_cabac_size_decision(
                    cb,
                    (27 as c_int + 5 as c_int) as c_long,
                    (bits & 1 as c_int) as c_long,
                );
                bits >>= 1 as c_int;
                x264_cabac_size_decision(
                    cb,
                    (27 as c_int + 5 as c_int) as c_long,
                    (bits & 1 as c_int) as c_long,
                );
                bits >>= 1 as c_int;
                if bits != 1 as c_int {
                    x264_cabac_size_decision_noup(
                        cb,
                        (27 as c_int + 5 as c_int) as c_long,
                        (bits & 1 as c_int) as c_long,
                    );
                }
            }
            let mut b_list: *const [uint8_t; 2] =
                (*x264_mb_type_list_table.as_ptr().offset(i_mb_type as isize)).as_ptr()
                    as *const [uint8_t; 2];
            if (*h).mb.pic.i_fref[0] > 1 as c_int {
                if (*b_list.offset(0))[0] != 0 {
                    cabac_ref_b(h, cb, 0 as c_int, 0 as c_int);
                }
                if (*b_list.offset(0))[1] as c_int != 0 && (*h).mb.i_partition != D_16x16 as c_int {
                    cabac_ref_b(
                        h,
                        cb,
                        0 as c_int,
                        8 as c_int >> ((*h).mb.i_partition == D_8x16 as c_int) as c_int,
                    );
                }
            }
            if (*h).mb.pic.i_fref[1] > 1 as c_int {
                if (*b_list.offset(1))[0] != 0 {
                    cabac_ref_b(h, cb, 1 as c_int, 0 as c_int);
                }
                if (*b_list.offset(1))[1] as c_int != 0 && (*h).mb.i_partition != D_16x16 as c_int {
                    cabac_ref_b(
                        h,
                        cb,
                        1 as c_int,
                        8 as c_int >> ((*h).mb.i_partition == D_8x16 as c_int) as c_int,
                    );
                }
            }
            let mut i_list: c_int = 0 as c_int;
            while i_list < 2 as c_int {
                if (*h).mb.i_partition == D_16x16 as c_int {
                    if (*b_list.offset(i_list as isize))[0] != 0 {
                        let mut mvd_1: uint16_t = cabac_mvd(h, cb, i_list, 0 as c_int, 4 as c_int);
                        x264_macroblock_cache_mvd(
                            h,
                            block_idx_x[0] as c_int,
                            block_idx_y[0] as c_int,
                            4 as c_int,
                            4 as c_int,
                            i_list,
                            mvd_1,
                        );
                    }
                } else if (*h).mb.i_partition == D_16x8 as c_int {
                    if (*b_list.offset(i_list as isize))[0] != 0 {
                        let mut mvd_2: uint16_t = cabac_mvd(h, cb, i_list, 0 as c_int, 4 as c_int);
                        x264_macroblock_cache_mvd(
                            h,
                            block_idx_x[0] as c_int,
                            block_idx_y[0] as c_int,
                            4 as c_int,
                            2 as c_int,
                            i_list,
                            mvd_2,
                        );
                    }
                    if (*b_list.offset(i_list as isize))[1] != 0 {
                        let mut mvd_3: uint16_t = cabac_mvd(h, cb, i_list, 8 as c_int, 4 as c_int);
                        x264_macroblock_cache_mvd(
                            h,
                            block_idx_x[8] as c_int,
                            block_idx_y[8] as c_int,
                            4 as c_int,
                            2 as c_int,
                            i_list,
                            mvd_3,
                        );
                    }
                } else {
                    if (*b_list.offset(i_list as isize))[0] != 0 {
                        let mut mvd_4: uint16_t = cabac_mvd(h, cb, i_list, 0 as c_int, 2 as c_int);
                        x264_macroblock_cache_mvd(
                            h,
                            block_idx_x[0] as c_int,
                            block_idx_y[0] as c_int,
                            2 as c_int,
                            4 as c_int,
                            i_list,
                            mvd_4,
                        );
                    }
                    if (*b_list.offset(i_list as isize))[1] != 0 {
                        let mut mvd_5: uint16_t = cabac_mvd(h, cb, i_list, 4 as c_int, 2 as c_int);
                        x264_macroblock_cache_mvd(
                            h,
                            block_idx_x[4] as c_int,
                            block_idx_y[4] as c_int,
                            2 as c_int,
                            4 as c_int,
                            i_list,
                            mvd_5,
                        );
                    }
                }
                i_list += 1;
            }
        } else {
            cabac_mb_header_i(h, cb, i_mb_type, SLICE_TYPE_B as c_int, chroma);
        };
    }
    #[inline(always)]
    #[c2rust::src_loc = "612:1"]
    pub unsafe extern "C" fn cabac_cbf_ctxidxinc(
        mut h: *mut x264_t,
        mut i_cat: c_int,
        mut i_idx: c_int,
        mut b_intra: c_int,
        mut b_dc: c_int,
    ) -> c_int {
        pub static mut base_ctx: [uint16_t; 14] = [
            85 as c_int as uint16_t,
            89 as c_int as uint16_t,
            93 as c_int as uint16_t,
            97 as c_int as uint16_t,
            101 as c_int as uint16_t,
            1012 as c_int as uint16_t,
            460 as c_int as uint16_t,
            464 as c_int as uint16_t,
            468 as c_int as uint16_t,
            1016 as c_int as uint16_t,
            472 as c_int as uint16_t,
            476 as c_int as uint16_t,
            480 as c_int as uint16_t,
            1020 as c_int as uint16_t,
        ];
        if b_dc != 0 {
            i_idx -= LUMA_DC;
            if i_cat == DCT_CHROMA_DC as c_int {
                let mut i_nza: c_int = if (*h).mb.cache.i_cbp_left != -1 {
                    (*h).mb.cache.i_cbp_left >> 8 as c_int + i_idx & 1 as c_int
                } else {
                    b_intra
                };
                let mut i_nzb: c_int = if (*h).mb.cache.i_cbp_top != -1 {
                    (*h).mb.cache.i_cbp_top >> 8 as c_int + i_idx & 1 as c_int
                } else {
                    b_intra
                };
                return base_ctx[i_cat as usize] as c_int + 2 as c_int * i_nzb + i_nza;
            } else {
                let mut i_nza_0: c_int =
                    (*h).mb.cache.i_cbp_left >> 8 as c_int + i_idx & 1 as c_int;
                let mut i_nzb_0: c_int = (*h).mb.cache.i_cbp_top >> 8 as c_int + i_idx & 1 as c_int;
                return base_ctx[i_cat as usize] as c_int + 2 as c_int * i_nzb_0 + i_nza_0;
            }
        } else {
            let mut i_nza_1: c_int = (*h).mb.cache.non_zero_count
                [(x264_scan8[i_idx as usize] as c_int - 1 as c_int) as usize]
                as c_int;
            let mut i_nzb_1: c_int = (*h).mb.cache.non_zero_count
                [(x264_scan8[i_idx as usize] as c_int - 8 as c_int) as usize]
                as c_int;
            if 0 != 0 && b_intra == 0 {
                return base_ctx[i_cat as usize] as c_int
                    + (2 as c_int * i_nzb_1 + i_nza_1 & 0x7f as c_int);
            } else {
                i_nza_1 &= 0x7f as c_int + (b_intra << 7 as c_int);
                i_nzb_1 &= 0x7f as c_int + (b_intra << 7 as c_int);
                return base_ctx[i_cat as usize] as c_int
                    + 2 as c_int * (i_nzb_1 != 0) as c_int
                    + (i_nza_1 != 0) as c_int;
            }
        };
    }
    #[c2rust::src_loc = "650:22"]
    pub static mut coeff_abs_level1_ctx: [uint8_t; 8] = [
        1 as c_int as uint8_t,
        2 as c_int as uint8_t,
        3 as c_int as uint8_t,
        4 as c_int as uint8_t,
        0 as c_int as uint8_t,
        0 as c_int as uint8_t,
        0 as c_int as uint8_t,
        0 as c_int as uint8_t,
    ];
    #[c2rust::src_loc = "652:22"]
    pub static mut coeff_abs_levelgt1_ctx: [uint8_t; 8] = [
        5 as c_int as uint8_t,
        5 as c_int as uint8_t,
        5 as c_int as uint8_t,
        5 as c_int as uint8_t,
        6 as c_int as uint8_t,
        7 as c_int as uint8_t,
        8 as c_int as uint8_t,
        9 as c_int as uint8_t,
    ];
    #[c2rust::src_loc = "655:22"]
    pub static mut coeff_abs_levelgt1_ctx_chroma_dc: [uint8_t; 8] = [
        5 as c_int as uint8_t,
        5 as c_int as uint8_t,
        5 as c_int as uint8_t,
        5 as c_int as uint8_t,
        6 as c_int as uint8_t,
        7 as c_int as uint8_t,
        8 as c_int as uint8_t,
        8 as c_int as uint8_t,
    ];
    #[c2rust::src_loc = "657:22"]
    pub static mut coeff_abs_level_transition: [[uint8_t; 8]; 2] = [
        [
            1 as c_int as uint8_t,
            2 as c_int as uint8_t,
            3 as c_int as uint8_t,
            3 as c_int as uint8_t,
            4 as c_int as uint8_t,
            5 as c_int as uint8_t,
            6 as c_int as uint8_t,
            7 as c_int as uint8_t,
        ],
        [
            4 as c_int as uint8_t,
            4 as c_int as uint8_t,
            4 as c_int as uint8_t,
            4 as c_int as uint8_t,
            5 as c_int as uint8_t,
            6 as c_int as uint8_t,
            7 as c_int as uint8_t,
            7 as c_int as uint8_t,
        ],
    ];
    #[inline(always)]
    #[c2rust::src_loc = "775:1"]
    pub unsafe extern "C" fn cabac_block_residual_internal(
        mut h: *mut x264_t,
        mut cb: *mut x264_cabac_t,
        mut ctx_block_cat: c_int,
        mut l: *mut dctcoef,
        mut b_8x8: c_int,
        mut chroma422dc: c_int,
    ) {
        let mut sig_offset: *const uint8_t = (*x264_significant_coeff_flag_offset_8x8
            .as_ptr()
            .offset((*h).mb.b_interlaced as isize))
        .as_ptr();
        let mut ctx_sig: c_int = x264_significant_coeff_flag_offset[(*h).mb.b_interlaced as usize]
            [ctx_block_cat as usize] as c_int;
        let mut ctx_last: c_int = x264_last_coeff_flag_offset[(*h).mb.b_interlaced as usize]
            [ctx_block_cat as usize] as c_int;
        let mut ctx_level: c_int = x264_coeff_abs_level_m1_offset[ctx_block_cat as usize] as c_int;
        let mut last: c_int =
            (*h).quantf.coeff_last[ctx_block_cat as usize].expect("non-null function pointer")(l);
        let mut coeff_abs: c_int = abs(*l.offset(last as isize));
        let mut ctx: c_int = coeff_abs_level1_ctx[0] as c_int + ctx_level;
        let mut node_ctx: c_int = 0;
        let mut levelgt1_ctx: *const uint8_t = if chroma422dc != 0 {
            coeff_abs_levelgt1_ctx_chroma_dc.as_ptr()
        } else {
            coeff_abs_levelgt1_ctx.as_ptr()
        };
        if last
            != (if b_8x8 != 0 {
                63 as c_int
            } else {
                (if chroma422dc != 0 {
                    7 as c_int
                } else {
                    x264_count_cat_m1[ctx_block_cat as usize] as c_int
                })
            })
        {
            x264_cabac_size_decision(
                cb,
                (ctx_sig
                    + (if b_8x8 != 0 {
                        *sig_offset.offset(last as isize) as c_int
                    } else {
                        (if chroma422dc != 0 {
                            x264_coeff_flag_offset_chroma_422_dc[last as usize] as c_int
                        } else {
                            last
                        })
                    })) as c_long,
                1 as c_long,
            );
            x264_cabac_size_decision(
                cb,
                (ctx_last
                    + (if b_8x8 != 0 {
                        x264_last_coeff_flag_offset_8x8[last as usize] as c_int
                    } else {
                        (if chroma422dc != 0 {
                            x264_coeff_flag_offset_chroma_422_dc[last as usize] as c_int
                        } else {
                            last
                        })
                    })) as c_long,
                1 as c_long,
            );
        }
        if coeff_abs > 1 as c_int {
            x264_cabac_size_decision(cb, ctx as c_long, 1 as c_long);
            ctx = *levelgt1_ctx.offset(0) as c_int + ctx_level;
            if coeff_abs < 15 as c_int {
                (*cb).f8_bits_encoded += x264_10_cabac_size_unary[(coeff_abs - 1 as c_int) as usize]
                    [(*cb).state[ctx as usize] as usize]
                    as c_int;
                (*cb).state[ctx as usize] = x264_10_cabac_transition_unary
                    [(coeff_abs - 1 as c_int) as usize][(*cb).state[ctx as usize] as usize];
            } else {
                (*cb).f8_bits_encoded +=
                    x264_10_cabac_size_unary[14][(*cb).state[ctx as usize] as usize] as c_int;
                (*cb).state[ctx as usize] =
                    x264_10_cabac_transition_unary[14][(*cb).state[ctx as usize] as usize];
                (*cb).f8_bits_encoded += (bs_size_ue_big(
                    (coeff_abs - 15 as c_int + ((1 as c_int) << 0 as c_int) - 1 as c_int) as c_uint,
                ) - 0 as c_int)
                    << 8 as c_int;
            }
            node_ctx = coeff_abs_level_transition[1][0] as c_int;
        } else {
            x264_cabac_size_decision(cb, ctx as c_long, 0 as c_long);
            node_ctx = coeff_abs_level_transition[0][0] as c_int;
            (*cb).f8_bits_encoded += 256 as c_int;
        }
        let mut i: c_int = last - 1 as c_int;
        while i >= 0 as c_int {
            if *l.offset(i as isize) != 0 {
                coeff_abs = abs(*l.offset(i as isize));
                x264_cabac_size_decision(
                    cb,
                    (ctx_sig
                        + (if b_8x8 != 0 {
                            *sig_offset.offset(i as isize) as c_int
                        } else {
                            (if chroma422dc != 0 {
                                x264_coeff_flag_offset_chroma_422_dc[i as usize] as c_int
                            } else {
                                i
                            })
                        })) as c_long,
                    1 as c_long,
                );
                x264_cabac_size_decision(
                    cb,
                    (ctx_last
                        + (if b_8x8 != 0 {
                            x264_last_coeff_flag_offset_8x8[i as usize] as c_int
                        } else {
                            (if chroma422dc != 0 {
                                x264_coeff_flag_offset_chroma_422_dc[i as usize] as c_int
                            } else {
                                i
                            })
                        })) as c_long,
                    0 as c_long,
                );
                ctx = coeff_abs_level1_ctx[node_ctx as usize] as c_int + ctx_level;
                if coeff_abs > 1 as c_int {
                    x264_cabac_size_decision(cb, ctx as c_long, 1 as c_long);
                    ctx = *levelgt1_ctx.offset(node_ctx as isize) as c_int + ctx_level;
                    if coeff_abs < 15 as c_int {
                        (*cb).f8_bits_encoded += x264_10_cabac_size_unary
                            [(coeff_abs - 1 as c_int) as usize]
                            [(*cb).state[ctx as usize] as usize]
                            as c_int;
                        (*cb).state[ctx as usize] = x264_10_cabac_transition_unary
                            [(coeff_abs - 1 as c_int) as usize]
                            [(*cb).state[ctx as usize] as usize];
                    } else {
                        (*cb).f8_bits_encoded += x264_10_cabac_size_unary[14]
                            [(*cb).state[ctx as usize] as usize]
                            as c_int;
                        (*cb).state[ctx as usize] =
                            x264_10_cabac_transition_unary[14][(*cb).state[ctx as usize] as usize];
                        (*cb).f8_bits_encoded += (bs_size_ue_big(
                            (coeff_abs - 15 as c_int + ((1 as c_int) << 0 as c_int) - 1 as c_int)
                                as c_uint,
                        ) - 0 as c_int)
                            << 8 as c_int;
                    }
                    node_ctx = coeff_abs_level_transition[1][node_ctx as usize] as c_int;
                } else {
                    x264_cabac_size_decision(cb, ctx as c_long, 0 as c_long);
                    node_ctx = coeff_abs_level_transition[0][node_ctx as usize] as c_int;
                    (*cb).f8_bits_encoded += 256 as c_int;
                }
            } else {
                x264_cabac_size_decision(
                    cb,
                    (ctx_sig
                        + (if b_8x8 != 0 {
                            *sig_offset.offset(i as isize) as c_int
                        } else {
                            (if chroma422dc != 0 {
                                x264_coeff_flag_offset_chroma_422_dc[i as usize] as c_int
                            } else {
                                i
                            })
                        })) as c_long,
                    0 as c_long,
                );
            }
            i -= 1;
        }
    }
    #[no_mangle]
    #[c2rust::src_loc = "860:1"]
    pub unsafe extern "C" fn x264_10_cabac_block_residual_8x8_rd_c(
        mut h: *mut x264_t,
        mut cb: *mut x264_cabac_t,
        mut ctx_block_cat: c_int,
        mut l: *mut dctcoef,
    ) {
        cabac_block_residual_internal(h, cb, ctx_block_cat, l, 1 as c_int, 0 as c_int);
    }
    #[no_mangle]
    #[c2rust::src_loc = "864:1"]
    pub unsafe extern "C" fn x264_10_cabac_block_residual_rd_c(
        mut h: *mut x264_t,
        mut cb: *mut x264_cabac_t,
        mut ctx_block_cat: c_int,
        mut l: *mut dctcoef,
    ) {
        cabac_block_residual_internal(h, cb, ctx_block_cat, l, 0 as c_int, 0 as c_int);
    }
    #[inline(always)]
    #[c2rust::src_loc = "869:1"]
    pub unsafe extern "C" fn cabac_block_residual_8x8(
        mut h: *mut x264_t,
        mut cb: *mut x264_cabac_t,
        mut ctx_block_cat: c_int,
        mut l: *mut dctcoef,
    ) {
        x264_10_cabac_block_residual_8x8_rd_c(h, cb, ctx_block_cat, l);
    }
    #[inline(always)]
    #[c2rust::src_loc = "877:1"]
    pub unsafe extern "C" fn cabac_block_residual(
        mut h: *mut x264_t,
        mut cb: *mut x264_cabac_t,
        mut ctx_block_cat: c_int,
        mut l: *mut dctcoef,
    ) {
        x264_10_cabac_block_residual_rd_c(h, cb, ctx_block_cat, l);
    }
    #[c2rust::src_loc = "886:1"]
    pub unsafe extern "C" fn cabac_block_residual_422_dc(
        mut h: *mut x264_t,
        mut cb: *mut x264_cabac_t,
        mut ctx_block_cat: c_int,
        mut l: *mut dctcoef,
    ) {
        cabac_block_residual_internal(h, cb, DCT_CHROMA_DC as c_int, l, 0 as c_int, 1 as c_int);
    }
    #[inline(always)]
    #[c2rust::src_loc = "917:1"]
    pub unsafe extern "C" fn macroblock_write_cabac_internal(
        mut h: *mut x264_t,
        mut cb: *mut x264_cabac_t,
        mut plane_count: c_int,
        mut chroma: c_int,
    ) {
        let i_mb_type: c_int = (*h).mb.i_type;
        if (*h).sh.i_type == SLICE_TYPE_P as c_int {
            cabac_mb_header_p(h, cb, i_mb_type, chroma);
        } else if (*h).sh.i_type == SLICE_TYPE_B as c_int {
            cabac_mb_header_b(h, cb, i_mb_type, chroma);
        } else {
            cabac_mb_header_i(h, cb, i_mb_type, SLICE_TYPE_I as c_int, chroma);
        }
        if i_mb_type != I_16x16 as c_int {
            cabac_cbp_luma(h, cb);
            if chroma != 0 {
                cabac_cbp_chroma(h, cb);
            }
        }
        if x264_mb_transform_8x8_allowed(h) != 0 && (*h).mb.i_cbp_luma != 0 {
            cabac_transform_size(h, cb);
        }
        if (*h).mb.i_cbp_luma != 0
            || chroma != 0 && (*h).mb.i_cbp_chroma != 0
            || i_mb_type == I_16x16 as c_int
        {
            let b_intra: c_int = (i_mb_type == I_4x4 as c_int
                || i_mb_type == I_8x8 as c_int
                || i_mb_type == I_16x16 as c_int
                || i_mb_type == I_PCM as c_int) as c_int;
            cabac_qp_delta(h, cb);
            if i_mb_type == I_16x16 as c_int {
                let mut p: c_int = 0 as c_int;
                while p < plane_count {
                    let mut ctxidxinc: c_int = cabac_cbf_ctxidxinc(
                        h,
                        ctx_cat_plane[DCT_LUMA_DC as c_int as usize][p as usize] as c_int,
                        48 as c_int + p,
                        1 as c_int,
                        1 as c_int,
                    );
                    if (*h).mb.cache.non_zero_count[x264_scan8[(48 as c_int + p) as usize] as usize]
                        != 0
                    {
                        x264_cabac_size_decision(cb, ctxidxinc as c_long, 1 as c_long);
                        cabac_block_residual(
                            h,
                            cb,
                            ctx_cat_plane[DCT_LUMA_DC as c_int as usize][p as usize] as c_int,
                            (*(*h).dct.luma16x16_dc.as_mut_ptr().offset(p as isize)).as_mut_ptr(),
                        );
                    } else {
                        x264_cabac_size_decision(cb, ctxidxinc as c_long, 0 as c_long);
                    }
                    if (*h).mb.i_cbp_luma != 0 {
                        let mut i: c_int = p * 16 as c_int;
                        while i < p * 16 as c_int + 16 as c_int {
                            let mut ctxidxinc_0: c_int = cabac_cbf_ctxidxinc(
                                h,
                                ctx_cat_plane[DCT_LUMA_AC as c_int as usize][p as usize] as c_int,
                                i,
                                1 as c_int,
                                0 as c_int,
                            );
                            if (*h).mb.cache.non_zero_count[x264_scan8[i as usize] as usize] != 0 {
                                x264_cabac_size_decision(cb, ctxidxinc_0 as c_long, 1 as c_long);
                                cabac_block_residual(
                                    h,
                                    cb,
                                    ctx_cat_plane[DCT_LUMA_AC as c_int as usize][p as usize]
                                        as c_int,
                                    (*(*h).dct.luma4x4.as_mut_ptr().offset(i as isize))
                                        .as_mut_ptr()
                                        .offset(1),
                                );
                            } else {
                                x264_cabac_size_decision(cb, ctxidxinc_0 as c_long, 0 as c_long);
                            }
                            i += 1;
                        }
                    }
                    p += 1;
                }
            } else if (*h).mb.b_transform_8x8 != 0 {
                if plane_count == 3 as c_int {
                    let mut nnzbak: [[uint8_t; 8]; 3] = [[0; 8]; 3];
                    if (*h).mb.i_neighbour & MB_LEFT as c_int as c_uint != 0
                        && *(*h)
                            .mb
                            .mb_transform_size
                            .offset((*h).mb.i_mb_left_xy[0] as isize)
                            == 0
                        && *(*h).mb.cbp.offset((*h).mb.i_mb_left_xy[0] as isize) as c_int
                            & 0x1000 as c_int
                            == 0
                    {
                        nnzbak[0][0] = (*h).mb.cache.non_zero_count[(x264_scan8
                            [(16 as c_int * 0 as c_int + 0 as c_int) as usize]
                            as c_int
                            - 1 as c_int)
                            as usize];
                        (*h).mb.cache.non_zero_count[(x264_scan8
                            [(16 as c_int * 0 as c_int + 0 as c_int) as usize]
                            as c_int
                            - 1 as c_int)
                            as usize] = 0 as uint8_t;
                        nnzbak[0][1] = (*h).mb.cache.non_zero_count[(x264_scan8
                            [(16 as c_int * 0 as c_int + 2 as c_int) as usize]
                            as c_int
                            - 1 as c_int)
                            as usize];
                        (*h).mb.cache.non_zero_count[(x264_scan8
                            [(16 as c_int * 0 as c_int + 2 as c_int) as usize]
                            as c_int
                            - 1 as c_int)
                            as usize] = 0 as uint8_t;
                        nnzbak[1][0] = (*h).mb.cache.non_zero_count[(x264_scan8
                            [(16 as c_int * 1 as c_int + 0 as c_int) as usize]
                            as c_int
                            - 1 as c_int)
                            as usize];
                        (*h).mb.cache.non_zero_count[(x264_scan8
                            [(16 as c_int * 1 as c_int + 0 as c_int) as usize]
                            as c_int
                            - 1 as c_int)
                            as usize] = 0 as uint8_t;
                        nnzbak[1][1] = (*h).mb.cache.non_zero_count[(x264_scan8
                            [(16 as c_int * 1 as c_int + 2 as c_int) as usize]
                            as c_int
                            - 1 as c_int)
                            as usize];
                        (*h).mb.cache.non_zero_count[(x264_scan8
                            [(16 as c_int * 1 as c_int + 2 as c_int) as usize]
                            as c_int
                            - 1 as c_int)
                            as usize] = 0 as uint8_t;
                        nnzbak[2][0] = (*h).mb.cache.non_zero_count[(x264_scan8
                            [(16 as c_int * 2 as c_int + 0 as c_int) as usize]
                            as c_int
                            - 1 as c_int)
                            as usize];
                        (*h).mb.cache.non_zero_count[(x264_scan8
                            [(16 as c_int * 2 as c_int + 0 as c_int) as usize]
                            as c_int
                            - 1 as c_int)
                            as usize] = 0 as uint8_t;
                        nnzbak[2][1] = (*h).mb.cache.non_zero_count[(x264_scan8
                            [(16 as c_int * 2 as c_int + 2 as c_int) as usize]
                            as c_int
                            - 1 as c_int)
                            as usize];
                        (*h).mb.cache.non_zero_count[(x264_scan8
                            [(16 as c_int * 2 as c_int + 2 as c_int) as usize]
                            as c_int
                            - 1 as c_int)
                            as usize] = 0 as uint8_t;
                    }
                    if (*h).mb.i_neighbour & MB_LEFT as c_int as c_uint != 0
                        && *(*h)
                            .mb
                            .mb_transform_size
                            .offset((*h).mb.i_mb_left_xy[1] as isize)
                            == 0
                        && *(*h).mb.cbp.offset((*h).mb.i_mb_left_xy[1] as isize) as c_int
                            & 0x1000 as c_int
                            == 0
                    {
                        nnzbak[0][2] = (*h).mb.cache.non_zero_count[(x264_scan8
                            [(16 as c_int * 0 as c_int + 8 as c_int) as usize]
                            as c_int
                            - 1 as c_int)
                            as usize];
                        (*h).mb.cache.non_zero_count[(x264_scan8
                            [(16 as c_int * 0 as c_int + 8 as c_int) as usize]
                            as c_int
                            - 1 as c_int)
                            as usize] = 0 as uint8_t;
                        nnzbak[0][3] = (*h).mb.cache.non_zero_count[(x264_scan8
                            [(16 as c_int * 0 as c_int + 10 as c_int) as usize]
                            as c_int
                            - 1 as c_int)
                            as usize];
                        (*h).mb.cache.non_zero_count[(x264_scan8
                            [(16 as c_int * 0 as c_int + 10 as c_int) as usize]
                            as c_int
                            - 1 as c_int)
                            as usize] = 0 as uint8_t;
                        nnzbak[1][2] = (*h).mb.cache.non_zero_count[(x264_scan8
                            [(16 as c_int * 1 as c_int + 8 as c_int) as usize]
                            as c_int
                            - 1 as c_int)
                            as usize];
                        (*h).mb.cache.non_zero_count[(x264_scan8
                            [(16 as c_int * 1 as c_int + 8 as c_int) as usize]
                            as c_int
                            - 1 as c_int)
                            as usize] = 0 as uint8_t;
                        nnzbak[1][3] = (*h).mb.cache.non_zero_count[(x264_scan8
                            [(16 as c_int * 1 as c_int + 10 as c_int) as usize]
                            as c_int
                            - 1 as c_int)
                            as usize];
                        (*h).mb.cache.non_zero_count[(x264_scan8
                            [(16 as c_int * 1 as c_int + 10 as c_int) as usize]
                            as c_int
                            - 1 as c_int)
                            as usize] = 0 as uint8_t;
                        nnzbak[2][2] = (*h).mb.cache.non_zero_count[(x264_scan8
                            [(16 as c_int * 2 as c_int + 8 as c_int) as usize]
                            as c_int
                            - 1 as c_int)
                            as usize];
                        (*h).mb.cache.non_zero_count[(x264_scan8
                            [(16 as c_int * 2 as c_int + 8 as c_int) as usize]
                            as c_int
                            - 1 as c_int)
                            as usize] = 0 as uint8_t;
                        nnzbak[2][3] = (*h).mb.cache.non_zero_count[(x264_scan8
                            [(16 as c_int * 2 as c_int + 10 as c_int) as usize]
                            as c_int
                            - 1 as c_int)
                            as usize];
                        (*h).mb.cache.non_zero_count[(x264_scan8
                            [(16 as c_int * 2 as c_int + 10 as c_int) as usize]
                            as c_int
                            - 1 as c_int)
                            as usize] = 0 as uint8_t;
                    }
                    if (*h).mb.i_neighbour & MB_TOP as c_int as c_uint != 0
                        && *(*h)
                            .mb
                            .mb_transform_size
                            .offset((*h).mb.i_mb_top_xy as isize)
                            == 0
                        && *(*h).mb.cbp.offset((*h).mb.i_mb_top_xy as isize) as c_int
                            & 0x1000 as c_int
                            == 0
                    {
                        (*(&mut *(*nnzbak.as_mut_ptr().offset(0)).as_mut_ptr().offset(4)
                            as *mut uint8_t as *mut x264_union32_t))
                            .i = (*(&mut *(*h).mb.cache.non_zero_count.as_mut_ptr().offset(
                            (*x264_scan8
                                .as_ptr()
                                .offset((16 as c_int * 0 as c_int) as isize)
                                as c_int
                                - 8 as c_int) as isize,
                        ) as *mut uint8_t
                            as *mut x264_union32_t))
                            .i;
                        (*(&mut *(*h).mb.cache.non_zero_count.as_mut_ptr().offset(
                            (*x264_scan8
                                .as_ptr()
                                .offset((16 as c_int * 0 as c_int) as isize)
                                as c_int
                                - 8 as c_int) as isize,
                        ) as *mut uint8_t as *mut x264_union32_t))
                            .i = 0 as c_uint as uint32_t;
                        (*(&mut *(*nnzbak.as_mut_ptr().offset(1)).as_mut_ptr().offset(4)
                            as *mut uint8_t as *mut x264_union32_t))
                            .i = (*(&mut *(*h).mb.cache.non_zero_count.as_mut_ptr().offset(
                            (*x264_scan8
                                .as_ptr()
                                .offset((16 as c_int * 1 as c_int) as isize)
                                as c_int
                                - 8 as c_int) as isize,
                        ) as *mut uint8_t
                            as *mut x264_union32_t))
                            .i;
                        (*(&mut *(*h).mb.cache.non_zero_count.as_mut_ptr().offset(
                            (*x264_scan8
                                .as_ptr()
                                .offset((16 as c_int * 1 as c_int) as isize)
                                as c_int
                                - 8 as c_int) as isize,
                        ) as *mut uint8_t as *mut x264_union32_t))
                            .i = 0 as c_uint as uint32_t;
                        (*(&mut *(*nnzbak.as_mut_ptr().offset(2)).as_mut_ptr().offset(4)
                            as *mut uint8_t as *mut x264_union32_t))
                            .i = (*(&mut *(*h).mb.cache.non_zero_count.as_mut_ptr().offset(
                            (*x264_scan8
                                .as_ptr()
                                .offset((16 as c_int * 2 as c_int) as isize)
                                as c_int
                                - 8 as c_int) as isize,
                        ) as *mut uint8_t
                            as *mut x264_union32_t))
                            .i;
                        (*(&mut *(*h).mb.cache.non_zero_count.as_mut_ptr().offset(
                            (*x264_scan8
                                .as_ptr()
                                .offset((16 as c_int * 2 as c_int) as isize)
                                as c_int
                                - 8 as c_int) as isize,
                        ) as *mut uint8_t as *mut x264_union32_t))
                            .i = 0 as c_uint as uint32_t;
                    }
                    let mut p_0: c_int = 0 as c_int;
                    while p_0 < 3 as c_int {
                        let mut i_0: c_int = 0 as c_int;
                        let mut msk: c_int = (*h).mb.i_cbp_luma;
                        let mut skip: c_int = 0;
                        while msk != 0 && {
                            skip = x264_ctz_4bit(msk as uint32_t);
                            i_0 += skip;
                            msk >>= skip + 1 as c_int;
                            1 as c_int != 0
                        } {
                            let mut ctxidxinc_1: c_int = cabac_cbf_ctxidxinc(
                                h,
                                ctx_cat_plane[DCT_LUMA_8x8 as c_int as usize][p_0 as usize]
                                    as c_int,
                                i_0 * 4 as c_int + p_0 * 16 as c_int,
                                b_intra,
                                0 as c_int,
                            );
                            if (*h).mb.cache.non_zero_count[x264_scan8
                                [(i_0 * 4 as c_int + p_0 * 16 as c_int) as usize]
                                as usize]
                                != 0
                            {
                                x264_cabac_size_decision(cb, ctxidxinc_1 as c_long, 1 as c_long);
                                cabac_block_residual_8x8(
                                    h,
                                    cb,
                                    ctx_cat_plane[DCT_LUMA_8x8 as c_int as usize][p_0 as usize]
                                        as c_int,
                                    (*(*h)
                                        .dct
                                        .luma8x8
                                        .as_mut_ptr()
                                        .offset((i_0 + p_0 * 4 as c_int) as isize))
                                    .as_mut_ptr(),
                                );
                            } else {
                                x264_cabac_size_decision(cb, ctxidxinc_1 as c_long, 0 as c_long);
                            }
                            i_0 += 1;
                        }
                        p_0 += 1;
                    }
                    if (*h).mb.i_neighbour & MB_LEFT as c_int as c_uint != 0
                        && *(*h)
                            .mb
                            .mb_transform_size
                            .offset((*h).mb.i_mb_left_xy[0] as isize)
                            == 0
                        && *(*h).mb.cbp.offset((*h).mb.i_mb_left_xy[0] as isize) as c_int
                            & 0x1000 as c_int
                            == 0
                    {
                        (*h).mb.cache.non_zero_count[(x264_scan8
                            [(16 as c_int * 0 as c_int + 0 as c_int) as usize]
                            as c_int
                            - 1 as c_int)
                            as usize] = nnzbak[0][0];
                        (*h).mb.cache.non_zero_count[(x264_scan8
                            [(16 as c_int * 0 as c_int + 2 as c_int) as usize]
                            as c_int
                            - 1 as c_int)
                            as usize] = nnzbak[0][1];
                        (*h).mb.cache.non_zero_count[(x264_scan8
                            [(16 as c_int * 1 as c_int + 0 as c_int) as usize]
                            as c_int
                            - 1 as c_int)
                            as usize] = nnzbak[1][0];
                        (*h).mb.cache.non_zero_count[(x264_scan8
                            [(16 as c_int * 1 as c_int + 2 as c_int) as usize]
                            as c_int
                            - 1 as c_int)
                            as usize] = nnzbak[1][1];
                        (*h).mb.cache.non_zero_count[(x264_scan8
                            [(16 as c_int * 2 as c_int + 0 as c_int) as usize]
                            as c_int
                            - 1 as c_int)
                            as usize] = nnzbak[2][0];
                        (*h).mb.cache.non_zero_count[(x264_scan8
                            [(16 as c_int * 2 as c_int + 2 as c_int) as usize]
                            as c_int
                            - 1 as c_int)
                            as usize] = nnzbak[2][1];
                    }
                    if (*h).mb.i_neighbour & MB_LEFT as c_int as c_uint != 0
                        && *(*h)
                            .mb
                            .mb_transform_size
                            .offset((*h).mb.i_mb_left_xy[1] as isize)
                            == 0
                        && *(*h).mb.cbp.offset((*h).mb.i_mb_left_xy[1] as isize) as c_int
                            & 0x1000 as c_int
                            == 0
                    {
                        (*h).mb.cache.non_zero_count[(x264_scan8
                            [(16 as c_int * 0 as c_int + 8 as c_int) as usize]
                            as c_int
                            - 1 as c_int)
                            as usize] = nnzbak[0][2];
                        (*h).mb.cache.non_zero_count[(x264_scan8
                            [(16 as c_int * 0 as c_int + 10 as c_int) as usize]
                            as c_int
                            - 1 as c_int)
                            as usize] = nnzbak[0][3];
                        (*h).mb.cache.non_zero_count[(x264_scan8
                            [(16 as c_int * 1 as c_int + 8 as c_int) as usize]
                            as c_int
                            - 1 as c_int)
                            as usize] = nnzbak[1][2];
                        (*h).mb.cache.non_zero_count[(x264_scan8
                            [(16 as c_int * 1 as c_int + 10 as c_int) as usize]
                            as c_int
                            - 1 as c_int)
                            as usize] = nnzbak[1][3];
                        (*h).mb.cache.non_zero_count[(x264_scan8
                            [(16 as c_int * 2 as c_int + 8 as c_int) as usize]
                            as c_int
                            - 1 as c_int)
                            as usize] = nnzbak[2][2];
                        (*h).mb.cache.non_zero_count[(x264_scan8
                            [(16 as c_int * 2 as c_int + 10 as c_int) as usize]
                            as c_int
                            - 1 as c_int)
                            as usize] = nnzbak[2][3];
                    }
                    if (*h).mb.i_neighbour & MB_TOP as c_int as c_uint != 0
                        && *(*h)
                            .mb
                            .mb_transform_size
                            .offset((*h).mb.i_mb_top_xy as isize)
                            == 0
                        && *(*h).mb.cbp.offset((*h).mb.i_mb_top_xy as isize) as c_int
                            & 0x1000 as c_int
                            == 0
                    {
                        (*(&mut *(*h).mb.cache.non_zero_count.as_mut_ptr().offset(
                            (*x264_scan8
                                .as_ptr()
                                .offset((16 as c_int * 0 as c_int) as isize)
                                as c_int
                                - 8 as c_int) as isize,
                        ) as *mut uint8_t as *mut x264_union32_t))
                            .i = (*(&mut *(*nnzbak.as_mut_ptr().offset(0)).as_mut_ptr().offset(4)
                            as *mut uint8_t
                            as *mut x264_union32_t))
                            .i;
                        (*(&mut *(*h).mb.cache.non_zero_count.as_mut_ptr().offset(
                            (*x264_scan8
                                .as_ptr()
                                .offset((16 as c_int * 1 as c_int) as isize)
                                as c_int
                                - 8 as c_int) as isize,
                        ) as *mut uint8_t as *mut x264_union32_t))
                            .i = (*(&mut *(*nnzbak.as_mut_ptr().offset(1)).as_mut_ptr().offset(4)
                            as *mut uint8_t
                            as *mut x264_union32_t))
                            .i;
                        (*(&mut *(*h).mb.cache.non_zero_count.as_mut_ptr().offset(
                            (*x264_scan8
                                .as_ptr()
                                .offset((16 as c_int * 2 as c_int) as isize)
                                as c_int
                                - 8 as c_int) as isize,
                        ) as *mut uint8_t as *mut x264_union32_t))
                            .i = (*(&mut *(*nnzbak.as_mut_ptr().offset(2)).as_mut_ptr().offset(4)
                            as *mut uint8_t
                            as *mut x264_union32_t))
                            .i;
                    }
                } else {
                    let mut i_1: c_int = 0 as c_int;
                    let mut msk_0: c_int = (*h).mb.i_cbp_luma;
                    let mut skip_0: c_int = 0;
                    while msk_0 != 0 && {
                        skip_0 = x264_ctz_4bit(msk_0 as uint32_t);
                        i_1 += skip_0;
                        msk_0 >>= skip_0 + 1 as c_int;
                        1 as c_int != 0
                    } {
                        cabac_block_residual_8x8(
                            h,
                            cb,
                            DCT_LUMA_8x8 as c_int,
                            (*(*h).dct.luma8x8.as_mut_ptr().offset(i_1 as isize)).as_mut_ptr(),
                        );
                        i_1 += 1;
                    }
                }
            } else {
                let mut p_1: c_int = 0 as c_int;
                while p_1 < plane_count {
                    let mut i8x8: c_int = 0 as c_int;
                    let mut msk_1: c_int = (*h).mb.i_cbp_luma;
                    let mut skip_1: c_int = 0;
                    while msk_1 != 0 && {
                        skip_1 = x264_ctz_4bit(msk_1 as uint32_t);
                        i8x8 += skip_1;
                        msk_1 >>= skip_1 + 1 as c_int;
                        1 as c_int != 0
                    } {
                        let mut i_2: c_int = 0 as c_int;
                        while i_2 < 4 as c_int {
                            let mut ctxidxinc_2: c_int = cabac_cbf_ctxidxinc(
                                h,
                                ctx_cat_plane[DCT_LUMA_4x4 as c_int as usize][p_1 as usize]
                                    as c_int,
                                i_2 + i8x8 * 4 as c_int + p_1 * 16 as c_int,
                                b_intra,
                                0 as c_int,
                            );
                            if (*h).mb.cache.non_zero_count[x264_scan8
                                [(i_2 + i8x8 * 4 as c_int + p_1 * 16 as c_int) as usize]
                                as usize]
                                != 0
                            {
                                x264_cabac_size_decision(cb, ctxidxinc_2 as c_long, 1 as c_long);
                                cabac_block_residual(
                                    h,
                                    cb,
                                    ctx_cat_plane[DCT_LUMA_4x4 as c_int as usize][p_1 as usize]
                                        as c_int,
                                    (*(*h).dct.luma4x4.as_mut_ptr().offset(
                                        (i_2 + i8x8 * 4 as c_int + p_1 * 16 as c_int) as isize,
                                    ))
                                    .as_mut_ptr(),
                                );
                            } else {
                                x264_cabac_size_decision(cb, ctxidxinc_2 as c_long, 0 as c_long);
                            }
                            i_2 += 1;
                        }
                        i8x8 += 1;
                    }
                    p_1 += 1;
                }
            }
            if chroma != 0 && (*h).mb.i_cbp_chroma != 0 {
                if (*(*h).sps.as_mut_ptr()).i_chroma_format_idc == CHROMA_422 as c_int {
                    let mut ctxidxinc_3: c_int = cabac_cbf_ctxidxinc(
                        h,
                        DCT_CHROMA_DC as c_int,
                        49 as c_int + 0 as c_int,
                        b_intra,
                        1 as c_int,
                    );
                    if (*h).mb.cache.non_zero_count
                        [x264_scan8[(49 as c_int + 0 as c_int) as usize] as usize]
                        != 0
                    {
                        x264_cabac_size_decision(cb, ctxidxinc_3 as c_long, 1 as c_long);
                        cabac_block_residual_422_dc(
                            h,
                            cb,
                            DCT_CHROMA_DC as c_int,
                            (*(*h).dct.chroma_dc.as_mut_ptr().offset(0)).as_mut_ptr(),
                        );
                    } else {
                        x264_cabac_size_decision(cb, ctxidxinc_3 as c_long, 0 as c_long);
                    }
                    let mut ctxidxinc_4: c_int = cabac_cbf_ctxidxinc(
                        h,
                        DCT_CHROMA_DC as c_int,
                        49 as c_int + 1 as c_int,
                        b_intra,
                        1 as c_int,
                    );
                    if (*h).mb.cache.non_zero_count
                        [x264_scan8[(49 as c_int + 1 as c_int) as usize] as usize]
                        != 0
                    {
                        x264_cabac_size_decision(cb, ctxidxinc_4 as c_long, 1 as c_long);
                        cabac_block_residual_422_dc(
                            h,
                            cb,
                            DCT_CHROMA_DC as c_int,
                            (*(*h).dct.chroma_dc.as_mut_ptr().offset(1)).as_mut_ptr(),
                        );
                    } else {
                        x264_cabac_size_decision(cb, ctxidxinc_4 as c_long, 0 as c_long);
                    }
                } else {
                    let mut ctxidxinc_5: c_int = cabac_cbf_ctxidxinc(
                        h,
                        DCT_CHROMA_DC as c_int,
                        49 as c_int + 0 as c_int,
                        b_intra,
                        1 as c_int,
                    );
                    if (*h).mb.cache.non_zero_count
                        [x264_scan8[(49 as c_int + 0 as c_int) as usize] as usize]
                        != 0
                    {
                        x264_cabac_size_decision(cb, ctxidxinc_5 as c_long, 1 as c_long);
                        cabac_block_residual(
                            h,
                            cb,
                            DCT_CHROMA_DC as c_int,
                            (*(*h).dct.chroma_dc.as_mut_ptr().offset(0)).as_mut_ptr(),
                        );
                    } else {
                        x264_cabac_size_decision(cb, ctxidxinc_5 as c_long, 0 as c_long);
                    }
                    let mut ctxidxinc_6: c_int = cabac_cbf_ctxidxinc(
                        h,
                        DCT_CHROMA_DC as c_int,
                        49 as c_int + 1 as c_int,
                        b_intra,
                        1 as c_int,
                    );
                    if (*h).mb.cache.non_zero_count
                        [x264_scan8[(49 as c_int + 1 as c_int) as usize] as usize]
                        != 0
                    {
                        x264_cabac_size_decision(cb, ctxidxinc_6 as c_long, 1 as c_long);
                        cabac_block_residual(
                            h,
                            cb,
                            DCT_CHROMA_DC as c_int,
                            (*(*h).dct.chroma_dc.as_mut_ptr().offset(1)).as_mut_ptr(),
                        );
                    } else {
                        x264_cabac_size_decision(cb, ctxidxinc_6 as c_long, 0 as c_long);
                    }
                }
                if (*h).mb.i_cbp_chroma == 2 as c_int {
                    let mut step: c_int = (8 as c_int) << (*h).mb.chroma_v_shift;
                    let mut i_3: c_int = 16 as c_int;
                    while i_3 < 3 as c_int * 16 as c_int {
                        let mut j: c_int = i_3;
                        while j < i_3 + 4 as c_int {
                            let mut ctxidxinc_7: c_int = cabac_cbf_ctxidxinc(
                                h,
                                DCT_CHROMA_AC as c_int,
                                j,
                                b_intra,
                                0 as c_int,
                            );
                            if (*h).mb.cache.non_zero_count[x264_scan8[j as usize] as usize] != 0 {
                                x264_cabac_size_decision(cb, ctxidxinc_7 as c_long, 1 as c_long);
                                cabac_block_residual(
                                    h,
                                    cb,
                                    DCT_CHROMA_AC as c_int,
                                    (*(*h).dct.luma4x4.as_mut_ptr().offset(j as isize))
                                        .as_mut_ptr()
                                        .offset(1),
                                );
                            } else {
                                x264_cabac_size_decision(cb, ctxidxinc_7 as c_long, 0 as c_long);
                            }
                            j += 1;
                        }
                        i_3 += step;
                    }
                }
            }
        }
    }
    #[c2rust::src_loc = "1088:1"]
    pub unsafe extern "C" fn macroblock_size_cabac(mut h: *mut x264_t, mut cb: *mut x264_cabac_t) {
        if (*(*h).sps.as_mut_ptr()).i_chroma_format_idc == CHROMA_444 as c_int {
            macroblock_write_cabac_internal(h, cb, 3 as c_int, 0 as c_int);
        } else if (*(*h).sps.as_mut_ptr()).i_chroma_format_idc != 0 {
            macroblock_write_cabac_internal(h, cb, 1 as c_int, 1 as c_int);
        } else {
            macroblock_write_cabac_internal(h, cb, 1 as c_int, 0 as c_int);
        };
    }
    #[c2rust::src_loc = "1106:1"]
    pub unsafe extern "C" fn partition_size_cabac(
        mut h: *mut x264_t,
        mut cb: *mut x264_cabac_t,
        mut i8: c_int,
        mut i_pixel: c_int,
    ) {
        let i_mb_type: c_int = (*h).mb.i_type;
        let mut b_8x16: c_int = ((*h).mb.i_partition == D_8x16 as c_int) as c_int;
        let mut plane_count: c_int =
            if (*(*h).sps.as_mut_ptr()).i_chroma_format_idc == CHROMA_444 as c_int {
                3 as c_int
            } else {
                1 as c_int
            };
        if i_mb_type == P_8x8 as c_int {
            cabac_8x8_mvd(h, cb, i8);
            cabac_subpartition_p(cb, (*h).mb.i_sub_partition[i8 as usize] as c_int);
        } else if i_mb_type == P_L0 as c_int {
            let mut mvd: uint16_t =
                cabac_mvd(h, cb, 0 as c_int, 4 as c_int * i8, 4 as c_int >> b_8x16);
            x264_macroblock_cache_mvd(
                h,
                block_idx_x[(4 as c_int * i8) as usize] as c_int,
                block_idx_y[(4 as c_int * i8) as usize] as c_int,
                4 as c_int >> b_8x16,
                (2 as c_int) << b_8x16,
                0 as c_int,
                mvd,
            );
        } else if i_mb_type > B_DIRECT as c_int && i_mb_type < B_8x8 as c_int {
            if x264_mb_type_list_table[i_mb_type as usize][0][(i8 != 0) as c_int as usize] != 0 {
                let mut mvd_0: uint16_t =
                    cabac_mvd(h, cb, 0 as c_int, 4 as c_int * i8, 4 as c_int >> b_8x16);
                x264_macroblock_cache_mvd(
                    h,
                    block_idx_x[(4 as c_int * i8) as usize] as c_int,
                    block_idx_y[(4 as c_int * i8) as usize] as c_int,
                    4 as c_int >> b_8x16,
                    (2 as c_int) << b_8x16,
                    0 as c_int,
                    mvd_0,
                );
            }
            if x264_mb_type_list_table[i_mb_type as usize][1][(i8 != 0) as c_int as usize] != 0 {
                let mut mvd_1: uint16_t =
                    cabac_mvd(h, cb, 1 as c_int, 4 as c_int * i8, 4 as c_int >> b_8x16);
                x264_macroblock_cache_mvd(
                    h,
                    block_idx_x[(4 as c_int * i8) as usize] as c_int,
                    block_idx_y[(4 as c_int * i8) as usize] as c_int,
                    4 as c_int >> b_8x16,
                    (2 as c_int) << b_8x16,
                    1 as c_int,
                    mvd_1,
                );
            }
        } else {
            if x264_mb_partition_listX_table[0][(*h).mb.i_sub_partition[i8 as usize] as usize] != 0
            {
                let mut mvd_2: uint16_t = cabac_mvd(h, cb, 0 as c_int, 4 as c_int * i8, 2 as c_int);
                x264_macroblock_cache_mvd(
                    h,
                    block_idx_x[(4 as c_int * i8) as usize] as c_int,
                    block_idx_y[(4 as c_int * i8) as usize] as c_int,
                    2 as c_int,
                    2 as c_int,
                    0 as c_int,
                    mvd_2,
                );
            }
            if x264_mb_partition_listX_table[1][(*h).mb.i_sub_partition[i8 as usize] as usize] != 0
            {
                let mut mvd_3: uint16_t = cabac_mvd(h, cb, 1 as c_int, 4 as c_int * i8, 2 as c_int);
                x264_macroblock_cache_mvd(
                    h,
                    block_idx_x[(4 as c_int * i8) as usize] as c_int,
                    block_idx_y[(4 as c_int * i8) as usize] as c_int,
                    2 as c_int,
                    2 as c_int,
                    1 as c_int,
                    mvd_3,
                );
            }
        }
        let mut j: c_int = (i_pixel < PIXEL_8x8 as c_int) as c_int;
        while j >= 0 as c_int {
            if (*h).mb.i_cbp_luma & (1 as c_int) << i8 != 0 {
                if (*h).mb.b_transform_8x8 != 0 {
                    if (*(*h).sps.as_mut_ptr()).i_chroma_format_idc == CHROMA_444 as c_int {
                        let mut p: c_int = 0 as c_int;
                        while p < 3 as c_int {
                            let mut ctxidxinc: c_int = cabac_cbf_ctxidxinc(
                                h,
                                ctx_cat_plane[DCT_LUMA_8x8 as c_int as usize][p as usize] as c_int,
                                i8 * 4 as c_int + p * 16 as c_int,
                                0 as c_int,
                                0 as c_int,
                            );
                            if (*h).mb.cache.non_zero_count
                                [x264_scan8[(i8 * 4 as c_int + p * 16 as c_int) as usize] as usize]
                                != 0
                            {
                                x264_cabac_size_decision(cb, ctxidxinc as c_long, 1 as c_long);
                                cabac_block_residual_8x8(
                                    h,
                                    cb,
                                    ctx_cat_plane[DCT_LUMA_8x8 as c_int as usize][p as usize]
                                        as c_int,
                                    (*(*h)
                                        .dct
                                        .luma8x8
                                        .as_mut_ptr()
                                        .offset((i8 + p * 4 as c_int) as isize))
                                    .as_mut_ptr(),
                                );
                            } else {
                                x264_cabac_size_decision(cb, ctxidxinc as c_long, 0 as c_long);
                            }
                            p += 1;
                        }
                    } else {
                        cabac_block_residual_8x8(
                            h,
                            cb,
                            DCT_LUMA_8x8 as c_int,
                            (*(*h).dct.luma8x8.as_mut_ptr().offset(i8 as isize)).as_mut_ptr(),
                        );
                    }
                } else {
                    let mut p_0: c_int = 0 as c_int;
                    while p_0 < plane_count {
                        let mut i4: c_int = 0 as c_int;
                        while i4 < 4 as c_int {
                            let mut ctxidxinc_0: c_int = cabac_cbf_ctxidxinc(
                                h,
                                ctx_cat_plane[DCT_LUMA_4x4 as c_int as usize][p_0 as usize]
                                    as c_int,
                                i4 + i8 * 4 as c_int + p_0 * 16 as c_int,
                                0 as c_int,
                                0 as c_int,
                            );
                            if (*h).mb.cache.non_zero_count[x264_scan8
                                [(i4 + i8 * 4 as c_int + p_0 * 16 as c_int) as usize]
                                as usize]
                                != 0
                            {
                                x264_cabac_size_decision(cb, ctxidxinc_0 as c_long, 1 as c_long);
                                cabac_block_residual(
                                    h,
                                    cb,
                                    ctx_cat_plane[DCT_LUMA_4x4 as c_int as usize][p_0 as usize]
                                        as c_int,
                                    (*(*h).dct.luma4x4.as_mut_ptr().offset(
                                        (i4 + i8 * 4 as c_int + p_0 * 16 as c_int) as isize,
                                    ))
                                    .as_mut_ptr(),
                                );
                            } else {
                                x264_cabac_size_decision(cb, ctxidxinc_0 as c_long, 0 as c_long);
                            }
                            i4 += 1;
                        }
                        p_0 += 1;
                    }
                }
            }
            if (*h).mb.i_cbp_chroma != 0 {
                if (*(*h).sps.as_mut_ptr()).i_chroma_format_idc == CHROMA_422 as c_int {
                    let mut offset: c_int = 5 as c_int * i8 & 0x9 as c_int;
                    let mut ctxidxinc_1: c_int = cabac_cbf_ctxidxinc(
                        h,
                        DCT_CHROMA_AC as c_int,
                        16 as c_int + offset,
                        0 as c_int,
                        0 as c_int,
                    );
                    if (*h).mb.cache.non_zero_count
                        [x264_scan8[(16 as c_int + offset) as usize] as usize]
                        != 0
                    {
                        x264_cabac_size_decision(cb, ctxidxinc_1 as c_long, 1 as c_long);
                        cabac_block_residual(
                            h,
                            cb,
                            DCT_CHROMA_AC as c_int,
                            (*(*h)
                                .dct
                                .luma4x4
                                .as_mut_ptr()
                                .offset((16 as c_int + offset) as isize))
                            .as_mut_ptr()
                            .offset(1),
                        );
                    } else {
                        x264_cabac_size_decision(cb, ctxidxinc_1 as c_long, 0 as c_long);
                    }
                    let mut ctxidxinc_2: c_int = cabac_cbf_ctxidxinc(
                        h,
                        DCT_CHROMA_AC as c_int,
                        18 as c_int + offset,
                        0 as c_int,
                        0 as c_int,
                    );
                    if (*h).mb.cache.non_zero_count
                        [x264_scan8[(18 as c_int + offset) as usize] as usize]
                        != 0
                    {
                        x264_cabac_size_decision(cb, ctxidxinc_2 as c_long, 1 as c_long);
                        cabac_block_residual(
                            h,
                            cb,
                            DCT_CHROMA_AC as c_int,
                            (*(*h)
                                .dct
                                .luma4x4
                                .as_mut_ptr()
                                .offset((18 as c_int + offset) as isize))
                            .as_mut_ptr()
                            .offset(1),
                        );
                    } else {
                        x264_cabac_size_decision(cb, ctxidxinc_2 as c_long, 0 as c_long);
                    }
                    let mut ctxidxinc_3: c_int = cabac_cbf_ctxidxinc(
                        h,
                        DCT_CHROMA_AC as c_int,
                        32 as c_int + offset,
                        0 as c_int,
                        0 as c_int,
                    );
                    if (*h).mb.cache.non_zero_count
                        [x264_scan8[(32 as c_int + offset) as usize] as usize]
                        != 0
                    {
                        x264_cabac_size_decision(cb, ctxidxinc_3 as c_long, 1 as c_long);
                        cabac_block_residual(
                            h,
                            cb,
                            DCT_CHROMA_AC as c_int,
                            (*(*h)
                                .dct
                                .luma4x4
                                .as_mut_ptr()
                                .offset((32 as c_int + offset) as isize))
                            .as_mut_ptr()
                            .offset(1),
                        );
                    } else {
                        x264_cabac_size_decision(cb, ctxidxinc_3 as c_long, 0 as c_long);
                    }
                    let mut ctxidxinc_4: c_int = cabac_cbf_ctxidxinc(
                        h,
                        DCT_CHROMA_AC as c_int,
                        34 as c_int + offset,
                        0 as c_int,
                        0 as c_int,
                    );
                    if (*h).mb.cache.non_zero_count
                        [x264_scan8[(34 as c_int + offset) as usize] as usize]
                        != 0
                    {
                        x264_cabac_size_decision(cb, ctxidxinc_4 as c_long, 1 as c_long);
                        cabac_block_residual(
                            h,
                            cb,
                            DCT_CHROMA_AC as c_int,
                            (*(*h)
                                .dct
                                .luma4x4
                                .as_mut_ptr()
                                .offset((34 as c_int + offset) as isize))
                            .as_mut_ptr()
                            .offset(1),
                        );
                    } else {
                        x264_cabac_size_decision(cb, ctxidxinc_4 as c_long, 0 as c_long);
                    }
                } else {
                    let mut ctxidxinc_5: c_int = cabac_cbf_ctxidxinc(
                        h,
                        DCT_CHROMA_AC as c_int,
                        16 as c_int + i8,
                        0 as c_int,
                        0 as c_int,
                    );
                    if (*h).mb.cache.non_zero_count
                        [x264_scan8[(16 as c_int + i8) as usize] as usize]
                        != 0
                    {
                        x264_cabac_size_decision(cb, ctxidxinc_5 as c_long, 1 as c_long);
                        cabac_block_residual(
                            h,
                            cb,
                            DCT_CHROMA_AC as c_int,
                            (*(*h)
                                .dct
                                .luma4x4
                                .as_mut_ptr()
                                .offset((16 as c_int + i8) as isize))
                            .as_mut_ptr()
                            .offset(1),
                        );
                    } else {
                        x264_cabac_size_decision(cb, ctxidxinc_5 as c_long, 0 as c_long);
                    }
                    let mut ctxidxinc_6: c_int = cabac_cbf_ctxidxinc(
                        h,
                        DCT_CHROMA_AC as c_int,
                        32 as c_int + i8,
                        0 as c_int,
                        0 as c_int,
                    );
                    if (*h).mb.cache.non_zero_count
                        [x264_scan8[(32 as c_int + i8) as usize] as usize]
                        != 0
                    {
                        x264_cabac_size_decision(cb, ctxidxinc_6 as c_long, 1 as c_long);
                        cabac_block_residual(
                            h,
                            cb,
                            DCT_CHROMA_AC as c_int,
                            (*(*h)
                                .dct
                                .luma4x4
                                .as_mut_ptr()
                                .offset((32 as c_int + i8) as isize))
                            .as_mut_ptr()
                            .offset(1),
                        );
                    } else {
                        x264_cabac_size_decision(cb, ctxidxinc_6 as c_long, 0 as c_long);
                    }
                }
            }
            i8 += x264_pixel_size[i_pixel as usize].h as c_int >> 3 as c_int;
            j -= 1;
        }
    }
    #[c2rust::src_loc = "1171:1"]
    pub unsafe extern "C" fn subpartition_size_cabac(
        mut h: *mut x264_t,
        mut cb: *mut x264_cabac_t,
        mut i4: c_int,
        mut i_pixel: c_int,
    ) {
        let mut b_8x4: c_int = (i_pixel == PIXEL_8x4 as c_int) as c_int;
        let mut plane_count: c_int =
            if (*(*h).sps.as_mut_ptr()).i_chroma_format_idc == CHROMA_444 as c_int {
                3 as c_int
            } else {
                1 as c_int
            };
        if i_pixel == PIXEL_4x4 as c_int {
            let mut mvd: uint16_t = cabac_mvd(h, cb, 0 as c_int, i4, 1 as c_int);
            x264_macroblock_cache_mvd(
                h,
                block_idx_x[i4 as usize] as c_int,
                block_idx_y[i4 as usize] as c_int,
                1 as c_int,
                1 as c_int,
                0 as c_int,
                mvd,
            );
        } else {
            let mut mvd_0: uint16_t = cabac_mvd(h, cb, 0 as c_int, i4, 1 as c_int + b_8x4);
            x264_macroblock_cache_mvd(
                h,
                block_idx_x[i4 as usize] as c_int,
                block_idx_y[i4 as usize] as c_int,
                1 as c_int + b_8x4,
                2 as c_int - b_8x4,
                0 as c_int,
                mvd_0,
            );
        }
        let mut p: c_int = 0 as c_int;
        while p < plane_count {
            let mut ctxidxinc: c_int = cabac_cbf_ctxidxinc(
                h,
                ctx_cat_plane[DCT_LUMA_4x4 as c_int as usize][p as usize] as c_int,
                p * 16 as c_int + i4,
                0 as c_int,
                0 as c_int,
            );
            if (*h).mb.cache.non_zero_count[x264_scan8[(p * 16 as c_int + i4) as usize] as usize]
                != 0
            {
                x264_cabac_size_decision(cb, ctxidxinc as c_long, 1 as c_long);
                cabac_block_residual(
                    h,
                    cb,
                    ctx_cat_plane[DCT_LUMA_4x4 as c_int as usize][p as usize] as c_int,
                    (*(*h)
                        .dct
                        .luma4x4
                        .as_mut_ptr()
                        .offset((p * 16 as c_int + i4) as isize))
                    .as_mut_ptr(),
                );
            } else {
                x264_cabac_size_decision(cb, ctxidxinc as c_long, 0 as c_long);
            }
            if i_pixel != PIXEL_4x4 as c_int {
                let mut ctxidxinc_0: c_int = cabac_cbf_ctxidxinc(
                    h,
                    ctx_cat_plane[DCT_LUMA_4x4 as c_int as usize][p as usize] as c_int,
                    p * 16 as c_int + i4 + 2 as c_int - b_8x4,
                    0 as c_int,
                    0 as c_int,
                );
                if (*h).mb.cache.non_zero_count
                    [x264_scan8[(p * 16 as c_int + i4 + 2 as c_int - b_8x4) as usize] as usize]
                    != 0
                {
                    x264_cabac_size_decision(cb, ctxidxinc_0 as c_long, 1 as c_long);
                    cabac_block_residual(
                        h,
                        cb,
                        ctx_cat_plane[DCT_LUMA_4x4 as c_int as usize][p as usize] as c_int,
                        (*(*h)
                            .dct
                            .luma4x4
                            .as_mut_ptr()
                            .offset((p * 16 as c_int + i4 + 2 as c_int - b_8x4) as isize))
                        .as_mut_ptr(),
                    );
                } else {
                    x264_cabac_size_decision(cb, ctxidxinc_0 as c_long, 0 as c_long);
                }
            }
            p += 1;
        }
    }
    #[c2rust::src_loc = "1187:1"]
    pub unsafe extern "C" fn partition_i8x8_size_cabac(
        mut h: *mut x264_t,
        mut cb: *mut x264_cabac_t,
        mut i8: c_int,
        mut i_mode: c_int,
    ) {
        let i_pred: c_int = x264_mb_predict_intra4x4_mode(h, 4 as c_int * i8) as c_int;
        i_mode = x264_mb_pred_mode4x4_fix[(i_mode + 1 as c_int) as usize] as c_int;
        cabac_intra4x4_pred_mode(cb, i_pred, i_mode);
        cabac_cbp_luma(h, cb);
        if (*h).mb.i_cbp_luma & (1 as c_int) << i8 != 0 {
            if (*(*h).sps.as_mut_ptr()).i_chroma_format_idc == CHROMA_444 as c_int {
                let mut p: c_int = 0 as c_int;
                while p < 3 as c_int {
                    let mut ctxidxinc: c_int = cabac_cbf_ctxidxinc(
                        h,
                        ctx_cat_plane[DCT_LUMA_8x8 as c_int as usize][p as usize] as c_int,
                        i8 * 4 as c_int + p * 16 as c_int,
                        1 as c_int,
                        0 as c_int,
                    );
                    if (*h).mb.cache.non_zero_count
                        [x264_scan8[(i8 * 4 as c_int + p * 16 as c_int) as usize] as usize]
                        != 0
                    {
                        x264_cabac_size_decision(cb, ctxidxinc as c_long, 1 as c_long);
                        cabac_block_residual_8x8(
                            h,
                            cb,
                            ctx_cat_plane[DCT_LUMA_8x8 as c_int as usize][p as usize] as c_int,
                            (*(*h)
                                .dct
                                .luma8x8
                                .as_mut_ptr()
                                .offset((i8 + p * 4 as c_int) as isize))
                            .as_mut_ptr(),
                        );
                    } else {
                        x264_cabac_size_decision(cb, ctxidxinc as c_long, 0 as c_long);
                    }
                    p += 1;
                }
            } else {
                cabac_block_residual_8x8(
                    h,
                    cb,
                    DCT_LUMA_8x8 as c_int,
                    (*(*h).dct.luma8x8.as_mut_ptr().offset(i8 as isize)).as_mut_ptr(),
                );
            }
        }
    }
    #[c2rust::src_loc = "1203:1"]
    pub unsafe extern "C" fn partition_i4x4_size_cabac(
        mut h: *mut x264_t,
        mut cb: *mut x264_cabac_t,
        mut i4: c_int,
        mut i_mode: c_int,
    ) {
        let i_pred: c_int = x264_mb_predict_intra4x4_mode(h, i4) as c_int;
        let mut plane_count: c_int =
            if (*(*h).sps.as_mut_ptr()).i_chroma_format_idc == CHROMA_444 as c_int {
                3 as c_int
            } else {
                1 as c_int
            };
        i_mode = x264_mb_pred_mode4x4_fix[(i_mode + 1 as c_int) as usize] as c_int;
        cabac_intra4x4_pred_mode(cb, i_pred, i_mode);
        let mut p: c_int = 0 as c_int;
        while p < plane_count {
            let mut ctxidxinc: c_int = cabac_cbf_ctxidxinc(
                h,
                ctx_cat_plane[DCT_LUMA_4x4 as c_int as usize][p as usize] as c_int,
                i4 + p * 16 as c_int,
                1 as c_int,
                0 as c_int,
            );
            if (*h).mb.cache.non_zero_count[x264_scan8[(i4 + p * 16 as c_int) as usize] as usize]
                != 0
            {
                x264_cabac_size_decision(cb, ctxidxinc as c_long, 1 as c_long);
                cabac_block_residual(
                    h,
                    cb,
                    ctx_cat_plane[DCT_LUMA_4x4 as c_int as usize][p as usize] as c_int,
                    (*(*h)
                        .dct
                        .luma4x4
                        .as_mut_ptr()
                        .offset((i4 + p * 16 as c_int) as isize))
                    .as_mut_ptr(),
                );
            } else {
                x264_cabac_size_decision(cb, ctxidxinc as c_long, 0 as c_long);
            }
            p += 1;
        }
    }
    #[c2rust::src_loc = "1213:1"]
    pub unsafe extern "C" fn chroma_size_cabac(mut h: *mut x264_t, mut cb: *mut x264_cabac_t) {
        cabac_intra_chroma_pred_mode(h, cb);
        cabac_cbp_chroma(h, cb);
        if (*h).mb.i_cbp_chroma != 0 {
            if (*(*h).sps.as_mut_ptr()).i_chroma_format_idc == CHROMA_422 as c_int {
                let mut ctxidxinc: c_int = cabac_cbf_ctxidxinc(
                    h,
                    DCT_CHROMA_DC as c_int,
                    49 as c_int + 0 as c_int,
                    1 as c_int,
                    1 as c_int,
                );
                if (*h).mb.cache.non_zero_count
                    [x264_scan8[(49 as c_int + 0 as c_int) as usize] as usize]
                    != 0
                {
                    x264_cabac_size_decision(cb, ctxidxinc as c_long, 1 as c_long);
                    cabac_block_residual_422_dc(
                        h,
                        cb,
                        DCT_CHROMA_DC as c_int,
                        (*(*h).dct.chroma_dc.as_mut_ptr().offset(0)).as_mut_ptr(),
                    );
                } else {
                    x264_cabac_size_decision(cb, ctxidxinc as c_long, 0 as c_long);
                }
                let mut ctxidxinc_0: c_int = cabac_cbf_ctxidxinc(
                    h,
                    DCT_CHROMA_DC as c_int,
                    49 as c_int + 1 as c_int,
                    1 as c_int,
                    1 as c_int,
                );
                if (*h).mb.cache.non_zero_count
                    [x264_scan8[(49 as c_int + 1 as c_int) as usize] as usize]
                    != 0
                {
                    x264_cabac_size_decision(cb, ctxidxinc_0 as c_long, 1 as c_long);
                    cabac_block_residual_422_dc(
                        h,
                        cb,
                        DCT_CHROMA_DC as c_int,
                        (*(*h).dct.chroma_dc.as_mut_ptr().offset(1)).as_mut_ptr(),
                    );
                } else {
                    x264_cabac_size_decision(cb, ctxidxinc_0 as c_long, 0 as c_long);
                }
            } else {
                let mut ctxidxinc_1: c_int = cabac_cbf_ctxidxinc(
                    h,
                    DCT_CHROMA_DC as c_int,
                    49 as c_int + 0 as c_int,
                    1 as c_int,
                    1 as c_int,
                );
                if (*h).mb.cache.non_zero_count
                    [x264_scan8[(49 as c_int + 0 as c_int) as usize] as usize]
                    != 0
                {
                    x264_cabac_size_decision(cb, ctxidxinc_1 as c_long, 1 as c_long);
                    cabac_block_residual(
                        h,
                        cb,
                        DCT_CHROMA_DC as c_int,
                        (*(*h).dct.chroma_dc.as_mut_ptr().offset(0)).as_mut_ptr(),
                    );
                } else {
                    x264_cabac_size_decision(cb, ctxidxinc_1 as c_long, 0 as c_long);
                }
                let mut ctxidxinc_2: c_int = cabac_cbf_ctxidxinc(
                    h,
                    DCT_CHROMA_DC as c_int,
                    49 as c_int + 1 as c_int,
                    1 as c_int,
                    1 as c_int,
                );
                if (*h).mb.cache.non_zero_count
                    [x264_scan8[(49 as c_int + 1 as c_int) as usize] as usize]
                    != 0
                {
                    x264_cabac_size_decision(cb, ctxidxinc_2 as c_long, 1 as c_long);
                    cabac_block_residual(
                        h,
                        cb,
                        DCT_CHROMA_DC as c_int,
                        (*(*h).dct.chroma_dc.as_mut_ptr().offset(1)).as_mut_ptr(),
                    );
                } else {
                    x264_cabac_size_decision(cb, ctxidxinc_2 as c_long, 0 as c_long);
                }
            }
            if (*h).mb.i_cbp_chroma == 2 as c_int {
                let mut step: c_int = (8 as c_int) << (*h).mb.chroma_v_shift;
                let mut i: c_int = 16 as c_int;
                while i < 3 as c_int * 16 as c_int {
                    let mut j: c_int = i;
                    while j < i + 4 as c_int {
                        let mut ctxidxinc_3: c_int = cabac_cbf_ctxidxinc(
                            h,
                            DCT_CHROMA_AC as c_int,
                            j,
                            1 as c_int,
                            0 as c_int,
                        );
                        if (*h).mb.cache.non_zero_count[x264_scan8[j as usize] as usize] != 0 {
                            x264_cabac_size_decision(cb, ctxidxinc_3 as c_long, 1 as c_long);
                            cabac_block_residual(
                                h,
                                cb,
                                DCT_CHROMA_AC as c_int,
                                (*(*h).dct.luma4x4.as_mut_ptr().offset(j as isize))
                                    .as_mut_ptr()
                                    .offset(1),
                            );
                        } else {
                            x264_cabac_size_decision(cb, ctxidxinc_3 as c_long, 0 as c_long);
                        }
                        j += 1;
                    }
                    i += step;
                }
            }
        }
    }
    use ::core::ffi::{c_char, c_int, c_long, c_uint};

    use super::assert_h::__assert_fail;
    use super::base_h::{
        x264_cabac_mvd_sum, x264_scan8, x264_union32_t, CHROMA_422, CHROMA_444, LUMA_DC,
        SLICE_TYPE_B, SLICE_TYPE_I, SLICE_TYPE_P,
    };
    use super::bitstream_h::bs_size_ue_big;
    use super::cabac_h::{x264_cabac_size_decision, x264_cabac_size_decision_noup, x264_cabac_t};
    use super::common_h::{dctcoef, x264_t, QP_MAX_SPEC};
    use super::macroblock_h::{
        block_idx_x, block_idx_y, ctx_cat_plane, pack8to16, x264_10_mb_predict_mv,
        x264_mb_partition_listX_table, x264_mb_predict_intra4x4_mode,
        x264_mb_transform_8x8_allowed, x264_mb_type_list_table, B_8x8, DCT_LUMA_4x4, DCT_LUMA_8x8,
        D_16x16, D_16x8, D_8x16, D_BI_8x8, D_DIRECT_8x8, D_L0_4x8, D_L0_8x4, D_L0_8x8, D_L1_8x8,
        I_16x16, I_4x4, I_8x8, P_8x8, B_BI_BI, B_DIRECT, B_L0_L0, B_SKIP, DCT_CHROMA_AC,
        DCT_CHROMA_DC, DCT_LUMA_AC, DCT_LUMA_DC, I_PCM, MB_LEFT, MB_TOP, P_L0,
    };
    use super::osdep_h::x264_ctz_4bit;
    use super::pixel_h::{x264_pixel_size, PIXEL_4x4, PIXEL_8x4, PIXEL_8x8};
    use super::predict_h::{
        x264_mb_chroma_pred_mode_fix, x264_mb_pred_mode16x16_fix, x264_mb_pred_mode4x4_fix,
    };
    use super::rdo_c::{
        cabac_size_5ones, cabac_transition_5ones, x264_10_cabac_size_unary,
        x264_10_cabac_transition_unary,
    };
    use super::rectangle_h::x264_macroblock_cache_mvd;
    use super::stdint_intn_h::{int16_t, int8_t};
    use super::stdint_uintn_h::{uint16_t, uint32_t, uint8_t};
    use super::stdlib_h::abs;
    use super::tables_h::{
        x264_coeff_abs_level_m1_offset, x264_coeff_flag_offset_chroma_422_dc, x264_count_cat_m1,
        x264_last_coeff_flag_offset, x264_last_coeff_flag_offset_8x8,
        x264_significant_coeff_flag_offset, x264_significant_coeff_flag_offset_8x8,
    };
}
#[c2rust::header_src = "/home/nwplayer123/Hacks/hex264/x264/encoder/cavlc.c:28"]
pub mod cavlc_c {
    #[c2rust::src_loc = "36:22"]
    pub static mut cbp_to_golomb: [[[uint8_t; 48]; 2]; 2] = [
        [
            [
                0 as c_int as uint8_t,
                1 as c_int as uint8_t,
                2 as c_int as uint8_t,
                5 as c_int as uint8_t,
                3 as c_int as uint8_t,
                6 as c_int as uint8_t,
                14 as c_int as uint8_t,
                10 as c_int as uint8_t,
                4 as c_int as uint8_t,
                15 as c_int as uint8_t,
                7 as c_int as uint8_t,
                11 as c_int as uint8_t,
                8 as c_int as uint8_t,
                12 as c_int as uint8_t,
                13 as c_int as uint8_t,
                9 as c_int as uint8_t,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
            ],
            [
                1 as c_int as uint8_t,
                10 as c_int as uint8_t,
                11 as c_int as uint8_t,
                6 as c_int as uint8_t,
                12 as c_int as uint8_t,
                7 as c_int as uint8_t,
                14 as c_int as uint8_t,
                2 as c_int as uint8_t,
                13 as c_int as uint8_t,
                15 as c_int as uint8_t,
                8 as c_int as uint8_t,
                3 as c_int as uint8_t,
                9 as c_int as uint8_t,
                4 as c_int as uint8_t,
                5 as c_int as uint8_t,
                0 as c_int as uint8_t,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
            ],
        ],
        [
            [
                0 as c_int as uint8_t,
                2 as c_int as uint8_t,
                3 as c_int as uint8_t,
                7 as c_int as uint8_t,
                4 as c_int as uint8_t,
                8 as c_int as uint8_t,
                17 as c_int as uint8_t,
                13 as c_int as uint8_t,
                5 as c_int as uint8_t,
                18 as c_int as uint8_t,
                9 as c_int as uint8_t,
                14 as c_int as uint8_t,
                10 as c_int as uint8_t,
                15 as c_int as uint8_t,
                16 as c_int as uint8_t,
                11 as c_int as uint8_t,
                1 as c_int as uint8_t,
                32 as c_int as uint8_t,
                33 as c_int as uint8_t,
                36 as c_int as uint8_t,
                34 as c_int as uint8_t,
                37 as c_int as uint8_t,
                44 as c_int as uint8_t,
                40 as c_int as uint8_t,
                35 as c_int as uint8_t,
                45 as c_int as uint8_t,
                38 as c_int as uint8_t,
                41 as c_int as uint8_t,
                39 as c_int as uint8_t,
                42 as c_int as uint8_t,
                43 as c_int as uint8_t,
                19 as c_int as uint8_t,
                6 as c_int as uint8_t,
                24 as c_int as uint8_t,
                25 as c_int as uint8_t,
                20 as c_int as uint8_t,
                26 as c_int as uint8_t,
                21 as c_int as uint8_t,
                46 as c_int as uint8_t,
                28 as c_int as uint8_t,
                27 as c_int as uint8_t,
                47 as c_int as uint8_t,
                22 as c_int as uint8_t,
                29 as c_int as uint8_t,
                23 as c_int as uint8_t,
                30 as c_int as uint8_t,
                31 as c_int as uint8_t,
                12 as c_int as uint8_t,
            ],
            [
                3 as c_int as uint8_t,
                29 as c_int as uint8_t,
                30 as c_int as uint8_t,
                17 as c_int as uint8_t,
                31 as c_int as uint8_t,
                18 as c_int as uint8_t,
                37 as c_int as uint8_t,
                8 as c_int as uint8_t,
                32 as c_int as uint8_t,
                38 as c_int as uint8_t,
                19 as c_int as uint8_t,
                9 as c_int as uint8_t,
                20 as c_int as uint8_t,
                10 as c_int as uint8_t,
                11 as c_int as uint8_t,
                2 as c_int as uint8_t,
                16 as c_int as uint8_t,
                33 as c_int as uint8_t,
                34 as c_int as uint8_t,
                21 as c_int as uint8_t,
                35 as c_int as uint8_t,
                22 as c_int as uint8_t,
                39 as c_int as uint8_t,
                4 as c_int as uint8_t,
                36 as c_int as uint8_t,
                40 as c_int as uint8_t,
                23 as c_int as uint8_t,
                5 as c_int as uint8_t,
                24 as c_int as uint8_t,
                6 as c_int as uint8_t,
                7 as c_int as uint8_t,
                1 as c_int as uint8_t,
                41 as c_int as uint8_t,
                42 as c_int as uint8_t,
                43 as c_int as uint8_t,
                25 as c_int as uint8_t,
                44 as c_int as uint8_t,
                26 as c_int as uint8_t,
                46 as c_int as uint8_t,
                12 as c_int as uint8_t,
                45 as c_int as uint8_t,
                47 as c_int as uint8_t,
                27 as c_int as uint8_t,
                13 as c_int as uint8_t,
                28 as c_int as uint8_t,
                14 as c_int as uint8_t,
                15 as c_int as uint8_t,
                0 as c_int as uint8_t,
            ],
        ],
    ];
    #[c2rust::src_loc = "48:22"]
    pub static mut mb_type_b_to_golomb: [[uint8_t; 9]; 3] = [
        [
            4 as c_int as uint8_t,
            8 as c_int as uint8_t,
            12 as c_int as uint8_t,
            10 as c_int as uint8_t,
            6 as c_int as uint8_t,
            14 as c_int as uint8_t,
            16 as c_int as uint8_t,
            18 as c_int as uint8_t,
            20 as c_int as uint8_t,
        ],
        [
            5 as c_int as uint8_t,
            9 as c_int as uint8_t,
            13 as c_int as uint8_t,
            11 as c_int as uint8_t,
            7 as c_int as uint8_t,
            15 as c_int as uint8_t,
            17 as c_int as uint8_t,
            19 as c_int as uint8_t,
            21 as c_int as uint8_t,
        ],
        [
            1 as c_int as uint8_t,
            u8::MAX,
            u8::MAX,
            u8::MAX,
            2 as c_int as uint8_t,
            u8::MAX,
            u8::MAX,
            u8::MAX,
            3 as c_int as uint8_t,
        ],
    ];
    #[c2rust::src_loc = "55:22"]
    pub static mut subpartition_p_to_golomb: [uint8_t; 4] = [
        3 as c_int as uint8_t,
        1 as c_int as uint8_t,
        2 as c_int as uint8_t,
        0 as c_int as uint8_t,
    ];
    #[c2rust::src_loc = "60:22"]
    pub static mut subpartition_b_to_golomb: [uint8_t; 13] = [
        10 as c_int as uint8_t,
        4 as c_int as uint8_t,
        5 as c_int as uint8_t,
        1 as c_int as uint8_t,
        11 as c_int as uint8_t,
        6 as c_int as uint8_t,
        7 as c_int as uint8_t,
        2 as c_int as uint8_t,
        12 as c_int as uint8_t,
        8 as c_int as uint8_t,
        9 as c_int as uint8_t,
        3 as c_int as uint8_t,
        0 as c_int as uint8_t,
    ];
    #[inline]
    #[c2rust::src_loc = "70:1"]
    pub unsafe extern "C" fn cavlc_block_residual_escape(
        mut h: *mut x264_t,
        mut i_suffix_length: c_int,
        mut level: c_int,
    ) -> c_int {
        let mut s: *mut bs_t = &mut (*h).out.bs;
        pub static mut next_suffix: [uint16_t; 7] = [
            0 as c_int as uint16_t,
            3 as c_int as uint16_t,
            6 as c_int as uint16_t,
            12 as c_int as uint16_t,
            24 as c_int as uint16_t,
            48 as c_int as uint16_t,
            0xffff as c_int as uint16_t,
        ];
        let mut i_level_prefix: c_int = 15 as c_int;
        let mut mask: c_int = level >> 31 as c_int;
        let mut abs_level: c_int = (level ^ mask) - mask;
        let mut i_level_code: c_int = abs_level * 2 as c_int - mask - 2 as c_int;
        if i_level_code >> i_suffix_length < 15 as c_int {
            (*s).i_bits_encoded += (i_level_code >> i_suffix_length) + 1 as c_int + i_suffix_length;
        } else {
            i_level_code -= (15 as c_int) << i_suffix_length;
            if i_suffix_length == 0 as c_int {
                i_level_code -= 15 as c_int;
            }
            if i_level_code >= (1 as c_int) << 12 as c_int {
                if (*(*h).sps.as_mut_ptr()).i_profile_idc >= PROFILE_HIGH as c_int {
                    while i_level_code >= (1 as c_int) << i_level_prefix - 3 as c_int {
                        i_level_code -= (1 as c_int) << i_level_prefix - 3 as c_int;
                        i_level_prefix += 1;
                    }
                } else {
                    (*s).i_bits_encoded += 2000 as c_int;
                }
            }
            (*s).i_bits_encoded += i_level_prefix + 1 as c_int;
            (*s).i_bits_encoded += i_level_prefix - 3 as c_int;
        }
        if i_suffix_length == 0 as c_int {
            i_suffix_length += 1;
        }
        if abs_level > next_suffix[i_suffix_length as usize] as c_int {
            i_suffix_length += 1;
        }
        return i_suffix_length;
    }
    #[c2rust::src_loc = "121:1"]
    pub unsafe extern "C" fn cavlc_block_residual_internal(
        mut h: *mut x264_t,
        mut ctx_block_cat: c_int,
        mut l: *mut dctcoef,
        mut nC: c_int,
    ) -> c_int {
        let mut s: *mut bs_t = &mut (*h).out.bs;
        pub static mut ctz_index: [uint8_t; 8] = [
            3 as c_int as uint8_t,
            0 as c_int as uint8_t,
            1 as c_int as uint8_t,
            0 as c_int as uint8_t,
            2 as c_int as uint8_t,
            0 as c_int as uint8_t,
            1 as c_int as uint8_t,
            0 as c_int as uint8_t,
        ];
        pub static mut count_cat: [uint8_t; 14] = [
            16 as c_int as uint8_t,
            15 as c_int as uint8_t,
            16 as c_int as uint8_t,
            0 as c_int as uint8_t,
            15 as c_int as uint8_t,
            64 as c_int as uint8_t,
            16 as c_int as uint8_t,
            15 as c_int as uint8_t,
            16 as c_int as uint8_t,
            64 as c_int as uint8_t,
            16 as c_int as uint8_t,
            15 as c_int as uint8_t,
            16 as c_int as uint8_t,
            64 as c_int as uint8_t,
        ];
        let mut runlevel: x264_run_level_t = x264_run_level_t {
            last: 0,
            mask: 0,
            level: [0; 18],
        };
        let mut i_total: c_int = 0;
        let mut i_trailing: c_int = 0;
        let mut i_total_zero: c_int = 0;
        let mut i_suffix_length: c_int = 0;
        let mut i_sign: c_uint = 0;
        i_total = (*h).quantf.coeff_level_run[ctx_block_cat as usize]
            .expect("non-null function pointer")(l, &mut runlevel);
        &mut *x264_10_run_before
            .as_mut_ptr()
            .offset(runlevel.mask as isize) as *mut uint32_t;
        i_total_zero = (runlevel.last + 1 as int32_t - i_total as int32_t) as c_int;
        runlevel.level[(i_total + 0 as c_int) as usize] = 2 as c_int as dctcoef;
        runlevel.level[(i_total + 1 as c_int) as usize] = 2 as c_int as dctcoef;
        i_trailing = ((runlevel.level[0] + 1 as dctcoef | 1 as dctcoef - runlevel.level[0])
            >> 31 as c_int
            & 1 as dctcoef
            | (runlevel.level[1] + 1 as dctcoef | 1 as dctcoef - runlevel.level[1]) >> 31 as c_int
                & 2 as dctcoef
            | (runlevel.level[2] + 1 as dctcoef | 1 as dctcoef - runlevel.level[2]) >> 31 as c_int
                & 4 as dctcoef) as c_int;
        i_trailing = ctz_index[i_trailing as usize] as c_int;
        i_sign = (runlevel.level[2] >> 31 as c_int & 1 as dctcoef
            | runlevel.level[1] >> 31 as c_int & 2 as dctcoef
            | runlevel.level[0] >> 31 as c_int & 4 as dctcoef) as c_uint;
        i_sign >>= 3 as c_int - i_trailing;
        (*s).i_bits_encoded += x264_coeff_token[nC as usize][(i_total - 1 as c_int) as usize]
            [i_trailing as usize]
            .i_size as c_int;
        i_suffix_length = (i_total > 10 as c_int && i_trailing < 3 as c_int) as c_int;
        (*s).i_bits_encoded += i_trailing;
        if i_trailing < i_total {
            let mut val: c_int = runlevel.level[i_trailing as usize];
            let mut val_original: c_int =
                runlevel.level[i_trailing as usize] + LEVEL_TABLE_SIZE / 2 as c_int;
            val -= (val >> 31 as c_int | 1 as c_int) & -((i_trailing < 3 as c_int) as c_int);
            val += LEVEL_TABLE_SIZE / 2 as c_int;
            if (val_original as c_uint) < LEVEL_TABLE_SIZE as c_uint {
                (*s).i_bits_encoded +=
                    x264_10_level_token[i_suffix_length as usize][val as usize].i_size as c_int;
                i_suffix_length = x264_10_level_token[i_suffix_length as usize]
                    [val_original as usize]
                    .i_next as c_int;
            } else {
                i_suffix_length = cavlc_block_residual_escape(
                    h,
                    i_suffix_length,
                    val - LEVEL_TABLE_SIZE / 2 as c_int,
                );
            }
            let mut i: c_int = i_trailing + 1 as c_int;
            while i < i_total {
                val = (runlevel.level[i as usize] + LEVEL_TABLE_SIZE as dctcoef / 2 as dctcoef)
                    as c_int;
                if (val as c_uint) < LEVEL_TABLE_SIZE as c_uint {
                    (*s).i_bits_encoded +=
                        x264_10_level_token[i_suffix_length as usize][val as usize].i_size as c_int;
                    i_suffix_length =
                        x264_10_level_token[i_suffix_length as usize][val as usize].i_next as c_int;
                } else {
                    i_suffix_length = cavlc_block_residual_escape(
                        h,
                        i_suffix_length,
                        val - LEVEL_TABLE_SIZE / 2 as c_int,
                    );
                }
                i += 1;
            }
        }
        if ctx_block_cat == DCT_CHROMA_DC as c_int {
            if i_total < 8 as c_int >> (*h).mb.chroma_v_shift {
                let mut total_zeros: vlc_t = if (*(*h).sps.as_mut_ptr()).i_chroma_format_idc
                    == CHROMA_420 as c_int
                {
                    x264_total_zeros_2x2_dc[(i_total - 1 as c_int) as usize][i_total_zero as usize]
                } else {
                    x264_total_zeros_2x4_dc[(i_total - 1 as c_int) as usize][i_total_zero as usize]
                };
                (*s).i_bits_encoded += total_zeros.i_size as c_int;
            }
        } else if (i_total as uint8_t as c_int) < count_cat[ctx_block_cat as usize] as c_int {
            (*s).i_bits_encoded += x264_total_zeros[(i_total - 1 as c_int) as usize]
                [i_total_zero as usize]
                .i_size as c_int;
        }
        let mut zero_run_code: c_int = x264_10_run_before[runlevel.mask as usize] as c_int;
        (*s).i_bits_encoded += zero_run_code & 0x1f as c_int;
        return i_total;
    }
    #[c2rust::src_loc = "198:22"]
    pub static mut ct_index: [uint8_t; 17] = [
        0 as c_int as uint8_t,
        0 as c_int as uint8_t,
        1 as c_int as uint8_t,
        1 as c_int as uint8_t,
        2 as c_int as uint8_t,
        2 as c_int as uint8_t,
        2 as c_int as uint8_t,
        2 as c_int as uint8_t,
        3 as c_int as uint8_t,
        3 as c_int as uint8_t,
        3 as c_int as uint8_t,
        3 as c_int as uint8_t,
        3 as c_int as uint8_t,
        3 as c_int as uint8_t,
        3 as c_int as uint8_t,
        3 as c_int as uint8_t,
        3 as c_int as uint8_t,
    ];
    #[c2rust::src_loc = "211:1"]
    pub unsafe extern "C" fn cavlc_qp_delta(mut h: *mut x264_t) {
        let mut s: *mut bs_t = &mut (*h).out.bs;
        let mut i_dqp: c_int = (*h).mb.i_qp - (*h).mb.i_last_qp;
        if (*h).mb.i_type == I_16x16 as c_int
            && (*h).mb.i_cbp_luma | (*h).mb.i_cbp_chroma == 0
            && (*h).mb.cache.non_zero_count[x264_scan8[LUMA_DC as usize] as usize] == 0
            && (*h).mb.cache.non_zero_count[x264_scan8[(CHROMA_DC + 0 as c_int) as usize] as usize]
                == 0
            && (*h).mb.cache.non_zero_count[x264_scan8[(CHROMA_DC + 1 as c_int) as usize] as usize]
                == 0
            && (*h).mb.i_qp > (*h).mb.i_last_qp
        {
            i_dqp = 0 as c_int;
        }
        if i_dqp != 0 {
            if i_dqp < -(QP_MAX_SPEC + 1 as c_int) / 2 as c_int {
                i_dqp += QP_MAX_SPEC + 1 as c_int;
            } else if i_dqp > QP_MAX_SPEC / 2 as c_int {
                i_dqp -= QP_MAX_SPEC + 1 as c_int;
            }
        }
        (*s).i_bits_encoded += bs_size_se(i_dqp);
    }
    #[c2rust::src_loc = "241:1"]
    pub unsafe extern "C" fn cavlc_mvd(
        mut h: *mut x264_t,
        mut i_list: c_int,
        mut idx: c_int,
        mut width: c_int,
    ) {
        let mut s: *mut bs_t = &mut (*h).out.bs;
        let mut mvp: [int16_t; 2] = [0; 2];
        x264_10_mb_predict_mv(h, i_list, idx, width, mvp.as_mut_ptr());
        (*s).i_bits_encoded += bs_size_se(
            (*h).mb.cache.mv[i_list as usize][x264_scan8[idx as usize] as usize][0] as c_int
                - mvp[0] as c_int,
        );
        (*s).i_bits_encoded += bs_size_se(
            (*h).mb.cache.mv[i_list as usize][x264_scan8[idx as usize] as usize][1] as c_int
                - mvp[1] as c_int,
        );
    }
    #[inline]
    #[c2rust::src_loc = "250:1"]
    pub unsafe extern "C" fn cavlc_8x8_mvd(mut h: *mut x264_t, mut i: c_int) {
        match (*h).mb.i_sub_partition[i as usize] as c_int {
            3 => {
                cavlc_mvd(h, 0 as c_int, 4 as c_int * i, 2 as c_int);
            }
            1 => {
                cavlc_mvd(h, 0 as c_int, 4 as c_int * i + 0 as c_int, 2 as c_int);
                cavlc_mvd(h, 0 as c_int, 4 as c_int * i + 2 as c_int, 2 as c_int);
            }
            2 => {
                cavlc_mvd(h, 0 as c_int, 4 as c_int * i + 0 as c_int, 1 as c_int);
                cavlc_mvd(h, 0 as c_int, 4 as c_int * i + 1 as c_int, 1 as c_int);
            }
            0 => {
                cavlc_mvd(h, 0 as c_int, 4 as c_int * i + 0 as c_int, 1 as c_int);
                cavlc_mvd(h, 0 as c_int, 4 as c_int * i + 1 as c_int, 1 as c_int);
                cavlc_mvd(h, 0 as c_int, 4 as c_int * i + 2 as c_int, 1 as c_int);
                cavlc_mvd(h, 0 as c_int, 4 as c_int * i + 3 as c_int, 1 as c_int);
            }
            _ => {}
        };
    }
    #[inline(always)]
    #[c2rust::src_loc = "274:1"]
    pub unsafe extern "C" fn cavlc_macroblock_luma_residual(
        mut h: *mut x264_t,
        mut plane_count: c_int,
    ) {
        if (*h).mb.b_transform_8x8 != 0 {
            let mut p: c_int = 0 as c_int;
            while p < plane_count {
                let mut i8: c_int = 0 as c_int;
                while i8 < 4 as c_int {
                    if (*h).mb.cache.non_zero_count
                        [x264_scan8[(p * 16 as c_int + i8 * 4 as c_int) as usize] as usize]
                        != 0
                    {
                        (*h).zigzagf
                            .interleave_8x8_cavlc
                            .expect("non-null function pointer")(
                            (*(*h)
                                .dct
                                .luma4x4
                                .as_mut_ptr()
                                .offset((p * 16 as c_int + i8 * 4 as c_int) as isize))
                            .as_mut_ptr(),
                            (*(*h)
                                .dct
                                .luma8x8
                                .as_mut_ptr()
                                .offset((p * 4 as c_int + i8) as isize))
                            .as_mut_ptr(),
                            &mut *(*h).mb.cache.non_zero_count.as_mut_ptr().offset(
                                *x264_scan8
                                    .as_ptr()
                                    .offset((p * 16 as c_int + i8 * 4 as c_int) as isize)
                                    as isize,
                            ),
                        );
                    }
                    i8 += 1;
                }
                p += 1;
            }
        }
        let mut p_0: c_int = 0 as c_int;
        while p_0 < plane_count {
            let mut i8_0: c_int = 0 as c_int;
            let mut msk: c_int = (*h).mb.i_cbp_luma;
            let mut skip: c_int = 0;
            while msk != 0 && {
                skip = x264_ctz_4bit(msk as uint32_t);
                i8_0 += skip;
                msk >>= skip + 1 as c_int;
                1 as c_int != 0
            } {
                let mut i4: c_int = 0 as c_int;
                while i4 < 4 as c_int {
                    let mut nC: c_int = if DCT_LUMA_4x4 as c_int == DCT_CHROMA_DC as c_int {
                        5 as c_int - (*h).mb.chroma_v_shift
                    } else {
                        ct_index[x264_mb_predict_non_zero_code(
                            h,
                            if DCT_LUMA_4x4 as c_int == DCT_LUMA_DC as c_int {
                                (i4 + i8_0 * 4 as c_int + p_0 * 16 as c_int - LUMA_DC) * 16 as c_int
                            } else {
                                i4 + i8_0 * 4 as c_int + p_0 * 16 as c_int
                            },
                        ) as usize] as c_int
                    };
                    let mut nnz: *mut uint8_t =
                        &mut *(*h).mb.cache.non_zero_count.as_mut_ptr().offset(
                            *x264_scan8
                                .as_ptr()
                                .offset((i4 + i8_0 * 4 as c_int + p_0 * 16 as c_int) as isize)
                                as isize,
                        ) as *mut uint8_t;
                    if *nnz == 0 {
                        (*h).out.bs.i_bits_encoded +=
                            x264_coeff0_token[nC as usize].i_size as c_int;
                    } else {
                        *nnz = cavlc_block_residual_internal(
                            h,
                            DCT_LUMA_4x4 as c_int,
                            (*(*h)
                                .dct
                                .luma4x4
                                .as_mut_ptr()
                                .offset((i4 + i8_0 * 4 as c_int + p_0 * 16 as c_int) as isize))
                            .as_mut_ptr(),
                            nC,
                        ) as uint8_t;
                    }
                    i4 += 1;
                }
                i8_0 += 1;
            }
            p_0 += 1;
        }
    }
    #[inline(always)]
    #[c2rust::src_loc = "293:1"]
    pub unsafe extern "C" fn cavlc_partition_luma_residual(
        mut h: *mut x264_t,
        mut i8: c_int,
        mut p: c_int,
    ) {
        if (*h).mb.b_transform_8x8 != 0
            && (*h).mb.cache.non_zero_count
                [x264_scan8[(i8 * 4 as c_int + p * 16 as c_int) as usize] as usize]
                as c_int
                != 0
        {
            (*h).zigzagf
                .interleave_8x8_cavlc
                .expect("non-null function pointer")(
                (*(*h)
                    .dct
                    .luma4x4
                    .as_mut_ptr()
                    .offset((i8 * 4 as c_int + p * 16 as c_int) as isize))
                .as_mut_ptr(),
                (*(*h)
                    .dct
                    .luma8x8
                    .as_mut_ptr()
                    .offset((i8 + p * 4 as c_int) as isize))
                .as_mut_ptr(),
                &mut *(*h).mb.cache.non_zero_count.as_mut_ptr().offset(
                    *x264_scan8
                        .as_ptr()
                        .offset((i8 * 4 as c_int + p * 16 as c_int) as isize)
                        as isize,
                ),
            );
        }
        if (*h).mb.i_cbp_luma & (1 as c_int) << i8 != 0 {
            let mut i4: c_int = 0 as c_int;
            while i4 < 4 as c_int {
                let mut nC: c_int = if DCT_LUMA_4x4 as c_int == DCT_CHROMA_DC as c_int {
                    5 as c_int - (*h).mb.chroma_v_shift
                } else {
                    ct_index[x264_mb_predict_non_zero_code(
                        h,
                        if DCT_LUMA_4x4 as c_int == DCT_LUMA_DC as c_int {
                            (i4 + i8 * 4 as c_int + p * 16 as c_int - LUMA_DC) * 16 as c_int
                        } else {
                            i4 + i8 * 4 as c_int + p * 16 as c_int
                        },
                    ) as usize] as c_int
                };
                let mut nnz: *mut uint8_t = &mut *(*h).mb.cache.non_zero_count.as_mut_ptr().offset(
                    *x264_scan8
                        .as_ptr()
                        .offset((i4 + i8 * 4 as c_int + p * 16 as c_int) as isize)
                        as isize,
                ) as *mut uint8_t;
                if *nnz == 0 {
                    (*h).out.bs.i_bits_encoded += x264_coeff0_token[nC as usize].i_size as c_int;
                } else {
                    *nnz = cavlc_block_residual_internal(
                        h,
                        DCT_LUMA_4x4 as c_int,
                        (*(*h)
                            .dct
                            .luma4x4
                            .as_mut_ptr()
                            .offset((i4 + i8 * 4 as c_int + p * 16 as c_int) as isize))
                        .as_mut_ptr(),
                        nC,
                    ) as uint8_t;
                }
                i4 += 1;
            }
        }
    }
    #[c2rust::src_loc = "305:1"]
    pub unsafe extern "C" fn cavlc_mb_header_i(
        mut h: *mut x264_t,
        mut i_mb_type: c_int,
        mut i_mb_i_offset: c_int,
        mut chroma: c_int,
    ) {
        let mut s: *mut bs_t = &mut (*h).out.bs;
        if i_mb_type == I_16x16 as c_int {
            (*s).i_bits_encoded += bs_size_ue(
                (i_mb_i_offset
                    + 1 as c_int
                    + x264_mb_pred_mode16x16_fix[(*h).mb.i_intra16x16_pred_mode as usize] as c_int
                    + (*h).mb.i_cbp_chroma * 4 as c_int
                    + (if (*h).mb.i_cbp_luma == 0 as c_int {
                        0 as c_int
                    } else {
                        12 as c_int
                    })) as c_uint,
            );
        } else {
            let mut di: c_int = if i_mb_type == I_8x8 as c_int {
                4 as c_int
            } else {
                1 as c_int
            };
            (*s).i_bits_encoded += bs_size_ue((i_mb_i_offset + 0 as c_int) as c_uint);
            if (*(*h).pps.as_mut_ptr()).b_transform_8x8_mode != 0 {
                (*s).i_bits_encoded += 1 as c_int;
            }
            let mut i: c_int = 0 as c_int;
            while i < 16 as c_int {
                let mut i_pred: c_int = x264_mb_predict_intra4x4_mode(h, i);
                let mut i_mode: c_int = x264_mb_pred_mode4x4_fix[((*h).mb.cache.intra4x4_pred_mode
                    [x264_scan8[i as usize] as usize]
                    as c_int
                    + 1 as c_int)
                    as usize] as c_int;
                if i_pred == i_mode {
                    (*s).i_bits_encoded += 1 as c_int;
                } else {
                    (*s).i_bits_encoded += 4 as c_int;
                }
                i += di;
            }
        }
        if chroma != 0 {
            (*s).i_bits_encoded += bs_size_ue(
                x264_mb_chroma_pred_mode_fix[(*h).mb.i_chroma_pred_mode as usize] as c_uint,
            );
        }
    }
    #[inline(always)]
    #[c2rust::src_loc = "337:1"]
    pub unsafe extern "C" fn cavlc_mb_header_p(
        mut h: *mut x264_t,
        mut i_mb_type: c_int,
        mut chroma: c_int,
    ) {
        let mut s: *mut bs_t = &mut (*h).out.bs;
        if i_mb_type == P_L0 as c_int {
            if (*h).mb.i_partition == D_16x16 as c_int {
                (*s).i_bits_encoded += 1 as c_int;
                if (*h).mb.pic.i_fref[0] > 1 as c_int {
                    (*s).i_bits_encoded += bs_size_te(
                        (*h).mb.pic.i_fref[0] - 1 as c_int,
                        (*h).mb.cache.ref_0[0][x264_scan8[0] as usize] as c_int,
                    );
                }
                cavlc_mvd(h, 0 as c_int, 0 as c_int, 4 as c_int);
            } else if (*h).mb.i_partition == D_16x8 as c_int {
                (*s).i_bits_encoded += bs_size_ue(1 as c_uint);
                if (*h).mb.pic.i_fref[0] > 1 as c_int {
                    (*s).i_bits_encoded += bs_size_te(
                        (*h).mb.pic.i_fref[0] - 1 as c_int,
                        (*h).mb.cache.ref_0[0][x264_scan8[0] as usize] as c_int,
                    );
                    (*s).i_bits_encoded += bs_size_te(
                        (*h).mb.pic.i_fref[0] - 1 as c_int,
                        (*h).mb.cache.ref_0[0][x264_scan8[8] as usize] as c_int,
                    );
                }
                cavlc_mvd(h, 0 as c_int, 0 as c_int, 4 as c_int);
                cavlc_mvd(h, 0 as c_int, 8 as c_int, 4 as c_int);
            } else if (*h).mb.i_partition == D_8x16 as c_int {
                (*s).i_bits_encoded += bs_size_ue(2 as c_uint);
                if (*h).mb.pic.i_fref[0] > 1 as c_int {
                    (*s).i_bits_encoded += bs_size_te(
                        (*h).mb.pic.i_fref[0] - 1 as c_int,
                        (*h).mb.cache.ref_0[0][x264_scan8[0] as usize] as c_int,
                    );
                    (*s).i_bits_encoded += bs_size_te(
                        (*h).mb.pic.i_fref[0] - 1 as c_int,
                        (*h).mb.cache.ref_0[0][x264_scan8[4] as usize] as c_int,
                    );
                }
                cavlc_mvd(h, 0 as c_int, 0 as c_int, 2 as c_int);
                cavlc_mvd(h, 0 as c_int, 4 as c_int, 2 as c_int);
            }
        } else if i_mb_type == P_8x8 as c_int {
            let mut b_sub_ref: c_int = 0;
            if (*h).mb.cache.ref_0[0][x264_scan8[0] as usize] as c_int
                | (*h).mb.cache.ref_0[0][x264_scan8[4] as usize] as c_int
                | (*h).mb.cache.ref_0[0][x264_scan8[8] as usize] as c_int
                | (*h).mb.cache.ref_0[0][x264_scan8[12] as usize] as c_int
                == 0 as c_int
            {
                (*s).i_bits_encoded += bs_size_ue(4 as c_uint);
                b_sub_ref = 0 as c_int;
            } else {
                (*s).i_bits_encoded += bs_size_ue(3 as c_uint);
                b_sub_ref = 1 as c_int;
            }
            if (*h).param.analyse.inter & X264_ANALYSE_PSUB8x8 != 0 {
                let mut i: c_int = 0 as c_int;
                while i < 4 as c_int {
                    (*s).i_bits_encoded += bs_size_ue(
                        subpartition_p_to_golomb[(*h).mb.i_sub_partition[i as usize] as usize]
                            as c_uint,
                    );
                    i += 1;
                }
            } else {
                (*s).i_bits_encoded += 4 as c_int;
            }
            if b_sub_ref != 0 {
                (*s).i_bits_encoded += bs_size_te(
                    (*h).mb.pic.i_fref[0] - 1 as c_int,
                    (*h).mb.cache.ref_0[0][x264_scan8[0] as usize] as c_int,
                );
                (*s).i_bits_encoded += bs_size_te(
                    (*h).mb.pic.i_fref[0] - 1 as c_int,
                    (*h).mb.cache.ref_0[0][x264_scan8[4] as usize] as c_int,
                );
                (*s).i_bits_encoded += bs_size_te(
                    (*h).mb.pic.i_fref[0] - 1 as c_int,
                    (*h).mb.cache.ref_0[0][x264_scan8[8] as usize] as c_int,
                );
                (*s).i_bits_encoded += bs_size_te(
                    (*h).mb.pic.i_fref[0] - 1 as c_int,
                    (*h).mb.cache.ref_0[0][x264_scan8[12] as usize] as c_int,
                );
            }
            let mut i_0: c_int = 0 as c_int;
            while i_0 < 4 as c_int {
                cavlc_8x8_mvd(h, i_0);
                i_0 += 1;
            }
        } else {
            cavlc_mb_header_i(h, i_mb_type, 5 as c_int, chroma);
        };
    }
    #[inline(always)]
    #[c2rust::src_loc = "411:1"]
    pub unsafe extern "C" fn cavlc_mb_header_b(
        mut h: *mut x264_t,
        mut i_mb_type: c_int,
        mut chroma: c_int,
    ) {
        let mut s: *mut bs_t = &mut (*h).out.bs;
        if i_mb_type == B_8x8 as c_int {
            (*s).i_bits_encoded += bs_size_ue(22 as c_uint);
            let mut i: c_int = 0 as c_int;
            while i < 4 as c_int {
                (*s).i_bits_encoded += bs_size_ue(
                    subpartition_b_to_golomb[(*h).mb.i_sub_partition[i as usize] as usize]
                        as c_uint,
                );
                i += 1;
            }
            if (*h).mb.pic.i_fref[0] > 1 as c_int {
                let mut i_0: c_int = 0 as c_int;
                while i_0 < 4 as c_int {
                    if x264_mb_partition_listX_table[0]
                        [(*h).mb.i_sub_partition[i_0 as usize] as usize]
                        != 0
                    {
                        (*s).i_bits_encoded += bs_size_te(
                            (*h).mb.pic.i_fref[0] - 1 as c_int,
                            (*h).mb.cache.ref_0[0][x264_scan8[(i_0 * 4 as c_int) as usize] as usize]
                                as c_int,
                        );
                    }
                    i_0 += 1;
                }
            }
            if (*h).mb.pic.i_fref[1] > 1 as c_int {
                let mut i_1: c_int = 0 as c_int;
                while i_1 < 4 as c_int {
                    if x264_mb_partition_listX_table[1]
                        [(*h).mb.i_sub_partition[i_1 as usize] as usize]
                        != 0
                    {
                        (*s).i_bits_encoded += bs_size_te(
                            (*h).mb.pic.i_fref[1] - 1 as c_int,
                            (*h).mb.cache.ref_0[1][x264_scan8[(i_1 * 4 as c_int) as usize] as usize]
                                as c_int,
                        );
                    }
                    i_1 += 1;
                }
            }
            let mut i_2: c_int = 0 as c_int;
            while i_2 < 4 as c_int {
                if x264_mb_partition_listX_table[0][(*h).mb.i_sub_partition[i_2 as usize] as usize]
                    != 0
                {
                    cavlc_mvd(h, 0 as c_int, 4 as c_int * i_2, 2 as c_int);
                }
                i_2 += 1;
            }
            let mut i_3: c_int = 0 as c_int;
            while i_3 < 4 as c_int {
                if x264_mb_partition_listX_table[1][(*h).mb.i_sub_partition[i_3 as usize] as usize]
                    != 0
                {
                    cavlc_mvd(h, 1 as c_int, 4 as c_int * i_3, 2 as c_int);
                }
                i_3 += 1;
            }
        } else if i_mb_type >= B_L0_L0 as c_int && i_mb_type <= B_BI_BI as c_int {
            let mut b_list: *const [uint8_t; 2] =
                (*x264_mb_type_list_table.as_ptr().offset(i_mb_type as isize)).as_ptr()
                    as *const [uint8_t; 2];
            let i_ref0_max: c_int = (*h).mb.pic.i_fref[0] - 1 as c_int;
            let i_ref1_max: c_int = (*h).mb.pic.i_fref[1] - 1 as c_int;
            (*s).i_bits_encoded += bs_size_ue(
                mb_type_b_to_golomb[((*h).mb.i_partition - D_16x8 as c_int) as usize]
                    [(i_mb_type - B_L0_L0 as c_int) as usize] as c_uint,
            );
            if (*h).mb.i_partition == D_16x16 as c_int {
                if i_ref0_max != 0 && (*b_list.offset(0))[0] as c_int != 0 {
                    (*s).i_bits_encoded += bs_size_te(
                        i_ref0_max,
                        (*h).mb.cache.ref_0[0][x264_scan8[0] as usize] as c_int,
                    );
                }
                if i_ref1_max != 0 && (*b_list.offset(1))[0] as c_int != 0 {
                    (*s).i_bits_encoded += bs_size_te(
                        i_ref1_max,
                        (*h).mb.cache.ref_0[1][x264_scan8[0] as usize] as c_int,
                    );
                }
                if (*b_list.offset(0))[0] != 0 {
                    cavlc_mvd(h, 0 as c_int, 0 as c_int, 4 as c_int);
                }
                if (*b_list.offset(1))[0] != 0 {
                    cavlc_mvd(h, 1 as c_int, 0 as c_int, 4 as c_int);
                }
            } else {
                if i_ref0_max != 0 && (*b_list.offset(0))[0] as c_int != 0 {
                    (*s).i_bits_encoded += bs_size_te(
                        i_ref0_max,
                        (*h).mb.cache.ref_0[0][x264_scan8[0] as usize] as c_int,
                    );
                }
                if i_ref0_max != 0 && (*b_list.offset(0))[1] as c_int != 0 {
                    (*s).i_bits_encoded += bs_size_te(
                        i_ref0_max,
                        (*h).mb.cache.ref_0[0][x264_scan8[12] as usize] as c_int,
                    );
                }
                if i_ref1_max != 0 && (*b_list.offset(1))[0] as c_int != 0 {
                    (*s).i_bits_encoded += bs_size_te(
                        i_ref1_max,
                        (*h).mb.cache.ref_0[1][x264_scan8[0] as usize] as c_int,
                    );
                }
                if i_ref1_max != 0 && (*b_list.offset(1))[1] as c_int != 0 {
                    (*s).i_bits_encoded += bs_size_te(
                        i_ref1_max,
                        (*h).mb.cache.ref_0[1][x264_scan8[12] as usize] as c_int,
                    );
                }
                if (*h).mb.i_partition == D_16x8 as c_int {
                    if (*b_list.offset(0))[0] != 0 {
                        cavlc_mvd(h, 0 as c_int, 0 as c_int, 4 as c_int);
                    }
                    if (*b_list.offset(0))[1] != 0 {
                        cavlc_mvd(h, 0 as c_int, 8 as c_int, 4 as c_int);
                    }
                    if (*b_list.offset(1))[0] != 0 {
                        cavlc_mvd(h, 1 as c_int, 0 as c_int, 4 as c_int);
                    }
                    if (*b_list.offset(1))[1] != 0 {
                        cavlc_mvd(h, 1 as c_int, 8 as c_int, 4 as c_int);
                    }
                } else {
                    if (*b_list.offset(0))[0] != 0 {
                        cavlc_mvd(h, 0 as c_int, 0 as c_int, 2 as c_int);
                    }
                    if (*b_list.offset(0))[1] != 0 {
                        cavlc_mvd(h, 0 as c_int, 4 as c_int, 2 as c_int);
                    }
                    if (*b_list.offset(1))[0] != 0 {
                        cavlc_mvd(h, 1 as c_int, 0 as c_int, 2 as c_int);
                    }
                    if (*b_list.offset(1))[1] != 0 {
                        cavlc_mvd(h, 1 as c_int, 4 as c_int, 2 as c_int);
                    }
                }
            }
        } else if i_mb_type == B_DIRECT as c_int {
            (*s).i_bits_encoded += 1 as c_int;
        } else {
            cavlc_mb_header_i(h, i_mb_type, 23 as c_int, chroma);
        };
    }
    #[c2rust::src_loc = "487:1"]
    pub unsafe extern "C" fn macroblock_size_cavlc(mut h: *mut x264_t) {
        let mut s: *mut bs_t = &mut (*h).out.bs;
        let i_mb_type: c_int = (*h).mb.i_type;
        let mut plane_count: c_int =
            if (*(*h).sps.as_mut_ptr()).i_chroma_format_idc == CHROMA_444 as c_int {
                3 as c_int
            } else {
                1 as c_int
            };
        let mut chroma: c_int = ((*(*h).sps.as_mut_ptr()).i_chroma_format_idc
            == CHROMA_420 as c_int
            || (*(*h).sps.as_mut_ptr()).i_chroma_format_idc == CHROMA_422 as c_int)
            as c_int;
        (*s).i_bits_encoded = 0 as c_int;
        if (*h).sh.b_mbaff != 0
            && ((*h).mb.i_mb_y & 1 as c_int == 0
                || (*(*h)
                    .mb
                    .type_0
                    .offset(((*h).mb.i_mb_xy - (*h).mb.i_mb_stride) as isize)
                    as c_int
                    == P_SKIP as c_int
                    || *(*h)
                        .mb
                        .type_0
                        .offset(((*h).mb.i_mb_xy - (*h).mb.i_mb_stride) as isize)
                        as c_int
                        == B_SKIP as c_int))
        {
            (*s).i_bits_encoded += 1 as c_int;
        }
        if (*h).sh.i_type == SLICE_TYPE_P as c_int {
            cavlc_mb_header_p(h, i_mb_type, chroma);
        } else if (*h).sh.i_type == SLICE_TYPE_B as c_int {
            cavlc_mb_header_b(h, i_mb_type, chroma);
        } else {
            cavlc_mb_header_i(h, i_mb_type, 0 as c_int, chroma);
        }
        if i_mb_type != I_16x16 as c_int {
            (*s).i_bits_encoded += bs_size_ue(
                cbp_to_golomb[chroma as usize][(i_mb_type == I_4x4 as c_int
                    || i_mb_type == I_8x8 as c_int
                    || i_mb_type == I_16x16 as c_int
                    || i_mb_type == I_PCM as c_int)
                    as c_int as usize]
                    [((*h).mb.i_cbp_chroma << 4 as c_int | (*h).mb.i_cbp_luma) as usize]
                    as c_uint,
            );
        }
        if x264_mb_transform_8x8_allowed(h) != 0 && (*h).mb.i_cbp_luma != 0 {
            (*s).i_bits_encoded += 1 as c_int;
        }
        if i_mb_type == I_16x16 as c_int {
            cavlc_qp_delta(h);
            let mut p: c_int = 0 as c_int;
            while p < plane_count {
                let mut nC: c_int = if DCT_LUMA_DC as c_int == DCT_CHROMA_DC as c_int {
                    5 as c_int - (*h).mb.chroma_v_shift
                } else {
                    ct_index[x264_mb_predict_non_zero_code(
                        h,
                        if DCT_LUMA_DC as c_int == DCT_LUMA_DC as c_int {
                            (48 as c_int + p - LUMA_DC) * 16 as c_int
                        } else {
                            48 as c_int + p
                        },
                    ) as usize] as c_int
                };
                let mut nnz: *mut uint8_t = &mut *(*h)
                    .mb
                    .cache
                    .non_zero_count
                    .as_mut_ptr()
                    .offset(*x264_scan8.as_ptr().offset((48 as c_int + p) as isize) as isize)
                    as *mut uint8_t;
                if *nnz == 0 {
                    (*h).out.bs.i_bits_encoded += x264_coeff0_token[nC as usize].i_size as c_int;
                } else {
                    *nnz = cavlc_block_residual_internal(
                        h,
                        DCT_LUMA_DC as c_int,
                        (*(*h).dct.luma16x16_dc.as_mut_ptr().offset(p as isize)).as_mut_ptr(),
                        nC,
                    ) as uint8_t;
                }
                if (*h).mb.i_cbp_luma != 0 {
                    let mut i: c_int = p * 16 as c_int;
                    while i < p * 16 as c_int + 16 as c_int {
                        let mut nC_0: c_int = if DCT_LUMA_AC as c_int == DCT_CHROMA_DC as c_int {
                            5 as c_int - (*h).mb.chroma_v_shift
                        } else {
                            ct_index[x264_mb_predict_non_zero_code(
                                h,
                                if DCT_LUMA_AC as c_int == DCT_LUMA_DC as c_int {
                                    (i - LUMA_DC) * 16 as c_int
                                } else {
                                    i
                                },
                            ) as usize] as c_int
                        };
                        let mut nnz_0: *mut uint8_t = &mut *(*h)
                            .mb
                            .cache
                            .non_zero_count
                            .as_mut_ptr()
                            .offset(*x264_scan8.as_ptr().offset(i as isize) as isize)
                            as *mut uint8_t;
                        if *nnz_0 == 0 {
                            (*h).out.bs.i_bits_encoded +=
                                x264_coeff0_token[nC_0 as usize].i_size as c_int;
                        } else {
                            *nnz_0 = cavlc_block_residual_internal(
                                h,
                                DCT_LUMA_AC as c_int,
                                (*(*h).dct.luma4x4.as_mut_ptr().offset(i as isize))
                                    .as_mut_ptr()
                                    .offset(1),
                                nC_0,
                            ) as uint8_t;
                        }
                        i += 1;
                    }
                }
                p += 1;
            }
        } else if (*h).mb.i_cbp_luma | (*h).mb.i_cbp_chroma != 0 {
            cavlc_qp_delta(h);
            cavlc_macroblock_luma_residual(h, plane_count);
        }
        if (*h).mb.i_cbp_chroma != 0 {
            let mut nC_1: c_int = if DCT_CHROMA_DC as c_int == DCT_CHROMA_DC as c_int {
                5 as c_int - (*h).mb.chroma_v_shift
            } else {
                ct_index[x264_mb_predict_non_zero_code(
                    h,
                    if DCT_CHROMA_DC as c_int == DCT_LUMA_DC as c_int {
                        (49 as c_int + 0 as c_int - LUMA_DC) * 16 as c_int
                    } else {
                        49 as c_int + 0 as c_int
                    },
                ) as usize] as c_int
            };
            let mut nnz_1: *mut uint8_t = &mut *(*h).mb.cache.non_zero_count.as_mut_ptr().offset(
                *x264_scan8
                    .as_ptr()
                    .offset((49 as c_int + 0 as c_int) as isize) as isize,
            ) as *mut uint8_t;
            if *nnz_1 == 0 {
                (*h).out.bs.i_bits_encoded += x264_coeff0_token[nC_1 as usize].i_size as c_int;
            } else {
                *nnz_1 = cavlc_block_residual_internal(
                    h,
                    DCT_CHROMA_DC as c_int,
                    (*(*h).dct.chroma_dc.as_mut_ptr().offset(0)).as_mut_ptr(),
                    nC_1,
                ) as uint8_t;
            }
            let mut nC_2: c_int = if DCT_CHROMA_DC as c_int == DCT_CHROMA_DC as c_int {
                5 as c_int - (*h).mb.chroma_v_shift
            } else {
                ct_index[x264_mb_predict_non_zero_code(
                    h,
                    if DCT_CHROMA_DC as c_int == DCT_LUMA_DC as c_int {
                        (49 as c_int + 1 as c_int - LUMA_DC) * 16 as c_int
                    } else {
                        49 as c_int + 1 as c_int
                    },
                ) as usize] as c_int
            };
            let mut nnz_2: *mut uint8_t = &mut *(*h).mb.cache.non_zero_count.as_mut_ptr().offset(
                *x264_scan8
                    .as_ptr()
                    .offset((49 as c_int + 1 as c_int) as isize) as isize,
            ) as *mut uint8_t;
            if *nnz_2 == 0 {
                (*h).out.bs.i_bits_encoded += x264_coeff0_token[nC_2 as usize].i_size as c_int;
            } else {
                *nnz_2 = cavlc_block_residual_internal(
                    h,
                    DCT_CHROMA_DC as c_int,
                    (*(*h).dct.chroma_dc.as_mut_ptr().offset(1)).as_mut_ptr(),
                    nC_2,
                ) as uint8_t;
            }
            if (*h).mb.i_cbp_chroma == 2 as c_int {
                let mut step: c_int = (8 as c_int) << (*h).mb.chroma_v_shift;
                let mut i_0: c_int = 16 as c_int;
                while i_0 < 3 as c_int * 16 as c_int {
                    let mut j: c_int = i_0;
                    while j < i_0 + 4 as c_int {
                        let mut nC_3: c_int = if DCT_CHROMA_AC as c_int == DCT_CHROMA_DC as c_int {
                            5 as c_int - (*h).mb.chroma_v_shift
                        } else {
                            ct_index[x264_mb_predict_non_zero_code(
                                h,
                                if DCT_CHROMA_AC as c_int == DCT_LUMA_DC as c_int {
                                    (j - LUMA_DC) * 16 as c_int
                                } else {
                                    j
                                },
                            ) as usize] as c_int
                        };
                        let mut nnz_3: *mut uint8_t = &mut *(*h)
                            .mb
                            .cache
                            .non_zero_count
                            .as_mut_ptr()
                            .offset(*x264_scan8.as_ptr().offset(j as isize) as isize)
                            as *mut uint8_t;
                        if *nnz_3 == 0 {
                            (*h).out.bs.i_bits_encoded +=
                                x264_coeff0_token[nC_3 as usize].i_size as c_int;
                        } else {
                            *nnz_3 = cavlc_block_residual_internal(
                                h,
                                DCT_CHROMA_AC as c_int,
                                (*(*h).dct.luma4x4.as_mut_ptr().offset(j as isize))
                                    .as_mut_ptr()
                                    .offset(1),
                                nC_3,
                            ) as uint8_t;
                        }
                        j += 1;
                    }
                    i_0 += step;
                }
            }
        }
    }
    #[c2rust::src_loc = "605:1"]
    pub unsafe extern "C" fn partition_size_cavlc(
        mut h: *mut x264_t,
        mut i8: c_int,
        mut i_pixel: c_int,
    ) -> c_int {
        let mut s: *mut bs_t = &mut (*h).out.bs;
        let i_mb_type: c_int = (*h).mb.i_type;
        let mut b_8x16: c_int = ((*h).mb.i_partition == D_8x16 as c_int) as c_int;
        let mut plane_count: c_int =
            if (*(*h).sps.as_mut_ptr()).i_chroma_format_idc == CHROMA_444 as c_int {
                3 as c_int
            } else {
                1 as c_int
            };
        let mut j: c_int = 0;
        (*h).out.bs.i_bits_encoded = 0 as c_int;
        if i_mb_type == P_8x8 as c_int {
            cavlc_8x8_mvd(h, i8);
            (*s).i_bits_encoded += bs_size_ue(
                subpartition_p_to_golomb[(*h).mb.i_sub_partition[i8 as usize] as usize] as c_uint,
            );
        } else if i_mb_type == P_L0 as c_int {
            cavlc_mvd(h, 0 as c_int, 4 as c_int * i8, 4 as c_int >> b_8x16);
        } else if i_mb_type > B_DIRECT as c_int && i_mb_type < B_8x8 as c_int {
            if x264_mb_type_list_table[i_mb_type as usize][0][(i8 != 0) as c_int as usize] != 0 {
                cavlc_mvd(h, 0 as c_int, 4 as c_int * i8, 4 as c_int >> b_8x16);
            }
            if x264_mb_type_list_table[i_mb_type as usize][1][(i8 != 0) as c_int as usize] != 0 {
                cavlc_mvd(h, 1 as c_int, 4 as c_int * i8, 4 as c_int >> b_8x16);
            }
        } else {
            if x264_mb_partition_listX_table[0][(*h).mb.i_sub_partition[i8 as usize] as usize] != 0
            {
                cavlc_mvd(h, 0 as c_int, 4 as c_int * i8, 2 as c_int);
            }
            if x264_mb_partition_listX_table[1][(*h).mb.i_sub_partition[i8 as usize] as usize] != 0
            {
                cavlc_mvd(h, 1 as c_int, 4 as c_int * i8, 2 as c_int);
            }
        }
        j = (i_pixel < PIXEL_8x8 as c_int) as c_int;
        while j >= 0 as c_int {
            let mut p: c_int = 0 as c_int;
            while p < plane_count {
                cavlc_partition_luma_residual(h, i8, p);
                p += 1;
            }
            if (*h).mb.i_cbp_chroma != 0 {
                if (*(*h).sps.as_mut_ptr()).i_chroma_format_idc == CHROMA_422 as c_int {
                    let mut offset: c_int = 5 as c_int * i8 & 0x9 as c_int;
                    let mut nC: c_int = if DCT_CHROMA_AC as c_int == DCT_CHROMA_DC as c_int {
                        5 as c_int - (*h).mb.chroma_v_shift
                    } else {
                        ct_index[x264_mb_predict_non_zero_code(
                            h,
                            if DCT_CHROMA_AC as c_int == DCT_LUMA_DC as c_int {
                                (16 as c_int + offset - LUMA_DC) * 16 as c_int
                            } else {
                                16 as c_int + offset
                            },
                        ) as usize] as c_int
                    };
                    let mut nnz: *mut uint8_t = &mut *(*h)
                        .mb
                        .cache
                        .non_zero_count
                        .as_mut_ptr()
                        .offset(
                            *x264_scan8.as_ptr().offset((16 as c_int + offset) as isize) as isize
                        ) as *mut uint8_t;
                    if *nnz == 0 {
                        (*h).out.bs.i_bits_encoded +=
                            x264_coeff0_token[nC as usize].i_size as c_int;
                    } else {
                        *nnz = cavlc_block_residual_internal(
                            h,
                            DCT_CHROMA_AC as c_int,
                            (*(*h)
                                .dct
                                .luma4x4
                                .as_mut_ptr()
                                .offset((16 as c_int + offset) as isize))
                            .as_mut_ptr()
                            .offset(1),
                            nC,
                        ) as uint8_t;
                    }
                    let mut nC_0: c_int = if DCT_CHROMA_AC as c_int == DCT_CHROMA_DC as c_int {
                        5 as c_int - (*h).mb.chroma_v_shift
                    } else {
                        ct_index[x264_mb_predict_non_zero_code(
                            h,
                            if DCT_CHROMA_AC as c_int == DCT_LUMA_DC as c_int {
                                (18 as c_int + offset - LUMA_DC) * 16 as c_int
                            } else {
                                18 as c_int + offset
                            },
                        ) as usize] as c_int
                    };
                    let mut nnz_0: *mut uint8_t = &mut *(*h)
                        .mb
                        .cache
                        .non_zero_count
                        .as_mut_ptr()
                        .offset(
                            *x264_scan8.as_ptr().offset((18 as c_int + offset) as isize) as isize
                        ) as *mut uint8_t;
                    if *nnz_0 == 0 {
                        (*h).out.bs.i_bits_encoded +=
                            x264_coeff0_token[nC_0 as usize].i_size as c_int;
                    } else {
                        *nnz_0 = cavlc_block_residual_internal(
                            h,
                            DCT_CHROMA_AC as c_int,
                            (*(*h)
                                .dct
                                .luma4x4
                                .as_mut_ptr()
                                .offset((18 as c_int + offset) as isize))
                            .as_mut_ptr()
                            .offset(1),
                            nC_0,
                        ) as uint8_t;
                    }
                    let mut nC_1: c_int = if DCT_CHROMA_AC as c_int == DCT_CHROMA_DC as c_int {
                        5 as c_int - (*h).mb.chroma_v_shift
                    } else {
                        ct_index[x264_mb_predict_non_zero_code(
                            h,
                            if DCT_CHROMA_AC as c_int == DCT_LUMA_DC as c_int {
                                (32 as c_int + offset - LUMA_DC) * 16 as c_int
                            } else {
                                32 as c_int + offset
                            },
                        ) as usize] as c_int
                    };
                    let mut nnz_1: *mut uint8_t = &mut *(*h)
                        .mb
                        .cache
                        .non_zero_count
                        .as_mut_ptr()
                        .offset(
                            *x264_scan8.as_ptr().offset((32 as c_int + offset) as isize) as isize
                        ) as *mut uint8_t;
                    if *nnz_1 == 0 {
                        (*h).out.bs.i_bits_encoded +=
                            x264_coeff0_token[nC_1 as usize].i_size as c_int;
                    } else {
                        *nnz_1 = cavlc_block_residual_internal(
                            h,
                            DCT_CHROMA_AC as c_int,
                            (*(*h)
                                .dct
                                .luma4x4
                                .as_mut_ptr()
                                .offset((32 as c_int + offset) as isize))
                            .as_mut_ptr()
                            .offset(1),
                            nC_1,
                        ) as uint8_t;
                    }
                    let mut nC_2: c_int = if DCT_CHROMA_AC as c_int == DCT_CHROMA_DC as c_int {
                        5 as c_int - (*h).mb.chroma_v_shift
                    } else {
                        ct_index[x264_mb_predict_non_zero_code(
                            h,
                            if DCT_CHROMA_AC as c_int == DCT_LUMA_DC as c_int {
                                (34 as c_int + offset - LUMA_DC) * 16 as c_int
                            } else {
                                34 as c_int + offset
                            },
                        ) as usize] as c_int
                    };
                    let mut nnz_2: *mut uint8_t = &mut *(*h)
                        .mb
                        .cache
                        .non_zero_count
                        .as_mut_ptr()
                        .offset(
                            *x264_scan8.as_ptr().offset((34 as c_int + offset) as isize) as isize
                        ) as *mut uint8_t;
                    if *nnz_2 == 0 {
                        (*h).out.bs.i_bits_encoded +=
                            x264_coeff0_token[nC_2 as usize].i_size as c_int;
                    } else {
                        *nnz_2 = cavlc_block_residual_internal(
                            h,
                            DCT_CHROMA_AC as c_int,
                            (*(*h)
                                .dct
                                .luma4x4
                                .as_mut_ptr()
                                .offset((34 as c_int + offset) as isize))
                            .as_mut_ptr()
                            .offset(1),
                            nC_2,
                        ) as uint8_t;
                    }
                } else {
                    let mut nC_3: c_int = if DCT_CHROMA_AC as c_int == DCT_CHROMA_DC as c_int {
                        5 as c_int - (*h).mb.chroma_v_shift
                    } else {
                        ct_index[x264_mb_predict_non_zero_code(
                            h,
                            if DCT_CHROMA_AC as c_int == DCT_LUMA_DC as c_int {
                                (16 as c_int + i8 - LUMA_DC) * 16 as c_int
                            } else {
                                16 as c_int + i8
                            },
                        ) as usize] as c_int
                    };
                    let mut nnz_3: *mut uint8_t =
                        &mut *(*h).mb.cache.non_zero_count.as_mut_ptr().offset(
                            *x264_scan8.as_ptr().offset((16 as c_int + i8) as isize) as isize,
                        ) as *mut uint8_t;
                    if *nnz_3 == 0 {
                        (*h).out.bs.i_bits_encoded +=
                            x264_coeff0_token[nC_3 as usize].i_size as c_int;
                    } else {
                        *nnz_3 = cavlc_block_residual_internal(
                            h,
                            DCT_CHROMA_AC as c_int,
                            (*(*h)
                                .dct
                                .luma4x4
                                .as_mut_ptr()
                                .offset((16 as c_int + i8) as isize))
                            .as_mut_ptr()
                            .offset(1),
                            nC_3,
                        ) as uint8_t;
                    }
                    let mut nC_4: c_int = if DCT_CHROMA_AC as c_int == DCT_CHROMA_DC as c_int {
                        5 as c_int - (*h).mb.chroma_v_shift
                    } else {
                        ct_index[x264_mb_predict_non_zero_code(
                            h,
                            if DCT_CHROMA_AC as c_int == DCT_LUMA_DC as c_int {
                                (32 as c_int + i8 - LUMA_DC) * 16 as c_int
                            } else {
                                32 as c_int + i8
                            },
                        ) as usize] as c_int
                    };
                    let mut nnz_4: *mut uint8_t =
                        &mut *(*h).mb.cache.non_zero_count.as_mut_ptr().offset(
                            *x264_scan8.as_ptr().offset((32 as c_int + i8) as isize) as isize,
                        ) as *mut uint8_t;
                    if *nnz_4 == 0 {
                        (*h).out.bs.i_bits_encoded +=
                            x264_coeff0_token[nC_4 as usize].i_size as c_int;
                    } else {
                        *nnz_4 = cavlc_block_residual_internal(
                            h,
                            DCT_CHROMA_AC as c_int,
                            (*(*h)
                                .dct
                                .luma4x4
                                .as_mut_ptr()
                                .offset((32 as c_int + i8) as isize))
                            .as_mut_ptr()
                            .offset(1),
                            nC_4,
                        ) as uint8_t;
                    }
                }
            }
            i8 += x264_pixel_size[i_pixel as usize].h as c_int >> 3 as c_int;
            j -= 1;
        }
        return (*h).out.bs.i_bits_encoded;
    }
    #[c2rust::src_loc = "661:1"]
    pub unsafe extern "C" fn subpartition_size_cavlc(
        mut h: *mut x264_t,
        mut i4: c_int,
        mut i_pixel: c_int,
    ) -> c_int {
        let mut plane_count: c_int =
            if (*(*h).sps.as_mut_ptr()).i_chroma_format_idc == CHROMA_444 as c_int {
                3 as c_int
            } else {
                1 as c_int
            };
        let mut b_8x4: c_int = (i_pixel == PIXEL_8x4 as c_int) as c_int;
        (*h).out.bs.i_bits_encoded = 0 as c_int;
        cavlc_mvd(h, 0 as c_int, i4, 1 as c_int + b_8x4);
        let mut p: c_int = 0 as c_int;
        while p < plane_count {
            let mut nC: c_int = if DCT_LUMA_4x4 as c_int == DCT_CHROMA_DC as c_int {
                5 as c_int - (*h).mb.chroma_v_shift
            } else {
                ct_index[x264_mb_predict_non_zero_code(
                    h,
                    if DCT_LUMA_4x4 as c_int == DCT_LUMA_DC as c_int {
                        (p * 16 as c_int + i4 - LUMA_DC) * 16 as c_int
                    } else {
                        p * 16 as c_int + i4
                    },
                ) as usize] as c_int
            };
            let mut nnz: *mut uint8_t = &mut *(*h)
                .mb
                .cache
                .non_zero_count
                .as_mut_ptr()
                .offset(*x264_scan8.as_ptr().offset((p * 16 as c_int + i4) as isize) as isize)
                as *mut uint8_t;
            if *nnz == 0 {
                (*h).out.bs.i_bits_encoded += x264_coeff0_token[nC as usize].i_size as c_int;
            } else {
                *nnz = cavlc_block_residual_internal(
                    h,
                    DCT_LUMA_4x4 as c_int,
                    (*(*h)
                        .dct
                        .luma4x4
                        .as_mut_ptr()
                        .offset((p * 16 as c_int + i4) as isize))
                    .as_mut_ptr(),
                    nC,
                ) as uint8_t;
            }
            if i_pixel != PIXEL_4x4 as c_int {
                let mut nC_0: c_int = if DCT_LUMA_4x4 as c_int == DCT_CHROMA_DC as c_int {
                    5 as c_int - (*h).mb.chroma_v_shift
                } else {
                    ct_index[x264_mb_predict_non_zero_code(
                        h,
                        if DCT_LUMA_4x4 as c_int == DCT_LUMA_DC as c_int {
                            (p * 16 as c_int + i4 + 2 as c_int - b_8x4 - LUMA_DC) * 16 as c_int
                        } else {
                            p * 16 as c_int + i4 + 2 as c_int - b_8x4
                        },
                    ) as usize] as c_int
                };
                let mut nnz_0: *mut uint8_t =
                    &mut *(*h).mb.cache.non_zero_count.as_mut_ptr().offset(
                        *x264_scan8
                            .as_ptr()
                            .offset((p * 16 as c_int + i4 + 2 as c_int - b_8x4) as isize)
                            as isize,
                    ) as *mut uint8_t;
                if *nnz_0 == 0 {
                    (*h).out.bs.i_bits_encoded += x264_coeff0_token[nC_0 as usize].i_size as c_int;
                } else {
                    *nnz_0 = cavlc_block_residual_internal(
                        h,
                        DCT_LUMA_4x4 as c_int,
                        (*(*h)
                            .dct
                            .luma4x4
                            .as_mut_ptr()
                            .offset((p * 16 as c_int + i4 + 2 as c_int - b_8x4) as isize))
                        .as_mut_ptr(),
                        nC_0,
                    ) as uint8_t;
                }
            }
            p += 1;
        }
        return (*h).out.bs.i_bits_encoded;
    }
    #[c2rust::src_loc = "677:1"]
    pub unsafe extern "C" fn cavlc_intra4x4_pred_size(
        mut h: *mut x264_t,
        mut i4: c_int,
        mut i_mode: c_int,
    ) -> c_int {
        if x264_mb_predict_intra4x4_mode(h, i4)
            == x264_mb_pred_mode4x4_fix[(i_mode + 1 as c_int) as usize] as c_int
        {
            return 1 as c_int;
        } else {
            return 4 as c_int;
        };
    }
    #[c2rust::src_loc = "685:1"]
    pub unsafe extern "C" fn partition_i8x8_size_cavlc(
        mut h: *mut x264_t,
        mut i8: c_int,
        mut i_mode: c_int,
    ) -> c_int {
        let mut plane_count: c_int =
            if (*(*h).sps.as_mut_ptr()).i_chroma_format_idc == CHROMA_444 as c_int {
                3 as c_int
            } else {
                1 as c_int
            };
        (*h).out.bs.i_bits_encoded = cavlc_intra4x4_pred_size(h, 4 as c_int * i8, i_mode);
        (*h).out.bs.i_bits_encoded += bs_size_ue(
            cbp_to_golomb[!((*(*h).sps.as_mut_ptr()).i_chroma_format_idc == CHROMA_444 as c_int)
                as c_int as usize][1]
                [((*h).mb.i_cbp_chroma << 4 as c_int | (*h).mb.i_cbp_luma) as usize]
                as c_uint,
        );
        let mut p: c_int = 0 as c_int;
        while p < plane_count {
            cavlc_partition_luma_residual(h, i8, p);
            p += 1;
        }
        return (*h).out.bs.i_bits_encoded;
    }
    #[c2rust::src_loc = "695:1"]
    pub unsafe extern "C" fn partition_i4x4_size_cavlc(
        mut h: *mut x264_t,
        mut i4: c_int,
        mut i_mode: c_int,
    ) -> c_int {
        let mut plane_count: c_int =
            if (*(*h).sps.as_mut_ptr()).i_chroma_format_idc == CHROMA_444 as c_int {
                3 as c_int
            } else {
                1 as c_int
            };
        (*h).out.bs.i_bits_encoded = cavlc_intra4x4_pred_size(h, i4, i_mode);
        let mut p: c_int = 0 as c_int;
        while p < plane_count {
            let mut nC: c_int = if DCT_LUMA_4x4 as c_int == DCT_CHROMA_DC as c_int {
                5 as c_int - (*h).mb.chroma_v_shift
            } else {
                ct_index[x264_mb_predict_non_zero_code(
                    h,
                    if DCT_LUMA_4x4 as c_int == DCT_LUMA_DC as c_int {
                        (p * 16 as c_int + i4 - LUMA_DC) * 16 as c_int
                    } else {
                        p * 16 as c_int + i4
                    },
                ) as usize] as c_int
            };
            let mut nnz: *mut uint8_t = &mut *(*h)
                .mb
                .cache
                .non_zero_count
                .as_mut_ptr()
                .offset(*x264_scan8.as_ptr().offset((p * 16 as c_int + i4) as isize) as isize)
                as *mut uint8_t;
            if *nnz == 0 {
                (*h).out.bs.i_bits_encoded += x264_coeff0_token[nC as usize].i_size as c_int;
            } else {
                *nnz = cavlc_block_residual_internal(
                    h,
                    DCT_LUMA_4x4 as c_int,
                    (*(*h)
                        .dct
                        .luma4x4
                        .as_mut_ptr()
                        .offset((p * 16 as c_int + i4) as isize))
                    .as_mut_ptr(),
                    nC,
                ) as uint8_t;
            }
            p += 1;
        }
        return (*h).out.bs.i_bits_encoded;
    }
    #[c2rust::src_loc = "704:1"]
    pub unsafe extern "C" fn chroma_size_cavlc(mut h: *mut x264_t) -> c_int {
        (*h).out.bs.i_bits_encoded =
            bs_size_ue(x264_mb_chroma_pred_mode_fix[(*h).mb.i_chroma_pred_mode as usize] as c_uint);
        if (*h).mb.i_cbp_chroma != 0 {
            let mut nC: c_int = if DCT_CHROMA_DC as c_int == DCT_CHROMA_DC as c_int {
                5 as c_int - (*h).mb.chroma_v_shift
            } else {
                ct_index[x264_mb_predict_non_zero_code(
                    h,
                    if DCT_CHROMA_DC as c_int == DCT_LUMA_DC as c_int {
                        (49 as c_int + 0 as c_int - LUMA_DC) * 16 as c_int
                    } else {
                        49 as c_int + 0 as c_int
                    },
                ) as usize] as c_int
            };
            let mut nnz: *mut uint8_t = &mut *(*h).mb.cache.non_zero_count.as_mut_ptr().offset(
                *x264_scan8
                    .as_ptr()
                    .offset((49 as c_int + 0 as c_int) as isize) as isize,
            ) as *mut uint8_t;
            if *nnz == 0 {
                (*h).out.bs.i_bits_encoded += x264_coeff0_token[nC as usize].i_size as c_int;
            } else {
                *nnz = cavlc_block_residual_internal(
                    h,
                    DCT_CHROMA_DC as c_int,
                    (*(*h).dct.chroma_dc.as_mut_ptr().offset(0)).as_mut_ptr(),
                    nC,
                ) as uint8_t;
            }
            let mut nC_0: c_int = if DCT_CHROMA_DC as c_int == DCT_CHROMA_DC as c_int {
                5 as c_int - (*h).mb.chroma_v_shift
            } else {
                ct_index[x264_mb_predict_non_zero_code(
                    h,
                    if DCT_CHROMA_DC as c_int == DCT_LUMA_DC as c_int {
                        (49 as c_int + 1 as c_int - LUMA_DC) * 16 as c_int
                    } else {
                        49 as c_int + 1 as c_int
                    },
                ) as usize] as c_int
            };
            let mut nnz_0: *mut uint8_t = &mut *(*h).mb.cache.non_zero_count.as_mut_ptr().offset(
                *x264_scan8
                    .as_ptr()
                    .offset((49 as c_int + 1 as c_int) as isize) as isize,
            ) as *mut uint8_t;
            if *nnz_0 == 0 {
                (*h).out.bs.i_bits_encoded += x264_coeff0_token[nC_0 as usize].i_size as c_int;
            } else {
                *nnz_0 = cavlc_block_residual_internal(
                    h,
                    DCT_CHROMA_DC as c_int,
                    (*(*h).dct.chroma_dc.as_mut_ptr().offset(1)).as_mut_ptr(),
                    nC_0,
                ) as uint8_t;
            }
            if (*h).mb.i_cbp_chroma == 2 as c_int {
                let mut step: c_int = (8 as c_int) << (*h).mb.chroma_v_shift;
                let mut i: c_int = 16 as c_int;
                while i < 3 as c_int * 16 as c_int {
                    let mut j: c_int = i;
                    while j < i + 4 as c_int {
                        let mut nC_1: c_int = if DCT_CHROMA_AC as c_int == DCT_CHROMA_DC as c_int {
                            5 as c_int - (*h).mb.chroma_v_shift
                        } else {
                            ct_index[x264_mb_predict_non_zero_code(
                                h,
                                if DCT_CHROMA_AC as c_int == DCT_LUMA_DC as c_int {
                                    (j - LUMA_DC) * 16 as c_int
                                } else {
                                    j
                                },
                            ) as usize] as c_int
                        };
                        let mut nnz_1: *mut uint8_t = &mut *(*h)
                            .mb
                            .cache
                            .non_zero_count
                            .as_mut_ptr()
                            .offset(*x264_scan8.as_ptr().offset(j as isize) as isize)
                            as *mut uint8_t;
                        if *nnz_1 == 0 {
                            (*h).out.bs.i_bits_encoded +=
                                x264_coeff0_token[nC_1 as usize].i_size as c_int;
                        } else {
                            *nnz_1 = cavlc_block_residual_internal(
                                h,
                                DCT_CHROMA_AC as c_int,
                                (*(*h).dct.luma4x4.as_mut_ptr().offset(j as isize))
                                    .as_mut_ptr()
                                    .offset(1),
                                nC_1,
                            ) as uint8_t;
                        }
                        j += 1;
                    }
                    i += step;
                }
            }
        }
        return (*h).out.bs.i_bits_encoded;
    }
    use ::core::ffi::{c_int, c_uint};

    use super::base_h::{
        x264_scan8, CHROMA_420, CHROMA_422, CHROMA_444, CHROMA_DC, LUMA_DC, PROFILE_HIGH,
        SLICE_TYPE_B, SLICE_TYPE_P,
    };
    use super::bitstream_h::{
        bs_size_se, bs_size_te, bs_size_ue, bs_t, x264_10_level_token, x264_10_run_before,
        x264_run_level_t, LEVEL_TABLE_SIZE,
    };
    use super::common_h::{dctcoef, x264_t, QP_BD_OFFSET, QP_MAX_SPEC};
    use super::macroblock_h::{
        x264_10_mb_predict_mv, x264_mb_partition_listX_table, x264_mb_predict_intra4x4_mode,
        x264_mb_predict_non_zero_code, x264_mb_transform_8x8_allowed, x264_mb_type_list_table,
        B_8x8, DCT_LUMA_4x4, D_16x16, D_16x8, D_8x16, I_16x16, I_4x4, I_8x8, P_8x8, B_BI_BI,
        B_DIRECT, B_L0_L0, B_SKIP, DCT_CHROMA_AC, DCT_CHROMA_DC, DCT_LUMA_AC, DCT_LUMA_DC, I_PCM,
        P_L0, P_SKIP,
    };
    use super::osdep_h::x264_ctz_4bit;
    use super::pixel_h::{x264_pixel_size, PIXEL_4x4, PIXEL_8x4, PIXEL_8x8};
    use super::predict_h::{
        x264_mb_chroma_pred_mode_fix, x264_mb_pred_mode16x16_fix, x264_mb_pred_mode4x4_fix,
    };
    use super::stdint_intn_h::{int16_t, int32_t, int8_t};
    use super::stdint_uintn_h::{uint16_t, uint32_t, uint8_t};
    use super::tables_h::{
        vlc_t, x264_coeff0_token, x264_coeff_token, x264_total_zeros, x264_total_zeros_2x2_dc,
        x264_total_zeros_2x4_dc,
    };
    use super::x264_h::X264_ANALYSE_PSUB8x8;
}
#[c2rust::header_src = "/home/nwplayer123/Hacks/hex264/x264/encoder/ratecontrol.h:28"]
pub mod ratecontrol_h {
    use ::core::ffi::{c_float, c_int};

    use super::common_h::x264_t;
    extern "C" {
        #[c2rust::src_loc = "65:1"]
        pub fn x264_10_ratecontrol_slice_type(_: *mut x264_t, i_frame: c_int) -> c_int;
        #[c2rust::src_loc = "73:1"]
        pub fn x264_10_ratecontrol_mb_qp(h: *mut x264_t) -> c_int;
    }
    use super::frame_h::x264_frame_t;
    extern "C" {
        #[c2rust::src_loc = "43:1"]
        pub fn x264_10_ratecontrol_new(_: *mut x264_t) -> c_int;
        #[c2rust::src_loc = "45:1"]
        pub fn x264_10_ratecontrol_delete(_: *mut x264_t);
        #[c2rust::src_loc = "48:1"]
        pub fn x264_10_ratecontrol_init_reconfigurable(h: *mut x264_t, b_init: c_int);
        #[c2rust::src_loc = "53:1"]
        pub fn x264_10_adaptive_quant_frame(
            h: *mut x264_t,
            frame: *mut x264_frame_t,
            quant_offsets: *mut c_float,
        );
        #[c2rust::src_loc = "55:1"]
        pub fn x264_10_macroblock_tree_read(
            h: *mut x264_t,
            frame: *mut x264_frame_t,
            quant_offsets: *mut c_float,
        ) -> c_int;
        #[c2rust::src_loc = "57:1"]
        pub fn x264_10_reference_build_list_optimal(h: *mut x264_t) -> c_int;
        #[c2rust::src_loc = "59:1"]
        pub fn x264_10_thread_sync_ratecontrol(
            cur: *mut x264_t,
            prev: *mut x264_t,
            next: *mut x264_t,
        );
        #[c2rust::src_loc = "61:1"]
        pub fn x264_10_ratecontrol_zone_init(_: *mut x264_t);
        #[c2rust::src_loc = "63:1"]
        pub fn x264_10_ratecontrol_start(_: *mut x264_t, i_force_qp: c_int, overhead: c_int);
        #[c2rust::src_loc = "67:1"]
        pub fn x264_10_ratecontrol_set_weights(h: *mut x264_t, frm: *mut x264_frame_t);
        #[c2rust::src_loc = "69:1"]
        pub fn x264_10_ratecontrol_mb(_: *mut x264_t, bits: c_int) -> c_int;
        #[c2rust::src_loc = "71:1"]
        pub fn x264_10_ratecontrol_qp(_: *mut x264_t) -> c_int;
        #[c2rust::src_loc = "75:1"]
        pub fn x264_10_ratecontrol_end(_: *mut x264_t, bits: c_int, filler: *mut c_int) -> c_int;
        #[c2rust::src_loc = "77:1"]
        pub fn x264_10_ratecontrol_summary(_: *mut x264_t);
        #[c2rust::src_loc = "81:1"]
        pub fn x264_10_threads_distribute_ratecontrol(h: *mut x264_t);
        #[c2rust::src_loc = "83:1"]
        pub fn x264_10_threads_merge_ratecontrol(h: *mut x264_t);
        #[c2rust::src_loc = "85:1"]
        pub fn x264_10_hrd_fullness(h: *mut x264_t);
    }

    use super::x264_h::x264_param_t;
    extern "C" {
        #[c2rust::src_loc = "50:1"]
        pub fn x264_10_encoder_reconfig_apply(h: *mut x264_t, param: *mut x264_param_t) -> c_int;
        #[c2rust::src_loc = "79:1"]
        pub fn x264_10_rc_analyse_slice(h: *mut x264_t) -> c_int;
    }
}
#[c2rust::header_src = "/usr/lib/clang/21/include/limits.h:28"]
pub mod limits_h {
    #[c2rust::src_loc = "50:9"]
    pub const INT_MAX: c_int = __INT_MAX__;
    use ::core::ffi::c_int;

    use super::internal::__INT_MAX__;
}

#[c2rust::header_src = "/home/nwplayer123/Hacks/hex264/x264/encoder/analyse.h:28"]
pub mod analyse_h {
    use ::core::ffi::c_int;

    use super::common_h::x264_t;
    use super::frame_h::x264_frame_t;
    extern "C" {
        #[c2rust::src_loc = "31:1"]
        pub fn x264_10_analyse_init_costs(h: *mut x264_t) -> c_int;
        #[c2rust::src_loc = "33:1"]
        pub fn x264_10_analyse_free_costs(h: *mut x264_t);
        #[c2rust::src_loc = "35:1"]
        pub fn x264_10_analyse_weight_frame(h: *mut x264_t, end: c_int);
        #[c2rust::src_loc = "37:1"]
        pub fn x264_10_macroblock_analyse(h: *mut x264_t);
        #[c2rust::src_loc = "45:1"]
        pub fn x264_10_lookahead_init(h: *mut x264_t, i_slicetype_length: c_int) -> c_int;
        #[c2rust::src_loc = "47:1"]
        pub fn x264_10_lookahead_is_empty(h: *mut x264_t) -> c_int;
        #[c2rust::src_loc = "49:1"]
        pub fn x264_10_lookahead_put_frame(h: *mut x264_t, frame: *mut x264_frame_t);
        #[c2rust::src_loc = "51:1"]
        pub fn x264_10_lookahead_get_frames(h: *mut x264_t);
        #[c2rust::src_loc = "53:1"]
        pub fn x264_10_lookahead_delete(h: *mut x264_t);
    }
    extern "C" {
        #[c2rust::src_loc = "39:1"]
        pub fn x264_10_slicetype_decide(h: *mut x264_t);
        #[c2rust::src_loc = "42:1"]
        pub fn x264_10_slicetype_analyse(h: *mut x264_t, intra_minigop: c_int);
    }
}

#[c2rust::header_src = "/home/nwplayer123/Hacks/hex264/x264/encoder/set.h:28"]
pub mod encoder_set_h {
    use ::core::ffi::c_int;

    use super::bitstream_h::bs_t;
    use super::common_h::x264_t;
    use super::set_h::{x264_pps_t, x264_sps_t};
    use super::stdint_uintn_h::uint8_t;
    use super::x264_h::x264_param_t;
    extern "C" {
        #[c2rust::src_loc = "31:1"]
        pub fn x264_10_sps_init(sps: *mut x264_sps_t, i_id: c_int, param: *mut x264_param_t);
        #[c2rust::src_loc = "33:1"]
        pub fn x264_10_sps_init_reconfigurable(sps: *mut x264_sps_t, param: *mut x264_param_t);
        #[c2rust::src_loc = "35:1"]
        pub fn x264_10_sps_init_scaling_list(sps: *mut x264_sps_t, param: *mut x264_param_t);
        #[c2rust::src_loc = "37:1"]
        pub fn x264_10_sps_write(s: *mut bs_t, sps: *mut x264_sps_t);
        #[c2rust::src_loc = "39:1"]
        pub fn x264_10_pps_init(
            pps: *mut x264_pps_t,
            i_id: c_int,
            param: *mut x264_param_t,
            sps: *mut x264_sps_t,
        );
        #[c2rust::src_loc = "41:1"]
        pub fn x264_10_pps_write(s: *mut bs_t, sps: *mut x264_sps_t, pps: *mut x264_pps_t);
        #[c2rust::src_loc = "43:1"]
        pub fn x264_10_sei_recovery_point_write(
            h: *mut x264_t,
            s: *mut bs_t,
            recovery_frame_cnt: c_int,
        );
        #[c2rust::src_loc = "45:1"]
        pub fn x264_10_sei_version_write(h: *mut x264_t, s: *mut bs_t) -> c_int;
        #[c2rust::src_loc = "47:1"]
        pub fn x264_10_validate_levels(h: *mut x264_t, verbose: c_int) -> c_int;
        #[c2rust::src_loc = "49:1"]
        pub fn x264_10_sei_buffering_period_write(h: *mut x264_t, s: *mut bs_t);
        #[c2rust::src_loc = "51:1"]
        pub fn x264_10_sei_pic_timing_write(h: *mut x264_t, s: *mut bs_t);
        #[c2rust::src_loc = "53:1"]
        pub fn x264_10_sei_dec_ref_pic_marking_write(h: *mut x264_t, s: *mut bs_t);
        #[c2rust::src_loc = "61:1"]
        pub fn x264_10_sei_alternative_transfer_write(h: *mut x264_t, s: *mut bs_t);
        #[c2rust::src_loc = "63:1"]
        pub fn x264_10_sei_avcintra_umid_write(h: *mut x264_t, s: *mut bs_t) -> c_int;
        #[c2rust::src_loc = "65:1"]
        pub fn x264_10_sei_avcintra_vanc_write(h: *mut x264_t, s: *mut bs_t, len: c_int) -> c_int;
        #[c2rust::src_loc = "67:1"]
        pub fn x264_10_sei_write(
            s: *mut bs_t,
            payload: *mut uint8_t,
            payload_size: c_int,
            payload_type: c_int,
        );
        #[c2rust::src_loc = "69:1"]
        pub fn x264_10_filler_write(h: *mut x264_t, s: *mut bs_t, filler: c_int);
    }
}

#[c2rust::header_src = "/usr/include/pthread.h:28"]
pub mod pthread_h {
    use ::core::ffi::{c_int, c_void};

    use super::pthreadtypes_h::{
        pthread_cond_t, pthread_condattr_t, pthread_mutex_t, pthread_mutexattr_t,
    };
    extern "C" {
        #[c2rust::src_loc = "781:1"]
        pub fn pthread_mutex_init(
            __mutex: *mut pthread_mutex_t,
            __mutexattr: *const pthread_mutexattr_t,
        ) -> c_int;
        #[c2rust::src_loc = "786:1"]
        pub fn pthread_mutex_destroy(__mutex: *mut pthread_mutex_t) -> c_int;
        #[c2rust::src_loc = "794:1"]
        pub fn pthread_mutex_lock(__mutex: *mut pthread_mutex_t) -> c_int;
        #[c2rust::src_loc = "835:1"]
        pub fn pthread_mutex_unlock(__mutex: *mut pthread_mutex_t) -> c_int;
        #[c2rust::src_loc = "1112:1"]
        pub fn pthread_cond_init(
            __cond: *mut pthread_cond_t,
            __cond_attr: *const pthread_condattr_t,
        ) -> c_int;
        #[c2rust::src_loc = "1117:1"]
        pub fn pthread_cond_destroy(__cond: *mut pthread_cond_t) -> c_int;
        #[c2rust::src_loc = "1125:1"]
        pub fn pthread_cond_broadcast(__cond: *mut pthread_cond_t) -> c_int;
    }
    use super::pthreadtypes_h::{pthread_attr_t, pthread_t};
    extern "C" {
        #[c2rust::src_loc = "202:1"]
        pub fn pthread_create(
            __newthread: *mut pthread_t,
            __attr: *const pthread_attr_t,
            __start_routine: Option<unsafe extern "C" fn(*mut c_void) -> *mut c_void>,
            __arg: *mut c_void,
        ) -> c_int;
        #[c2rust::src_loc = "219:1"]
        pub fn pthread_join(__th: pthread_t, __thread_return: *mut *mut c_void) -> c_int;
        #[c2rust::src_loc = "1133:1"]
        pub fn pthread_cond_wait(
            __cond: *mut pthread_cond_t,
            __mutex: *mut pthread_mutex_t,
        ) -> c_int;
    }
}

#[c2rust::header_src = "/usr/include/bits/types/clockid_t.h:28"]
pub mod clockid_t_h {
    #[c2rust::src_loc = "7:1"]
    pub type clockid_t = __clockid_t;
    use super::types_h::__clockid_t;
}
#[c2rust::header_src = "/usr/include/time.h:28"]
pub mod time_h {
    use ::core::ffi::c_int;

    use super::clockid_t_h::clockid_t;
    use super::struct_timespec_h::timespec;
    extern "C" {
        #[c2rust::src_loc = "288:1"]
        pub fn clock_gettime(__clock_id: clockid_t, __tp: *mut timespec) -> c_int;
    }
}
#[c2rust::header_src = "/usr/include/bits/time.h:28"]
pub mod bits_time_h {
    use ::core::ffi::c_int;

    #[c2rust::src_loc = "48:10"]
    pub const CLOCK_MONOTONIC: c_int = 1 as c_int;
}

#[c2rust::header_src = "/usr/include/bits/cpu-set.h:28"]
pub mod cpu_set_h {
    #[c2rust::src_loc = "32:1"]
    pub type __cpu_mask = c_ulong;
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "39:9"]
    pub struct cpu_set_t {
        pub __bits: [__cpu_mask; 16],
    }
    use ::core::ffi::{c_int, c_ulong};

    use super::__stddef_size_t_h::size_t;
    extern "C" {
        #[c2rust::src_loc = "117:1"]
        pub fn __sched_cpucount(__setsize: size_t, __setp: *const cpu_set_t) -> c_int;
    }
}

#[c2rust::header_src = "/usr/include/sched.h:28"]
pub mod sched_h {
    use ::core::ffi::c_int;

    use super::__stddef_size_t_h::size_t;
    use super::cpu_set_h::cpu_set_t;
    use super::types_h::__pid_t;
    extern "C" {
        #[c2rust::src_loc = "134:1"]
        pub fn sched_getaffinity(
            __pid: __pid_t,
            __cpusetsize: size_t,
            __cpuset: *mut cpu_set_t,
        ) -> c_int;
    }
}

#[c2rust::header_src = "/usr/include/ctype.h:27"]
pub mod ctype_h {
    use ::core::ffi::{c_uint, c_ushort};

    #[c2rust::src_loc = "51:3"]
    pub const _ISdigit: C2RustUnnamed_5 = 2048;
    #[c2rust::src_loc = "46:1"]
    pub type C2RustUnnamed_5 = c_uint;
    #[c2rust::src_loc = "59:3"]
    pub const _ISalnum: C2RustUnnamed_5 = 8;
    #[c2rust::src_loc = "58:3"]
    pub const _ISpunct: C2RustUnnamed_5 = 4;
    #[c2rust::src_loc = "57:3"]
    pub const _IScntrl: C2RustUnnamed_5 = 2;
    #[c2rust::src_loc = "56:3"]
    pub const _ISblank: C2RustUnnamed_5 = 1;
    #[c2rust::src_loc = "55:3"]
    pub const _ISgraph: C2RustUnnamed_5 = 32768;
    #[c2rust::src_loc = "54:3"]
    pub const _ISprint: C2RustUnnamed_5 = 16384;
    #[c2rust::src_loc = "53:3"]
    pub const _ISspace: C2RustUnnamed_5 = 8192;
    #[c2rust::src_loc = "52:3"]
    pub const _ISxdigit: C2RustUnnamed_5 = 4096;
    #[c2rust::src_loc = "50:3"]
    pub const _ISalpha: C2RustUnnamed_5 = 1024;
    #[c2rust::src_loc = "49:3"]
    pub const _ISlower: C2RustUnnamed_5 = 512;
    #[c2rust::src_loc = "48:3"]
    pub const _ISupper: C2RustUnnamed_5 = 256;
    extern "C" {
        #[c2rust::src_loc = "79:1"]
        pub fn __ctype_b_loc() -> *mut *const c_ushort;
    }
}

#[c2rust::header_src = "/usr/include/malloc.h:32"]
pub mod malloc_h {
    use ::core::ffi::c_void;

    use super::__stddef_size_t_h::size_t;
    extern "C" {
        #[c2rust::src_loc = "39:1"]
        pub fn malloc(__size: size_t) -> *mut c_void;
        #[c2rust::src_loc = "51:1"]
        pub fn realloc(__ptr: *mut c_void, __size: size_t) -> *mut c_void;
        #[c2rust::src_loc = "64:1"]
        pub fn free(__ptr: *mut c_void);
        #[c2rust::src_loc = "67:1"]
        pub fn memalign(__alignment: size_t, __size: size_t) -> *mut c_void;
    }
}
#[c2rust::header_src = "/usr/include/sys/mman.h:27"]
pub mod mman_h {
    use ::core::ffi::{c_int, c_void};

    use super::__stddef_size_t_h::size_t;
    extern "C" {
        #[c2rust::src_loc = "94:1"]
        pub fn madvise(__addr: *mut c_void, __len: size_t, __advice: c_int) -> c_int;
    }
    #[c2rust::src_loc = "44:9"]
    pub const MAP_FAILED: *mut c_void = core::ptr::null_mut();
    use super::types_h::__off64_t;
    extern "C" {
        #[c2rust::src_loc = "61:1"]
        pub fn mmap(
            __addr: *mut c_void,
            __len: size_t,
            __prot: c_int,
            __flags: c_int,
            __fd: c_int,
            __offset: __off64_t,
        ) -> *mut c_void;
        #[c2rust::src_loc = "76:1"]
        pub fn munmap(__addr: *mut c_void, __len: size_t) -> c_int;
    }
}
#[c2rust::header_src = "/usr/include/bits/mman-linux.h:27"]
pub mod mman_linux_h {
    use ::core::ffi::c_int;

    #[c2rust::src_loc = "32:9"]
    pub const PROT_READ: c_int = 0x1 as c_int;
    #[c2rust::src_loc = "43:9"]
    pub const MAP_PRIVATE: c_int = 0x2 as c_int;
    #[c2rust::src_loc = "50:9"]
    pub const MAP_FIXED: c_int = 0x10 as c_int;
    #[c2rust::src_loc = "91:10"]
    pub const MADV_WILLNEED: c_int = 3 as c_int;
    #[c2rust::src_loc = "99:10"]
    pub const MADV_HUGEPAGE: c_int = 14 as c_int;
}

#[c2rust::header_src = "/home/nwplayer123/Hacks/hex264/x264/filters/video/internal.h:26"]
pub mod internal_h {
    use ::core::ffi::c_int;

    use super::input_h::cli_pic_t;
    extern "C" {
        #[c2rust::src_loc = "32:1"]
        pub fn x264_cli_pic_copy(out: *mut cli_pic_t, in_0: *mut cli_pic_t) -> c_int;
    }
}
#[c2rust::header_src = "/home/nwplayer123/Hacks/hex264/x264/filters/filters.h:27"]
pub mod filters_h {
    use ::core::ffi::{c_char, c_int};

    extern "C" {
        #[c2rust::src_loc = "34:1"]
        pub fn x264_get_option(name: *const c_char, split_options: *mut *mut c_char)
            -> *mut c_char;
        #[c2rust::src_loc = "37:1"]
        pub fn x264_otoi(str: *const c_char, def: c_int) -> c_int;
        #[c2rust::src_loc = "38:1"]
        pub fn x264_otos(str: *mut c_char, def: *mut c_char) -> *mut c_char;
    }
}

#[c2rust::header_src = "/usr/include/libavutil/opt.h:26"]
pub mod opt_h {
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "508:16"]
    pub struct AVOptionRanges {
        pub range: *mut *mut AVOptionRange,
        pub nb_ranges: c_int,
        pub nb_components: c_int,
    }
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "485:16"]
    pub struct AVOptionRange {
        pub str_0: *const c_char,
        pub value_min: c_double,
        pub value_max: c_double,
        pub component_min: c_double,
        pub component_max: c_double,
        pub is_range: c_int,
    }
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "429:16"]
    pub struct AVOption {
        pub name: *const c_char,
        pub help: *const c_char,
        pub offset: c_int,
        pub type_0: AVOptionType,
        pub default_val: C2RustUnnamed_5,
        pub min: c_double,
        pub max: c_double,
        pub flags: c_int,
        pub unit: *const c_char,
    }
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "451:5"]
    pub union C2RustUnnamed_5 {
        pub i64_0: int64_t,
        pub dbl: c_double,
        pub str_0: *const c_char,
        pub q: AVRational,
        pub arr: *const AVOptionArrayDef,
    }
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "395:16"]
    pub struct AVOptionArrayDef {
        pub def: *const c_char,
        pub size_min: c_uint,
        pub size_max: c_uint,
        pub sep: c_char,
    }
    #[c2rust::src_loc = "251:1"]
    pub type AVOptionType = c_uint;
    #[c2rust::src_loc = "346:5"]
    pub const AV_OPT_TYPE_FLAG_ARRAY: AVOptionType = 65536;
    #[c2rust::src_loc = "335:5"]
    pub const AV_OPT_TYPE_UINT: AVOptionType = 20;
    #[c2rust::src_loc = "331:5"]
    pub const AV_OPT_TYPE_CHLAYOUT: AVOptionType = 19;
    #[c2rust::src_loc = "327:5"]
    pub const AV_OPT_TYPE_BOOL: AVOptionType = 18;
    #[c2rust::src_loc = "323:5"]
    pub const AV_OPT_TYPE_COLOR: AVOptionType = 17;
    #[c2rust::src_loc = "319:5"]
    pub const AV_OPT_TYPE_DURATION: AVOptionType = 16;
    #[c2rust::src_loc = "315:5"]
    pub const AV_OPT_TYPE_VIDEO_RATE: AVOptionType = 15;
    #[c2rust::src_loc = "311:5"]
    pub const AV_OPT_TYPE_SAMPLE_FMT: AVOptionType = 14;
    #[c2rust::src_loc = "307:5"]
    pub const AV_OPT_TYPE_PIXEL_FMT: AVOptionType = 13;
    #[c2rust::src_loc = "303:5"]
    pub const AV_OPT_TYPE_IMAGE_SIZE: AVOptionType = 12;
    #[c2rust::src_loc = "299:5"]
    pub const AV_OPT_TYPE_CONST: AVOptionType = 11;
    #[c2rust::src_loc = "294:5"]
    pub const AV_OPT_TYPE_UINT64: AVOptionType = 10;
    #[c2rust::src_loc = "290:5"]
    pub const AV_OPT_TYPE_DICT: AVOptionType = 9;
    #[c2rust::src_loc = "286:5"]
    pub const AV_OPT_TYPE_BINARY: AVOptionType = 8;
    #[c2rust::src_loc = "280:5"]
    pub const AV_OPT_TYPE_RATIONAL: AVOptionType = 7;
    #[c2rust::src_loc = "276:5"]
    pub const AV_OPT_TYPE_STRING: AVOptionType = 6;
    #[c2rust::src_loc = "271:5"]
    pub const AV_OPT_TYPE_FLOAT: AVOptionType = 5;
    #[c2rust::src_loc = "267:5"]
    pub const AV_OPT_TYPE_DOUBLE: AVOptionType = 4;
    #[c2rust::src_loc = "263:5"]
    pub const AV_OPT_TYPE_INT64: AVOptionType = 3;
    #[c2rust::src_loc = "259:5"]
    pub const AV_OPT_TYPE_INT: AVOptionType = 2;
    #[c2rust::src_loc = "255:5"]
    pub const AV_OPT_TYPE_FLAGS: AVOptionType = 1;
    use ::core::ffi::{c_char, c_double, c_int, c_uint, c_void};

    use super::rational_h::AVRational;
    use super::stdint_intn_h::int64_t;
    extern "C" {
        #[c2rust::src_loc = "870:1"]
        pub fn av_opt_set_int(
            obj: *mut c_void,
            name: *const c_char,
            val: int64_t,
            search_flags: c_int,
        ) -> c_int;
    }
}
#[c2rust::header_src = "/usr/include/libavutil/rational.h:26"]
pub mod rational_h {
    use ::core::ffi::c_int;

    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "58:16"]
    pub struct AVRational {
        pub num: c_int,
        pub den: c_int,
    }
}

#[c2rust::header_src = "/home/nwplayer123/Hacks/hex264/x264/extras/avisynth_c.h:27"]
pub mod avisynth_c_h {
    #[c2rust::src_loc = "812:1"]
    pub type avs_is_y_func = Option<unsafe extern "C" fn(*const AVS_VideoInfo) -> c_int>;
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "618:16"]
    pub struct AVS_VideoInfo {
        pub width: c_int,
        pub height: c_int,
        pub fps_numerator: c_uint,
        pub fps_denominator: c_uint,
        pub num_frames: c_int,
        pub pixel_type: c_int,
        pub audio_samples_per_second: c_int,
        pub sample_type: c_int,
        pub num_audio_samples: int64_t,
        pub nchannels: c_int,
        pub image_type: c_int,
    }
    #[c2rust::src_loc = "810:1"]
    pub type avs_is_420_func = Option<unsafe extern "C" fn(*const AVS_VideoInfo) -> c_int>;
    #[c2rust::src_loc = "808:1"]
    pub type avs_is_422_func = Option<unsafe extern "C" fn(*const AVS_VideoInfo) -> c_int>;
    #[c2rust::src_loc = "806:1"]
    pub type avs_is_444_func = Option<unsafe extern "C" fn(*const AVS_VideoInfo) -> c_int>;
    #[c2rust::src_loc = "800:1"]
    pub type avs_is_y16_func = Option<unsafe extern "C" fn(*const AVS_VideoInfo) -> c_int>;
    #[c2rust::src_loc = "799:1"]
    pub type avs_is_yuv420p16_func = Option<unsafe extern "C" fn(*const AVS_VideoInfo) -> c_int>;
    #[c2rust::src_loc = "798:1"]
    pub type avs_is_yuv422p16_func = Option<unsafe extern "C" fn(*const AVS_VideoInfo) -> c_int>;
    #[c2rust::src_loc = "797:1"]
    pub type avs_is_yuv444p16_func = Option<unsafe extern "C" fn(*const AVS_VideoInfo) -> c_int>;
    #[c2rust::src_loc = "795:1"]
    pub type avs_is_rgb64_func = Option<unsafe extern "C" fn(*const AVS_VideoInfo) -> c_int>;
    #[c2rust::src_loc = "793:1"]
    pub type avs_is_rgb48_func = Option<unsafe extern "C" fn(*const AVS_VideoInfo) -> c_int>;
    #[c2rust::src_loc = "880:1"]
    pub type avs_get_read_ptr_p_func =
        Option<unsafe extern "C" fn(*const AVS_VideoFrame, c_int) -> *const BYTE>;
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "857:16"]
    pub struct AVS_VideoFrame {
        pub refcount: c_long,
        pub vfb: *mut AVS_VideoFrameBuffer,
        pub offset: c_int,
        pub pitch: c_int,
        pub row_size: c_int,
        pub height: c_int,
        pub offsetU: c_int,
        pub offsetV: c_int,
        pub pitchUV: c_int,
        pub row_sizeUV: c_int,
        pub heightUV: c_int,
        pub offsetA: c_int,
        pub pitchA: c_int,
        pub row_sizeA: c_int,
        pub properties: *mut c_void,
    }
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "841:16"]
    pub struct AVS_VideoFrameBuffer {
        pub data: *mut BYTE,
        pub data_size: c_int,
        pub sequence_number: c_long,
        pub refcount: c_long,
        pub device: *mut c_void,
    }
    #[c2rust::src_loc = "257:1"]
    pub type BYTE = uint8_t;
    #[c2rust::src_loc = "874:1"]
    pub type avs_get_pitch_p_func =
        Option<unsafe extern "C" fn(*const AVS_VideoFrame, c_int) -> c_int>;
    #[c2rust::src_loc = "665:1"]
    pub type avs_is_y8_func = Option<unsafe extern "C" fn(*const AVS_VideoInfo) -> c_int>;
    #[c2rust::src_loc = "663:1"]
    pub type avs_is_yv411_func = Option<unsafe extern "C" fn(*const AVS_VideoInfo) -> c_int>;
    #[c2rust::src_loc = "661:1"]
    pub type avs_is_yv12_func = Option<unsafe extern "C" fn(*const AVS_VideoInfo) -> c_int>;
    #[c2rust::src_loc = "659:1"]
    pub type avs_is_yv16_func = Option<unsafe extern "C" fn(*const AVS_VideoInfo) -> c_int>;
    #[c2rust::src_loc = "657:1"]
    pub type avs_is_yv24_func = Option<unsafe extern "C" fn(*const AVS_VideoInfo) -> c_int>;
    #[c2rust::src_loc = "1022:1"]
    pub type avs_take_clip_func =
        Option<unsafe extern "C" fn(AVS_Value, *mut AVS_ScriptEnvironment) -> *mut AVS_Clip>;
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "994:8"]
    pub struct AVS_Value {
        pub type_0: c_short,
        pub array_size: c_short,
        pub d: C2RustUnnamed_0,
    }
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "998:3"]
    pub union C2RustUnnamed_0 {
        pub clip: *mut c_void,
        pub boolean: c_char,
        pub integer: c_int,
        pub floating_pt: c_float,
        pub string: *const c_char,
        pub array: *const AVS_Value,
        pub function: *mut c_void,
        pub longlong: int64_t,
        pub double_pt: c_double,
    }
    #[c2rust::src_loc = "937:1"]
    pub type avs_release_video_frame_func = Option<unsafe extern "C" fn(*mut AVS_VideoFrame) -> ()>;
    #[c2rust::src_loc = "1021:1"]
    pub type avs_release_value_func = Option<unsafe extern "C" fn(AVS_Value) -> ()>;
    #[c2rust::src_loc = "1079:1"]
    pub type avs_release_clip_func = Option<unsafe extern "C" fn(*mut AVS_Clip) -> ()>;
    #[c2rust::src_loc = "1199:1"]
    pub type avs_invoke_func = Option<
        unsafe extern "C" fn(
            *mut AVS_ScriptEnvironment,
            *const c_char,
            AVS_Value,
            *mut *const c_char,
        ) -> AVS_Value,
    >;
    #[c2rust::src_loc = "1197:1"]
    pub type avs_function_exists_func =
        Option<unsafe extern "C" fn(*mut AVS_ScriptEnvironment, *const c_char) -> c_int>;
    #[c2rust::src_loc = "1084:1"]
    pub type avs_get_video_info_func =
        Option<unsafe extern "C" fn(*mut AVS_Clip) -> *const AVS_VideoInfo>;
    #[c2rust::src_loc = "1088:1"]
    pub type avs_get_frame_func =
        Option<unsafe extern "C" fn(*mut AVS_Clip, c_int) -> *mut AVS_VideoFrame>;
    #[c2rust::src_loc = "1183:1"]
    pub type avs_get_error_func =
        Option<unsafe extern "C" fn(*mut AVS_ScriptEnvironment) -> *const c_char>;
    #[c2rust::src_loc = "1265:1"]
    pub type avs_delete_script_environment_func =
        Option<unsafe extern "C" fn(*mut AVS_ScriptEnvironment) -> ()>;
    #[c2rust::src_loc = "1257:1"]
    pub type avs_create_script_environment_func =
        Option<unsafe extern "C" fn(c_int) -> *mut AVS_ScriptEnvironment>;
    #[c2rust::src_loc = "1082:1"]
    pub type avs_clip_get_error_func = Option<unsafe extern "C" fn(*mut AVS_Clip) -> *const c_char>;
    #[c2rust::src_loc = "282:7"]
    pub const AVS_PLANAR_V: C2RustUnnamed_1 = 4;
    #[c2rust::src_loc = "281:7"]
    pub const AVS_PLANAR_U: C2RustUnnamed_1 = 2;
    #[c2rust::src_loc = "280:7"]
    pub const AVS_PLANAR_Y: C2RustUnnamed_1 = 1;
    #[c2rust::src_loc = "287:7"]
    pub const AVS_PLANAR_A: C2RustUnnamed_1 = 16;
    #[c2rust::src_loc = "288:7"]
    pub const AVS_PLANAR_R: C2RustUnnamed_1 = 32;
    #[c2rust::src_loc = "290:7"]
    pub const AVS_PLANAR_B: C2RustUnnamed_1 = 128;
    #[c2rust::src_loc = "330:5"]
    pub const AVS_CS_PLANAR_FILTER: C2RustUnnamed_2 = -25;
    #[c2rust::src_loc = "361:3"]
    pub const AVS_CS_YV411: C2RustUnnamed_3 = -1610611959;
    #[c2rust::src_loc = "329:5"]
    pub const AVS_CS_PLANAR_MASK: C2RustUnnamed_2 = -133757177;
    #[c2rust::src_loc = "351:3"]
    pub const AVS_CS_YUY2: C2RustUnnamed_3 = 1610612740;
    #[c2rust::src_loc = "363:3"]
    pub const AVS_CS_Y8: C2RustUnnamed_3 = -536870912;
    #[c2rust::src_loc = "358:3"]
    pub const AVS_CS_YV12: C2RustUnnamed_3 = -1610612728;
    #[c2rust::src_loc = "357:3"]
    pub const AVS_CS_YV16: C2RustUnnamed_3 = -1610611960;
    #[c2rust::src_loc = "356:3"]
    pub const AVS_CS_YV24: C2RustUnnamed_3 = -1610611957;
    #[c2rust::src_loc = "322:5"]
    pub const AVS_CS_SAMPLE_BITS_8: C2RustUnnamed_2 = 0;
    #[c2rust::src_loc = "321:5"]
    pub const AVS_CS_SAMPLE_BITS_MASK: C2RustUnnamed_2 = 458752;
    #[c2rust::src_loc = "349:3"]
    pub const AVS_CS_BGR24: C2RustUnnamed_3 = 1342177281;
    #[c2rust::src_loc = "350:3"]
    pub const AVS_CS_BGR32: C2RustUnnamed_3 = 1342177282;
    #[c2rust::src_loc = "444:3"]
    pub const AVS_IT_TFF: C2RustUnnamed_4 = 2;
    #[c2rust::src_loc = "445:3"]
    pub const AVS_IT_FIELDBASED: C2RustUnnamed_4 = 4;
    #[c2rust::src_loc = "280:1"]
    pub type C2RustUnnamed_1 = c_uint;
    #[c2rust::src_loc = "294:7"]
    pub const AVS_PLANAR_B_ALIGNED: C2RustUnnamed_1 = 136;
    #[c2rust::src_loc = "293:7"]
    pub const AVS_PLANAR_G_ALIGNED: C2RustUnnamed_1 = 72;
    #[c2rust::src_loc = "292:7"]
    pub const AVS_PLANAR_R_ALIGNED: C2RustUnnamed_1 = 40;
    #[c2rust::src_loc = "291:7"]
    pub const AVS_PLANAR_A_ALIGNED: C2RustUnnamed_1 = 24;
    #[c2rust::src_loc = "289:7"]
    pub const AVS_PLANAR_G: C2RustUnnamed_1 = 64;
    #[c2rust::src_loc = "286:7"]
    pub const AVS_PLANAR_V_ALIGNED: C2RustUnnamed_1 = 12;
    #[c2rust::src_loc = "285:7"]
    pub const AVS_PLANAR_U_ALIGNED: C2RustUnnamed_1 = 10;
    #[c2rust::src_loc = "284:7"]
    pub const AVS_PLANAR_Y_ALIGNED: C2RustUnnamed_1 = 9;
    #[c2rust::src_loc = "283:7"]
    pub const AVS_PLANAR_ALIGNED: C2RustUnnamed_1 = 8;
    #[c2rust::src_loc = "297:1"]
    pub type C2RustUnnamed_2 = c_int;
    #[c2rust::src_loc = "343:5"]
    pub const AVS_CS_GENERIC_YUVA444: C2RustUnnamed_2 = -2013265141;
    #[c2rust::src_loc = "342:5"]
    pub const AVS_CS_GENERIC_YUVA422: C2RustUnnamed_2 = -2013265144;
    #[c2rust::src_loc = "341:5"]
    pub const AVS_CS_GENERIC_YUVA420: C2RustUnnamed_2 = -2013265912;
    #[c2rust::src_loc = "340:5"]
    pub const AVS_CS_GENERIC_RGBAP: C2RustUnnamed_2 = -1879048190;
    #[c2rust::src_loc = "339:5"]
    pub const AVS_CS_GENERIC_RGBP: C2RustUnnamed_2 = -1879048191;
    #[c2rust::src_loc = "338:5"]
    pub const AVS_CS_GENERIC_Y: C2RustUnnamed_2 = -536870912;
    #[c2rust::src_loc = "337:5"]
    pub const AVS_CS_GENERIC_YUV444: C2RustUnnamed_2 = -1610611957;
    #[c2rust::src_loc = "336:5"]
    pub const AVS_CS_GENERIC_YUV422: C2RustUnnamed_2 = -1610611960;
    #[c2rust::src_loc = "335:5"]
    pub const AVS_CS_GENERIC_YUV420: C2RustUnnamed_2 = -1610612728;
    #[c2rust::src_loc = "333:5"]
    pub const AVS_CS_RGBA_TYPE: C2RustUnnamed_2 = 2;
    #[c2rust::src_loc = "332:5"]
    pub const AVS_CS_RGB_TYPE: C2RustUnnamed_2 = 1;
    #[c2rust::src_loc = "327:5"]
    pub const AVS_CS_SAMPLE_BITS_32: C2RustUnnamed_2 = 131072;
    #[c2rust::src_loc = "326:5"]
    pub const AVS_CS_SAMPLE_BITS_16: C2RustUnnamed_2 = 65536;
    #[c2rust::src_loc = "325:5"]
    pub const AVS_CS_SAMPLE_BITS_14: C2RustUnnamed_2 = 458752;
    #[c2rust::src_loc = "324:5"]
    pub const AVS_CS_SAMPLE_BITS_12: C2RustUnnamed_2 = 393216;
    #[c2rust::src_loc = "323:5"]
    pub const AVS_CS_SAMPLE_BITS_10: C2RustUnnamed_2 = 327680;
    #[c2rust::src_loc = "319:5"]
    pub const AVS_CS_SUB_HEIGHT_4: C2RustUnnamed_2 = 256;
    #[c2rust::src_loc = "318:5"]
    pub const AVS_CS_SUB_HEIGHT_2: C2RustUnnamed_2 = 0;
    #[c2rust::src_loc = "317:5"]
    pub const AVS_CS_SUB_HEIGHT_1: C2RustUnnamed_2 = 768;
    #[c2rust::src_loc = "316:5"]
    pub const AVS_CS_SUB_HEIGHT_MASK: C2RustUnnamed_2 = 1792;
    #[c2rust::src_loc = "314:5"]
    pub const AVS_CS_UPLANEFIRST: C2RustUnnamed_2 = 16;
    #[c2rust::src_loc = "313:5"]
    pub const AVS_CS_VPLANEFIRST: C2RustUnnamed_2 = 8;
    #[c2rust::src_loc = "311:5"]
    pub const AVS_CS_SUB_WIDTH_4: C2RustUnnamed_2 = 1;
    #[c2rust::src_loc = "310:5"]
    pub const AVS_CS_SUB_WIDTH_2: C2RustUnnamed_2 = 0;
    #[c2rust::src_loc = "309:5"]
    pub const AVS_CS_SUB_WIDTH_1: C2RustUnnamed_2 = 3;
    #[c2rust::src_loc = "308:5"]
    pub const AVS_CS_SUB_WIDTH_MASK: C2RustUnnamed_2 = 7;
    #[c2rust::src_loc = "306:5"]
    pub const AVS_CS_SHIFT_SAMPLE_BITS: C2RustUnnamed_2 = 16;
    #[c2rust::src_loc = "305:5"]
    pub const AVS_CS_SHIFT_SUB_HEIGHT: C2RustUnnamed_2 = 8;
    #[c2rust::src_loc = "304:5"]
    pub const AVS_CS_SHIFT_SUB_WIDTH: C2RustUnnamed_2 = 0;
    #[c2rust::src_loc = "302:5"]
    pub const AVS_CS_PLANAR: C2RustUnnamed_2 = -2147483648;
    #[c2rust::src_loc = "301:5"]
    pub const AVS_CS_INTERLEAVED: C2RustUnnamed_2 = 1073741824;
    #[c2rust::src_loc = "300:5"]
    pub const AVS_CS_YUV: C2RustUnnamed_2 = 536870912;
    #[c2rust::src_loc = "299:5"]
    pub const AVS_CS_BGR: C2RustUnnamed_2 = 268435456;
    #[c2rust::src_loc = "298:5"]
    pub const AVS_CS_YUVA: C2RustUnnamed_2 = 134217728;
    #[c2rust::src_loc = "347:1"]
    pub type C2RustUnnamed_3 = c_int;
    #[c2rust::src_loc = "438:3"]
    pub const AVS_CS_YUVA420PS: C2RustUnnamed_3 = -2013134840;
    #[c2rust::src_loc = "437:3"]
    pub const AVS_CS_YUVA422PS: C2RustUnnamed_3 = -2013134072;
    #[c2rust::src_loc = "436:3"]
    pub const AVS_CS_YUVA444PS: C2RustUnnamed_3 = -2013134069;
    #[c2rust::src_loc = "434:3"]
    pub const AVS_CS_YUVA420P16: C2RustUnnamed_3 = -2013200376;
    #[c2rust::src_loc = "433:3"]
    pub const AVS_CS_YUVA422P16: C2RustUnnamed_3 = -2013199608;
    #[c2rust::src_loc = "432:3"]
    pub const AVS_CS_YUVA444P16: C2RustUnnamed_3 = -2013199605;
    #[c2rust::src_loc = "430:3"]
    pub const AVS_CS_YUVA420P14: C2RustUnnamed_3 = -2012807160;
    #[c2rust::src_loc = "429:3"]
    pub const AVS_CS_YUVA422P14: C2RustUnnamed_3 = -2012806392;
    #[c2rust::src_loc = "428:3"]
    pub const AVS_CS_YUVA444P14: C2RustUnnamed_3 = -2012806389;
    #[c2rust::src_loc = "426:3"]
    pub const AVS_CS_YUVA420P12: C2RustUnnamed_3 = -2012872696;
    #[c2rust::src_loc = "425:3"]
    pub const AVS_CS_YUVA422P12: C2RustUnnamed_3 = -2012871928;
    #[c2rust::src_loc = "424:3"]
    pub const AVS_CS_YUVA444P12: C2RustUnnamed_3 = -2012871925;
    #[c2rust::src_loc = "422:3"]
    pub const AVS_CS_YUVA420P10: C2RustUnnamed_3 = -2012938232;
    #[c2rust::src_loc = "421:3"]
    pub const AVS_CS_YUVA422P10: C2RustUnnamed_3 = -2012937464;
    #[c2rust::src_loc = "420:3"]
    pub const AVS_CS_YUVA444P10: C2RustUnnamed_3 = -2012937461;
    #[c2rust::src_loc = "418:3"]
    pub const AVS_CS_YUVA420: C2RustUnnamed_3 = -2013265912;
    #[c2rust::src_loc = "417:3"]
    pub const AVS_CS_YUVA422: C2RustUnnamed_3 = -2013265144;
    #[c2rust::src_loc = "416:3"]
    pub const AVS_CS_YUVA444: C2RustUnnamed_3 = -2013265141;
    #[c2rust::src_loc = "413:3"]
    pub const AVS_CS_RGBAPS: C2RustUnnamed_3 = -1878917118;
    #[c2rust::src_loc = "412:3"]
    pub const AVS_CS_RGBAP16: C2RustUnnamed_3 = -1878982654;
    #[c2rust::src_loc = "411:3"]
    pub const AVS_CS_RGBAP14: C2RustUnnamed_3 = -1878589438;
    #[c2rust::src_loc = "410:3"]
    pub const AVS_CS_RGBAP12: C2RustUnnamed_3 = -1878654974;
    #[c2rust::src_loc = "409:3"]
    pub const AVS_CS_RGBAP10: C2RustUnnamed_3 = -1878720510;
    #[c2rust::src_loc = "408:3"]
    pub const AVS_CS_RGBAP: C2RustUnnamed_3 = -1879048190;
    #[c2rust::src_loc = "405:3"]
    pub const AVS_CS_RGBPS: C2RustUnnamed_3 = -1878917119;
    #[c2rust::src_loc = "404:3"]
    pub const AVS_CS_RGBP16: C2RustUnnamed_3 = -1878982655;
    #[c2rust::src_loc = "403:3"]
    pub const AVS_CS_RGBP14: C2RustUnnamed_3 = -1878589439;
    #[c2rust::src_loc = "402:3"]
    pub const AVS_CS_RGBP12: C2RustUnnamed_3 = -1878654975;
    #[c2rust::src_loc = "401:3"]
    pub const AVS_CS_RGBP10: C2RustUnnamed_3 = -1878720511;
    #[c2rust::src_loc = "400:3"]
    pub const AVS_CS_RGBP: C2RustUnnamed_3 = -1879048191;
    #[c2rust::src_loc = "396:3"]
    pub const AVS_CS_BGR64: C2RustUnnamed_3 = 1342242818;
    #[c2rust::src_loc = "395:3"]
    pub const AVS_CS_BGR48: C2RustUnnamed_3 = 1342242817;
    #[c2rust::src_loc = "392:3"]
    pub const AVS_CS_Y32: C2RustUnnamed_3 = -536739840;
    #[c2rust::src_loc = "391:3"]
    pub const AVS_CS_YUV420PS: C2RustUnnamed_3 = -1610481656;
    #[c2rust::src_loc = "390:3"]
    pub const AVS_CS_YUV422PS: C2RustUnnamed_3 = -1610480888;
    #[c2rust::src_loc = "389:3"]
    pub const AVS_CS_YUV444PS: C2RustUnnamed_3 = -1610480885;
    #[c2rust::src_loc = "386:3"]
    pub const AVS_CS_Y16: C2RustUnnamed_3 = -536805376;
    #[c2rust::src_loc = "385:3"]
    pub const AVS_CS_YUV420P16: C2RustUnnamed_3 = -1610547192;
    #[c2rust::src_loc = "384:3"]
    pub const AVS_CS_YUV422P16: C2RustUnnamed_3 = -1610546424;
    #[c2rust::src_loc = "383:3"]
    pub const AVS_CS_YUV444P16: C2RustUnnamed_3 = -1610546421;
    #[c2rust::src_loc = "381:3"]
    pub const AVS_CS_Y14: C2RustUnnamed_3 = -536412160;
    #[c2rust::src_loc = "380:3"]
    pub const AVS_CS_YUV420P14: C2RustUnnamed_3 = -1610153976;
    #[c2rust::src_loc = "379:3"]
    pub const AVS_CS_YUV422P14: C2RustUnnamed_3 = -1610153208;
    #[c2rust::src_loc = "378:3"]
    pub const AVS_CS_YUV444P14: C2RustUnnamed_3 = -1610153205;
    #[c2rust::src_loc = "376:3"]
    pub const AVS_CS_Y12: C2RustUnnamed_3 = -536477696;
    #[c2rust::src_loc = "375:3"]
    pub const AVS_CS_YUV420P12: C2RustUnnamed_3 = -1610219512;
    #[c2rust::src_loc = "374:3"]
    pub const AVS_CS_YUV422P12: C2RustUnnamed_3 = -1610218744;
    #[c2rust::src_loc = "373:3"]
    pub const AVS_CS_YUV444P12: C2RustUnnamed_3 = -1610218741;
    #[c2rust::src_loc = "371:3"]
    pub const AVS_CS_Y10: C2RustUnnamed_3 = -536543232;
    #[c2rust::src_loc = "370:3"]
    pub const AVS_CS_YUV420P10: C2RustUnnamed_3 = -1610285048;
    #[c2rust::src_loc = "369:3"]
    pub const AVS_CS_YUV422P10: C2RustUnnamed_3 = -1610284280;
    #[c2rust::src_loc = "368:3"]
    pub const AVS_CS_YUV444P10: C2RustUnnamed_3 = -1610284277;
    #[c2rust::src_loc = "362:3"]
    pub const AVS_CS_YUV9: C2RustUnnamed_3 = -1610612471;
    #[c2rust::src_loc = "360:3"]
    pub const AVS_CS_IYUV: C2RustUnnamed_3 = -1610612720;
    #[c2rust::src_loc = "359:3"]
    pub const AVS_CS_I420: C2RustUnnamed_3 = -1610612720;
    #[c2rust::src_loc = "354:3"]
    pub const AVS_CS_RAW32: C2RustUnnamed_3 = 1073741856;
    #[c2rust::src_loc = "348:3"]
    pub const AVS_CS_UNKNOWN: C2RustUnnamed_3 = 0;
    #[c2rust::src_loc = "442:1"]
    pub type C2RustUnnamed_4 = c_uint;
    #[c2rust::src_loc = "443:3"]
    pub const AVS_IT_BFF: C2RustUnnamed_4 = 1;
    #[inline]
    #[c2rust::src_loc = "636:1"]
    pub unsafe extern "C" fn avs_has_video(mut p: *const AVS_VideoInfo) -> c_int {
        return ((*p).width != 0 as c_int) as c_int;
    }
    #[inline]
    #[c2rust::src_loc = "645:1"]
    pub unsafe extern "C" fn avs_is_rgb24(mut p: *const AVS_VideoInfo) -> c_int {
        return ((*p).pixel_type & AVS_CS_BGR24 as c_int == AVS_CS_BGR24 as c_int
            && (*p).pixel_type & AVS_CS_SAMPLE_BITS_MASK as c_int == AVS_CS_SAMPLE_BITS_8 as c_int)
            as c_int;
    }
    #[inline]
    #[c2rust::src_loc = "648:1"]
    pub unsafe extern "C" fn avs_is_rgb32(mut p: *const AVS_VideoInfo) -> c_int {
        return ((*p).pixel_type & AVS_CS_BGR32 as c_int == AVS_CS_BGR32 as c_int
            && (*p).pixel_type & AVS_CS_SAMPLE_BITS_MASK as c_int == AVS_CS_SAMPLE_BITS_8 as c_int)
            as c_int;
    }
    #[inline]
    #[c2rust::src_loc = "654:1"]
    pub unsafe extern "C" fn avs_is_yuy2(mut p: *const AVS_VideoInfo) -> c_int {
        return ((*p).pixel_type & AVS_CS_YUY2 as c_int == AVS_CS_YUY2 as c_int) as c_int;
    }
    #[inline]
    #[c2rust::src_loc = "668:1"]
    pub unsafe extern "C" fn avs_is_yv24(mut p: *const AVS_VideoInfo) -> c_int {
        return ((*p).pixel_type & AVS_CS_PLANAR_MASK as c_int
            == AVS_CS_YV24 as c_int & AVS_CS_PLANAR_FILTER as c_int) as c_int;
    }
    #[inline]
    #[c2rust::src_loc = "671:1"]
    pub unsafe extern "C" fn avs_is_yv16(mut p: *const AVS_VideoInfo) -> c_int {
        return ((*p).pixel_type & AVS_CS_PLANAR_MASK as c_int
            == AVS_CS_YV16 as c_int & AVS_CS_PLANAR_FILTER as c_int) as c_int;
    }
    #[inline]
    #[c2rust::src_loc = "674:1"]
    pub unsafe extern "C" fn avs_is_yv12(mut p: *const AVS_VideoInfo) -> c_int {
        return ((*p).pixel_type & AVS_CS_PLANAR_MASK as c_int
            == AVS_CS_YV12 as c_int & AVS_CS_PLANAR_FILTER as c_int) as c_int;
    }
    #[inline]
    #[c2rust::src_loc = "677:1"]
    pub unsafe extern "C" fn avs_is_yv411(mut p: *const AVS_VideoInfo) -> c_int {
        return ((*p).pixel_type & AVS_CS_PLANAR_MASK as c_int
            == AVS_CS_YV411 as c_int & AVS_CS_PLANAR_FILTER as c_int) as c_int;
    }
    #[inline]
    #[c2rust::src_loc = "680:1"]
    pub unsafe extern "C" fn avs_is_y8(mut p: *const AVS_VideoInfo) -> c_int {
        return ((*p).pixel_type & AVS_CS_PLANAR_MASK as c_int
            == AVS_CS_Y8 as c_int & AVS_CS_PLANAR_FILTER as c_int) as c_int;
    }
    #[inline]
    #[c2rust::src_loc = "709:1"]
    pub unsafe extern "C" fn avs_is_field_based(mut p: *const AVS_VideoInfo) -> c_int {
        return ((*p).image_type & AVS_IT_FIELDBASED as c_int != 0) as c_int;
    }
    #[inline]
    #[c2rust::src_loc = "724:1"]
    pub unsafe extern "C" fn avs_is_tff(mut p: *const AVS_VideoInfo) -> c_int {
        return ((*p).image_type & AVS_IT_TFF as c_int != 0) as c_int;
    }
    #[inline]
    #[c2rust::src_loc = "883:1"]
    pub unsafe extern "C" fn avs_get_pitch_p(
        mut p: *const AVS_VideoFrame,
        mut plane: c_int,
    ) -> c_int {
        match plane {
            2 | 4 => return (*p).pitchUV,
            16 => return (*p).pitchA,
            _ => {}
        }
        return (*p).pitch;
    }
    #[inline]
    #[c2rust::src_loc = "916:1"]
    pub unsafe extern "C" fn avs_get_read_ptr_p(
        mut p: *const AVS_VideoFrame,
        mut plane: c_int,
    ) -> *const BYTE {
        match plane {
            2 | 128 => return (*(*p).vfb).data.offset((*p).offsetU as isize),
            4 | 32 => return (*(*p).vfb).data.offset((*p).offsetV as isize),
            16 => return (*(*p).vfb).data.offset((*p).offsetA as isize),
            _ => {}
        }
        return (*(*p).vfb).data.offset((*p).offset as isize);
    }
    #[inline]
    #[c2rust::src_loc = "1028:1"]
    pub unsafe extern "C" fn avs_is_clip(mut v: AVS_Value) -> c_int {
        return (v.type_0 as c_int == 'c' as i32) as c_int;
    }
    #[inline]
    #[c2rust::src_loc = "1030:1"]
    pub unsafe extern "C" fn avs_is_int(mut v: AVS_Value) -> c_int {
        return (v.type_0 as c_int == 'i' as i32) as c_int;
    }
    #[inline]
    #[c2rust::src_loc = "1031:1"]
    pub unsafe extern "C" fn avs_is_float(mut v: AVS_Value) -> c_int {
        return (v.type_0 as c_int == 'f' as i32 || v.type_0 as c_int == 'i' as i32) as c_int;
    }
    #[inline]
    #[c2rust::src_loc = "1032:1"]
    pub unsafe extern "C" fn avs_is_string(mut v: AVS_Value) -> c_int {
        return (v.type_0 as c_int == 's' as i32) as c_int;
    }
    #[inline]
    #[c2rust::src_loc = "1034:1"]
    pub unsafe extern "C" fn avs_is_error(mut v: AVS_Value) -> c_int {
        return (v.type_0 as c_int == 'e' as i32) as c_int;
    }
    #[inline]
    #[c2rust::src_loc = "1038:1"]
    pub unsafe extern "C" fn avs_as_int(mut v: AVS_Value) -> c_int {
        return v.d.integer;
    }
    #[inline]
    #[c2rust::src_loc = "1040:1"]
    pub unsafe extern "C" fn avs_as_string(mut v: AVS_Value) -> *const c_char {
        return if avs_is_error(v) != 0 || avs_is_string(v) != 0 {
            v.d.string
        } else {
            0 as *const c_char
        };
    }
    #[inline]
    #[c2rust::src_loc = "1042:1"]
    pub unsafe extern "C" fn avs_as_float(mut v: AVS_Value) -> c_double {
        return (if avs_is_int(v) != 0 {
            v.d.integer as c_float
        } else {
            v.d.floating_pt
        }) as c_double;
    }
    #[inline]
    #[c2rust::src_loc = "1044:1"]
    pub unsafe extern "C" fn avs_as_error(mut v: AVS_Value) -> *const c_char {
        return if avs_is_error(v) != 0 {
            v.d.string
        } else {
            0 as *const c_char
        };
    }
    #[inline]
    #[c2rust::src_loc = "1055:1"]
    pub unsafe extern "C" fn avs_new_value_bool(mut v0: c_int) -> AVS_Value {
        let mut v: AVS_Value = AVS_Value {
            type_0: 0,
            array_size: 0,
            d: C2RustUnnamed_0 {
                clip: 0 as *mut c_void,
            },
        };
        v.type_0 = 'b' as i32 as c_short;
        v.d.boolean = (if v0 == 0 as c_int {
            0 as c_int
        } else {
            1 as c_int
        }) as c_char;
        return v;
    }
    #[inline]
    #[c2rust::src_loc = "1059:1"]
    pub unsafe extern "C" fn avs_new_value_string(mut v0: *const c_char) -> AVS_Value {
        let mut v: AVS_Value = AVS_Value {
            type_0: 0,
            array_size: 0,
            d: C2RustUnnamed_0 {
                clip: 0 as *mut c_void,
            },
        };
        v.type_0 = 's' as i32 as c_short;
        v.d.string = v0;
        return v;
    }
    #[inline]
    #[c2rust::src_loc = "1070:1"]
    pub unsafe extern "C" fn avs_new_value_array(
        mut v0: *mut AVS_Value,
        mut size: c_int,
    ) -> AVS_Value {
        let mut v: AVS_Value = AVS_Value {
            type_0: 0,
            array_size: 0,
            d: C2RustUnnamed_0 {
                clip: 0 as *mut c_void,
            },
        };
        v.type_0 = 'a' as i32 as c_short;
        v.d.array = v0;
        v.array_size = size as c_short;
        return v;
    }
    use ::core::ffi::{c_char, c_double, c_float, c_int, c_long, c_short, c_uint, c_void};

    use super::stdint_intn_h::int64_t;
    use super::stdint_uintn_h::uint8_t;
    extern "C" {
        #[c2rust::src_loc = "610:16"]
        pub type AVS_ScriptEnvironment;
        #[c2rust::src_loc = "609:16"]
        pub type AVS_Clip;
    }
}
#[c2rust::header_src = "/usr/include/bits/dlfcn.h:27"]
pub mod bits_dlfcn_h {
    use ::core::ffi::c_int;

    #[c2rust::src_loc = "25:9"]
    pub const RTLD_NOW: c_int = 0x2 as c_int;
}
#[c2rust::header_src = "/usr/include/dlfcn.h:27"]
pub mod dlfcn_h {
    use ::core::ffi::{c_char, c_int, c_void};

    extern "C" {
        #[c2rust::src_loc = "56:1"]
        pub fn dlopen(__file: *const c_char, __mode: c_int) -> *mut c_void;
        #[c2rust::src_loc = "60:1"]
        pub fn dlclose(__handle: *mut c_void) -> c_int;
        #[c2rust::src_loc = "64:1"]
        pub fn dlsym(__handle: *mut c_void, __name: *const c_char) -> *mut c_void;
    }
}
#[c2rust::header_src = "/usr/include/bits/confname.h:27"]
pub mod confname_h {
    use ::core::ffi::c_uint;

    #[c2rust::src_loc = "133:5"]
    pub const _SC_PAGESIZE: C2RustUnnamed = 30;
    #[c2rust::src_loc = "71:1"]
    pub type C2RustUnnamed = c_uint;
    #[c2rust::src_loc = "534:5"]
    pub const _SC_SIGSTKSZ: C2RustUnnamed = 250;
    #[c2rust::src_loc = "531:5"]
    pub const _SC_MINSIGSTKSZ: C2RustUnnamed = 249;
    #[c2rust::src_loc = "528:5"]
    pub const _SC_THREAD_ROBUST_PRIO_PROTECT: C2RustUnnamed = 248;
    #[c2rust::src_loc = "526:5"]
    pub const _SC_THREAD_ROBUST_PRIO_INHERIT: C2RustUnnamed = 247;
    #[c2rust::src_loc = "523:5"]
    pub const _SC_XOPEN_STREAMS: C2RustUnnamed = 246;
    #[c2rust::src_loc = "520:5"]
    pub const _SC_TRACE_USER_EVENT_MAX: C2RustUnnamed = 245;
    #[c2rust::src_loc = "518:5"]
    pub const _SC_TRACE_SYS_MAX: C2RustUnnamed = 244;
    #[c2rust::src_loc = "516:5"]
    pub const _SC_TRACE_NAME_MAX: C2RustUnnamed = 243;
    #[c2rust::src_loc = "514:5"]
    pub const _SC_TRACE_EVENT_NAME_MAX: C2RustUnnamed = 242;
    #[c2rust::src_loc = "511:5"]
    pub const _SC_SS_REPL_MAX: C2RustUnnamed = 241;
    #[c2rust::src_loc = "508:5"]
    pub const _SC_V7_LPBIG_OFFBIG: C2RustUnnamed = 240;
    #[c2rust::src_loc = "506:5"]
    pub const _SC_V7_LP64_OFF64: C2RustUnnamed = 239;
    #[c2rust::src_loc = "504:5"]
    pub const _SC_V7_ILP32_OFFBIG: C2RustUnnamed = 238;
    #[c2rust::src_loc = "502:5"]
    pub const _SC_V7_ILP32_OFF32: C2RustUnnamed = 237;
    #[c2rust::src_loc = "499:5"]
    pub const _SC_RAW_SOCKETS: C2RustUnnamed = 236;
    #[c2rust::src_loc = "497:5"]
    pub const _SC_IPV6: C2RustUnnamed = 235;
    #[c2rust::src_loc = "493:5"]
    pub const _SC_LEVEL4_CACHE_LINESIZE: C2RustUnnamed = 199;
    #[c2rust::src_loc = "491:5"]
    pub const _SC_LEVEL4_CACHE_ASSOC: C2RustUnnamed = 198;
    #[c2rust::src_loc = "489:5"]
    pub const _SC_LEVEL4_CACHE_SIZE: C2RustUnnamed = 197;
    #[c2rust::src_loc = "487:5"]
    pub const _SC_LEVEL3_CACHE_LINESIZE: C2RustUnnamed = 196;
    #[c2rust::src_loc = "485:5"]
    pub const _SC_LEVEL3_CACHE_ASSOC: C2RustUnnamed = 195;
    #[c2rust::src_loc = "483:5"]
    pub const _SC_LEVEL3_CACHE_SIZE: C2RustUnnamed = 194;
    #[c2rust::src_loc = "481:5"]
    pub const _SC_LEVEL2_CACHE_LINESIZE: C2RustUnnamed = 193;
    #[c2rust::src_loc = "479:5"]
    pub const _SC_LEVEL2_CACHE_ASSOC: C2RustUnnamed = 192;
    #[c2rust::src_loc = "477:5"]
    pub const _SC_LEVEL2_CACHE_SIZE: C2RustUnnamed = 191;
    #[c2rust::src_loc = "475:5"]
    pub const _SC_LEVEL1_DCACHE_LINESIZE: C2RustUnnamed = 190;
    #[c2rust::src_loc = "473:5"]
    pub const _SC_LEVEL1_DCACHE_ASSOC: C2RustUnnamed = 189;
    #[c2rust::src_loc = "471:5"]
    pub const _SC_LEVEL1_DCACHE_SIZE: C2RustUnnamed = 188;
    #[c2rust::src_loc = "469:5"]
    pub const _SC_LEVEL1_ICACHE_LINESIZE: C2RustUnnamed = 187;
    #[c2rust::src_loc = "467:5"]
    pub const _SC_LEVEL1_ICACHE_ASSOC: C2RustUnnamed = 186;
    #[c2rust::src_loc = "465:5"]
    pub const _SC_LEVEL1_ICACHE_SIZE: C2RustUnnamed = 185;
    #[c2rust::src_loc = "462:5"]
    pub const _SC_TRACE_LOG: C2RustUnnamed = 184;
    #[c2rust::src_loc = "460:5"]
    pub const _SC_TRACE_INHERIT: C2RustUnnamed = 183;
    #[c2rust::src_loc = "458:5"]
    pub const _SC_TRACE_EVENT_FILTER: C2RustUnnamed = 182;
    #[c2rust::src_loc = "456:5"]
    pub const _SC_TRACE: C2RustUnnamed = 181;
    #[c2rust::src_loc = "454:5"]
    pub const _SC_HOST_NAME_MAX: C2RustUnnamed = 180;
    #[c2rust::src_loc = "451:5"]
    pub const _SC_V6_LPBIG_OFFBIG: C2RustUnnamed = 179;
    #[c2rust::src_loc = "449:5"]
    pub const _SC_V6_LP64_OFF64: C2RustUnnamed = 178;
    #[c2rust::src_loc = "447:5"]
    pub const _SC_V6_ILP32_OFFBIG: C2RustUnnamed = 177;
    #[c2rust::src_loc = "445:5"]
    pub const _SC_V6_ILP32_OFF32: C2RustUnnamed = 176;
    #[c2rust::src_loc = "442:5"]
    pub const _SC_2_PBS_CHECKPOINT: C2RustUnnamed = 175;
    #[c2rust::src_loc = "440:5"]
    pub const _SC_STREAMS: C2RustUnnamed = 174;
    #[c2rust::src_loc = "438:5"]
    pub const _SC_SYMLOOP_MAX: C2RustUnnamed = 173;
    #[c2rust::src_loc = "436:5"]
    pub const _SC_2_PBS_TRACK: C2RustUnnamed = 172;
    #[c2rust::src_loc = "434:5"]
    pub const _SC_2_PBS_MESSAGE: C2RustUnnamed = 171;
    #[c2rust::src_loc = "432:5"]
    pub const _SC_2_PBS_LOCATE: C2RustUnnamed = 170;
    #[c2rust::src_loc = "430:5"]
    pub const _SC_2_PBS_ACCOUNTING: C2RustUnnamed = 169;
    #[c2rust::src_loc = "428:5"]
    pub const _SC_2_PBS: C2RustUnnamed = 168;
    #[c2rust::src_loc = "426:5"]
    pub const _SC_USER_GROUPS_R: C2RustUnnamed = 167;
    #[c2rust::src_loc = "424:5"]
    pub const _SC_USER_GROUPS: C2RustUnnamed = 166;
    #[c2rust::src_loc = "422:5"]
    pub const _SC_TYPED_MEMORY_OBJECTS: C2RustUnnamed = 165;
    #[c2rust::src_loc = "420:5"]
    pub const _SC_TIMEOUTS: C2RustUnnamed = 164;
    #[c2rust::src_loc = "418:5"]
    pub const _SC_SYSTEM_DATABASE_R: C2RustUnnamed = 163;
    #[c2rust::src_loc = "416:5"]
    pub const _SC_SYSTEM_DATABASE: C2RustUnnamed = 162;
    #[c2rust::src_loc = "414:5"]
    pub const _SC_THREAD_SPORADIC_SERVER: C2RustUnnamed = 161;
    #[c2rust::src_loc = "412:5"]
    pub const _SC_SPORADIC_SERVER: C2RustUnnamed = 160;
    #[c2rust::src_loc = "410:5"]
    pub const _SC_SPAWN: C2RustUnnamed = 159;
    #[c2rust::src_loc = "408:5"]
    pub const _SC_SIGNALS: C2RustUnnamed = 158;
    #[c2rust::src_loc = "406:5"]
    pub const _SC_SHELL: C2RustUnnamed = 157;
    #[c2rust::src_loc = "404:5"]
    pub const _SC_REGEX_VERSION: C2RustUnnamed = 156;
    #[c2rust::src_loc = "402:5"]
    pub const _SC_REGEXP: C2RustUnnamed = 155;
    #[c2rust::src_loc = "400:5"]
    pub const _SC_SPIN_LOCKS: C2RustUnnamed = 154;
    #[c2rust::src_loc = "398:5"]
    pub const _SC_READER_WRITER_LOCKS: C2RustUnnamed = 153;
    #[c2rust::src_loc = "396:5"]
    pub const _SC_NETWORKING: C2RustUnnamed = 152;
    #[c2rust::src_loc = "394:5"]
    pub const _SC_SINGLE_PROCESS: C2RustUnnamed = 151;
    #[c2rust::src_loc = "392:5"]
    pub const _SC_MULTI_PROCESS: C2RustUnnamed = 150;
    #[c2rust::src_loc = "390:5"]
    pub const _SC_MONOTONIC_CLOCK: C2RustUnnamed = 149;
    #[c2rust::src_loc = "388:5"]
    pub const _SC_FILE_SYSTEM: C2RustUnnamed = 148;
    #[c2rust::src_loc = "386:5"]
    pub const _SC_FILE_LOCKING: C2RustUnnamed = 147;
    #[c2rust::src_loc = "384:5"]
    pub const _SC_FILE_ATTRIBUTES: C2RustUnnamed = 146;
    #[c2rust::src_loc = "382:5"]
    pub const _SC_PIPE: C2RustUnnamed = 145;
    #[c2rust::src_loc = "380:5"]
    pub const _SC_FIFO: C2RustUnnamed = 144;
    #[c2rust::src_loc = "378:5"]
    pub const _SC_FD_MGMT: C2RustUnnamed = 143;
    #[c2rust::src_loc = "376:5"]
    pub const _SC_DEVICE_SPECIFIC_R: C2RustUnnamed = 142;
    #[c2rust::src_loc = "374:5"]
    pub const _SC_DEVICE_SPECIFIC: C2RustUnnamed = 141;
    #[c2rust::src_loc = "372:5"]
    pub const _SC_DEVICE_IO: C2RustUnnamed = 140;
    #[c2rust::src_loc = "370:5"]
    pub const _SC_THREAD_CPUTIME: C2RustUnnamed = 139;
    #[c2rust::src_loc = "368:5"]
    pub const _SC_CPUTIME: C2RustUnnamed = 138;
    #[c2rust::src_loc = "366:5"]
    pub const _SC_CLOCK_SELECTION: C2RustUnnamed = 137;
    #[c2rust::src_loc = "364:5"]
    pub const _SC_C_LANG_SUPPORT_R: C2RustUnnamed = 136;
    #[c2rust::src_loc = "362:5"]
    pub const _SC_C_LANG_SUPPORT: C2RustUnnamed = 135;
    #[c2rust::src_loc = "360:5"]
    pub const _SC_BASE: C2RustUnnamed = 134;
    #[c2rust::src_loc = "358:5"]
    pub const _SC_BARRIERS: C2RustUnnamed = 133;
    #[c2rust::src_loc = "356:5"]
    pub const _SC_ADVISORY_INFO: C2RustUnnamed = 132;
    #[c2rust::src_loc = "353:5"]
    pub const _SC_XOPEN_REALTIME_THREADS: C2RustUnnamed = 131;
    #[c2rust::src_loc = "351:5"]
    pub const _SC_XOPEN_REALTIME: C2RustUnnamed = 130;
    #[c2rust::src_loc = "349:5"]
    pub const _SC_XOPEN_LEGACY: C2RustUnnamed = 129;
    #[c2rust::src_loc = "346:5"]
    pub const _SC_XBS5_LPBIG_OFFBIG: C2RustUnnamed = 128;
    #[c2rust::src_loc = "344:5"]
    pub const _SC_XBS5_LP64_OFF64: C2RustUnnamed = 127;
    #[c2rust::src_loc = "342:5"]
    pub const _SC_XBS5_ILP32_OFFBIG: C2RustUnnamed = 126;
    #[c2rust::src_loc = "340:5"]
    pub const _SC_XBS5_ILP32_OFF32: C2RustUnnamed = 125;
    #[c2rust::src_loc = "337:5"]
    pub const _SC_NL_TEXTMAX: C2RustUnnamed = 124;
    #[c2rust::src_loc = "335:5"]
    pub const _SC_NL_SETMAX: C2RustUnnamed = 123;
    #[c2rust::src_loc = "333:5"]
    pub const _SC_NL_NMAX: C2RustUnnamed = 122;
    #[c2rust::src_loc = "331:5"]
    pub const _SC_NL_MSGMAX: C2RustUnnamed = 121;
    #[c2rust::src_loc = "329:5"]
    pub const _SC_NL_LANGMAX: C2RustUnnamed = 120;
    #[c2rust::src_loc = "327:5"]
    pub const _SC_NL_ARGMAX: C2RustUnnamed = 119;
    #[c2rust::src_loc = "324:5"]
    pub const _SC_USHRT_MAX: C2RustUnnamed = 118;
    #[c2rust::src_loc = "322:5"]
    pub const _SC_ULONG_MAX: C2RustUnnamed = 117;
    #[c2rust::src_loc = "320:5"]
    pub const _SC_UINT_MAX: C2RustUnnamed = 116;
    #[c2rust::src_loc = "318:5"]
    pub const _SC_UCHAR_MAX: C2RustUnnamed = 115;
    #[c2rust::src_loc = "316:5"]
    pub const _SC_SHRT_MIN: C2RustUnnamed = 114;
    #[c2rust::src_loc = "314:5"]
    pub const _SC_SHRT_MAX: C2RustUnnamed = 113;
    #[c2rust::src_loc = "312:5"]
    pub const _SC_SCHAR_MIN: C2RustUnnamed = 112;
    #[c2rust::src_loc = "310:5"]
    pub const _SC_SCHAR_MAX: C2RustUnnamed = 111;
    #[c2rust::src_loc = "308:5"]
    pub const _SC_SSIZE_MAX: C2RustUnnamed = 110;
    #[c2rust::src_loc = "306:5"]
    pub const _SC_NZERO: C2RustUnnamed = 109;
    #[c2rust::src_loc = "304:5"]
    pub const _SC_MB_LEN_MAX: C2RustUnnamed = 108;
    #[c2rust::src_loc = "302:5"]
    pub const _SC_WORD_BIT: C2RustUnnamed = 107;
    #[c2rust::src_loc = "300:5"]
    pub const _SC_LONG_BIT: C2RustUnnamed = 106;
    #[c2rust::src_loc = "298:5"]
    pub const _SC_INT_MIN: C2RustUnnamed = 105;
    #[c2rust::src_loc = "296:5"]
    pub const _SC_INT_MAX: C2RustUnnamed = 104;
    #[c2rust::src_loc = "294:5"]
    pub const _SC_CHAR_MIN: C2RustUnnamed = 103;
    #[c2rust::src_loc = "292:5"]
    pub const _SC_CHAR_MAX: C2RustUnnamed = 102;
    #[c2rust::src_loc = "290:5"]
    pub const _SC_CHAR_BIT: C2RustUnnamed = 101;
    #[c2rust::src_loc = "287:5"]
    pub const _SC_XOPEN_XPG4: C2RustUnnamed = 100;
    #[c2rust::src_loc = "285:5"]
    pub const _SC_XOPEN_XPG3: C2RustUnnamed = 99;
    #[c2rust::src_loc = "283:5"]
    pub const _SC_XOPEN_XPG2: C2RustUnnamed = 98;
    #[c2rust::src_loc = "280:5"]
    pub const _SC_2_UPE: C2RustUnnamed = 97;
    #[c2rust::src_loc = "278:5"]
    pub const _SC_2_C_VERSION: C2RustUnnamed = 96;
    #[c2rust::src_loc = "276:5"]
    pub const _SC_2_CHAR_TERM: C2RustUnnamed = 95;
    #[c2rust::src_loc = "273:5"]
    pub const _SC_XOPEN_SHM: C2RustUnnamed = 94;
    #[c2rust::src_loc = "271:5"]
    pub const _SC_XOPEN_ENH_I18N: C2RustUnnamed = 93;
    #[c2rust::src_loc = "269:5"]
    pub const _SC_XOPEN_CRYPT: C2RustUnnamed = 92;
    #[c2rust::src_loc = "267:5"]
    pub const _SC_XOPEN_UNIX: C2RustUnnamed = 91;
    #[c2rust::src_loc = "265:5"]
    pub const _SC_XOPEN_XCU_VERSION: C2RustUnnamed = 90;
    #[c2rust::src_loc = "263:5"]
    pub const _SC_XOPEN_VERSION: C2RustUnnamed = 89;
    #[c2rust::src_loc = "260:5"]
    pub const _SC_PASS_MAX: C2RustUnnamed = 88;
    #[c2rust::src_loc = "258:5"]
    pub const _SC_ATEXIT_MAX: C2RustUnnamed = 87;
    #[c2rust::src_loc = "256:5"]
    pub const _SC_AVPHYS_PAGES: C2RustUnnamed = 86;
    #[c2rust::src_loc = "254:5"]
    pub const _SC_PHYS_PAGES: C2RustUnnamed = 85;
    #[c2rust::src_loc = "252:5"]
    pub const _SC_NPROCESSORS_ONLN: C2RustUnnamed = 84;
    #[c2rust::src_loc = "250:5"]
    pub const _SC_NPROCESSORS_CONF: C2RustUnnamed = 83;
    #[c2rust::src_loc = "247:5"]
    pub const _SC_THREAD_PROCESS_SHARED: C2RustUnnamed = 82;
    #[c2rust::src_loc = "245:5"]
    pub const _SC_THREAD_PRIO_PROTECT: C2RustUnnamed = 81;
    #[c2rust::src_loc = "243:5"]
    pub const _SC_THREAD_PRIO_INHERIT: C2RustUnnamed = 80;
    #[c2rust::src_loc = "241:5"]
    pub const _SC_THREAD_PRIORITY_SCHEDULING: C2RustUnnamed = 79;
    #[c2rust::src_loc = "239:5"]
    pub const _SC_THREAD_ATTR_STACKSIZE: C2RustUnnamed = 78;
    #[c2rust::src_loc = "237:5"]
    pub const _SC_THREAD_ATTR_STACKADDR: C2RustUnnamed = 77;
    #[c2rust::src_loc = "235:5"]
    pub const _SC_THREAD_THREADS_MAX: C2RustUnnamed = 76;
    #[c2rust::src_loc = "233:5"]
    pub const _SC_THREAD_STACK_MIN: C2RustUnnamed = 75;
    #[c2rust::src_loc = "231:5"]
    pub const _SC_THREAD_KEYS_MAX: C2RustUnnamed = 74;
    #[c2rust::src_loc = "229:5"]
    pub const _SC_THREAD_DESTRUCTOR_ITERATIONS: C2RustUnnamed = 73;
    #[c2rust::src_loc = "227:5"]
    pub const _SC_TTY_NAME_MAX: C2RustUnnamed = 72;
    #[c2rust::src_loc = "225:5"]
    pub const _SC_LOGIN_NAME_MAX: C2RustUnnamed = 71;
    #[c2rust::src_loc = "223:5"]
    pub const _SC_GETPW_R_SIZE_MAX: C2RustUnnamed = 70;
    #[c2rust::src_loc = "221:5"]
    pub const _SC_GETGR_R_SIZE_MAX: C2RustUnnamed = 69;
    #[c2rust::src_loc = "219:5"]
    pub const _SC_THREAD_SAFE_FUNCTIONS: C2RustUnnamed = 68;
    #[c2rust::src_loc = "217:5"]
    pub const _SC_THREADS: C2RustUnnamed = 67;
    #[c2rust::src_loc = "213:5"]
    pub const _SC_T_IOV_MAX: C2RustUnnamed = 66;
    #[c2rust::src_loc = "211:5"]
    pub const _SC_PII_OSI_M: C2RustUnnamed = 65;
    #[c2rust::src_loc = "209:5"]
    pub const _SC_PII_OSI_CLTS: C2RustUnnamed = 64;
    #[c2rust::src_loc = "207:5"]
    pub const _SC_PII_OSI_COTS: C2RustUnnamed = 63;
    #[c2rust::src_loc = "205:5"]
    pub const _SC_PII_INTERNET_DGRAM: C2RustUnnamed = 62;
    #[c2rust::src_loc = "203:5"]
    pub const _SC_PII_INTERNET_STREAM: C2RustUnnamed = 61;
    #[c2rust::src_loc = "201:5"]
    pub const _SC_IOV_MAX: C2RustUnnamed = 60;
    #[c2rust::src_loc = "199:5"]
    pub const _SC_UIO_MAXIOV: C2RustUnnamed = 60;
    #[c2rust::src_loc = "197:5"]
    pub const _SC_SELECT: C2RustUnnamed = 59;
    #[c2rust::src_loc = "195:5"]
    pub const _SC_POLL: C2RustUnnamed = 58;
    #[c2rust::src_loc = "193:5"]
    pub const _SC_PII_OSI: C2RustUnnamed = 57;
    #[c2rust::src_loc = "191:5"]
    pub const _SC_PII_INTERNET: C2RustUnnamed = 56;
    #[c2rust::src_loc = "189:5"]
    pub const _SC_PII_SOCKET: C2RustUnnamed = 55;
    #[c2rust::src_loc = "187:5"]
    pub const _SC_PII_XTI: C2RustUnnamed = 54;
    #[c2rust::src_loc = "185:5"]
    pub const _SC_PII: C2RustUnnamed = 53;
    #[c2rust::src_loc = "182:5"]
    pub const _SC_2_LOCALEDEF: C2RustUnnamed = 52;
    #[c2rust::src_loc = "180:5"]
    pub const _SC_2_SW_DEV: C2RustUnnamed = 51;
    #[c2rust::src_loc = "178:5"]
    pub const _SC_2_FORT_RUN: C2RustUnnamed = 50;
    #[c2rust::src_loc = "176:5"]
    pub const _SC_2_FORT_DEV: C2RustUnnamed = 49;
    #[c2rust::src_loc = "174:5"]
    pub const _SC_2_C_DEV: C2RustUnnamed = 48;
    #[c2rust::src_loc = "172:5"]
    pub const _SC_2_C_BIND: C2RustUnnamed = 47;
    #[c2rust::src_loc = "170:5"]
    pub const _SC_2_VERSION: C2RustUnnamed = 46;
    #[c2rust::src_loc = "167:5"]
    pub const _SC_CHARCLASS_NAME_MAX: C2RustUnnamed = 45;
    #[c2rust::src_loc = "165:5"]
    pub const _SC_RE_DUP_MAX: C2RustUnnamed = 44;
    #[c2rust::src_loc = "163:5"]
    pub const _SC_LINE_MAX: C2RustUnnamed = 43;
    #[c2rust::src_loc = "161:5"]
    pub const _SC_EXPR_NEST_MAX: C2RustUnnamed = 42;
    #[c2rust::src_loc = "159:5"]
    pub const _SC_EQUIV_CLASS_MAX: C2RustUnnamed = 41;
    #[c2rust::src_loc = "157:5"]
    pub const _SC_COLL_WEIGHTS_MAX: C2RustUnnamed = 40;
    #[c2rust::src_loc = "155:5"]
    pub const _SC_BC_STRING_MAX: C2RustUnnamed = 39;
    #[c2rust::src_loc = "153:5"]
    pub const _SC_BC_SCALE_MAX: C2RustUnnamed = 38;
    #[c2rust::src_loc = "151:5"]
    pub const _SC_BC_DIM_MAX: C2RustUnnamed = 37;
    #[c2rust::src_loc = "149:5"]
    pub const _SC_BC_BASE_MAX: C2RustUnnamed = 36;
    #[c2rust::src_loc = "144:5"]
    pub const _SC_TIMER_MAX: C2RustUnnamed = 35;
    #[c2rust::src_loc = "142:5"]
    pub const _SC_SIGQUEUE_MAX: C2RustUnnamed = 34;
    #[c2rust::src_loc = "140:5"]
    pub const _SC_SEM_VALUE_MAX: C2RustUnnamed = 33;
    #[c2rust::src_loc = "138:5"]
    pub const _SC_SEM_NSEMS_MAX: C2RustUnnamed = 32;
    #[c2rust::src_loc = "136:5"]
    pub const _SC_RTSIG_MAX: C2RustUnnamed = 31;
    #[c2rust::src_loc = "131:5"]
    pub const _SC_VERSION: C2RustUnnamed = 29;
    #[c2rust::src_loc = "129:5"]
    pub const _SC_MQ_PRIO_MAX: C2RustUnnamed = 28;
    #[c2rust::src_loc = "127:5"]
    pub const _SC_MQ_OPEN_MAX: C2RustUnnamed = 27;
    #[c2rust::src_loc = "125:5"]
    pub const _SC_DELAYTIMER_MAX: C2RustUnnamed = 26;
    #[c2rust::src_loc = "123:5"]
    pub const _SC_AIO_PRIO_DELTA_MAX: C2RustUnnamed = 25;
    #[c2rust::src_loc = "121:5"]
    pub const _SC_AIO_MAX: C2RustUnnamed = 24;
    #[c2rust::src_loc = "119:5"]
    pub const _SC_AIO_LISTIO_MAX: C2RustUnnamed = 23;
    #[c2rust::src_loc = "117:5"]
    pub const _SC_SHARED_MEMORY_OBJECTS: C2RustUnnamed = 22;
    #[c2rust::src_loc = "115:5"]
    pub const _SC_SEMAPHORES: C2RustUnnamed = 21;
    #[c2rust::src_loc = "113:5"]
    pub const _SC_MESSAGE_PASSING: C2RustUnnamed = 20;
    #[c2rust::src_loc = "111:5"]
    pub const _SC_MEMORY_PROTECTION: C2RustUnnamed = 19;
    #[c2rust::src_loc = "109:5"]
    pub const _SC_MEMLOCK_RANGE: C2RustUnnamed = 18;
    #[c2rust::src_loc = "107:5"]
    pub const _SC_MEMLOCK: C2RustUnnamed = 17;
    #[c2rust::src_loc = "105:5"]
    pub const _SC_MAPPED_FILES: C2RustUnnamed = 16;
    #[c2rust::src_loc = "103:5"]
    pub const _SC_FSYNC: C2RustUnnamed = 15;
    #[c2rust::src_loc = "101:5"]
    pub const _SC_SYNCHRONIZED_IO: C2RustUnnamed = 14;
    #[c2rust::src_loc = "99:5"]
    pub const _SC_PRIORITIZED_IO: C2RustUnnamed = 13;
    #[c2rust::src_loc = "97:5"]
    pub const _SC_ASYNCHRONOUS_IO: C2RustUnnamed = 12;
    #[c2rust::src_loc = "95:5"]
    pub const _SC_TIMERS: C2RustUnnamed = 11;
    #[c2rust::src_loc = "93:5"]
    pub const _SC_PRIORITY_SCHEDULING: C2RustUnnamed = 10;
    #[c2rust::src_loc = "91:5"]
    pub const _SC_REALTIME_SIGNALS: C2RustUnnamed = 9;
    #[c2rust::src_loc = "89:5"]
    pub const _SC_SAVED_IDS: C2RustUnnamed = 8;
    #[c2rust::src_loc = "87:5"]
    pub const _SC_JOB_CONTROL: C2RustUnnamed = 7;
    #[c2rust::src_loc = "85:5"]
    pub const _SC_TZNAME_MAX: C2RustUnnamed = 6;
    #[c2rust::src_loc = "83:5"]
    pub const _SC_STREAM_MAX: C2RustUnnamed = 5;
    #[c2rust::src_loc = "81:5"]
    pub const _SC_OPEN_MAX: C2RustUnnamed = 4;
    #[c2rust::src_loc = "79:5"]
    pub const _SC_NGROUPS_MAX: C2RustUnnamed = 3;
    #[c2rust::src_loc = "77:5"]
    pub const _SC_CLK_TCK: C2RustUnnamed = 2;
    #[c2rust::src_loc = "75:5"]
    pub const _SC_CHILD_MAX: C2RustUnnamed = 1;
    #[c2rust::src_loc = "73:5"]
    pub const _SC_ARG_MAX: C2RustUnnamed = 0;
}

#[c2rust::header_src = "/usr/include/unistd.h:27"]
pub mod unistd_h {
    use ::core::ffi::{c_int, c_long};

    extern "C" {
        #[c2rust::src_loc = "640:1"]
        pub fn sysconf(__name: c_int) -> c_long;
    }
}

#[c2rust::header_src = "/usr/include/libavcodec/packet.h:27"]
pub mod packet_h {
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "529:16"]
    pub struct AVPacket {
        pub buf: *mut AVBufferRef,
        pub pts: int64_t,
        pub dts: int64_t,
        pub data: *mut uint8_t,
        pub size: c_int,
        pub stream_index: c_int,
        pub flags: c_int,
        pub side_data: *mut AVPacketSideData,
        pub side_data_elems: c_int,
        pub duration: int64_t,
        pub pos: int64_t,
        pub opaque: *mut c_void,
        pub opaque_ref: *mut AVBufferRef,
        pub time_base: AVRational,
    }
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "403:16"]
    pub struct AVPacketSideData {
        pub data: *mut uint8_t,
        pub size: size_t,
        pub type_0: AVPacketSideDataType,
    }
    #[c2rust::src_loc = "41:1"]
    pub type AVPacketSideDataType = c_uint;
    #[c2rust::src_loc = "373:5"]
    pub const AV_PKT_DATA_NB: AVPacketSideDataType = 40;
    #[c2rust::src_loc = "363:5"]
    pub const AV_PKT_DATA_RTCP_SR: AVPacketSideDataType = 39;
    #[c2rust::src_loc = "357:5"]
    pub const AV_PKT_DATA_3D_REFERENCE_DISPLAYS: AVPacketSideDataType = 38;
    #[c2rust::src_loc = "346:5"]
    pub const AV_PKT_DATA_LCEVC: AVPacketSideDataType = 37;
    #[c2rust::src_loc = "340:5"]
    pub const AV_PKT_DATA_FRAME_CROPPING: AVPacketSideDataType = 36;
    #[c2rust::src_loc = "327:5"]
    pub const AV_PKT_DATA_AMBIENT_VIEWING_ENVIRONMENT: AVPacketSideDataType = 35;
    #[c2rust::src_loc = "320:5"]
    pub const AV_PKT_DATA_IAMF_RECON_GAIN_INFO_PARAM: AVPacketSideDataType = 34;
    #[c2rust::src_loc = "312:5"]
    pub const AV_PKT_DATA_IAMF_DEMIXING_INFO_PARAM: AVPacketSideDataType = 33;
    #[c2rust::src_loc = "304:5"]
    pub const AV_PKT_DATA_IAMF_MIX_GAIN_PARAM: AVPacketSideDataType = 32;
    #[c2rust::src_loc = "296:5"]
    pub const AV_PKT_DATA_DYNAMIC_HDR10_PLUS: AVPacketSideDataType = 31;
    #[c2rust::src_loc = "288:5"]
    pub const AV_PKT_DATA_S12M_TIMECODE: AVPacketSideDataType = 30;
    #[c2rust::src_loc = "280:5"]
    pub const AV_PKT_DATA_DOVI_CONF: AVPacketSideDataType = 29;
    #[c2rust::src_loc = "271:5"]
    pub const AV_PKT_DATA_ICC_PROFILE: AVPacketSideDataType = 28;
    #[c2rust::src_loc = "265:5"]
    pub const AV_PKT_DATA_PRFT: AVPacketSideDataType = 27;
    #[c2rust::src_loc = "258:5"]
    pub const AV_PKT_DATA_AFD: AVPacketSideDataType = 26;
    #[c2rust::src_loc = "252:5"]
    pub const AV_PKT_DATA_ENCRYPTION_INFO: AVPacketSideDataType = 25;
    #[c2rust::src_loc = "246:5"]
    pub const AV_PKT_DATA_ENCRYPTION_INIT_INFO: AVPacketSideDataType = 24;
    #[c2rust::src_loc = "239:5"]
    pub const AV_PKT_DATA_A53_CC: AVPacketSideDataType = 23;
    #[c2rust::src_loc = "232:5"]
    pub const AV_PKT_DATA_CONTENT_LIGHT_LEVEL: AVPacketSideDataType = 22;
    #[c2rust::src_loc = "225:5"]
    pub const AV_PKT_DATA_SPHERICAL: AVPacketSideDataType = 21;
    #[c2rust::src_loc = "219:5"]
    pub const AV_PKT_DATA_MASTERING_DISPLAY_METADATA: AVPacketSideDataType = 20;
    #[c2rust::src_loc = "212:5"]
    pub const AV_PKT_DATA_MPEGTS_STREAM_ID: AVPacketSideDataType = 19;
    #[c2rust::src_loc = "206:5"]
    pub const AV_PKT_DATA_METADATA_UPDATE: AVPacketSideDataType = 18;
    #[c2rust::src_loc = "199:5"]
    pub const AV_PKT_DATA_WEBVTT_SETTINGS: AVPacketSideDataType = 17;
    #[c2rust::src_loc = "193:5"]
    pub const AV_PKT_DATA_WEBVTT_IDENTIFIER: AVPacketSideDataType = 16;
    #[c2rust::src_loc = "188:5"]
    pub const AV_PKT_DATA_MATROSKA_BLOCKADDITIONAL: AVPacketSideDataType = 15;
    #[c2rust::src_loc = "180:5"]
    pub const AV_PKT_DATA_SUBTITLE_POSITION: AVPacketSideDataType = 14;
    #[c2rust::src_loc = "169:5"]
    pub const AV_PKT_DATA_STRINGS_METADATA: AVPacketSideDataType = 13;
    #[c2rust::src_loc = "163:5"]
    pub const AV_PKT_DATA_JP_DUALMONO: AVPacketSideDataType = 12;
    #[c2rust::src_loc = "153:5"]
    pub const AV_PKT_DATA_SKIP_SAMPLES: AVPacketSideDataType = 11;
    #[c2rust::src_loc = "142:5"]
    pub const AV_PKT_DATA_CPB_PROPERTIES: AVPacketSideDataType = 10;
    #[c2rust::src_loc = "137:5"]
    pub const AV_PKT_DATA_FALLBACK_TRACK: AVPacketSideDataType = 9;
    #[c2rust::src_loc = "129:5"]
    pub const AV_PKT_DATA_QUALITY_STATS: AVPacketSideDataType = 8;
    #[c2rust::src_loc = "117:5"]
    pub const AV_PKT_DATA_AUDIO_SERVICE_TYPE: AVPacketSideDataType = 7;
    #[c2rust::src_loc = "111:5"]
    pub const AV_PKT_DATA_STEREO3D: AVPacketSideDataType = 6;
    #[c2rust::src_loc = "105:5"]
    pub const AV_PKT_DATA_DISPLAYMATRIX: AVPacketSideDataType = 5;
    #[c2rust::src_loc = "96:5"]
    pub const AV_PKT_DATA_REPLAYGAIN: AVPacketSideDataType = 4;
    #[c2rust::src_loc = "90:5"]
    pub const AV_PKT_DATA_H263_MB_INFO: AVPacketSideDataType = 3;
    #[c2rust::src_loc = "69:5"]
    pub const AV_PKT_DATA_PARAM_CHANGE: AVPacketSideDataType = 2;
    #[c2rust::src_loc = "56:5"]
    pub const AV_PKT_DATA_NEW_EXTRADATA: AVPacketSideDataType = 1;
    #[c2rust::src_loc = "47:5"]
    pub const AV_PKT_DATA_PALETTE: AVPacketSideDataType = 0;
    use ::core::ffi::{c_int, c_uint, c_void};

    use super::__stddef_size_t_h::size_t;
    use super::buffer_h::AVBufferRef;
    use super::rational_h::AVRational;
    use super::stdint_intn_h::int64_t;
    use super::stdint_uintn_h::uint8_t;
    extern "C" {
        #[c2rust::src_loc = "644:1"]
        pub fn av_packet_alloc() -> *mut AVPacket;
        #[c2rust::src_loc = "665:1"]
        pub fn av_packet_free(pkt: *mut *mut AVPacket);
        #[c2rust::src_loc = "831:1"]
        pub fn av_packet_unref(pkt: *mut AVPacket);
    }
}
#[c2rust::header_src = "/usr/include/libavutil/buffer.h:27"]
pub mod buffer_h {
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "82:16"]
    pub struct AVBufferRef {
        pub buffer: *mut AVBuffer,
        pub data: *mut uint8_t,
        pub size: size_t,
    }
    use super::__stddef_size_t_h::size_t;
    use super::stdint_uintn_h::uint8_t;
    extern "C" {
        #[c2rust::src_loc = "74:16"]
        pub type AVBuffer;
    }
}
#[c2rust::header_src = "/usr/include/libavutil/channel_layout.h:27"]
pub mod channel_layout_h {
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "319:16"]
    pub struct AVChannelLayout {
        pub order: AVChannelOrder,
        pub nb_channels: c_int,
        pub u: C2RustUnnamed,
        pub opaque: *mut c_void,
    }
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "336:5"]
    pub union C2RustUnnamed {
        pub mask: uint64_t,
        pub map: *mut AVChannelCustom,
    }
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "283:16"]
    pub struct AVChannelCustom {
        pub id: AVChannel,
        pub name: [c_char; 16],
        pub opaque: *mut c_void,
    }
    #[c2rust::src_loc = "47:1"]
    pub type AVChannel = c_int;
    #[c2rust::src_loc = "111:5"]
    pub const AV_CHAN_AMBISONIC_END: AVChannel = 2047;
    #[c2rust::src_loc = "108:5"]
    pub const AV_CHAN_AMBISONIC_BASE: AVChannel = 1024;
    #[c2rust::src_loc = "94:5"]
    pub const AV_CHAN_UNKNOWN: AVChannel = 768;
    #[c2rust::src_loc = "91:5"]
    pub const AV_CHAN_UNUSED: AVChannel = 512;
    #[c2rust::src_loc = "88:5"]
    pub const AV_CHAN_BINAURAL_RIGHT: AVChannel = 62;
    #[c2rust::src_loc = "87:5"]
    pub const AV_CHAN_BINAURAL_LEFT: AVChannel = 61;
    #[c2rust::src_loc = "85:5"]
    pub const AV_CHAN_TOP_SURROUND_RIGHT: AVChannel = 44;
    #[c2rust::src_loc = "84:5"]
    pub const AV_CHAN_TOP_SURROUND_LEFT: AVChannel = 43;
    #[c2rust::src_loc = "83:5"]
    pub const AV_CHAN_SIDE_SURROUND_RIGHT: AVChannel = 42;
    #[c2rust::src_loc = "82:5"]
    pub const AV_CHAN_SIDE_SURROUND_LEFT: AVChannel = 41;
    #[c2rust::src_loc = "81:5"]
    pub const AV_CHAN_BOTTOM_FRONT_RIGHT: AVChannel = 40;
    #[c2rust::src_loc = "80:5"]
    pub const AV_CHAN_BOTTOM_FRONT_LEFT: AVChannel = 39;
    #[c2rust::src_loc = "79:5"]
    pub const AV_CHAN_BOTTOM_FRONT_CENTER: AVChannel = 38;
    #[c2rust::src_loc = "78:5"]
    pub const AV_CHAN_TOP_SIDE_RIGHT: AVChannel = 37;
    #[c2rust::src_loc = "77:5"]
    pub const AV_CHAN_TOP_SIDE_LEFT: AVChannel = 36;
    #[c2rust::src_loc = "76:5"]
    pub const AV_CHAN_LOW_FREQUENCY_2: AVChannel = 35;
    #[c2rust::src_loc = "75:5"]
    pub const AV_CHAN_SURROUND_DIRECT_RIGHT: AVChannel = 34;
    #[c2rust::src_loc = "74:5"]
    pub const AV_CHAN_SURROUND_DIRECT_LEFT: AVChannel = 33;
    #[c2rust::src_loc = "73:5"]
    pub const AV_CHAN_WIDE_RIGHT: AVChannel = 32;
    #[c2rust::src_loc = "72:5"]
    pub const AV_CHAN_WIDE_LEFT: AVChannel = 31;
    #[c2rust::src_loc = "71:5"]
    pub const AV_CHAN_STEREO_RIGHT: AVChannel = 30;
    #[c2rust::src_loc = "69:5"]
    pub const AV_CHAN_STEREO_LEFT: AVChannel = 29;
    #[c2rust::src_loc = "67:5"]
    pub const AV_CHAN_TOP_BACK_RIGHT: AVChannel = 17;
    #[c2rust::src_loc = "66:5"]
    pub const AV_CHAN_TOP_BACK_CENTER: AVChannel = 16;
    #[c2rust::src_loc = "65:5"]
    pub const AV_CHAN_TOP_BACK_LEFT: AVChannel = 15;
    #[c2rust::src_loc = "64:5"]
    pub const AV_CHAN_TOP_FRONT_RIGHT: AVChannel = 14;
    #[c2rust::src_loc = "63:5"]
    pub const AV_CHAN_TOP_FRONT_CENTER: AVChannel = 13;
    #[c2rust::src_loc = "62:5"]
    pub const AV_CHAN_TOP_FRONT_LEFT: AVChannel = 12;
    #[c2rust::src_loc = "61:5"]
    pub const AV_CHAN_TOP_CENTER: AVChannel = 11;
    #[c2rust::src_loc = "60:5"]
    pub const AV_CHAN_SIDE_RIGHT: AVChannel = 10;
    #[c2rust::src_loc = "59:5"]
    pub const AV_CHAN_SIDE_LEFT: AVChannel = 9;
    #[c2rust::src_loc = "58:5"]
    pub const AV_CHAN_BACK_CENTER: AVChannel = 8;
    #[c2rust::src_loc = "57:5"]
    pub const AV_CHAN_FRONT_RIGHT_OF_CENTER: AVChannel = 7;
    #[c2rust::src_loc = "56:5"]
    pub const AV_CHAN_FRONT_LEFT_OF_CENTER: AVChannel = 6;
    #[c2rust::src_loc = "55:5"]
    pub const AV_CHAN_BACK_RIGHT: AVChannel = 5;
    #[c2rust::src_loc = "54:5"]
    pub const AV_CHAN_BACK_LEFT: AVChannel = 4;
    #[c2rust::src_loc = "53:5"]
    pub const AV_CHAN_LOW_FREQUENCY: AVChannel = 3;
    #[c2rust::src_loc = "52:5"]
    pub const AV_CHAN_FRONT_CENTER: AVChannel = 2;
    #[c2rust::src_loc = "51:5"]
    pub const AV_CHAN_FRONT_RIGHT: AVChannel = 1;
    #[c2rust::src_loc = "50:5"]
    pub const AV_CHAN_FRONT_LEFT: AVChannel = 0;
    #[c2rust::src_loc = "49:5"]
    pub const AV_CHAN_NONE: AVChannel = -1;
    #[c2rust::src_loc = "114:1"]
    pub type AVChannelOrder = c_uint;
    #[c2rust::src_loc = "159:5"]
    pub const FF_CHANNEL_ORDER_NB: AVChannelOrder = 4;
    #[c2rust::src_loc = "155:5"]
    pub const AV_CHANNEL_ORDER_AMBISONIC: AVChannelOrder = 3;
    #[c2rust::src_loc = "132:5"]
    pub const AV_CHANNEL_ORDER_CUSTOM: AVChannelOrder = 2;
    #[c2rust::src_loc = "125:5"]
    pub const AV_CHANNEL_ORDER_NATIVE: AVChannelOrder = 1;
    #[c2rust::src_loc = "119:5"]
    pub const AV_CHANNEL_ORDER_UNSPEC: AVChannelOrder = 0;
    use ::core::ffi::{c_char, c_int, c_uint, c_void};

    use super::stdint_uintn_h::uint64_t;
}
#[c2rust::header_src = "/usr/include/libavutil/dict.h:27"]
pub mod dict_h {
    use ::core::ffi::{c_char, c_int};

    extern "C" {
        #[c2rust::src_loc = "95:16"]
        pub type AVDictionary;
        #[c2rust::src_loc = "166:1"]
        pub fn av_dict_set(
            pm: *mut *mut AVDictionary,
            key: *const c_char,
            value: *const c_char,
            flags: c_int,
        ) -> c_int;
        #[c2rust::src_loc = "216:1"]
        pub fn av_dict_free(m: *mut *mut AVDictionary);
    }
}
#[c2rust::header_src = "/usr/include/libavutil/avutil.h:27"]
pub mod avutil_h {
    #[c2rust::src_loc = "276:1"]
    pub type AVPictureType = c_uint;
    #[c2rust::src_loc = "284:5"]
    pub const AV_PICTURE_TYPE_BI: AVPictureType = 7;
    #[c2rust::src_loc = "283:5"]
    pub const AV_PICTURE_TYPE_SP: AVPictureType = 6;
    #[c2rust::src_loc = "282:5"]
    pub const AV_PICTURE_TYPE_SI: AVPictureType = 5;
    #[c2rust::src_loc = "281:5"]
    pub const AV_PICTURE_TYPE_S: AVPictureType = 4;
    #[c2rust::src_loc = "280:5"]
    pub const AV_PICTURE_TYPE_B: AVPictureType = 3;
    #[c2rust::src_loc = "279:5"]
    pub const AV_PICTURE_TYPE_P: AVPictureType = 2;
    #[c2rust::src_loc = "278:5"]
    pub const AV_PICTURE_TYPE_I: AVPictureType = 1;
    #[c2rust::src_loc = "277:5"]
    pub const AV_PICTURE_TYPE_NONE: AVPictureType = 0;
    #[c2rust::src_loc = "198:1"]
    pub type AVMediaType = c_int;
    #[c2rust::src_loc = "205:5"]
    pub const AVMEDIA_TYPE_NB: AVMediaType = 5;
    #[c2rust::src_loc = "204:5"]
    pub const AVMEDIA_TYPE_ATTACHMENT: AVMediaType = 4;
    #[c2rust::src_loc = "203:5"]
    pub const AVMEDIA_TYPE_SUBTITLE: AVMediaType = 3;
    #[c2rust::src_loc = "202:5"]
    pub const AVMEDIA_TYPE_DATA: AVMediaType = 2;
    #[c2rust::src_loc = "201:5"]
    pub const AVMEDIA_TYPE_AUDIO: AVMediaType = 1;
    #[c2rust::src_loc = "200:5"]
    pub const AVMEDIA_TYPE_VIDEO: AVMediaType = 0;
    #[c2rust::src_loc = "199:5"]
    pub const AVMEDIA_TYPE_UNKNOWN: AVMediaType = -1;
    #[c2rust::src_loc = "247:9"]
    pub const AV_NOPTS_VALUE: int64_t = 0x8000000000000000 as c_ulong as int64_t;
    use ::core::ffi::{c_int, c_uint, c_ulong};

    use super::stdint_intn_h::int64_t;
}
#[c2rust::header_src = "/usr/include/libavcodec/avcodec.h:30"]
pub mod avcodec_h {
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "431:16"]
    pub struct AVCodecContext {
        pub av_class: *const AVClass,
        pub log_level_offset: c_int,
        pub codec_type: AVMediaType,
        pub codec: *const AVCodec,
        pub codec_id: AVCodecID,
        pub codec_tag: c_uint,
        pub priv_data: *mut c_void,
        pub internal: *mut AVCodecInternal,
        pub opaque: *mut c_void,
        pub bit_rate: int64_t,
        pub flags: c_int,
        pub flags2: c_int,
        pub extradata: *mut uint8_t,
        pub extradata_size: c_int,
        pub time_base: AVRational,
        pub pkt_timebase: AVRational,
        pub framerate: AVRational,
        pub delay: c_int,
        pub width: c_int,
        pub height: c_int,
        pub coded_width: c_int,
        pub coded_height: c_int,
        pub sample_aspect_ratio: AVRational,
        pub pix_fmt: AVPixelFormat,
        pub sw_pix_fmt: AVPixelFormat,
        pub color_primaries: AVColorPrimaries,
        pub color_trc: AVColorTransferCharacteristic,
        pub colorspace: AVColorSpace,
        pub color_range: AVColorRange,
        pub chroma_sample_location: AVChromaLocation,
        pub field_order: AVFieldOrder,
        pub refs: c_int,
        pub has_b_frames: c_int,
        pub slice_flags: c_int,
        pub draw_horiz_band: Option<
            unsafe extern "C" fn(
                *mut AVCodecContext,
                *const AVFrame,
                *mut c_int,
                c_int,
                c_int,
                c_int,
            ) -> (),
        >,
        pub get_format: Option<
            unsafe extern "C" fn(*mut AVCodecContext, *const AVPixelFormat) -> AVPixelFormat,
        >,
        pub max_b_frames: c_int,
        pub b_quant_factor: c_float,
        pub b_quant_offset: c_float,
        pub i_quant_factor: c_float,
        pub i_quant_offset: c_float,
        pub lumi_masking: c_float,
        pub temporal_cplx_masking: c_float,
        pub spatial_cplx_masking: c_float,
        pub p_masking: c_float,
        pub dark_masking: c_float,
        pub nsse_weight: c_int,
        pub me_cmp: c_int,
        pub me_sub_cmp: c_int,
        pub mb_cmp: c_int,
        pub ildct_cmp: c_int,
        pub dia_size: c_int,
        pub last_predictor_count: c_int,
        pub me_pre_cmp: c_int,
        pub pre_dia_size: c_int,
        pub me_subpel_quality: c_int,
        pub me_range: c_int,
        pub mb_decision: c_int,
        pub intra_matrix: *mut uint16_t,
        pub inter_matrix: *mut uint16_t,
        pub chroma_intra_matrix: *mut uint16_t,
        pub intra_dc_precision: c_int,
        pub mb_lmin: c_int,
        pub mb_lmax: c_int,
        pub bidir_refine: c_int,
        pub keyint_min: c_int,
        pub gop_size: c_int,
        pub mv0_threshold: c_int,
        pub slices: c_int,
        pub sample_rate: c_int,
        pub sample_fmt: AVSampleFormat,
        pub ch_layout: AVChannelLayout,
        pub frame_size: c_int,
        pub block_align: c_int,
        pub cutoff: c_int,
        pub audio_service_type: AVAudioServiceType,
        pub request_sample_fmt: AVSampleFormat,
        pub initial_padding: c_int,
        pub trailing_padding: c_int,
        pub seek_preroll: c_int,
        pub get_buffer2:
            Option<unsafe extern "C" fn(*mut AVCodecContext, *mut AVFrame, c_int) -> c_int>,
        pub bit_rate_tolerance: c_int,
        pub global_quality: c_int,
        pub compression_level: c_int,
        pub qcompress: c_float,
        pub qblur: c_float,
        pub qmin: c_int,
        pub qmax: c_int,
        pub max_qdiff: c_int,
        pub rc_buffer_size: c_int,
        pub rc_override_count: c_int,
        pub rc_override: *mut RcOverride,
        pub rc_max_rate: int64_t,
        pub rc_min_rate: int64_t,
        pub rc_max_available_vbv_use: c_float,
        pub rc_min_vbv_overflow_use: c_float,
        pub rc_initial_buffer_occupancy: c_int,
        pub trellis: c_int,
        pub stats_out: *mut c_char,
        pub stats_in: *mut c_char,
        pub workaround_bugs: c_int,
        pub strict_std_compliance: c_int,
        pub error_concealment: c_int,
        pub debug: c_int,
        pub err_recognition: c_int,
        pub hwaccel: *const AVHWAccel,
        pub hwaccel_context: *mut c_void,
        pub hw_frames_ctx: *mut AVBufferRef,
        pub hw_device_ctx: *mut AVBufferRef,
        pub hwaccel_flags: c_int,
        pub extra_hw_frames: c_int,
        pub error: [uint64_t; 8],
        pub dct_algo: c_int,
        pub idct_algo: c_int,
        pub bits_per_coded_sample: c_int,
        pub bits_per_raw_sample: c_int,
        pub thread_count: c_int,
        pub thread_type: c_int,
        pub active_thread_type: c_int,
        pub execute: Option<
            unsafe extern "C" fn(
                *mut AVCodecContext,
                Option<unsafe extern "C" fn(*mut AVCodecContext, *mut c_void) -> c_int>,
                *mut c_void,
                *mut c_int,
                c_int,
                c_int,
            ) -> c_int,
        >,
        pub execute2: Option<
            unsafe extern "C" fn(
                *mut AVCodecContext,
                Option<
                    unsafe extern "C" fn(*mut AVCodecContext, *mut c_void, c_int, c_int) -> c_int,
                >,
                *mut c_void,
                *mut c_int,
                c_int,
            ) -> c_int,
        >,
        pub profile: c_int,
        pub level: c_int,
        pub properties: c_uint,
        pub skip_loop_filter: AVDiscard,
        pub skip_idct: AVDiscard,
        pub skip_frame: AVDiscard,
        pub skip_alpha: c_int,
        pub skip_top: c_int,
        pub skip_bottom: c_int,
        pub lowres: c_int,
        pub codec_descriptor: *const AVCodecDescriptor,
        pub sub_charenc: *mut c_char,
        pub sub_charenc_mode: c_int,
        pub subtitle_header_size: c_int,
        pub subtitle_header: *mut uint8_t,
        pub dump_separator: *mut uint8_t,
        pub codec_whitelist: *mut c_char,
        pub coded_side_data: *mut AVPacketSideData,
        pub nb_coded_side_data: c_int,
        pub export_side_data: c_int,
        pub max_pixels: int64_t,
        pub apply_cropping: c_int,
        pub discard_damaged_percentage: c_int,
        pub max_samples: int64_t,
        pub get_encode_buffer:
            Option<unsafe extern "C" fn(*mut AVCodecContext, *mut AVPacket, c_int) -> c_int>,
        pub frame_num: int64_t,
        pub side_data_prefer_packet: *mut c_int,
        pub nb_side_data_prefer_packet: c_uint,
        pub decoded_side_data: *mut *mut AVFrameSideData,
        pub nb_decoded_side_data: c_int,
    }
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "1936:16"]
    pub struct AVHWAccel {
        pub name: *const c_char,
        pub type_0: AVMediaType,
        pub id: AVCodecID,
        pub pix_fmt: AVPixelFormat,
        pub capabilities: c_int,
    }
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "193:16"]
    pub struct RcOverride {
        pub start_frame: c_int,
        pub end_frame: c_int,
        pub qscale: c_int,
        pub quality_factor: c_float,
    }
    use ::core::ffi::{c_char, c_float, c_int, c_uint, c_void};

    use super::avutil_h::AVMediaType;
    use super::buffer_h::AVBufferRef;
    use super::channel_layout_h::AVChannelLayout;
    use super::codec_desc_h::AVCodecDescriptor;
    use super::codec_h::AVCodec;
    use super::codec_id_h::AVCodecID;
    use super::codec_par_h::AVCodecParameters;
    use super::defs_h::{AVAudioServiceType, AVDiscard, AVFieldOrder};
    use super::dict_h::AVDictionary;
    use super::libav_frame_h::{AVFrame, AVFrameSideData};
    use super::log_h::AVClass;
    use super::packet_h::{AVPacket, AVPacketSideData};
    use super::pixfmt_h::{
        AVChromaLocation, AVColorPrimaries, AVColorRange, AVColorSpace,
        AVColorTransferCharacteristic, AVPixelFormat,
    };
    use super::rational_h::AVRational;
    use super::samplefmt_h::AVSampleFormat;
    use super::stdint_intn_h::int64_t;
    use super::stdint_uintn_h::{uint16_t, uint64_t, uint8_t};
    extern "C" {
        #[c2rust::src_loc = "466:12"]
        pub type AVCodecInternal;
        #[c2rust::src_loc = "2112:1"]
        pub fn avcodec_alloc_context3(codec: *const AVCodec) -> *mut AVCodecContext;
        #[c2rust::src_loc = "2118:1"]
        pub fn avcodec_free_context(avctx: *mut *mut AVCodecContext);
        #[c2rust::src_loc = "2154:1"]
        pub fn avcodec_parameters_to_context(
            codec: *mut AVCodecContext,
            par: *const AVCodecParameters,
        ) -> c_int;
        #[c2rust::src_loc = "2218:1"]
        pub fn avcodec_open2(
            avctx: *mut AVCodecContext,
            codec: *const AVCodec,
            options: *mut *mut AVDictionary,
        ) -> c_int;
        #[c2rust::src_loc = "2345:1"]
        pub fn avcodec_send_packet(avctx: *mut AVCodecContext, avpkt: *const AVPacket) -> c_int;
        #[c2rust::src_loc = "2366:1"]
        pub fn avcodec_receive_frame(avctx: *mut AVCodecContext, frame: *mut AVFrame) -> c_int;
    }
}
#[c2rust::header_src = "/usr/include/libavcodec/codec_desc.h:30"]
pub mod codec_desc_h {
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "38:16"]
    pub struct AVCodecDescriptor {
        pub id: AVCodecID,
        pub type_0: AVMediaType,
        pub name: *const c_char,
        pub long_name: *const c_char,
        pub props: c_int,
        pub mime_types: *const *const c_char,
        pub profiles: *const AVProfile,
    }
    use ::core::ffi::{c_char, c_int};

    use super::avutil_h::AVMediaType;
    use super::codec_h::AVProfile;
    use super::codec_id_h::AVCodecID;
}
#[c2rust::header_src = "/usr/include/libavcodec/codec.h:30"]
pub mod codec_h {
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "164:16"]
    pub struct AVProfile {
        pub profile: c_int,
        pub name: *const c_char,
    }
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "172:16"]
    pub struct AVCodec {
        pub name: *const c_char,
        pub long_name: *const c_char,
        pub type_0: AVMediaType,
        pub id: AVCodecID,
        pub capabilities: c_int,
        pub max_lowres: uint8_t,
        pub supported_framerates: *const AVRational,
        pub pix_fmts: *const AVPixelFormat,
        pub supported_samplerates: *const c_int,
        pub sample_fmts: *const AVSampleFormat,
        pub priv_class: *const AVClass,
        pub profiles: *const AVProfile,
        pub wrapper_name: *const c_char,
        pub ch_layouts: *const AVChannelLayout,
    }
    use ::core::ffi::{c_char, c_int};

    use super::avutil_h::AVMediaType;
    use super::channel_layout_h::AVChannelLayout;
    use super::codec_id_h::{AVCodecID, AV_CODEC_ID_NONE};
    use super::log_h::AVClass;
    use super::pixfmt_h::AVPixelFormat;
    use super::rational_h::AVRational;
    use super::samplefmt_h::AVSampleFormat;
    use super::stdint_uintn_h::uint8_t;
    extern "C" {
        #[c2rust::src_loc = "246:1"]
        pub fn avcodec_find_decoder(id: AVCodecID) -> *const AVCodec;
    }
}
#[c2rust::header_src = "/usr/include/libavcodec/codec_id.h:27"]
pub mod codec_id_h {
    use ::core::ffi::c_uint;

    #[c2rust::src_loc = "49:1"]
    pub type AVCodecID = c_uint;
    #[c2rust::src_loc = "626:5"]
    pub const AV_CODEC_ID_ANULL: AVCodecID = 135171;
    #[c2rust::src_loc = "621:5"]
    pub const AV_CODEC_ID_VNULL: AVCodecID = 135170;
    #[c2rust::src_loc = "616:5"]
    pub const AV_CODEC_ID_WRAPPED_AVFRAME: AVCodecID = 135169;
    #[c2rust::src_loc = "615:5"]
    pub const AV_CODEC_ID_FFMETADATA: AVCodecID = 135168;
    #[c2rust::src_loc = "613:5"]
    pub const AV_CODEC_ID_MPEG4SYSTEMS: AVCodecID = 131073;
    #[c2rust::src_loc = "611:5"]
    pub const AV_CODEC_ID_MPEG2TS: AVCodecID = 131072;
    #[c2rust::src_loc = "609:5"]
    pub const AV_CODEC_ID_PROBE: AVCodecID = 102400;
    #[c2rust::src_loc = "606:5"]
    pub const AV_CODEC_ID_SMPTE_436M_ANC: AVCodecID = 98317;
    #[c2rust::src_loc = "605:5"]
    pub const AV_CODEC_ID_LCEVC: AVCodecID = 98316;
    #[c2rust::src_loc = "604:5"]
    pub const AV_CODEC_ID_SMPTE_2038: AVCodecID = 98315;
    #[c2rust::src_loc = "603:5"]
    pub const AV_CODEC_ID_BIN_DATA: AVCodecID = 98314;
    #[c2rust::src_loc = "602:5"]
    pub const AV_CODEC_ID_TIMED_ID3: AVCodecID = 98313;
    #[c2rust::src_loc = "601:5"]
    pub const AV_CODEC_ID_DVD_NAV: AVCodecID = 98312;
    #[c2rust::src_loc = "600:5"]
    pub const AV_CODEC_ID_SMPTE_KLV: AVCodecID = 98311;
    #[c2rust::src_loc = "599:5"]
    pub const AV_CODEC_ID_OTF: AVCodecID = 98310;
    #[c2rust::src_loc = "598:5"]
    pub const AV_CODEC_ID_IDF: AVCodecID = 98309;
    #[c2rust::src_loc = "597:5"]
    pub const AV_CODEC_ID_XBIN: AVCodecID = 98308;
    #[c2rust::src_loc = "596:5"]
    pub const AV_CODEC_ID_BINTEXT: AVCodecID = 98307;
    #[c2rust::src_loc = "595:5"]
    pub const AV_CODEC_ID_EPG: AVCodecID = 98306;
    #[c2rust::src_loc = "594:5"]
    pub const AV_CODEC_ID_SCTE_35: AVCodecID = 98305;
    #[c2rust::src_loc = "592:5"]
    pub const AV_CODEC_ID_TTF: AVCodecID = 98304;
    #[c2rust::src_loc = "591:5"]
    pub const AV_CODEC_ID_FIRST_UNKNOWN: AVCodecID = 98304;
    #[c2rust::src_loc = "588:5"]
    pub const AV_CODEC_ID_IVTV_VBI: AVCodecID = 94234;
    #[c2rust::src_loc = "587:5"]
    pub const AV_CODEC_ID_ARIB_CAPTION: AVCodecID = 94233;
    #[c2rust::src_loc = "586:5"]
    pub const AV_CODEC_ID_TTML: AVCodecID = 94232;
    #[c2rust::src_loc = "585:5"]
    pub const AV_CODEC_ID_HDMV_TEXT_SUBTITLE: AVCodecID = 94231;
    #[c2rust::src_loc = "584:5"]
    pub const AV_CODEC_ID_ASS: AVCodecID = 94230;
    #[c2rust::src_loc = "583:5"]
    pub const AV_CODEC_ID_PJS: AVCodecID = 94229;
    #[c2rust::src_loc = "582:5"]
    pub const AV_CODEC_ID_VPLAYER: AVCodecID = 94228;
    #[c2rust::src_loc = "581:5"]
    pub const AV_CODEC_ID_MPL2: AVCodecID = 94227;
    #[c2rust::src_loc = "580:5"]
    pub const AV_CODEC_ID_WEBVTT: AVCodecID = 94226;
    #[c2rust::src_loc = "579:5"]
    pub const AV_CODEC_ID_SUBRIP: AVCodecID = 94225;
    #[c2rust::src_loc = "578:5"]
    pub const AV_CODEC_ID_SUBVIEWER: AVCodecID = 94224;
    #[c2rust::src_loc = "577:5"]
    pub const AV_CODEC_ID_SUBVIEWER1: AVCodecID = 94223;
    #[c2rust::src_loc = "576:5"]
    pub const AV_CODEC_ID_STL: AVCodecID = 94222;
    #[c2rust::src_loc = "575:5"]
    pub const AV_CODEC_ID_REALTEXT: AVCodecID = 94221;
    #[c2rust::src_loc = "574:5"]
    pub const AV_CODEC_ID_SAMI: AVCodecID = 94220;
    #[c2rust::src_loc = "573:5"]
    pub const AV_CODEC_ID_JACOSUB: AVCodecID = 94219;
    #[c2rust::src_loc = "572:5"]
    pub const AV_CODEC_ID_EIA_608: AVCodecID = 94218;
    #[c2rust::src_loc = "571:5"]
    pub const AV_CODEC_ID_MICRODVD: AVCodecID = 94217;
    #[c2rust::src_loc = "570:5"]
    pub const AV_CODEC_ID_SRT: AVCodecID = 94216;
    #[c2rust::src_loc = "569:5"]
    pub const AV_CODEC_ID_DVB_TELETEXT: AVCodecID = 94215;
    #[c2rust::src_loc = "568:5"]
    pub const AV_CODEC_ID_HDMV_PGS_SUBTITLE: AVCodecID = 94214;
    #[c2rust::src_loc = "567:5"]
    pub const AV_CODEC_ID_MOV_TEXT: AVCodecID = 94213;
    #[c2rust::src_loc = "566:5"]
    pub const AV_CODEC_ID_SSA: AVCodecID = 94212;
    #[c2rust::src_loc = "565:5"]
    pub const AV_CODEC_ID_XSUB: AVCodecID = 94211;
    #[c2rust::src_loc = "564:5"]
    pub const AV_CODEC_ID_TEXT: AVCodecID = 94210;
    #[c2rust::src_loc = "563:5"]
    pub const AV_CODEC_ID_DVB_SUBTITLE: AVCodecID = 94209;
    #[c2rust::src_loc = "562:5"]
    pub const AV_CODEC_ID_DVD_SUBTITLE: AVCodecID = 94208;
    #[c2rust::src_loc = "561:5"]
    pub const AV_CODEC_ID_FIRST_SUBTITLE: AVCodecID = 94208;
    #[c2rust::src_loc = "558:5"]
    pub const AV_CODEC_ID_G728: AVCodecID = 86123;
    #[c2rust::src_loc = "557:5"]
    pub const AV_CODEC_ID_LC3: AVCodecID = 86122;
    #[c2rust::src_loc = "556:5"]
    pub const AV_CODEC_ID_QOA: AVCodecID = 86121;
    #[c2rust::src_loc = "555:5"]
    pub const AV_CODEC_ID_OSQ: AVCodecID = 86120;
    #[c2rust::src_loc = "554:5"]
    pub const AV_CODEC_ID_AC4: AVCodecID = 86119;
    #[c2rust::src_loc = "553:5"]
    pub const AV_CODEC_ID_RKA: AVCodecID = 86118;
    #[c2rust::src_loc = "552:5"]
    pub const AV_CODEC_ID_WAVARC: AVCodecID = 86117;
    #[c2rust::src_loc = "551:5"]
    pub const AV_CODEC_ID_FTR: AVCodecID = 86116;
    #[c2rust::src_loc = "550:5"]
    pub const AV_CODEC_ID_APAC: AVCodecID = 86115;
    #[c2rust::src_loc = "549:5"]
    pub const AV_CODEC_ID_MISC4: AVCodecID = 86114;
    #[c2rust::src_loc = "548:5"]
    pub const AV_CODEC_ID_BONK: AVCodecID = 86113;
    #[c2rust::src_loc = "547:5"]
    pub const AV_CODEC_ID_DFPWM: AVCodecID = 86112;
    #[c2rust::src_loc = "546:5"]
    pub const AV_CODEC_ID_MSNSIREN: AVCodecID = 86111;
    #[c2rust::src_loc = "545:5"]
    pub const AV_CODEC_ID_FASTAUDIO: AVCodecID = 86110;
    #[c2rust::src_loc = "544:5"]
    pub const AV_CODEC_ID_HCA: AVCodecID = 86109;
    #[c2rust::src_loc = "543:5"]
    pub const AV_CODEC_ID_SIREN: AVCodecID = 86108;
    #[c2rust::src_loc = "542:5"]
    pub const AV_CODEC_ID_MPEGH_3D_AUDIO: AVCodecID = 86107;
    #[c2rust::src_loc = "541:5"]
    pub const AV_CODEC_ID_ACELP_KELVIN: AVCodecID = 86106;
    #[c2rust::src_loc = "540:5"]
    pub const AV_CODEC_ID_HCOM: AVCodecID = 86105;
    #[c2rust::src_loc = "539:5"]
    pub const AV_CODEC_ID_ATRAC9: AVCodecID = 86104;
    #[c2rust::src_loc = "538:5"]
    pub const AV_CODEC_ID_SBC: AVCodecID = 86103;
    #[c2rust::src_loc = "537:5"]
    pub const AV_CODEC_ID_APTX_HD: AVCodecID = 86102;
    #[c2rust::src_loc = "536:5"]
    pub const AV_CODEC_ID_APTX: AVCodecID = 86101;
    #[c2rust::src_loc = "535:5"]
    pub const AV_CODEC_ID_DOLBY_E: AVCodecID = 86100;
    #[c2rust::src_loc = "534:5"]
    pub const AV_CODEC_ID_ATRAC3PAL: AVCodecID = 86099;
    #[c2rust::src_loc = "533:5"]
    pub const AV_CODEC_ID_ATRAC3AL: AVCodecID = 86098;
    #[c2rust::src_loc = "532:5"]
    pub const AV_CODEC_ID_DST: AVCodecID = 86097;
    #[c2rust::src_loc = "531:5"]
    pub const AV_CODEC_ID_XMA2: AVCodecID = 86096;
    #[c2rust::src_loc = "530:5"]
    pub const AV_CODEC_ID_XMA1: AVCodecID = 86095;
    #[c2rust::src_loc = "529:5"]
    pub const AV_CODEC_ID_INTERPLAY_ACM: AVCodecID = 86094;
    #[c2rust::src_loc = "528:5"]
    pub const AV_CODEC_ID_4GV: AVCodecID = 86093;
    #[c2rust::src_loc = "527:5"]
    pub const AV_CODEC_ID_DSD_MSBF_PLANAR: AVCodecID = 86092;
    #[c2rust::src_loc = "526:5"]
    pub const AV_CODEC_ID_DSD_LSBF_PLANAR: AVCodecID = 86091;
    #[c2rust::src_loc = "525:5"]
    pub const AV_CODEC_ID_DSD_MSBF: AVCodecID = 86090;
    #[c2rust::src_loc = "524:5"]
    pub const AV_CODEC_ID_DSD_LSBF: AVCodecID = 86089;
    #[c2rust::src_loc = "523:5"]
    pub const AV_CODEC_ID_SMV: AVCodecID = 86088;
    #[c2rust::src_loc = "522:5"]
    pub const AV_CODEC_ID_EVRC: AVCodecID = 86087;
    #[c2rust::src_loc = "521:5"]
    pub const AV_CODEC_ID_SONIC_LS: AVCodecID = 86086;
    #[c2rust::src_loc = "520:5"]
    pub const AV_CODEC_ID_SONIC: AVCodecID = 86085;
    #[c2rust::src_loc = "519:5"]
    pub const AV_CODEC_ID_FFWAVESYNTH: AVCodecID = 86084;
    #[c2rust::src_loc = "518:5"]
    pub const AV_CODEC_ID_CODEC2: AVCodecID = 86083;
    #[c2rust::src_loc = "517:5"]
    pub const AV_CODEC_ID_DSS_SP: AVCodecID = 86082;
    #[c2rust::src_loc = "516:5"]
    pub const AV_CODEC_ID_ON2AVC: AVCodecID = 86081;
    #[c2rust::src_loc = "515:5"]
    pub const AV_CODEC_ID_PAF_AUDIO: AVCodecID = 86080;
    #[c2rust::src_loc = "514:5"]
    pub const AV_CODEC_ID_METASOUND: AVCodecID = 86079;
    #[c2rust::src_loc = "513:5"]
    pub const AV_CODEC_ID_TAK: AVCodecID = 86078;
    #[c2rust::src_loc = "512:5"]
    pub const AV_CODEC_ID_COMFORT_NOISE: AVCodecID = 86077;
    #[c2rust::src_loc = "511:5"]
    pub const AV_CODEC_ID_OPUS: AVCodecID = 86076;
    #[c2rust::src_loc = "510:5"]
    pub const AV_CODEC_ID_ILBC: AVCodecID = 86075;
    #[c2rust::src_loc = "509:5"]
    pub const AV_CODEC_ID_IAC: AVCodecID = 86074;
    #[c2rust::src_loc = "508:5"]
    pub const AV_CODEC_ID_RALF: AVCodecID = 86073;
    #[c2rust::src_loc = "507:5"]
    pub const AV_CODEC_ID_BMV_AUDIO: AVCodecID = 86072;
    #[c2rust::src_loc = "506:5"]
    pub const AV_CODEC_ID_8SVX_FIB: AVCodecID = 86071;
    #[c2rust::src_loc = "505:5"]
    pub const AV_CODEC_ID_8SVX_EXP: AVCodecID = 86070;
    #[c2rust::src_loc = "504:5"]
    pub const AV_CODEC_ID_G729: AVCodecID = 86069;
    #[c2rust::src_loc = "503:5"]
    pub const AV_CODEC_ID_G723_1: AVCodecID = 86068;
    #[c2rust::src_loc = "502:5"]
    pub const AV_CODEC_ID_CELT: AVCodecID = 86067;
    #[c2rust::src_loc = "501:5"]
    pub const AV_CODEC_ID_QDMC: AVCodecID = 86066;
    #[c2rust::src_loc = "500:5"]
    pub const AV_CODEC_ID_AAC_LATM: AVCodecID = 86065;
    #[c2rust::src_loc = "499:5"]
    pub const AV_CODEC_ID_BINKAUDIO_DCT: AVCodecID = 86064;
    #[c2rust::src_loc = "498:5"]
    pub const AV_CODEC_ID_BINKAUDIO_RDFT: AVCodecID = 86063;
    #[c2rust::src_loc = "497:5"]
    pub const AV_CODEC_ID_ATRAC1: AVCodecID = 86062;
    #[c2rust::src_loc = "496:5"]
    pub const AV_CODEC_ID_MP4ALS: AVCodecID = 86061;
    #[c2rust::src_loc = "495:5"]
    pub const AV_CODEC_ID_TRUEHD: AVCodecID = 86060;
    #[c2rust::src_loc = "494:5"]
    pub const AV_CODEC_ID_TWINVQ: AVCodecID = 86059;
    #[c2rust::src_loc = "493:5"]
    pub const AV_CODEC_ID_MP1: AVCodecID = 86058;
    #[c2rust::src_loc = "492:5"]
    pub const AV_CODEC_ID_SIPR: AVCodecID = 86057;
    #[c2rust::src_loc = "491:5"]
    pub const AV_CODEC_ID_EAC3: AVCodecID = 86056;
    #[c2rust::src_loc = "490:5"]
    pub const AV_CODEC_ID_ATRAC3P: AVCodecID = 86055;
    #[c2rust::src_loc = "489:5"]
    pub const AV_CODEC_ID_WMALOSSLESS: AVCodecID = 86054;
    #[c2rust::src_loc = "488:5"]
    pub const AV_CODEC_ID_WMAPRO: AVCodecID = 86053;
    #[c2rust::src_loc = "487:5"]
    pub const AV_CODEC_ID_WMAVOICE: AVCodecID = 86052;
    #[c2rust::src_loc = "486:5"]
    pub const AV_CODEC_ID_SPEEX: AVCodecID = 86051;
    #[c2rust::src_loc = "485:5"]
    pub const AV_CODEC_ID_MUSEPACK8: AVCodecID = 86050;
    #[c2rust::src_loc = "484:5"]
    pub const AV_CODEC_ID_NELLYMOSER: AVCodecID = 86049;
    #[c2rust::src_loc = "483:5"]
    pub const AV_CODEC_ID_APE: AVCodecID = 86048;
    #[c2rust::src_loc = "482:5"]
    pub const AV_CODEC_ID_ATRAC3: AVCodecID = 86047;
    #[c2rust::src_loc = "481:5"]
    pub const AV_CODEC_ID_GSM_MS: AVCodecID = 86046;
    #[c2rust::src_loc = "480:5"]
    pub const AV_CODEC_ID_MLP: AVCodecID = 86045;
    #[c2rust::src_loc = "479:5"]
    pub const AV_CODEC_ID_MUSEPACK7: AVCodecID = 86044;
    #[c2rust::src_loc = "478:5"]
    pub const AV_CODEC_ID_IMC: AVCodecID = 86043;
    #[c2rust::src_loc = "477:5"]
    pub const AV_CODEC_ID_DSICINAUDIO: AVCodecID = 86042;
    #[c2rust::src_loc = "476:5"]
    pub const AV_CODEC_ID_WAVPACK: AVCodecID = 86041;
    #[c2rust::src_loc = "475:5"]
    pub const AV_CODEC_ID_QCELP: AVCodecID = 86040;
    #[c2rust::src_loc = "474:5"]
    pub const AV_CODEC_ID_SMACKAUDIO: AVCodecID = 86039;
    #[c2rust::src_loc = "473:5"]
    pub const AV_CODEC_ID_TTA: AVCodecID = 86038;
    #[c2rust::src_loc = "472:5"]
    pub const AV_CODEC_ID_TRUESPEECH: AVCodecID = 86037;
    #[c2rust::src_loc = "471:5"]
    pub const AV_CODEC_ID_COOK: AVCodecID = 86036;
    #[c2rust::src_loc = "470:5"]
    pub const AV_CODEC_ID_QDM2: AVCodecID = 86035;
    #[c2rust::src_loc = "469:5"]
    pub const AV_CODEC_ID_GSM: AVCodecID = 86034;
    #[c2rust::src_loc = "468:5"]
    pub const AV_CODEC_ID_WESTWOOD_SND1: AVCodecID = 86033;
    #[c2rust::src_loc = "467:5"]
    pub const AV_CODEC_ID_ALAC: AVCodecID = 86032;
    #[c2rust::src_loc = "466:5"]
    pub const AV_CODEC_ID_SHORTEN: AVCodecID = 86031;
    #[c2rust::src_loc = "465:5"]
    pub const AV_CODEC_ID_MP3ON4: AVCodecID = 86030;
    #[c2rust::src_loc = "464:5"]
    pub const AV_CODEC_ID_MP3ADU: AVCodecID = 86029;
    #[c2rust::src_loc = "463:5"]
    pub const AV_CODEC_ID_FLAC: AVCodecID = 86028;
    #[c2rust::src_loc = "462:5"]
    pub const AV_CODEC_ID_VMDAUDIO: AVCodecID = 86027;
    #[c2rust::src_loc = "461:5"]
    pub const AV_CODEC_ID_MACE6: AVCodecID = 86026;
    #[c2rust::src_loc = "460:5"]
    pub const AV_CODEC_ID_MACE3: AVCodecID = 86025;
    #[c2rust::src_loc = "459:5"]
    pub const AV_CODEC_ID_WMAV2: AVCodecID = 86024;
    #[c2rust::src_loc = "458:5"]
    pub const AV_CODEC_ID_WMAV1: AVCodecID = 86023;
    #[c2rust::src_loc = "457:5"]
    pub const AV_CODEC_ID_DVAUDIO: AVCodecID = 86022;
    #[c2rust::src_loc = "456:5"]
    pub const AV_CODEC_ID_VORBIS: AVCodecID = 86021;
    #[c2rust::src_loc = "455:5"]
    pub const AV_CODEC_ID_DTS: AVCodecID = 86020;
    #[c2rust::src_loc = "454:5"]
    pub const AV_CODEC_ID_AC3: AVCodecID = 86019;
    #[c2rust::src_loc = "453:5"]
    pub const AV_CODEC_ID_AAC: AVCodecID = 86018;
    #[c2rust::src_loc = "452:5"]
    pub const AV_CODEC_ID_MP3: AVCodecID = 86017;
    #[c2rust::src_loc = "451:5"]
    pub const AV_CODEC_ID_MP2: AVCodecID = 86016;
    #[c2rust::src_loc = "448:5"]
    pub const AV_CODEC_ID_CBD2_DPCM: AVCodecID = 81928;
    #[c2rust::src_loc = "447:5"]
    pub const AV_CODEC_ID_WADY_DPCM: AVCodecID = 81927;
    #[c2rust::src_loc = "446:5"]
    pub const AV_CODEC_ID_DERF_DPCM: AVCodecID = 81926;
    #[c2rust::src_loc = "445:5"]
    pub const AV_CODEC_ID_GREMLIN_DPCM: AVCodecID = 81925;
    #[c2rust::src_loc = "444:5"]
    pub const AV_CODEC_ID_SDX2_DPCM: AVCodecID = 81924;
    #[c2rust::src_loc = "443:5"]
    pub const AV_CODEC_ID_SOL_DPCM: AVCodecID = 81923;
    #[c2rust::src_loc = "442:5"]
    pub const AV_CODEC_ID_XAN_DPCM: AVCodecID = 81922;
    #[c2rust::src_loc = "441:5"]
    pub const AV_CODEC_ID_INTERPLAY_DPCM: AVCodecID = 81921;
    #[c2rust::src_loc = "440:5"]
    pub const AV_CODEC_ID_ROQ_DPCM: AVCodecID = 81920;
    #[c2rust::src_loc = "437:5"]
    pub const AV_CODEC_ID_RA_288: AVCodecID = 77825;
    #[c2rust::src_loc = "436:5"]
    pub const AV_CODEC_ID_RA_144: AVCodecID = 77824;
    #[c2rust::src_loc = "433:5"]
    pub const AV_CODEC_ID_AMR_WB: AVCodecID = 73729;
    #[c2rust::src_loc = "432:5"]
    pub const AV_CODEC_ID_AMR_NB: AVCodecID = 73728;
    #[c2rust::src_loc = "429:5"]
    pub const AV_CODEC_ID_ADPCM_SANYO: AVCodecID = 69685;
    #[c2rust::src_loc = "428:5"]
    pub const AV_CODEC_ID_ADPCM_IMA_XBOX: AVCodecID = 69684;
    #[c2rust::src_loc = "427:5"]
    pub const AV_CODEC_ID_ADPCM_XMD: AVCodecID = 69683;
    #[c2rust::src_loc = "426:5"]
    pub const AV_CODEC_ID_ADPCM_IMA_ACORN: AVCodecID = 69682;
    #[c2rust::src_loc = "425:5"]
    pub const AV_CODEC_ID_ADPCM_IMA_MOFLEX: AVCodecID = 69681;
    #[c2rust::src_loc = "424:5"]
    pub const AV_CODEC_ID_ADPCM_IMA_CUNNING: AVCodecID = 69680;
    #[c2rust::src_loc = "423:5"]
    pub const AV_CODEC_ID_ADPCM_IMA_MTF: AVCodecID = 69679;
    #[c2rust::src_loc = "422:5"]
    pub const AV_CODEC_ID_ADPCM_IMA_ALP: AVCodecID = 69678;
    #[c2rust::src_loc = "421:5"]
    pub const AV_CODEC_ID_ADPCM_IMA_APM: AVCodecID = 69677;
    #[c2rust::src_loc = "420:5"]
    pub const AV_CODEC_ID_ADPCM_ZORK: AVCodecID = 69676;
    #[c2rust::src_loc = "419:5"]
    pub const AV_CODEC_ID_ADPCM_IMA_SSI: AVCodecID = 69675;
    #[c2rust::src_loc = "418:5"]
    pub const AV_CODEC_ID_ADPCM_ARGO: AVCodecID = 69674;
    #[c2rust::src_loc = "417:5"]
    pub const AV_CODEC_ID_ADPCM_AGM: AVCodecID = 69673;
    #[c2rust::src_loc = "416:5"]
    pub const AV_CODEC_ID_ADPCM_MTAF: AVCodecID = 69672;
    #[c2rust::src_loc = "415:5"]
    pub const AV_CODEC_ID_ADPCM_IMA_DAT4: AVCodecID = 69671;
    #[c2rust::src_loc = "414:5"]
    pub const AV_CODEC_ID_ADPCM_AICA: AVCodecID = 69670;
    #[c2rust::src_loc = "413:5"]
    pub const AV_CODEC_ID_ADPCM_PSX: AVCodecID = 69669;
    #[c2rust::src_loc = "412:5"]
    pub const AV_CODEC_ID_ADPCM_THP_LE: AVCodecID = 69668;
    #[c2rust::src_loc = "411:5"]
    pub const AV_CODEC_ID_ADPCM_G726LE: AVCodecID = 69667;
    #[c2rust::src_loc = "410:5"]
    pub const AV_CODEC_ID_ADPCM_IMA_RAD: AVCodecID = 69666;
    #[c2rust::src_loc = "409:5"]
    pub const AV_CODEC_ID_ADPCM_DTK: AVCodecID = 69665;
    #[c2rust::src_loc = "408:5"]
    pub const AV_CODEC_ID_ADPCM_IMA_OKI: AVCodecID = 69664;
    #[c2rust::src_loc = "407:5"]
    pub const AV_CODEC_ID_ADPCM_AFC: AVCodecID = 69663;
    #[c2rust::src_loc = "406:5"]
    pub const AV_CODEC_ID_ADPCM_VIMA: AVCodecID = 69662;
    #[c2rust::src_loc = "405:5"]
    pub const AV_CODEC_ID_ADPCM_IMA_APC: AVCodecID = 69661;
    #[c2rust::src_loc = "404:5"]
    pub const AV_CODEC_ID_ADPCM_G722: AVCodecID = 69660;
    #[c2rust::src_loc = "403:5"]
    pub const AV_CODEC_ID_ADPCM_IMA_ISS: AVCodecID = 69659;
    #[c2rust::src_loc = "402:5"]
    pub const AV_CODEC_ID_ADPCM_EA_MAXIS_XA: AVCodecID = 69658;
    #[c2rust::src_loc = "401:5"]
    pub const AV_CODEC_ID_ADPCM_EA_XAS: AVCodecID = 69657;
    #[c2rust::src_loc = "400:5"]
    pub const AV_CODEC_ID_ADPCM_IMA_EA_EACS: AVCodecID = 69656;
    #[c2rust::src_loc = "399:5"]
    pub const AV_CODEC_ID_ADPCM_IMA_EA_SEAD: AVCodecID = 69655;
    #[c2rust::src_loc = "398:5"]
    pub const AV_CODEC_ID_ADPCM_EA_R2: AVCodecID = 69654;
    #[c2rust::src_loc = "397:5"]
    pub const AV_CODEC_ID_ADPCM_EA_R3: AVCodecID = 69653;
    #[c2rust::src_loc = "396:5"]
    pub const AV_CODEC_ID_ADPCM_EA_R1: AVCodecID = 69652;
    #[c2rust::src_loc = "395:5"]
    pub const AV_CODEC_ID_ADPCM_IMA_AMV: AVCodecID = 69651;
    #[c2rust::src_loc = "394:5"]
    pub const AV_CODEC_ID_ADPCM_THP: AVCodecID = 69650;
    #[c2rust::src_loc = "393:5"]
    pub const AV_CODEC_ID_ADPCM_SBPRO_2: AVCodecID = 69649;
    #[c2rust::src_loc = "392:5"]
    pub const AV_CODEC_ID_ADPCM_SBPRO_3: AVCodecID = 69648;
    #[c2rust::src_loc = "391:5"]
    pub const AV_CODEC_ID_ADPCM_SBPRO_4: AVCodecID = 69647;
    #[c2rust::src_loc = "390:5"]
    pub const AV_CODEC_ID_ADPCM_YAMAHA: AVCodecID = 69646;
    #[c2rust::src_loc = "389:5"]
    pub const AV_CODEC_ID_ADPCM_SWF: AVCodecID = 69645;
    #[c2rust::src_loc = "388:5"]
    pub const AV_CODEC_ID_ADPCM_CT: AVCodecID = 69644;
    #[c2rust::src_loc = "387:5"]
    pub const AV_CODEC_ID_ADPCM_G726: AVCodecID = 69643;
    #[c2rust::src_loc = "386:5"]
    pub const AV_CODEC_ID_ADPCM_EA: AVCodecID = 69642;
    #[c2rust::src_loc = "385:5"]
    pub const AV_CODEC_ID_ADPCM_ADX: AVCodecID = 69641;
    #[c2rust::src_loc = "384:5"]
    pub const AV_CODEC_ID_ADPCM_XA: AVCodecID = 69640;
    #[c2rust::src_loc = "383:5"]
    pub const AV_CODEC_ID_ADPCM_4XM: AVCodecID = 69639;
    #[c2rust::src_loc = "382:5"]
    pub const AV_CODEC_ID_ADPCM_MS: AVCodecID = 69638;
    #[c2rust::src_loc = "381:5"]
    pub const AV_CODEC_ID_ADPCM_IMA_SMJPEG: AVCodecID = 69637;
    #[c2rust::src_loc = "380:5"]
    pub const AV_CODEC_ID_ADPCM_IMA_WS: AVCodecID = 69636;
    #[c2rust::src_loc = "379:5"]
    pub const AV_CODEC_ID_ADPCM_IMA_DK4: AVCodecID = 69635;
    #[c2rust::src_loc = "378:5"]
    pub const AV_CODEC_ID_ADPCM_IMA_DK3: AVCodecID = 69634;
    #[c2rust::src_loc = "377:5"]
    pub const AV_CODEC_ID_ADPCM_IMA_WAV: AVCodecID = 69633;
    #[c2rust::src_loc = "376:5"]
    pub const AV_CODEC_ID_ADPCM_IMA_QT: AVCodecID = 69632;
    #[c2rust::src_loc = "373:5"]
    pub const AV_CODEC_ID_PCM_SGA: AVCodecID = 65572;
    #[c2rust::src_loc = "372:5"]
    pub const AV_CODEC_ID_PCM_VIDC: AVCodecID = 65571;
    #[c2rust::src_loc = "371:5"]
    pub const AV_CODEC_ID_PCM_F24LE: AVCodecID = 65570;
    #[c2rust::src_loc = "370:5"]
    pub const AV_CODEC_ID_PCM_F16LE: AVCodecID = 65569;
    #[c2rust::src_loc = "369:5"]
    pub const AV_CODEC_ID_PCM_S64BE: AVCodecID = 65568;
    #[c2rust::src_loc = "368:5"]
    pub const AV_CODEC_ID_PCM_S64LE: AVCodecID = 65567;
    #[c2rust::src_loc = "367:5"]
    pub const AV_CODEC_ID_PCM_S16BE_PLANAR: AVCodecID = 65566;
    #[c2rust::src_loc = "366:5"]
    pub const AV_CODEC_ID_PCM_S32LE_PLANAR: AVCodecID = 65565;
    #[c2rust::src_loc = "365:5"]
    pub const AV_CODEC_ID_PCM_S24LE_PLANAR: AVCodecID = 65564;
    #[c2rust::src_loc = "364:5"]
    pub const AV_CODEC_ID_PCM_S8_PLANAR: AVCodecID = 65563;
    #[c2rust::src_loc = "363:5"]
    pub const AV_CODEC_ID_S302M: AVCodecID = 65562;
    #[c2rust::src_loc = "362:5"]
    pub const AV_CODEC_ID_PCM_LXF: AVCodecID = 65561;
    #[c2rust::src_loc = "361:5"]
    pub const AV_CODEC_ID_PCM_BLURAY: AVCodecID = 65560;
    #[c2rust::src_loc = "360:5"]
    pub const AV_CODEC_ID_PCM_F64LE: AVCodecID = 65559;
    #[c2rust::src_loc = "359:5"]
    pub const AV_CODEC_ID_PCM_F64BE: AVCodecID = 65558;
    #[c2rust::src_loc = "358:5"]
    pub const AV_CODEC_ID_PCM_F32LE: AVCodecID = 65557;
    #[c2rust::src_loc = "357:5"]
    pub const AV_CODEC_ID_PCM_F32BE: AVCodecID = 65556;
    #[c2rust::src_loc = "356:5"]
    pub const AV_CODEC_ID_PCM_DVD: AVCodecID = 65555;
    #[c2rust::src_loc = "355:5"]
    pub const AV_CODEC_ID_PCM_S16LE_PLANAR: AVCodecID = 65554;
    #[c2rust::src_loc = "354:5"]
    pub const AV_CODEC_ID_PCM_ZORK: AVCodecID = 65553;
    #[c2rust::src_loc = "353:5"]
    pub const AV_CODEC_ID_PCM_S24DAUD: AVCodecID = 65552;
    #[c2rust::src_loc = "352:5"]
    pub const AV_CODEC_ID_PCM_U24BE: AVCodecID = 65551;
    #[c2rust::src_loc = "351:5"]
    pub const AV_CODEC_ID_PCM_U24LE: AVCodecID = 65550;
    #[c2rust::src_loc = "350:5"]
    pub const AV_CODEC_ID_PCM_S24BE: AVCodecID = 65549;
    #[c2rust::src_loc = "349:5"]
    pub const AV_CODEC_ID_PCM_S24LE: AVCodecID = 65548;
    #[c2rust::src_loc = "348:5"]
    pub const AV_CODEC_ID_PCM_U32BE: AVCodecID = 65547;
    #[c2rust::src_loc = "347:5"]
    pub const AV_CODEC_ID_PCM_U32LE: AVCodecID = 65546;
    #[c2rust::src_loc = "346:5"]
    pub const AV_CODEC_ID_PCM_S32BE: AVCodecID = 65545;
    #[c2rust::src_loc = "345:5"]
    pub const AV_CODEC_ID_PCM_S32LE: AVCodecID = 65544;
    #[c2rust::src_loc = "344:5"]
    pub const AV_CODEC_ID_PCM_ALAW: AVCodecID = 65543;
    #[c2rust::src_loc = "343:5"]
    pub const AV_CODEC_ID_PCM_MULAW: AVCodecID = 65542;
    #[c2rust::src_loc = "342:5"]
    pub const AV_CODEC_ID_PCM_U8: AVCodecID = 65541;
    #[c2rust::src_loc = "341:5"]
    pub const AV_CODEC_ID_PCM_S8: AVCodecID = 65540;
    #[c2rust::src_loc = "340:5"]
    pub const AV_CODEC_ID_PCM_U16BE: AVCodecID = 65539;
    #[c2rust::src_loc = "339:5"]
    pub const AV_CODEC_ID_PCM_U16LE: AVCodecID = 65538;
    #[c2rust::src_loc = "338:5"]
    pub const AV_CODEC_ID_PCM_S16BE: AVCodecID = 65537;
    #[c2rust::src_loc = "337:5"]
    pub const AV_CODEC_ID_PCM_S16LE: AVCodecID = 65536;
    #[c2rust::src_loc = "336:5"]
    pub const AV_CODEC_ID_FIRST_AUDIO: AVCodecID = 65536;
    #[c2rust::src_loc = "333:5"]
    pub const AV_CODEC_ID_PRORES_RAW: AVCodecID = 274;
    #[c2rust::src_loc = "332:5"]
    pub const AV_CODEC_ID_APV: AVCodecID = 273;
    #[c2rust::src_loc = "331:5"]
    pub const AV_CODEC_ID_JPEGXL_ANIM: AVCodecID = 272;
    #[c2rust::src_loc = "330:5"]
    pub const AV_CODEC_ID_RV60: AVCodecID = 271;
    #[c2rust::src_loc = "329:5"]
    pub const AV_CODEC_ID_DNXUC: AVCodecID = 270;
    #[c2rust::src_loc = "328:5"]
    pub const AV_CODEC_ID_LEAD: AVCodecID = 269;
    #[c2rust::src_loc = "327:5"]
    pub const AV_CODEC_ID_VMIX: AVCodecID = 268;
    #[c2rust::src_loc = "326:5"]
    pub const AV_CODEC_ID_RTV1: AVCodecID = 267;
    #[c2rust::src_loc = "325:5"]
    pub const AV_CODEC_ID_EVC: AVCodecID = 266;
    #[c2rust::src_loc = "324:5"]
    pub const AV_CODEC_ID_PDV: AVCodecID = 265;
    #[c2rust::src_loc = "323:5"]
    pub const AV_CODEC_ID_VQC: AVCodecID = 264;
    #[c2rust::src_loc = "322:5"]
    pub const AV_CODEC_ID_MEDIA100: AVCodecID = 263;
    #[c2rust::src_loc = "321:5"]
    pub const AV_CODEC_ID_WBMP: AVCodecID = 262;
    #[c2rust::src_loc = "320:5"]
    pub const AV_CODEC_ID_RADIANCE_HDR: AVCodecID = 261;
    #[c2rust::src_loc = "319:5"]
    pub const AV_CODEC_ID_PHM: AVCodecID = 260;
    #[c2rust::src_loc = "318:5"]
    pub const AV_CODEC_ID_QOI: AVCodecID = 259;
    #[c2rust::src_loc = "317:5"]
    pub const AV_CODEC_ID_JPEGXL: AVCodecID = 258;
    #[c2rust::src_loc = "316:5"]
    pub const AV_CODEC_ID_VBN: AVCodecID = 257;
    #[c2rust::src_loc = "315:5"]
    pub const AV_CODEC_ID_GEM: AVCodecID = 256;
    #[c2rust::src_loc = "314:5"]
    pub const AV_CODEC_ID_SGA_VIDEO: AVCodecID = 255;
    #[c2rust::src_loc = "313:5"]
    pub const AV_CODEC_ID_SIMBIOSIS_IMX: AVCodecID = 254;
    #[c2rust::src_loc = "312:5"]
    pub const AV_CODEC_ID_CRI: AVCodecID = 253;
    #[c2rust::src_loc = "311:5"]
    pub const AV_CODEC_ID_ARGO: AVCodecID = 252;
    #[c2rust::src_loc = "310:5"]
    pub const AV_CODEC_ID_IPU: AVCodecID = 251;
    #[c2rust::src_loc = "309:5"]
    pub const AV_CODEC_ID_PHOTOCD: AVCodecID = 250;
    #[c2rust::src_loc = "308:5"]
    pub const AV_CODEC_ID_MOBICLIP: AVCodecID = 249;
    #[c2rust::src_loc = "307:5"]
    pub const AV_CODEC_ID_PFM: AVCodecID = 248;
    #[c2rust::src_loc = "306:5"]
    pub const AV_CODEC_ID_NOTCHLC: AVCodecID = 247;
    #[c2rust::src_loc = "305:5"]
    pub const AV_CODEC_ID_MV30: AVCodecID = 246;
    #[c2rust::src_loc = "304:5"]
    pub const AV_CODEC_ID_CDTOONS: AVCodecID = 245;
    #[c2rust::src_loc = "303:5"]
    pub const AV_CODEC_ID_MVHA: AVCodecID = 244;
    #[c2rust::src_loc = "302:5"]
    pub const AV_CODEC_ID_MVDV: AVCodecID = 243;
    #[c2rust::src_loc = "301:5"]
    pub const AV_CODEC_ID_IMM5: AVCodecID = 242;
    #[c2rust::src_loc = "300:5"]
    pub const AV_CODEC_ID_VP4: AVCodecID = 241;
    #[c2rust::src_loc = "299:5"]
    pub const AV_CODEC_ID_LSCR: AVCodecID = 240;
    #[c2rust::src_loc = "298:5"]
    pub const AV_CODEC_ID_AGM: AVCodecID = 239;
    #[c2rust::src_loc = "297:5"]
    pub const AV_CODEC_ID_ARBC: AVCodecID = 238;
    #[c2rust::src_loc = "296:5"]
    pub const AV_CODEC_ID_HYMT: AVCodecID = 237;
    #[c2rust::src_loc = "295:5"]
    pub const AV_CODEC_ID_RASC: AVCodecID = 236;
    #[c2rust::src_loc = "294:5"]
    pub const AV_CODEC_ID_WCMV: AVCodecID = 235;
    #[c2rust::src_loc = "293:5"]
    pub const AV_CODEC_ID_MWSC: AVCodecID = 234;
    #[c2rust::src_loc = "292:5"]
    pub const AV_CODEC_ID_PROSUMER: AVCodecID = 233;
    #[c2rust::src_loc = "291:5"]
    pub const AV_CODEC_ID_IMM4: AVCodecID = 232;
    #[c2rust::src_loc = "290:5"]
    pub const AV_CODEC_ID_FITS: AVCodecID = 231;
    #[c2rust::src_loc = "289:5"]
    pub const AV_CODEC_ID_GDV: AVCodecID = 230;
    #[c2rust::src_loc = "288:5"]
    pub const AV_CODEC_ID_SVG: AVCodecID = 229;
    #[c2rust::src_loc = "287:5"]
    pub const AV_CODEC_ID_SRGC: AVCodecID = 228;
    #[c2rust::src_loc = "286:5"]
    pub const AV_CODEC_ID_MSCC: AVCodecID = 227;
    #[c2rust::src_loc = "285:5"]
    pub const AV_CODEC_ID_BITPACKED: AVCodecID = 226;
    #[c2rust::src_loc = "284:5"]
    pub const AV_CODEC_ID_AV1: AVCodecID = 225;
    #[c2rust::src_loc = "283:5"]
    pub const AV_CODEC_ID_XPM: AVCodecID = 224;
    #[c2rust::src_loc = "282:5"]
    pub const AV_CODEC_ID_CLEARVIDEO: AVCodecID = 223;
    #[c2rust::src_loc = "281:5"]
    pub const AV_CODEC_ID_SCPR: AVCodecID = 222;
    #[c2rust::src_loc = "280:5"]
    pub const AV_CODEC_ID_FMVC: AVCodecID = 221;
    #[c2rust::src_loc = "279:5"]
    pub const AV_CODEC_ID_SPEEDHQ: AVCodecID = 220;
    #[c2rust::src_loc = "278:5"]
    pub const AV_CODEC_ID_PIXLET: AVCodecID = 219;
    #[c2rust::src_loc = "277:5"]
    pub const AV_CODEC_ID_PSD: AVCodecID = 218;
    #[c2rust::src_loc = "276:5"]
    pub const AV_CODEC_ID_YLC: AVCodecID = 217;
    #[c2rust::src_loc = "275:5"]
    pub const AV_CODEC_ID_SHEERVIDEO: AVCodecID = 216;
    #[c2rust::src_loc = "274:5"]
    pub const AV_CODEC_ID_MAGICYUV: AVCodecID = 215;
    #[c2rust::src_loc = "273:5"]
    pub const AV_CODEC_ID_M101: AVCodecID = 214;
    #[c2rust::src_loc = "272:5"]
    pub const AV_CODEC_ID_TRUEMOTION2RT: AVCodecID = 213;
    #[c2rust::src_loc = "271:5"]
    pub const AV_CODEC_ID_CFHD: AVCodecID = 212;
    #[c2rust::src_loc = "270:5"]
    pub const AV_CODEC_ID_DAALA: AVCodecID = 211;
    #[c2rust::src_loc = "269:5"]
    pub const AV_CODEC_ID_APNG: AVCodecID = 210;
    #[c2rust::src_loc = "268:5"]
    pub const AV_CODEC_ID_SMVJPEG: AVCodecID = 209;
    #[c2rust::src_loc = "267:5"]
    pub const AV_CODEC_ID_SNOW: AVCodecID = 208;
    #[c2rust::src_loc = "266:5"]
    pub const AV_CODEC_ID_XFACE: AVCodecID = 207;
    #[c2rust::src_loc = "265:5"]
    pub const AV_CODEC_ID_CPIA: AVCodecID = 206;
    #[c2rust::src_loc = "264:5"]
    pub const AV_CODEC_ID_AVRN: AVCodecID = 205;
    #[c2rust::src_loc = "263:5"]
    pub const AV_CODEC_ID_YUV4: AVCodecID = 204;
    #[c2rust::src_loc = "261:5"]
    pub const AV_CODEC_ID_V408: AVCodecID = 203;
    #[c2rust::src_loc = "260:5"]
    pub const AV_CODEC_ID_V308: AVCodecID = 202;
    #[c2rust::src_loc = "258:5"]
    pub const AV_CODEC_ID_TARGA_Y216: AVCodecID = 201;
    #[c2rust::src_loc = "257:5"]
    pub const AV_CODEC_ID_AVUI: AVCodecID = 200;
    #[c2rust::src_loc = "256:5"]
    pub const AV_CODEC_ID_012V: AVCodecID = 199;
    #[c2rust::src_loc = "255:5"]
    pub const AV_CODEC_ID_AVRP: AVCodecID = 198;
    #[c2rust::src_loc = "254:5"]
    pub const AV_CODEC_ID_Y41P: AVCodecID = 197;
    #[c2rust::src_loc = "252:5"]
    pub const AV_CODEC_ID_VVC: AVCodecID = 196;
    #[c2rust::src_loc = "251:5"]
    pub const AV_CODEC_ID_MSP2: AVCodecID = 195;
    #[c2rust::src_loc = "250:5"]
    pub const AV_CODEC_ID_AVS3: AVCodecID = 194;
    #[c2rust::src_loc = "249:5"]
    pub const AV_CODEC_ID_PGX: AVCodecID = 193;
    #[c2rust::src_loc = "248:5"]
    pub const AV_CODEC_ID_AVS2: AVCodecID = 192;
    #[c2rust::src_loc = "247:5"]
    pub const AV_CODEC_ID_RSCC: AVCodecID = 191;
    #[c2rust::src_loc = "246:5"]
    pub const AV_CODEC_ID_SCREENPRESSO: AVCodecID = 190;
    #[c2rust::src_loc = "245:5"]
    pub const AV_CODEC_ID_DXV: AVCodecID = 189;
    #[c2rust::src_loc = "244:5"]
    pub const AV_CODEC_ID_DDS: AVCodecID = 188;
    #[c2rust::src_loc = "243:5"]
    pub const AV_CODEC_ID_HAP: AVCodecID = 187;
    #[c2rust::src_loc = "242:5"]
    pub const AV_CODEC_ID_HQ_HQA: AVCodecID = 186;
    #[c2rust::src_loc = "241:5"]
    pub const AV_CODEC_ID_TDSC: AVCodecID = 185;
    #[c2rust::src_loc = "240:5"]
    pub const AV_CODEC_ID_HQX: AVCodecID = 184;
    #[c2rust::src_loc = "239:5"]
    pub const AV_CODEC_ID_MVC2: AVCodecID = 183;
    #[c2rust::src_loc = "238:5"]
    pub const AV_CODEC_ID_MVC1: AVCodecID = 182;
    #[c2rust::src_loc = "237:5"]
    pub const AV_CODEC_ID_SGIRLE: AVCodecID = 181;
    #[c2rust::src_loc = "236:5"]
    pub const AV_CODEC_ID_SANM: AVCodecID = 180;
    #[c2rust::src_loc = "235:5"]
    pub const AV_CODEC_ID_VP7: AVCodecID = 179;
    #[c2rust::src_loc = "234:5"]
    pub const AV_CODEC_ID_EXR: AVCodecID = 178;
    #[c2rust::src_loc = "233:5"]
    pub const AV_CODEC_ID_PAF_VIDEO: AVCodecID = 177;
    #[c2rust::src_loc = "232:5"]
    pub const AV_CODEC_ID_BRENDER_PIX: AVCodecID = 176;
    #[c2rust::src_loc = "231:5"]
    pub const AV_CODEC_ID_ALIAS_PIX: AVCodecID = 175;
    #[c2rust::src_loc = "230:5"]
    pub const AV_CODEC_ID_FIC: AVCodecID = 174;
    #[c2rust::src_loc = "228:5"]
    pub const AV_CODEC_ID_HEVC: AVCodecID = 173;
    #[c2rust::src_loc = "227:5"]
    pub const AV_CODEC_ID_HNM4_VIDEO: AVCodecID = 172;
    #[c2rust::src_loc = "226:5"]
    pub const AV_CODEC_ID_WEBP: AVCodecID = 171;
    #[c2rust::src_loc = "225:5"]
    pub const AV_CODEC_ID_G2M: AVCodecID = 170;
    #[c2rust::src_loc = "224:5"]
    pub const AV_CODEC_ID_ESCAPE130: AVCodecID = 169;
    #[c2rust::src_loc = "223:5"]
    pub const AV_CODEC_ID_AIC: AVCodecID = 168;
    #[c2rust::src_loc = "222:5"]
    pub const AV_CODEC_ID_VP9: AVCodecID = 167;
    #[c2rust::src_loc = "221:5"]
    pub const AV_CODEC_ID_MSS2: AVCodecID = 166;
    #[c2rust::src_loc = "220:5"]
    pub const AV_CODEC_ID_CLLC: AVCodecID = 165;
    #[c2rust::src_loc = "219:5"]
    pub const AV_CODEC_ID_MTS2: AVCodecID = 164;
    #[c2rust::src_loc = "218:5"]
    pub const AV_CODEC_ID_TSCC2: AVCodecID = 163;
    #[c2rust::src_loc = "217:5"]
    pub const AV_CODEC_ID_MSA1: AVCodecID = 162;
    #[c2rust::src_loc = "216:5"]
    pub const AV_CODEC_ID_MSS1: AVCodecID = 161;
    #[c2rust::src_loc = "215:5"]
    pub const AV_CODEC_ID_ZEROCODEC: AVCodecID = 160;
    #[c2rust::src_loc = "214:5"]
    pub const AV_CODEC_ID_XBM: AVCodecID = 159;
    #[c2rust::src_loc = "213:5"]
    pub const AV_CODEC_ID_CDXL: AVCodecID = 158;
    #[c2rust::src_loc = "212:5"]
    pub const AV_CODEC_ID_XWD: AVCodecID = 157;
    #[c2rust::src_loc = "210:5"]
    pub const AV_CODEC_ID_V410: AVCodecID = 156;
    #[c2rust::src_loc = "208:5"]
    pub const AV_CODEC_ID_DXTORY: AVCodecID = 155;
    #[c2rust::src_loc = "207:5"]
    pub const AV_CODEC_ID_VBLE: AVCodecID = 154;
    #[c2rust::src_loc = "206:5"]
    pub const AV_CODEC_ID_BMV_VIDEO: AVCodecID = 153;
    #[c2rust::src_loc = "205:5"]
    pub const AV_CODEC_ID_UTVIDEO: AVCodecID = 152;
    #[c2rust::src_loc = "204:5"]
    pub const AV_CODEC_ID_VC1IMAGE: AVCodecID = 151;
    #[c2rust::src_loc = "203:5"]
    pub const AV_CODEC_ID_WMV3IMAGE: AVCodecID = 150;
    #[c2rust::src_loc = "202:5"]
    pub const AV_CODEC_ID_DFA: AVCodecID = 149;
    #[c2rust::src_loc = "201:5"]
    pub const AV_CODEC_ID_JV: AVCodecID = 148;
    #[c2rust::src_loc = "200:5"]
    pub const AV_CODEC_ID_PRORES: AVCodecID = 147;
    #[c2rust::src_loc = "199:5"]
    pub const AV_CODEC_ID_LAGARITH: AVCodecID = 146;
    #[c2rust::src_loc = "198:5"]
    pub const AV_CODEC_ID_MXPEG: AVCodecID = 145;
    #[c2rust::src_loc = "197:5"]
    pub const AV_CODEC_ID_R10K: AVCodecID = 144;
    #[c2rust::src_loc = "196:5"]
    pub const AV_CODEC_ID_A64_MULTI5: AVCodecID = 143;
    #[c2rust::src_loc = "195:5"]
    pub const AV_CODEC_ID_A64_MULTI: AVCodecID = 142;
    #[c2rust::src_loc = "194:5"]
    pub const AV_CODEC_ID_ANSI: AVCodecID = 141;
    #[c2rust::src_loc = "193:5"]
    pub const AV_CODEC_ID_PICTOR: AVCodecID = 140;
    #[c2rust::src_loc = "192:5"]
    pub const AV_CODEC_ID_VP8: AVCodecID = 139;
    #[c2rust::src_loc = "191:5"]
    pub const AV_CODEC_ID_YOP: AVCodecID = 138;
    #[c2rust::src_loc = "190:5"]
    pub const AV_CODEC_ID_KGV1: AVCodecID = 137;
    #[c2rust::src_loc = "188:5"]
    pub const AV_CODEC_ID_IFF_ILBM: AVCodecID = 136;
    #[c2rust::src_loc = "187:5"]
    pub const AV_CODEC_ID_BINKVIDEO: AVCodecID = 135;
    #[c2rust::src_loc = "186:5"]
    pub const AV_CODEC_ID_ANM: AVCodecID = 134;
    #[c2rust::src_loc = "185:5"]
    pub const AV_CODEC_ID_R210: AVCodecID = 133;
    #[c2rust::src_loc = "184:5"]
    pub const AV_CODEC_ID_CDGRAPHICS: AVCodecID = 132;
    #[c2rust::src_loc = "183:5"]
    pub const AV_CODEC_ID_FLASHSV2: AVCodecID = 131;
    #[c2rust::src_loc = "182:5"]
    pub const AV_CODEC_ID_FRWU: AVCodecID = 130;
    #[c2rust::src_loc = "181:5"]
    pub const AV_CODEC_ID_MAD: AVCodecID = 129;
    #[c2rust::src_loc = "180:5"]
    pub const AV_CODEC_ID_DPX: AVCodecID = 128;
    #[c2rust::src_loc = "179:5"]
    pub const AV_CODEC_ID_V210: AVCodecID = 127;
    #[c2rust::src_loc = "178:5"]
    pub const AV_CODEC_ID_TMV: AVCodecID = 126;
    #[c2rust::src_loc = "177:5"]
    pub const AV_CODEC_ID_V210X: AVCodecID = 125;
    #[c2rust::src_loc = "176:5"]
    pub const AV_CODEC_ID_AURA2: AVCodecID = 124;
    #[c2rust::src_loc = "175:5"]
    pub const AV_CODEC_ID_AURA: AVCodecID = 123;
    #[c2rust::src_loc = "174:5"]
    pub const AV_CODEC_ID_TQI: AVCodecID = 122;
    #[c2rust::src_loc = "173:5"]
    pub const AV_CODEC_ID_TGQ: AVCodecID = 121;
    #[c2rust::src_loc = "172:5"]
    pub const AV_CODEC_ID_TGV: AVCodecID = 120;
    #[c2rust::src_loc = "171:5"]
    pub const AV_CODEC_ID_MOTIONPIXELS: AVCodecID = 119;
    #[c2rust::src_loc = "170:5"]
    pub const AV_CODEC_ID_CMV: AVCodecID = 118;
    #[c2rust::src_loc = "169:5"]
    pub const AV_CODEC_ID_BFI: AVCodecID = 117;
    #[c2rust::src_loc = "168:5"]
    pub const AV_CODEC_ID_DIRAC: AVCodecID = 116;
    #[c2rust::src_loc = "167:5"]
    pub const AV_CODEC_ID_ESCAPE124: AVCodecID = 115;
    #[c2rust::src_loc = "166:5"]
    pub const AV_CODEC_ID_RL2: AVCodecID = 114;
    #[c2rust::src_loc = "165:5"]
    pub const AV_CODEC_ID_MIMIC: AVCodecID = 113;
    #[c2rust::src_loc = "164:5"]
    pub const AV_CODEC_ID_INDEO5: AVCodecID = 112;
    #[c2rust::src_loc = "163:5"]
    pub const AV_CODEC_ID_INDEO4: AVCodecID = 111;
    #[c2rust::src_loc = "162:5"]
    pub const AV_CODEC_ID_SUNRAST: AVCodecID = 110;
    #[c2rust::src_loc = "161:5"]
    pub const AV_CODEC_ID_PCX: AVCodecID = 109;
    #[c2rust::src_loc = "160:5"]
    pub const AV_CODEC_ID_VB: AVCodecID = 108;
    #[c2rust::src_loc = "159:5"]
    pub const AV_CODEC_ID_AMV: AVCodecID = 107;
    #[c2rust::src_loc = "158:5"]
    pub const AV_CODEC_ID_VP6A: AVCodecID = 106;
    #[c2rust::src_loc = "157:5"]
    pub const AV_CODEC_ID_TXD: AVCodecID = 105;
    #[c2rust::src_loc = "156:5"]
    pub const AV_CODEC_ID_PTX: AVCodecID = 104;
    #[c2rust::src_loc = "155:5"]
    pub const AV_CODEC_ID_BETHSOFTVID: AVCodecID = 103;
    #[c2rust::src_loc = "154:5"]
    pub const AV_CODEC_ID_C93: AVCodecID = 102;
    #[c2rust::src_loc = "153:5"]
    pub const AV_CODEC_ID_SGI: AVCodecID = 101;
    #[c2rust::src_loc = "152:5"]
    pub const AV_CODEC_ID_THP: AVCodecID = 100;
    #[c2rust::src_loc = "151:5"]
    pub const AV_CODEC_ID_DNXHD: AVCodecID = 99;
    #[c2rust::src_loc = "150:5"]
    pub const AV_CODEC_ID_DXA: AVCodecID = 98;
    #[c2rust::src_loc = "149:5"]
    pub const AV_CODEC_ID_GIF: AVCodecID = 97;
    #[c2rust::src_loc = "148:5"]
    pub const AV_CODEC_ID_TIFF: AVCodecID = 96;
    #[c2rust::src_loc = "147:5"]
    pub const AV_CODEC_ID_TIERTEXSEQVIDEO: AVCodecID = 95;
    #[c2rust::src_loc = "146:5"]
    pub const AV_CODEC_ID_DSICINVIDEO: AVCodecID = 94;
    #[c2rust::src_loc = "145:5"]
    pub const AV_CODEC_ID_TARGA: AVCodecID = 93;
    #[c2rust::src_loc = "144:5"]
    pub const AV_CODEC_ID_VP6F: AVCodecID = 92;
    #[c2rust::src_loc = "143:5"]
    pub const AV_CODEC_ID_VP6: AVCodecID = 91;
    #[c2rust::src_loc = "142:5"]
    pub const AV_CODEC_ID_VP5: AVCodecID = 90;
    #[c2rust::src_loc = "141:5"]
    pub const AV_CODEC_ID_VMNC: AVCodecID = 89;
    #[c2rust::src_loc = "140:5"]
    pub const AV_CODEC_ID_JPEG2000: AVCodecID = 88;
    #[c2rust::src_loc = "139:5"]
    pub const AV_CODEC_ID_CAVS: AVCodecID = 87;
    #[c2rust::src_loc = "138:5"]
    pub const AV_CODEC_ID_FLASHSV: AVCodecID = 86;
    #[c2rust::src_loc = "137:5"]
    pub const AV_CODEC_ID_KMVC: AVCodecID = 85;
    #[c2rust::src_loc = "136:5"]
    pub const AV_CODEC_ID_NUV: AVCodecID = 84;
    #[c2rust::src_loc = "135:5"]
    pub const AV_CODEC_ID_SMACKVIDEO: AVCodecID = 83;
    #[c2rust::src_loc = "134:5"]
    pub const AV_CODEC_ID_AVS: AVCodecID = 82;
    #[c2rust::src_loc = "133:5"]
    pub const AV_CODEC_ID_ZMBV: AVCodecID = 81;
    #[c2rust::src_loc = "132:5"]
    pub const AV_CODEC_ID_MMVIDEO: AVCodecID = 80;
    #[c2rust::src_loc = "131:5"]
    pub const AV_CODEC_ID_CSCD: AVCodecID = 79;
    #[c2rust::src_loc = "130:5"]
    pub const AV_CODEC_ID_BMP: AVCodecID = 78;
    #[c2rust::src_loc = "129:5"]
    pub const AV_CODEC_ID_TRUEMOTION2: AVCodecID = 77;
    #[c2rust::src_loc = "128:5"]
    pub const AV_CODEC_ID_FRAPS: AVCodecID = 76;
    #[c2rust::src_loc = "127:5"]
    pub const AV_CODEC_ID_INDEO2: AVCodecID = 75;
    #[c2rust::src_loc = "126:5"]
    pub const AV_CODEC_ID_AASC: AVCodecID = 74;
    #[c2rust::src_loc = "125:5"]
    pub const AV_CODEC_ID_WNV1: AVCodecID = 73;
    #[c2rust::src_loc = "124:5"]
    pub const AV_CODEC_ID_LOCO: AVCodecID = 72;
    #[c2rust::src_loc = "123:5"]
    pub const AV_CODEC_ID_WMV3: AVCodecID = 71;
    #[c2rust::src_loc = "122:5"]
    pub const AV_CODEC_ID_VC1: AVCodecID = 70;
    #[c2rust::src_loc = "121:5"]
    pub const AV_CODEC_ID_RV40: AVCodecID = 69;
    #[c2rust::src_loc = "120:5"]
    pub const AV_CODEC_ID_RV30: AVCodecID = 68;
    #[c2rust::src_loc = "119:5"]
    pub const AV_CODEC_ID_FFVHUFF: AVCodecID = 67;
    #[c2rust::src_loc = "118:5"]
    pub const AV_CODEC_ID_PAM: AVCodecID = 66;
    #[c2rust::src_loc = "117:5"]
    pub const AV_CODEC_ID_PGMYUV: AVCodecID = 65;
    #[c2rust::src_loc = "116:5"]
    pub const AV_CODEC_ID_PGM: AVCodecID = 64;
    #[c2rust::src_loc = "115:5"]
    pub const AV_CODEC_ID_PBM: AVCodecID = 63;
    #[c2rust::src_loc = "114:5"]
    pub const AV_CODEC_ID_PPM: AVCodecID = 62;
    #[c2rust::src_loc = "113:5"]
    pub const AV_CODEC_ID_PNG: AVCodecID = 61;
    #[c2rust::src_loc = "112:5"]
    pub const AV_CODEC_ID_QPEG: AVCodecID = 60;
    #[c2rust::src_loc = "111:5"]
    pub const AV_CODEC_ID_VIXL: AVCodecID = 59;
    #[c2rust::src_loc = "110:5"]
    pub const AV_CODEC_ID_QDRAW: AVCodecID = 58;
    #[c2rust::src_loc = "109:5"]
    pub const AV_CODEC_ID_ULTI: AVCodecID = 57;
    #[c2rust::src_loc = "108:5"]
    pub const AV_CODEC_ID_TSCC: AVCodecID = 56;
    #[c2rust::src_loc = "107:5"]
    pub const AV_CODEC_ID_QTRLE: AVCodecID = 55;
    #[c2rust::src_loc = "106:5"]
    pub const AV_CODEC_ID_ZLIB: AVCodecID = 54;
    #[c2rust::src_loc = "105:5"]
    pub const AV_CODEC_ID_MSZH: AVCodecID = 53;
    #[c2rust::src_loc = "104:5"]
    pub const AV_CODEC_ID_VMDVIDEO: AVCodecID = 52;
    #[c2rust::src_loc = "103:5"]
    pub const AV_CODEC_ID_TRUEMOTION1: AVCodecID = 51;
    #[c2rust::src_loc = "102:5"]
    pub const AV_CODEC_ID_FLIC: AVCodecID = 50;
    #[c2rust::src_loc = "101:5"]
    pub const AV_CODEC_ID_SMC: AVCodecID = 49;
    #[c2rust::src_loc = "100:5"]
    pub const AV_CODEC_ID_8BPS: AVCodecID = 48;
    #[c2rust::src_loc = "99:5"]
    pub const AV_CODEC_ID_IDCIN: AVCodecID = 47;
    #[c2rust::src_loc = "98:5"]
    pub const AV_CODEC_ID_MSVIDEO1: AVCodecID = 46;
    #[c2rust::src_loc = "97:5"]
    pub const AV_CODEC_ID_MSRLE: AVCodecID = 45;
    #[c2rust::src_loc = "96:5"]
    pub const AV_CODEC_ID_WS_VQA: AVCodecID = 44;
    #[c2rust::src_loc = "95:5"]
    pub const AV_CODEC_ID_CINEPAK: AVCodecID = 43;
    #[c2rust::src_loc = "94:5"]
    pub const AV_CODEC_ID_RPZA: AVCodecID = 42;
    #[c2rust::src_loc = "93:5"]
    pub const AV_CODEC_ID_XAN_WC4: AVCodecID = 41;
    #[c2rust::src_loc = "92:5"]
    pub const AV_CODEC_ID_XAN_WC3: AVCodecID = 40;
    #[c2rust::src_loc = "91:5"]
    pub const AV_CODEC_ID_INTERPLAY_VIDEO: AVCodecID = 39;
    #[c2rust::src_loc = "90:5"]
    pub const AV_CODEC_ID_ROQ: AVCodecID = 38;
    #[c2rust::src_loc = "89:5"]
    pub const AV_CODEC_ID_MDEC: AVCodecID = 37;
    #[c2rust::src_loc = "88:5"]
    pub const AV_CODEC_ID_CLJR: AVCodecID = 36;
    #[c2rust::src_loc = "87:5"]
    pub const AV_CODEC_ID_VCR1: AVCodecID = 35;
    #[c2rust::src_loc = "86:5"]
    pub const AV_CODEC_ID_4XM: AVCodecID = 34;
    #[c2rust::src_loc = "85:5"]
    pub const AV_CODEC_ID_FFV1: AVCodecID = 33;
    #[c2rust::src_loc = "84:5"]
    pub const AV_CODEC_ID_ASV2: AVCodecID = 32;
    #[c2rust::src_loc = "83:5"]
    pub const AV_CODEC_ID_ASV1: AVCodecID = 31;
    #[c2rust::src_loc = "82:5"]
    pub const AV_CODEC_ID_THEORA: AVCodecID = 30;
    #[c2rust::src_loc = "81:5"]
    pub const AV_CODEC_ID_VP3: AVCodecID = 29;
    #[c2rust::src_loc = "80:5"]
    pub const AV_CODEC_ID_INDEO3: AVCodecID = 28;
    #[c2rust::src_loc = "79:5"]
    pub const AV_CODEC_ID_H264: AVCodecID = 27;
    #[c2rust::src_loc = "78:5"]
    pub const AV_CODEC_ID_CYUV: AVCodecID = 26;
    #[c2rust::src_loc = "77:5"]
    pub const AV_CODEC_ID_HUFFYUV: AVCodecID = 25;
    #[c2rust::src_loc = "76:5"]
    pub const AV_CODEC_ID_DVVIDEO: AVCodecID = 24;
    #[c2rust::src_loc = "75:5"]
    pub const AV_CODEC_ID_SVQ3: AVCodecID = 23;
    #[c2rust::src_loc = "74:5"]
    pub const AV_CODEC_ID_SVQ1: AVCodecID = 22;
    #[c2rust::src_loc = "73:5"]
    pub const AV_CODEC_ID_FLV1: AVCodecID = 21;
    #[c2rust::src_loc = "72:5"]
    pub const AV_CODEC_ID_H263I: AVCodecID = 20;
    #[c2rust::src_loc = "71:5"]
    pub const AV_CODEC_ID_H263P: AVCodecID = 19;
    #[c2rust::src_loc = "70:5"]
    pub const AV_CODEC_ID_WMV2: AVCodecID = 18;
    #[c2rust::src_loc = "69:5"]
    pub const AV_CODEC_ID_WMV1: AVCodecID = 17;
    #[c2rust::src_loc = "68:5"]
    pub const AV_CODEC_ID_MSMPEG4V3: AVCodecID = 16;
    #[c2rust::src_loc = "67:5"]
    pub const AV_CODEC_ID_MSMPEG4V2: AVCodecID = 15;
    #[c2rust::src_loc = "66:5"]
    pub const AV_CODEC_ID_MSMPEG4V1: AVCodecID = 14;
    #[c2rust::src_loc = "65:5"]
    pub const AV_CODEC_ID_RAWVIDEO: AVCodecID = 13;
    #[c2rust::src_loc = "64:5"]
    pub const AV_CODEC_ID_MPEG4: AVCodecID = 12;
    #[c2rust::src_loc = "63:5"]
    pub const AV_CODEC_ID_JPEGLS: AVCodecID = 11;
    #[c2rust::src_loc = "62:5"]
    pub const AV_CODEC_ID_SP5X: AVCodecID = 10;
    #[c2rust::src_loc = "61:5"]
    pub const AV_CODEC_ID_LJPEG: AVCodecID = 9;
    #[c2rust::src_loc = "60:5"]
    pub const AV_CODEC_ID_MJPEGB: AVCodecID = 8;
    #[c2rust::src_loc = "59:5"]
    pub const AV_CODEC_ID_MJPEG: AVCodecID = 7;
    #[c2rust::src_loc = "58:5"]
    pub const AV_CODEC_ID_RV20: AVCodecID = 6;
    #[c2rust::src_loc = "57:5"]
    pub const AV_CODEC_ID_RV10: AVCodecID = 5;
    #[c2rust::src_loc = "56:5"]
    pub const AV_CODEC_ID_H263: AVCodecID = 4;
    #[c2rust::src_loc = "55:5"]
    pub const AV_CODEC_ID_H261: AVCodecID = 3;
    #[c2rust::src_loc = "54:5"]
    pub const AV_CODEC_ID_MPEG2VIDEO: AVCodecID = 2;
    #[c2rust::src_loc = "53:5"]
    pub const AV_CODEC_ID_MPEG1VIDEO: AVCodecID = 1;
    #[c2rust::src_loc = "50:5"]
    pub const AV_CODEC_ID_NONE: AVCodecID = 0;
}
#[c2rust::header_src = "/usr/include/libavcodec/defs.h:27"]
pub mod defs_h {
    use ::core::ffi::{c_int, c_uint};

    #[c2rust::src_loc = "223:1"]
    pub type AVDiscard = c_int;
    #[c2rust::src_loc = "232:5"]
    pub const AVDISCARD_ALL: AVDiscard = 48;
    #[c2rust::src_loc = "231:5"]
    pub const AVDISCARD_NONKEY: AVDiscard = 32;
    #[c2rust::src_loc = "230:5"]
    pub const AVDISCARD_NONINTRA: AVDiscard = 24;
    #[c2rust::src_loc = "229:5"]
    pub const AVDISCARD_BIDIR: AVDiscard = 16;
    #[c2rust::src_loc = "228:5"]
    pub const AVDISCARD_NONREF: AVDiscard = 8;
    #[c2rust::src_loc = "227:5"]
    pub const AVDISCARD_DEFAULT: AVDiscard = 0;
    #[c2rust::src_loc = "226:5"]
    pub const AVDISCARD_NONE: AVDiscard = -16;
    #[c2rust::src_loc = "235:1"]
    pub type AVAudioServiceType = c_uint;
    #[c2rust::src_loc = "245:5"]
    pub const AV_AUDIO_SERVICE_TYPE_NB: AVAudioServiceType = 9;
    #[c2rust::src_loc = "244:5"]
    pub const AV_AUDIO_SERVICE_TYPE_KARAOKE: AVAudioServiceType = 8;
    #[c2rust::src_loc = "243:5"]
    pub const AV_AUDIO_SERVICE_TYPE_VOICE_OVER: AVAudioServiceType = 7;
    #[c2rust::src_loc = "242:5"]
    pub const AV_AUDIO_SERVICE_TYPE_EMERGENCY: AVAudioServiceType = 6;
    #[c2rust::src_loc = "241:5"]
    pub const AV_AUDIO_SERVICE_TYPE_COMMENTARY: AVAudioServiceType = 5;
    #[c2rust::src_loc = "240:5"]
    pub const AV_AUDIO_SERVICE_TYPE_DIALOGUE: AVAudioServiceType = 4;
    #[c2rust::src_loc = "239:5"]
    pub const AV_AUDIO_SERVICE_TYPE_HEARING_IMPAIRED: AVAudioServiceType = 3;
    #[c2rust::src_loc = "238:5"]
    pub const AV_AUDIO_SERVICE_TYPE_VISUALLY_IMPAIRED: AVAudioServiceType = 2;
    #[c2rust::src_loc = "237:5"]
    pub const AV_AUDIO_SERVICE_TYPE_EFFECTS: AVAudioServiceType = 1;
    #[c2rust::src_loc = "236:5"]
    pub const AV_AUDIO_SERVICE_TYPE_MAIN: AVAudioServiceType = 0;
    #[c2rust::src_loc = "211:1"]
    pub type AVFieldOrder = c_uint;
    #[c2rust::src_loc = "217:5"]
    pub const AV_FIELD_BT: AVFieldOrder = 5;
    #[c2rust::src_loc = "216:5"]
    pub const AV_FIELD_TB: AVFieldOrder = 4;
    #[c2rust::src_loc = "215:5"]
    pub const AV_FIELD_BB: AVFieldOrder = 3;
    #[c2rust::src_loc = "214:5"]
    pub const AV_FIELD_TT: AVFieldOrder = 2;
    #[c2rust::src_loc = "213:5"]
    pub const AV_FIELD_PROGRESSIVE: AVFieldOrder = 1;
    #[c2rust::src_loc = "212:5"]
    pub const AV_FIELD_UNKNOWN: AVFieldOrder = 0;
}
#[c2rust::header_src = "/usr/include/libavutil/samplefmt.h:27"]
pub mod samplefmt_h {
    use ::core::ffi::c_int;

    #[c2rust::src_loc = "55:1"]
    pub type AVSampleFormat = c_int;
    #[c2rust::src_loc = "71:5"]
    pub const AV_SAMPLE_FMT_NB: AVSampleFormat = 12;
    #[c2rust::src_loc = "69:5"]
    pub const AV_SAMPLE_FMT_S64P: AVSampleFormat = 11;
    #[c2rust::src_loc = "68:5"]
    pub const AV_SAMPLE_FMT_S64: AVSampleFormat = 10;
    #[c2rust::src_loc = "67:5"]
    pub const AV_SAMPLE_FMT_DBLP: AVSampleFormat = 9;
    #[c2rust::src_loc = "66:5"]
    pub const AV_SAMPLE_FMT_FLTP: AVSampleFormat = 8;
    #[c2rust::src_loc = "65:5"]
    pub const AV_SAMPLE_FMT_S32P: AVSampleFormat = 7;
    #[c2rust::src_loc = "64:5"]
    pub const AV_SAMPLE_FMT_S16P: AVSampleFormat = 6;
    #[c2rust::src_loc = "63:5"]
    pub const AV_SAMPLE_FMT_U8P: AVSampleFormat = 5;
    #[c2rust::src_loc = "61:5"]
    pub const AV_SAMPLE_FMT_DBL: AVSampleFormat = 4;
    #[c2rust::src_loc = "60:5"]
    pub const AV_SAMPLE_FMT_FLT: AVSampleFormat = 3;
    #[c2rust::src_loc = "59:5"]
    pub const AV_SAMPLE_FMT_S32: AVSampleFormat = 2;
    #[c2rust::src_loc = "58:5"]
    pub const AV_SAMPLE_FMT_S16: AVSampleFormat = 1;
    #[c2rust::src_loc = "57:5"]
    pub const AV_SAMPLE_FMT_U8: AVSampleFormat = 0;
    #[c2rust::src_loc = "56:5"]
    pub const AV_SAMPLE_FMT_NONE: AVSampleFormat = -1;
}
#[c2rust::header_src = "/usr/include/libavformat/avio.h:27"]
pub mod avio_h {
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "160:16"]
    pub struct AVIOContext {
        pub av_class: *const AVClass,
        pub buffer: *mut c_uchar,
        pub buffer_size: c_int,
        pub buf_ptr: *mut c_uchar,
        pub buf_end: *mut c_uchar,
        pub opaque: *mut c_void,
        pub read_packet: Option<unsafe extern "C" fn(*mut c_void, *mut uint8_t, c_int) -> c_int>,
        pub write_packet: Option<unsafe extern "C" fn(*mut c_void, *const uint8_t, c_int) -> c_int>,
        pub seek: Option<unsafe extern "C" fn(*mut c_void, int64_t, c_int) -> int64_t>,
        pub pos: int64_t,
        pub eof_reached: c_int,
        pub error: c_int,
        pub write_flag: c_int,
        pub max_packet_size: c_int,
        pub min_packet_size: c_int,
        pub checksum: c_ulong,
        pub checksum_ptr: *mut c_uchar,
        pub update_checksum:
            Option<unsafe extern "C" fn(c_ulong, *const uint8_t, c_uint) -> c_ulong>,
        pub read_pause: Option<unsafe extern "C" fn(*mut c_void, c_int) -> c_int>,
        pub read_seek: Option<unsafe extern "C" fn(*mut c_void, c_int, int64_t, c_int) -> int64_t>,
        pub seekable: c_int,
        pub direct: c_int,
        pub protocol_whitelist: *const c_char,
        pub protocol_blacklist: *const c_char,
        pub write_data_type: Option<
            unsafe extern "C" fn(
                *mut c_void,
                *const uint8_t,
                c_int,
                AVIODataMarkerType,
                int64_t,
            ) -> c_int,
        >,
        pub ignore_boundary_point: c_int,
        pub buf_ptr_max: *mut c_uchar,
        pub bytes_read: int64_t,
        pub bytes_written: int64_t,
    }
    #[c2rust::src_loc = "110:1"]
    pub type AVIODataMarkerType = c_uint;
    #[c2rust::src_loc = "145:5"]
    pub const AVIO_DATA_MARKER_FLUSH_POINT: AVIODataMarkerType = 5;
    #[c2rust::src_loc = "139:5"]
    pub const AVIO_DATA_MARKER_TRAILER: AVIODataMarkerType = 4;
    #[c2rust::src_loc = "134:5"]
    pub const AVIO_DATA_MARKER_UNKNOWN: AVIODataMarkerType = 3;
    #[c2rust::src_loc = "127:5"]
    pub const AVIO_DATA_MARKER_BOUNDARY_POINT: AVIODataMarkerType = 2;
    #[c2rust::src_loc = "121:5"]
    pub const AVIO_DATA_MARKER_SYNC_POINT: AVIODataMarkerType = 1;
    #[c2rust::src_loc = "114:5"]
    pub const AVIO_DATA_MARKER_HEADER: AVIODataMarkerType = 0;
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "59:16"]
    pub struct AVIOInterruptCB {
        pub callback: Option<unsafe extern "C" fn(*mut c_void) -> c_int>,
        pub opaque: *mut c_void,
    }
    use ::core::ffi::{c_char, c_int, c_uchar, c_uint, c_ulong, c_void};

    use super::log_h::AVClass;
    use super::stdint_intn_h::int64_t;
    use super::stdint_uintn_h::uint8_t;
}
#[c2rust::header_src = "/usr/include/libavcodec/codec_par.h:27"]
pub mod codec_par_h {
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "47:16"]
    pub struct AVCodecParameters {
        pub codec_type: AVMediaType,
        pub codec_id: AVCodecID,
        pub codec_tag: uint32_t,
        pub extradata: *mut uint8_t,
        pub extradata_size: c_int,
        pub coded_side_data: *mut AVPacketSideData,
        pub nb_coded_side_data: c_int,
        pub format: c_int,
        pub bit_rate: int64_t,
        pub bits_per_coded_sample: c_int,
        pub bits_per_raw_sample: c_int,
        pub profile: c_int,
        pub level: c_int,
        pub width: c_int,
        pub height: c_int,
        pub sample_aspect_ratio: AVRational,
        pub framerate: AVRational,
        pub field_order: AVFieldOrder,
        pub color_range: AVColorRange,
        pub color_primaries: AVColorPrimaries,
        pub color_trc: AVColorTransferCharacteristic,
        pub color_space: AVColorSpace,
        pub chroma_location: AVChromaLocation,
        pub video_delay: c_int,
        pub ch_layout: AVChannelLayout,
        pub sample_rate: c_int,
        pub block_align: c_int,
        pub frame_size: c_int,
        pub initial_padding: c_int,
        pub trailing_padding: c_int,
        pub seek_preroll: c_int,
    }
    use ::core::ffi::c_int;

    use super::avutil_h::AVMediaType;
    use super::channel_layout_h::AVChannelLayout;
    use super::codec_id_h::AVCodecID;
    use super::defs_h::AVFieldOrder;
    use super::packet_h::AVPacketSideData;
    use super::pixfmt_h::{
        AVChromaLocation, AVColorPrimaries, AVColorRange, AVColorSpace,
        AVColorTransferCharacteristic,
    };
    use super::rational_h::AVRational;
    use super::stdint_intn_h::int64_t;
    use super::stdint_uintn_h::{uint32_t, uint8_t};
}
#[c2rust::header_src = "/usr/include/libavutil/error.h:27"]
pub mod error_h {
    use ::core::ffi::{c_int, c_uint};

    #[c2rust::src_loc = "57:9"]
    pub const AVERROR_EOF: c_int =
        -((('E' as i32 | ('O' as i32) << 8 as c_int | ('F' as i32) << 16 as c_int) as c_uint
            | (' ' as i32 as c_uint) << 24 as c_int) as c_int);
}

#[c2rust::header_src = "/usr/include/libavutil/frame.h:27"]
pub mod libav_frame_h {
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "421:16"]
    pub struct AVFrame {
        pub data: [*mut uint8_t; 8],
        pub linesize: [c_int; 8],
        pub extended_data: *mut *mut uint8_t,
        pub width: c_int,
        pub height: c_int,
        pub nb_samples: c_int,
        pub format: c_int,
        pub pict_type: AVPictureType,
        pub sample_aspect_ratio: AVRational,
        pub pts: int64_t,
        pub pkt_dts: int64_t,
        pub time_base: AVRational,
        pub quality: c_int,
        pub opaque: *mut c_void,
        pub repeat_pict: c_int,
        pub sample_rate: c_int,
        pub buf: [*mut AVBufferRef; 8],
        pub extended_buf: *mut *mut AVBufferRef,
        pub nb_extended_buf: c_int,
        pub side_data: *mut *mut AVFrameSideData,
        pub nb_side_data: c_int,
        pub flags: c_int,
        pub color_range: AVColorRange,
        pub color_primaries: AVColorPrimaries,
        pub color_trc: AVColorTransferCharacteristic,
        pub colorspace: AVColorSpace,
        pub chroma_location: AVChromaLocation,
        pub best_effort_timestamp: int64_t,
        pub metadata: *mut AVDictionary,
        pub decode_error_flags: c_int,
        pub hw_frames_ctx: *mut AVBufferRef,
        pub opaque_ref: *mut AVBufferRef,
        pub crop_top: size_t,
        pub crop_bottom: size_t,
        pub crop_left: size_t,
        pub crop_right: size_t,
        pub private_ref: *mut c_void,
        pub ch_layout: AVChannelLayout,
        pub duration: int64_t,
    }
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "276:16"]
    pub struct AVFrameSideData {
        pub type_0: AVFrameSideDataType,
        pub data: *mut uint8_t,
        pub size: size_t,
        pub metadata: *mut AVDictionary,
        pub buf: *mut AVBufferRef,
    }
    #[c2rust::src_loc = "49:1"]
    pub type AVFrameSideDataType = c_uint;
    #[c2rust::src_loc = "256:5"]
    pub const AV_FRAME_DATA_3D_REFERENCE_DISPLAYS: AVFrameSideDataType = 30;
    #[c2rust::src_loc = "245:5"]
    pub const AV_FRAME_DATA_VIEW_ID: AVFrameSideDataType = 29;
    #[c2rust::src_loc = "236:5"]
    pub const AV_FRAME_DATA_LCEVC: AVFrameSideDataType = 28;
    #[c2rust::src_loc = "230:5"]
    pub const AV_FRAME_DATA_VIDEO_HINT: AVFrameSideDataType = 27;
    #[c2rust::src_loc = "220:5"]
    pub const AV_FRAME_DATA_AMBIENT_VIEWING_ENVIRONMENT: AVFrameSideDataType = 26;
    #[c2rust::src_loc = "215:5"]
    pub const AV_FRAME_DATA_DYNAMIC_HDR_VIVID: AVFrameSideDataType = 25;
    #[c2rust::src_loc = "208:5"]
    pub const AV_FRAME_DATA_DOVI_METADATA: AVFrameSideDataType = 24;
    #[c2rust::src_loc = "201:5"]
    pub const AV_FRAME_DATA_DOVI_RPU_BUFFER: AVFrameSideDataType = 23;
    #[c2rust::src_loc = "194:5"]
    pub const AV_FRAME_DATA_DETECTION_BBOXES: AVFrameSideDataType = 22;
    #[c2rust::src_loc = "188:5"]
    pub const AV_FRAME_DATA_FILM_GRAIN_PARAMS: AVFrameSideDataType = 21;
    #[c2rust::src_loc = "178:5"]
    pub const AV_FRAME_DATA_SEI_UNREGISTERED: AVFrameSideDataType = 20;
    #[c2rust::src_loc = "170:5"]
    pub const AV_FRAME_DATA_VIDEO_ENC_PARAMS: AVFrameSideDataType = 19;
    #[c2rust::src_loc = "165:5"]
    pub const AV_FRAME_DATA_REGIONS_OF_INTEREST: AVFrameSideDataType = 18;
    #[c2rust::src_loc = "159:5"]
    pub const AV_FRAME_DATA_DYNAMIC_HDR_PLUS: AVFrameSideDataType = 17;
    #[c2rust::src_loc = "152:5"]
    pub const AV_FRAME_DATA_S12M_TIMECODE: AVFrameSideDataType = 16;
    #[c2rust::src_loc = "144:5"]
    pub const AV_FRAME_DATA_ICC_PROFILE: AVFrameSideDataType = 15;
    #[c2rust::src_loc = "137:5"]
    pub const AV_FRAME_DATA_CONTENT_LIGHT_LEVEL: AVFrameSideDataType = 14;
    #[c2rust::src_loc = "131:5"]
    pub const AV_FRAME_DATA_SPHERICAL: AVFrameSideDataType = 13;
    #[c2rust::src_loc = "125:5"]
    pub const AV_FRAME_DATA_GOP_TIMECODE: AVFrameSideDataType = 12;
    #[c2rust::src_loc = "120:5"]
    pub const AV_FRAME_DATA_MASTERING_DISPLAY_METADATA: AVFrameSideDataType = 11;
    #[c2rust::src_loc = "114:5"]
    pub const AV_FRAME_DATA_AUDIO_SERVICE_TYPE: AVFrameSideDataType = 10;
    #[c2rust::src_loc = "109:5"]
    pub const AV_FRAME_DATA_SKIP_SAMPLES: AVFrameSideDataType = 9;
    #[c2rust::src_loc = "97:5"]
    pub const AV_FRAME_DATA_MOTION_VECTORS: AVFrameSideDataType = 8;
    #[c2rust::src_loc = "90:5"]
    pub const AV_FRAME_DATA_AFD: AVFrameSideDataType = 7;
    #[c2rust::src_loc = "85:5"]
    pub const AV_FRAME_DATA_DISPLAYMATRIX: AVFrameSideDataType = 6;
    #[c2rust::src_loc = "77:5"]
    pub const AV_FRAME_DATA_REPLAYGAIN: AVFrameSideDataType = 5;
    #[c2rust::src_loc = "73:5"]
    pub const AV_FRAME_DATA_DOWNMIX_INFO: AVFrameSideDataType = 4;
    #[c2rust::src_loc = "68:5"]
    pub const AV_FRAME_DATA_MATRIXENCODING: AVFrameSideDataType = 3;
    #[c2rust::src_loc = "64:5"]
    pub const AV_FRAME_DATA_STEREO3D: AVFrameSideDataType = 2;
    #[c2rust::src_loc = "59:5"]
    pub const AV_FRAME_DATA_A53_CC: AVFrameSideDataType = 1;
    #[c2rust::src_loc = "53:5"]
    pub const AV_FRAME_DATA_PANSCAN: AVFrameSideDataType = 0;
    #[c2rust::src_loc = "644:9"]
    pub const AV_FRAME_FLAG_INTERLACED: c_int = (1 as c_int) << 3 as c_int;
    #[c2rust::src_loc = "649:9"]
    pub const AV_FRAME_FLAG_TOP_FIELD_FIRST: c_int = (1 as c_int) << 4 as c_int;
    use ::core::ffi::{c_int, c_uint, c_void};

    use super::__stddef_size_t_h::size_t;
    use super::avutil_h::AVPictureType;
    use super::buffer_h::AVBufferRef;
    use super::channel_layout_h::AVChannelLayout;
    use super::dict_h::AVDictionary;
    use super::pixfmt_h::{
        AVChromaLocation, AVColorPrimaries, AVColorRange, AVColorSpace,
        AVColorTransferCharacteristic,
    };
    use super::rational_h::AVRational;
    use super::stdint_intn_h::int64_t;
    use super::stdint_uintn_h::uint8_t;
    extern "C" {
        #[c2rust::src_loc = "783:1"]
        pub fn av_frame_alloc() -> *mut AVFrame;
        #[c2rust::src_loc = "792:1"]
        pub fn av_frame_free(frame: *mut *mut AVFrame);
    }
}

#[c2rust::header_src = "/home/nwplayer123/Hacks/hex264/x264/output/flv_bytestream.h:26"]
pub mod flv_bytestream_h {
    #[c2rust::src_loc = "97:9"]
    pub type C2RustUnnamed = c_uint;
    #[c2rust::src_loc = "111:5"]
    pub const AMF_DATA_TYPE_UNSUPPORTED: C2RustUnnamed = 13;
    #[c2rust::src_loc = "110:5"]
    pub const AMF_DATA_TYPE_LONG_STRING: C2RustUnnamed = 12;
    #[c2rust::src_loc = "109:5"]
    pub const AMF_DATA_TYPE_DATE: C2RustUnnamed = 11;
    #[c2rust::src_loc = "108:5"]
    pub const AMF_DATA_TYPE_ARRAY: C2RustUnnamed = 10;
    #[c2rust::src_loc = "107:5"]
    pub const AMF_DATA_TYPE_OBJECT_END: C2RustUnnamed = 9;
    #[c2rust::src_loc = "106:5"]
    pub const AMF_DATA_TYPE_MIXEDARRAY: C2RustUnnamed = 8;
    #[c2rust::src_loc = "105:5"]
    pub const AMF_DATA_TYPE_REFERENCE: C2RustUnnamed = 7;
    #[c2rust::src_loc = "104:5"]
    pub const AMF_DATA_TYPE_UNDEFINED: C2RustUnnamed = 6;
    #[c2rust::src_loc = "103:5"]
    pub const AMF_DATA_TYPE_NULL: C2RustUnnamed = 5;
    #[c2rust::src_loc = "102:5"]
    pub const AMF_DATA_TYPE_OBJECT: C2RustUnnamed = 3;
    #[c2rust::src_loc = "101:5"]
    pub const AMF_DATA_TYPE_STRING: C2RustUnnamed = 2;
    #[c2rust::src_loc = "100:5"]
    pub const AMF_DATA_TYPE_BOOL: C2RustUnnamed = 1;
    #[c2rust::src_loc = "99:5"]
    pub const AMF_DATA_TYPE_NUMBER: C2RustUnnamed = 0;
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "114:16"]
    pub struct flv_buffer {
        pub data: *mut uint8_t,
        pub d_cur: c_uint,
        pub d_max: c_uint,
        pub fp: *mut FILE,
        pub d_total: uint64_t,
    }
    use ::core::ffi::{c_char, c_double, c_int, c_uint};

    use super::stdint_uintn_h::{uint64_t, uint8_t};
    use super::FILE_h::FILE;

    #[c2rust::src_loc = "88:5"]
    pub const FLV_CODECID_H264: C2RustUnnamed_6 = 7;
    #[c2rust::src_loc = "94:5"]
    pub const FLV_FRAME_INTER: C2RustUnnamed_7 = 32;
    #[c2rust::src_loc = "93:5"]
    pub const FLV_FRAME_KEY: C2RustUnnamed_7 = 16;
    #[c2rust::src_loc = "56:5"]
    pub const FLV_TAG_TYPE_VIDEO: C2RustUnnamed_5 = 9;
    #[c2rust::src_loc = "57:5"]
    pub const FLV_TAG_TYPE_META: C2RustUnnamed_5 = 18;
    #[c2rust::src_loc = "53:1"]
    pub type C2RustUnnamed_5 = c_uint;
    #[c2rust::src_loc = "55:5"]
    pub const FLV_TAG_TYPE_AUDIO: C2RustUnnamed_5 = 8;
    #[c2rust::src_loc = "86:1"]
    pub type C2RustUnnamed_6 = c_uint;
    #[c2rust::src_loc = "91:1"]
    pub type C2RustUnnamed_7 = c_uint;
    #[c2rust::src_loc = "97:9"]
    pub type C2RustUnnamed_8 = c_uint;
    #[c2rust::src_loc = "45:9"]
    pub const AMF_END_OF_OBJECT: c_int = 0x9 as c_int;
    use super::stdint_uintn_h::{uint16_t, uint32_t};
    extern "C" {
        #[c2rust::src_loc = "123:1"]
        pub fn flv_create_writer(filename: *const c_char) -> *mut flv_buffer;
        #[c2rust::src_loc = "124:1"]
        pub fn flv_append_data(c: *mut flv_buffer, data: *mut uint8_t, size: c_uint) -> c_int;
        #[c2rust::src_loc = "126:1"]
        pub fn flv_flush_data(c: *mut flv_buffer) -> c_int;
        #[c2rust::src_loc = "127:1"]
        pub fn flv_rewrite_amf_be24(c: *mut flv_buffer, length: c_uint, start: c_uint);
        #[c2rust::src_loc = "129:1"]
        pub fn flv_dbl2int(value: c_double) -> uint64_t;
        #[c2rust::src_loc = "130:1"]
        pub fn flv_put_byte(c: *mut flv_buffer, b: uint8_t);
        #[c2rust::src_loc = "131:1"]
        pub fn flv_put_be32(c: *mut flv_buffer, val: uint32_t);
        #[c2rust::src_loc = "133:1"]
        pub fn flv_put_be16(c: *mut flv_buffer, val: uint16_t);
        #[c2rust::src_loc = "134:1"]
        pub fn flv_put_be24(c: *mut flv_buffer, val: uint32_t);
        #[c2rust::src_loc = "135:1"]
        pub fn flv_put_tag(c: *mut flv_buffer, tag: *const c_char);
        #[c2rust::src_loc = "136:1"]
        pub fn flv_put_amf_string(c: *mut flv_buffer, str: *const c_char);
        #[c2rust::src_loc = "137:1"]
        pub fn flv_put_amf_double(c: *mut flv_buffer, d: c_double);
    }
}

#[c2rust::header_src = "/home/nwplayer123/Hacks/hex264/x264/output/matroska_ebml.h:26"]
pub mod matroska_ebml_h {
    #[c2rust::src_loc = "30:9"]
    pub const DS_PIXELS: c_int = 0 as c_int;
    use ::core::ffi::{c_char, c_int, c_uint, c_void};

    use super::stdint_intn_h::int64_t;
    extern "C" {
        #[c2rust::src_loc = "35:16"]
        pub type mk_writer;
        #[c2rust::src_loc = "37:1"]
        pub fn mk_create_writer(filename: *const c_char) -> *mut mk_writer;
        #[c2rust::src_loc = "39:1"]
        pub fn mk_write_header(
            w: *mut mk_writer,
            writing_app: *const c_char,
            codec_id: *const c_char,
            codec_private: *const c_void,
            codec_private_size: c_uint,
            default_frame_duration: int64_t,
            timescale: int64_t,
            width: c_uint,
            height: c_uint,
            d_width: c_uint,
            d_height: c_uint,
            display_size_units: c_int,
            stereo_mode: c_int,
        ) -> c_int;
        #[c2rust::src_loc = "47:1"]
        pub fn mk_start_frame(w: *mut mk_writer) -> c_int;
        #[c2rust::src_loc = "48:1"]
        pub fn mk_add_frame_data(w: *mut mk_writer, data: *const c_void, size: c_uint) -> c_int;
        #[c2rust::src_loc = "49:1"]
        pub fn mk_set_frame_flags(
            w: *mut mk_writer,
            timestamp: int64_t,
            keyframe: c_int,
            skippable: c_int,
        ) -> c_int;
        #[c2rust::src_loc = "50:1"]
        pub fn mk_close(w: *mut mk_writer, last_delta: int64_t) -> c_int;
    }
}
