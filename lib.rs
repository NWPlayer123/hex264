#![allow(dead_code)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(unused_assignments)]
#![allow(unused_mut)]
#![feature(c_variadic)]
#![allow(internal_features)]
#![feature(core_intrinsics)]
#![feature(extern_types)]
#![feature(lint_reasons)]
#![feature(register_tool)]
//#![feature(stdsimd)]
#![register_tool(c2rust)]

#[macro_use]
extern crate c2rust_bitfields;
pub mod src {
    pub mod autocomplete;
    pub mod common {
        pub mod base;
        pub mod bitstream;
        pub mod cabac;
        pub mod common;
        pub mod cpu;
        pub mod dct;
        pub mod deblock;
        pub mod frame;
        pub mod macroblock;
        pub mod mc;
        pub mod mvpred;
        pub mod osdep;
        pub mod pixel;
        pub mod predict;
        pub mod quant;
        pub mod rectangle;
        pub mod set;
        pub mod tables;
        pub mod threadpool;
        pub mod vlc;
    } // mod common
    pub mod encoder {
        pub mod analyse;
        pub mod api;
        pub mod cabac;
        pub mod cavlc;
        pub mod encoder;
        pub mod lookahead;
        pub mod macroblock;
        pub mod me;
        pub mod ratecontrol;
        pub mod set;
    } // mod encoder
    pub mod filters {
        pub mod filters;
        pub mod video {
            pub mod cache;
            pub mod crop;
            pub mod depth;
            pub mod fix_vfr_pts;
            pub mod internal;
            pub mod resize;
            pub mod select_every;
            pub mod source;
            pub mod video;
        } // mod video
    } // mod filters
    pub mod input {
        pub mod avs;
        pub mod input;
        pub mod lavf;
        pub mod raw;
        pub mod thread;
        pub mod timecode;
        pub mod y4m;
    } // mod input
    pub mod output {
        pub mod flv;
        pub mod flv_bytestream;
        pub mod matroska;
        pub mod matroska_ebml;
        pub mod mp4_lsmash;
        pub mod raw;
    } // mod output
    pub mod x264;
} // mod src

#[c2rust::header_src = "internal:0"]
pub mod internal {
    #[c2rust::src_loc = "0:0"]
    pub type __builtin_va_list = [__va_list_tag; 1];
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "0:0"]
    pub struct __va_list_tag {
        pub gp_offset: ::core::ffi::c_uint,
        pub fp_offset: ::core::ffi::c_uint,
        pub overflow_arg_area: *mut ::core::ffi::c_void,
        pub reg_save_area: *mut ::core::ffi::c_void,
    }
    #[c2rust::src_loc = "3:9"]
    pub const BIT_DEPTH: ::core::ffi::c_int = 10 as ::core::ffi::c_int;
    #[c2rust::src_loc = "61:9"]
    pub const __INT_MAX__: ::core::ffi::c_int = 2147483647 as ::core::ffi::c_int;
}
#[c2rust::header_src = "/usr/lib/clang/21/include/__stddef_size_t.h:37"]
pub mod __stddef_size_t_h {
    #[c2rust::src_loc = "18:1"]
    pub type size_t = usize;
}
#[c2rust::header_src = "/usr/lib/clang/21/include/__stdarg___gnuc_va_list.h:37"]
pub mod __stdarg___gnuc_va_list_h {
    #[c2rust::src_loc = "12:1"]
    pub type __gnuc_va_list = __builtin_va_list;
    use super::internal::__builtin_va_list;
}
#[c2rust::header_src = "/usr/include/bits/types.h:37"]
pub mod types_h {
    #[c2rust::src_loc = "37:1"]
    pub type __int8_t = i8;
    #[c2rust::src_loc = "38:1"]
    pub type __uint8_t = u8;
    #[c2rust::src_loc = "39:1"]
    pub type __int16_t = i16;
    #[c2rust::src_loc = "40:1"]
    pub type __uint16_t = u16;
    #[c2rust::src_loc = "41:1"]
    pub type __int32_t = i32;
    #[c2rust::src_loc = "42:1"]
    pub type __uint32_t = u32;
    #[c2rust::src_loc = "44:1"]
    pub type __int64_t = i64;
    #[c2rust::src_loc = "45:1"]
    pub type __uint64_t = u64;
    #[c2rust::src_loc = "145:1"]
    pub type __dev_t = ::core::ffi::c_ulong;
    #[c2rust::src_loc = "146:1"]
    pub type __uid_t = ::core::ffi::c_uint;
    #[c2rust::src_loc = "147:1"]
    pub type __gid_t = ::core::ffi::c_uint;
    #[c2rust::src_loc = "148:1"]
    pub type __ino_t = ::core::ffi::c_ulong;
    #[c2rust::src_loc = "150:1"]
    pub type __mode_t = ::core::ffi::c_uint;
    #[c2rust::src_loc = "151:1"]
    pub type __nlink_t = ::core::ffi::c_ulong;
    #[c2rust::src_loc = "152:1"]
    pub type __off_t = ::core::ffi::c_long;
    #[c2rust::src_loc = "153:1"]
    pub type __off64_t = ::core::ffi::c_long;
    #[c2rust::src_loc = "160:1"]
    pub type __time_t = ::core::ffi::c_long;
    #[c2rust::src_loc = "175:1"]
    pub type __blksize_t = ::core::ffi::c_long;
    #[c2rust::src_loc = "180:1"]
    pub type __blkcnt_t = ::core::ffi::c_long;
    #[c2rust::src_loc = "197:1"]
    pub type __syscall_slong_t = ::core::ffi::c_long;
}
#[c2rust::header_src = "/usr/include/bits/types/struct_FILE.h:37"]
pub mod struct_FILE_h {
    #[derive(Copy, Clone, BitfieldStruct)]
    #[repr(C)]
    #[c2rust::src_loc = "51:8"]
    pub struct _IO_FILE {
        pub _flags: ::core::ffi::c_int,
        pub _IO_read_ptr: *mut ::core::ffi::c_char,
        pub _IO_read_end: *mut ::core::ffi::c_char,
        pub _IO_read_base: *mut ::core::ffi::c_char,
        pub _IO_write_base: *mut ::core::ffi::c_char,
        pub _IO_write_ptr: *mut ::core::ffi::c_char,
        pub _IO_write_end: *mut ::core::ffi::c_char,
        pub _IO_buf_base: *mut ::core::ffi::c_char,
        pub _IO_buf_end: *mut ::core::ffi::c_char,
        pub _IO_save_base: *mut ::core::ffi::c_char,
        pub _IO_backup_base: *mut ::core::ffi::c_char,
        pub _IO_save_end: *mut ::core::ffi::c_char,
        pub _markers: *mut _IO_marker,
        pub _chain: *mut _IO_FILE,
        pub _fileno: ::core::ffi::c_int,
        #[bitfield(name = "_flags2", ty = "core::ffi::c_int", bits = "0..=23")]
        pub _flags2: [u8; 3],
        pub _short_backupbuf: [::core::ffi::c_char; 1],
        pub _old_offset: __off_t,
        pub _cur_column: ::core::ffi::c_ushort,
        pub _vtable_offset: ::core::ffi::c_schar,
        pub _shortbuf: [::core::ffi::c_char; 1],
        pub _lock: *mut ::core::ffi::c_void,
        pub _offset: __off64_t,
        pub _codecvt: *mut _IO_codecvt,
        pub _wide_data: *mut _IO_wide_data,
        pub _freeres_list: *mut _IO_FILE,
        pub _freeres_buf: *mut ::core::ffi::c_void,
        pub _prevchain: *mut *mut _IO_FILE,
        pub _mode: ::core::ffi::c_int,
        pub _unused3: ::core::ffi::c_int,
        pub _total_written: __uint64_t,
        pub _unused2: [::core::ffi::c_char; 8],
    }
    #[c2rust::src_loc = "45:1"]
    pub type _IO_lock_t = ();
    use super::types_h::{__off64_t, __off_t, __uint64_t};
    extern "C" {
        #[c2rust::src_loc = "40:8"]
        pub type _IO_wide_data;
        #[c2rust::src_loc = "39:8"]
        pub type _IO_codecvt;
        #[c2rust::src_loc = "38:8"]
        pub type _IO_marker;
    }
}
#[c2rust::header_src = "/usr/include/bits/types/FILE.h:37"]
pub mod FILE_h {
    #[c2rust::src_loc = "7:1"]
    pub type FILE = _IO_FILE;
    use super::struct_FILE_h::_IO_FILE;
}
#[c2rust::header_src = "/usr/include/stdio.h:37"]
pub mod stdio_h {
    #[c2rust::src_loc = "53:1"]
    pub type va_list = __gnuc_va_list;
    #[c2rust::src_loc = "105:9"]
    pub const EOF: ::core::ffi::c_int = -(1 as ::core::ffi::c_int);
    #[c2rust::src_loc = "110:9"]
    pub const SEEK_SET: ::core::ffi::c_int = 0 as ::core::ffi::c_int;
    use super::FILE_h::FILE;
    use super::__stdarg___gnuc_va_list_h::__gnuc_va_list;
    use super::types_h::__off64_t;
    extern "C" {
        #[c2rust::src_loc = "151:14"]
        pub static mut stderr: *mut FILE;
        #[c2rust::src_loc = "187:1"]
        pub fn fclose(__stream: *mut FILE) -> ::core::ffi::c_int;
        #[c2rust::src_loc = "239:1"]
        pub fn fflush(__stream: *mut FILE) -> ::core::ffi::c_int;
        #[c2rust::src_loc = "279:1"]
        pub fn fopen(
            __filename: *const ::core::ffi::c_char,
            __modes: *const ::core::ffi::c_char,
        ) -> *mut FILE;
        #[c2rust::src_loc = "360:1"]
        pub fn fprintf(
            __stream: *mut FILE,
            __format: *const ::core::ffi::c_char,
            ...
        ) -> ::core::ffi::c_int;
        #[c2rust::src_loc = "366:1"]
        pub fn printf(__format: *const ::core::ffi::c_char, ...) -> ::core::ffi::c_int;
        #[c2rust::src_loc = "368:1"]
        pub fn sprintf(
            __s: *mut ::core::ffi::c_char,
            __format: *const ::core::ffi::c_char,
            ...
        ) -> ::core::ffi::c_int;
        #[c2rust::src_loc = "375:1"]
        pub fn vfprintf(
            __s: *mut FILE,
            __format: *const ::core::ffi::c_char,
            __arg: ::core::ffi::VaList,
        ) -> ::core::ffi::c_int;
        #[c2rust::src_loc = "445:1"]
        pub fn fscanf(
            __stream: *mut FILE,
            __format: *const ::core::ffi::c_char,
            ...
        ) -> ::core::ffi::c_int;
        #[c2rust::src_loc = "450:1"]
        pub fn sscanf(
            __s: *const ::core::ffi::c_char,
            __format: *const ::core::ffi::c_char,
            ...
        ) -> ::core::ffi::c_int;
        #[c2rust::src_loc = "802:1"]
        pub fn fseeko(
            __stream: *mut FILE,
            __off: __off64_t,
            __whence: ::core::ffi::c_int,
        ) -> ::core::ffi::c_int;
        #[c2rust::src_loc = "805:1"]
        pub fn ftello(__stream: *mut FILE) -> __off64_t;
        #[c2rust::src_loc = "873:1"]
        pub fn fileno(__stream: *mut FILE) -> ::core::ffi::c_int;
    }
    use super::__stddef_size_t_h::size_t;
    extern "C" {
        #[c2rust::src_loc = "150:14"]
        pub static mut stdout: *mut FILE;
        #[c2rust::src_loc = "388:1"]
        pub fn snprintf(
            __s: *mut ::core::ffi::c_char,
            __maxlen: size_t,
            __format: *const ::core::ffi::c_char,
            ...
        ) -> ::core::ffi::c_int;
        #[c2rust::src_loc = "612:1"]
        pub fn putc(__c: ::core::ffi::c_int, __stream: *mut FILE) -> ::core::ffi::c_int;
    }
    extern "C" {
        #[c2rust::src_loc = "735:1"]
        pub fn fwrite(
            __ptr: *const ::core::ffi::c_void,
            __size: size_t,
            __n: size_t,
            __s: *mut FILE,
        ) -> ::core::ffi::c_ulong;
    }
}
#[c2rust::header_src = "/usr/include/bits/types/struct_timespec.h:37"]
pub mod struct_timespec_h {
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "11:8"]
    pub struct timespec {
        pub tv_sec: __time_t,
        pub tv_nsec: __syscall_slong_t,
    }
    use super::types_h::{__syscall_slong_t, __time_t};
}
#[c2rust::header_src = "/usr/include/bits/struct_stat.h:37"]
pub mod struct_stat_h {
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "26:8"]
    pub struct stat {
        pub st_dev: __dev_t,
        pub st_ino: __ino_t,
        pub st_nlink: __nlink_t,
        pub st_mode: __mode_t,
        pub st_uid: __uid_t,
        pub st_gid: __gid_t,
        pub __pad0: ::core::ffi::c_int,
        pub st_rdev: __dev_t,
        pub st_size: __off_t,
        pub st_blksize: __blksize_t,
        pub st_blocks: __blkcnt_t,
        pub st_atim: timespec,
        pub st_mtim: timespec,
        pub st_ctim: timespec,
        pub __glibc_reserved: [__syscall_slong_t; 3],
    }
    use super::struct_timespec_h::timespec;
    use super::types_h::{
        __blkcnt_t, __blksize_t, __dev_t, __gid_t, __ino_t, __mode_t, __nlink_t, __off_t,
        __syscall_slong_t, __uid_t,
    };
}
#[c2rust::header_src = "/usr/include/bits/stdint-intn.h:37"]
pub mod stdint_intn_h {
    #[c2rust::src_loc = "24:1"]
    pub type int8_t = __int8_t;
    #[c2rust::src_loc = "25:1"]
    pub type int16_t = __int16_t;
    #[c2rust::src_loc = "26:1"]
    pub type int32_t = __int32_t;
    #[c2rust::src_loc = "27:1"]
    pub type int64_t = __int64_t;
    use super::types_h::{__int16_t, __int32_t, __int64_t, __int8_t};
}
#[c2rust::header_src = "/usr/include/bits/stdint-uintn.h:37"]
pub mod stdint_uintn_h {
    #[c2rust::src_loc = "24:1"]
    pub type uint8_t = __uint8_t;
    #[c2rust::src_loc = "25:1"]
    pub type uint16_t = __uint16_t;
    #[c2rust::src_loc = "26:1"]
    pub type uint32_t = __uint32_t;
    #[c2rust::src_loc = "27:1"]
    pub type uint64_t = __uint64_t;
    use super::types_h::{__uint16_t, __uint32_t, __uint64_t, __uint8_t};
}
#[c2rust::header_src = "/home/nwplayer123/Hacks/hex264/x264/x264.h:37"]
pub mod x264_h {
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "114:16"]
    pub struct x264_nal_t {
        pub i_ref_idc: ::core::ffi::c_int,
        pub i_type: ::core::ffi::c_int,
        pub b_long_startcode: ::core::ffi::c_int,
        pub i_first_mb: ::core::ffi::c_int,
        pub i_last_mb: ::core::ffi::c_int,
        pub i_payload: ::core::ffi::c_int,
        pub p_payload: *mut uint8_t,
        pub i_padding: ::core::ffi::c_int,
    }
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "306:16"]
    pub struct x264_zone_t {
        pub i_start: ::core::ffi::c_int,
        pub i_end: ::core::ffi::c_int,
        pub b_force_qp: ::core::ffi::c_int,
        pub i_qp: ::core::ffi::c_int,
        pub f_bitrate_factor: ::core::ffi::c_float,
        pub param: *mut x264_param_t,
    }
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "315:16"]
    pub struct x264_param_t {
        pub cpu: uint32_t,
        pub i_threads: ::core::ffi::c_int,
        pub i_lookahead_threads: ::core::ffi::c_int,
        pub b_sliced_threads: ::core::ffi::c_int,
        pub b_deterministic: ::core::ffi::c_int,
        pub b_cpu_independent: ::core::ffi::c_int,
        pub i_sync_lookahead: ::core::ffi::c_int,
        pub i_width: ::core::ffi::c_int,
        pub i_height: ::core::ffi::c_int,
        pub i_csp: ::core::ffi::c_int,
        pub i_bitdepth: ::core::ffi::c_int,
        pub i_level_idc: ::core::ffi::c_int,
        pub i_frame_total: ::core::ffi::c_int,
        pub i_nal_hrd: ::core::ffi::c_int,
        pub vui: C2RustUnnamed_4,
        pub i_frame_reference: ::core::ffi::c_int,
        pub i_dpb_size: ::core::ffi::c_int,
        pub i_keyint_max: ::core::ffi::c_int,
        pub i_keyint_min: ::core::ffi::c_int,
        pub i_scenecut_threshold: ::core::ffi::c_int,
        pub b_intra_refresh: ::core::ffi::c_int,
        pub i_bframe: ::core::ffi::c_int,
        pub i_bframe_adaptive: ::core::ffi::c_int,
        pub i_bframe_bias: ::core::ffi::c_int,
        pub i_bframe_pyramid: ::core::ffi::c_int,
        pub b_open_gop: ::core::ffi::c_int,
        pub b_bluray_compat: ::core::ffi::c_int,
        pub i_avcintra_class: ::core::ffi::c_int,
        pub i_avcintra_flavor: ::core::ffi::c_int,
        pub b_deblocking_filter: ::core::ffi::c_int,
        pub i_deblocking_filter_alphac0: ::core::ffi::c_int,
        pub i_deblocking_filter_beta: ::core::ffi::c_int,
        pub b_cabac: ::core::ffi::c_int,
        pub i_cabac_init_idc: ::core::ffi::c_int,
        pub b_interlaced: ::core::ffi::c_int,
        pub b_constrained_intra: ::core::ffi::c_int,
        pub i_cqm_preset: ::core::ffi::c_int,
        pub psz_cqm_file: *mut ::core::ffi::c_char,
        pub cqm_4iy: [uint8_t; 16],
        pub cqm_4py: [uint8_t; 16],
        pub cqm_4ic: [uint8_t; 16],
        pub cqm_4pc: [uint8_t; 16],
        pub cqm_8iy: [uint8_t; 64],
        pub cqm_8py: [uint8_t; 64],
        pub cqm_8ic: [uint8_t; 64],
        pub cqm_8pc: [uint8_t; 64],
        pub pf_log: Option<
            unsafe extern "C" fn(
                *mut ::core::ffi::c_void,
                ::core::ffi::c_int,
                *const ::core::ffi::c_char,
                ::core::ffi::VaList,
            ) -> (),
        >,
        pub p_log_private: *mut ::core::ffi::c_void,
        pub i_log_level: ::core::ffi::c_int,
        pub b_full_recon: ::core::ffi::c_int,
        pub psz_dump_yuv: *mut ::core::ffi::c_char,
        pub analyse: C2RustUnnamed_3,
        pub rc: C2RustUnnamed_2,
        pub crop_rect: C2RustUnnamed_1,
        pub i_frame_packing: ::core::ffi::c_int,
        pub mastering_display: C2RustUnnamed_0,
        pub content_light_level: C2RustUnnamed,
        pub i_alternative_transfer: ::core::ffi::c_int,
        pub b_aud: ::core::ffi::c_int,
        pub b_repeat_headers: ::core::ffi::c_int,
        pub b_annexb: ::core::ffi::c_int,
        pub i_sps_id: ::core::ffi::c_int,
        pub b_vfr_input: ::core::ffi::c_int,
        pub b_pulldown: ::core::ffi::c_int,
        pub i_fps_num: uint32_t,
        pub i_fps_den: uint32_t,
        pub i_timebase_num: uint32_t,
        pub i_timebase_den: uint32_t,
        pub b_tff: ::core::ffi::c_int,
        pub b_pic_struct: ::core::ffi::c_int,
        pub b_fake_interlaced: ::core::ffi::c_int,
        pub b_stitchable: ::core::ffi::c_int,
        pub b_opencl: ::core::ffi::c_int,
        pub i_opencl_device: ::core::ffi::c_int,
        pub opencl_device_id: *mut ::core::ffi::c_void,
        pub psz_clbin_file: *mut ::core::ffi::c_char,
        pub i_slice_max_size: ::core::ffi::c_int,
        pub i_slice_max_mbs: ::core::ffi::c_int,
        pub i_slice_min_mbs: ::core::ffi::c_int,
        pub i_slice_count: ::core::ffi::c_int,
        pub i_slice_count_max: ::core::ffi::c_int,
        pub param_free: Option<unsafe extern "C" fn(*mut ::core::ffi::c_void) -> ()>,
        pub nalu_process: Option<
            unsafe extern "C" fn(*mut x264_t, *mut x264_nal_t, *mut ::core::ffi::c_void) -> (),
        >,
        pub opaque: *mut ::core::ffi::c_void,
    }
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "517:5"]
    pub struct C2RustUnnamed {
        pub b_cll: ::core::ffi::c_int,
        pub i_max_cll: ::core::ffi::c_int,
        pub i_max_fall: ::core::ffi::c_int,
    }
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "501:5"]
    pub struct C2RustUnnamed_0 {
        pub b_mastering_display: ::core::ffi::c_int,
        pub i_green_x: ::core::ffi::c_int,
        pub i_green_y: ::core::ffi::c_int,
        pub i_blue_x: ::core::ffi::c_int,
        pub i_blue_y: ::core::ffi::c_int,
        pub i_red_x: ::core::ffi::c_int,
        pub i_red_y: ::core::ffi::c_int,
        pub i_white_x: ::core::ffi::c_int,
        pub i_white_y: ::core::ffi::c_int,
        pub i_display_max: int64_t,
        pub i_display_min: int64_t,
    }
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "488:5"]
    pub struct C2RustUnnamed_1 {
        pub i_left: ::core::ffi::c_int,
        pub i_top: ::core::ffi::c_int,
        pub i_right: ::core::ffi::c_int,
        pub i_bottom: ::core::ffi::c_int,
    }
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "443:5"]
    pub struct C2RustUnnamed_2 {
        pub i_rc_method: ::core::ffi::c_int,
        pub i_qp_constant: ::core::ffi::c_int,
        pub i_qp_min: ::core::ffi::c_int,
        pub i_qp_max: ::core::ffi::c_int,
        pub i_qp_step: ::core::ffi::c_int,
        pub i_bitrate: ::core::ffi::c_int,
        pub f_rf_constant: ::core::ffi::c_float,
        pub f_rf_constant_max: ::core::ffi::c_float,
        pub f_rate_tolerance: ::core::ffi::c_float,
        pub i_vbv_max_bitrate: ::core::ffi::c_int,
        pub i_vbv_buffer_size: ::core::ffi::c_int,
        pub f_vbv_buffer_init: ::core::ffi::c_float,
        pub f_ip_factor: ::core::ffi::c_float,
        pub f_pb_factor: ::core::ffi::c_float,
        pub b_filler: ::core::ffi::c_int,
        pub i_aq_mode: ::core::ffi::c_int,
        pub f_aq_strength: ::core::ffi::c_float,
        pub b_mb_tree: ::core::ffi::c_int,
        pub i_lookahead: ::core::ffi::c_int,
        pub b_stat_write: ::core::ffi::c_int,
        pub psz_stat_out: *mut ::core::ffi::c_char,
        pub b_stat_read: ::core::ffi::c_int,
        pub psz_stat_in: *mut ::core::ffi::c_char,
        pub f_qcompress: ::core::ffi::c_float,
        pub f_qblur: ::core::ffi::c_float,
        pub f_complexity_blur: ::core::ffi::c_float,
        pub zones: *mut x264_zone_t,
        pub i_zones: ::core::ffi::c_int,
        pub psz_zones: *mut ::core::ffi::c_char,
    }
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "406:5"]
    pub struct C2RustUnnamed_3 {
        pub intra: ::core::ffi::c_uint,
        pub inter: ::core::ffi::c_uint,
        pub b_transform_8x8: ::core::ffi::c_int,
        pub i_weighted_pred: ::core::ffi::c_int,
        pub b_weighted_bipred: ::core::ffi::c_int,
        pub i_direct_mv_pred: ::core::ffi::c_int,
        pub i_chroma_qp_offset: ::core::ffi::c_int,
        pub i_me_method: ::core::ffi::c_int,
        pub i_me_range: ::core::ffi::c_int,
        pub i_mv_range: ::core::ffi::c_int,
        pub i_mv_range_thread: ::core::ffi::c_int,
        pub i_subpel_refine: ::core::ffi::c_int,
        pub b_chroma_me: ::core::ffi::c_int,
        pub b_mixed_references: ::core::ffi::c_int,
        pub i_trellis: ::core::ffi::c_int,
        pub b_fast_pskip: ::core::ffi::c_int,
        pub b_dct_decimate: ::core::ffi::c_int,
        pub i_noise_reduction: ::core::ffi::c_int,
        pub f_psy_rd: ::core::ffi::c_float,
        pub f_psy_trellis: ::core::ffi::c_float,
        pub b_psy: ::core::ffi::c_int,
        pub b_mb_info: ::core::ffi::c_int,
        pub b_mb_info_update: ::core::ffi::c_int,
        pub i_luma_deadzone: [::core::ffi::c_int; 2],
        pub b_psnr: ::core::ffi::c_int,
        pub b_ssim: ::core::ffi::c_int,
    }
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "342:5"]
    pub struct C2RustUnnamed_4 {
        pub i_sar_height: ::core::ffi::c_int,
        pub i_sar_width: ::core::ffi::c_int,
        pub i_overscan: ::core::ffi::c_int,
        pub i_vidformat: ::core::ffi::c_int,
        pub b_fullrange: ::core::ffi::c_int,
        pub i_colorprim: ::core::ffi::c_int,
        pub i_transfer: ::core::ffi::c_int,
        pub i_colmatrix: ::core::ffi::c_int,
        pub i_chroma_loc: ::core::ffi::c_int,
    }
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "633:16"]
    pub struct x264_level_t {
        pub level_idc: uint8_t,
        pub mbps: int32_t,
        pub frame_size: int32_t,
        pub dpb: int32_t,
        pub bitrate: int32_t,
        pub cpb: int32_t,
        pub mv_range: uint16_t,
        pub mvs_per_2mb: uint8_t,
        pub slice_rate: uint8_t,
        pub mincr: uint8_t,
        pub bipred8x8: uint8_t,
        pub direct8x8: uint8_t,
        pub frame_only: uint8_t,
    }
    #[c2rust::src_loc = "757:1"]
    pub type pic_struct_e = ::core::ffi::c_uint;
    #[c2rust::src_loc = "767:5"]
    pub const PIC_STRUCT_TRIPLE: pic_struct_e = 9;
    #[c2rust::src_loc = "766:5"]
    pub const PIC_STRUCT_DOUBLE: pic_struct_e = 8;
    #[c2rust::src_loc = "765:5"]
    pub const PIC_STRUCT_BOTTOM_TOP_BOTTOM: pic_struct_e = 7;
    #[c2rust::src_loc = "764:5"]
    pub const PIC_STRUCT_TOP_BOTTOM_TOP: pic_struct_e = 6;
    #[c2rust::src_loc = "763:5"]
    pub const PIC_STRUCT_BOTTOM_TOP: pic_struct_e = 5;
    #[c2rust::src_loc = "762:5"]
    pub const PIC_STRUCT_TOP_BOTTOM: pic_struct_e = 4;
    #[c2rust::src_loc = "760:5"]
    pub const PIC_STRUCT_PROGRESSIVE: pic_struct_e = 1;
    #[c2rust::src_loc = "759:5"]
    pub const PIC_STRUCT_AUTO: pic_struct_e = 0;
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "770:16"]
    pub struct x264_hrd_t {
        pub cpb_initial_arrival_time: ::core::ffi::c_double,
        pub cpb_final_arrival_time: ::core::ffi::c_double,
        pub cpb_removal_time: ::core::ffi::c_double,
        pub dpb_output_time: ::core::ffi::c_double,
    }
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "788:16"]
    pub struct x264_sei_payload_t {
        pub payload_size: ::core::ffi::c_int,
        pub payload_type: ::core::ffi::c_int,
        pub payload: *mut uint8_t,
    }
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "795:16"]
    pub struct x264_sei_t {
        pub num_payloads: ::core::ffi::c_int,
        pub payloads: *mut x264_sei_payload_t,
        pub sei_free: Option<unsafe extern "C" fn(*mut ::core::ffi::c_void) -> ()>,
    }
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "803:16"]
    pub struct x264_image_t {
        pub i_csp: ::core::ffi::c_int,
        pub i_plane: ::core::ffi::c_int,
        pub i_stride: [::core::ffi::c_int; 4],
        pub plane: [*mut uint8_t; 4],
    }
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "811:16"]
    pub struct x264_image_properties_t {
        pub quant_offsets: *mut ::core::ffi::c_float,
        pub quant_offsets_free: Option<unsafe extern "C" fn(*mut ::core::ffi::c_void) -> ()>,
        pub mb_info: *mut uint8_t,
        pub mb_info_free: Option<unsafe extern "C" fn(*mut ::core::ffi::c_void) -> ()>,
        pub f_ssim: ::core::ffi::c_double,
        pub f_psnr_avg: ::core::ffi::c_double,
        pub f_psnr: [::core::ffi::c_double; 3],
        pub f_crf_avg: ::core::ffi::c_double,
    }
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "867:16"]
    pub struct x264_picture_t {
        pub i_type: ::core::ffi::c_int,
        pub i_qpplus1: ::core::ffi::c_int,
        pub i_pic_struct: ::core::ffi::c_int,
        pub b_keyframe: ::core::ffi::c_int,
        pub i_pts: int64_t,
        pub i_dts: int64_t,
        pub param: *mut x264_param_t,
        pub img: x264_image_t,
        pub prop: x264_image_properties_t,
        pub hrd_timing: x264_hrd_t,
        pub extra_sei: x264_sei_t,
        pub opaque: *mut ::core::ffi::c_void,
    }
    #[c2rust::src_loc = "48:9"]
    pub const X264_BUILD: ::core::ffi::c_int = 165 as ::core::ffi::c_int;
    #[c2rust::src_loc = "217:9"]
    pub const X264_QP_AUTO: ::core::ffi::c_int = 0 as ::core::ffi::c_int;
    #[c2rust::src_loc = "238:27"]
    pub static mut x264_direct_pred_names: [*const ::core::ffi::c_char; 5] = [
        b"none\0" as *const u8 as *const ::core::ffi::c_char,
        b"spatial\0" as *const u8 as *const ::core::ffi::c_char,
        b"temporal\0" as *const u8 as *const ::core::ffi::c_char,
        b"auto\0" as *const u8 as *const ::core::ffi::c_char,
        0 as *const ::core::ffi::c_char,
    ];
    #[c2rust::src_loc = "239:27"]
    pub static mut x264_motion_est_names: [*const ::core::ffi::c_char; 6] = [
        b"dia\0" as *const u8 as *const ::core::ffi::c_char,
        b"hex\0" as *const u8 as *const ::core::ffi::c_char,
        b"umh\0" as *const u8 as *const ::core::ffi::c_char,
        b"esa\0" as *const u8 as *const ::core::ffi::c_char,
        b"tesa\0" as *const u8 as *const ::core::ffi::c_char,
        0 as *const ::core::ffi::c_char,
    ];
    #[c2rust::src_loc = "240:27"]
    pub static mut x264_b_pyramid_names: [*const ::core::ffi::c_char; 4] = [
        b"none\0" as *const u8 as *const ::core::ffi::c_char,
        b"strict\0" as *const u8 as *const ::core::ffi::c_char,
        b"normal\0" as *const u8 as *const ::core::ffi::c_char,
        0 as *const ::core::ffi::c_char,
    ];
    #[c2rust::src_loc = "241:27"]
    pub static mut x264_overscan_names: [*const ::core::ffi::c_char; 4] = [
        b"undef\0" as *const u8 as *const ::core::ffi::c_char,
        b"show\0" as *const u8 as *const ::core::ffi::c_char,
        b"crop\0" as *const u8 as *const ::core::ffi::c_char,
        0 as *const ::core::ffi::c_char,
    ];
    #[c2rust::src_loc = "242:27"]
    pub static mut x264_vidformat_names: [*const ::core::ffi::c_char; 7] = [
        b"component\0" as *const u8 as *const ::core::ffi::c_char,
        b"pal\0" as *const u8 as *const ::core::ffi::c_char,
        b"ntsc\0" as *const u8 as *const ::core::ffi::c_char,
        b"secam\0" as *const u8 as *const ::core::ffi::c_char,
        b"mac\0" as *const u8 as *const ::core::ffi::c_char,
        b"undef\0" as *const u8 as *const ::core::ffi::c_char,
        0 as *const ::core::ffi::c_char,
    ];
    #[c2rust::src_loc = "244:27"]
    pub static mut x264_colorprim_names: [*const ::core::ffi::c_char; 14] = [
        b"\0" as *const u8 as *const ::core::ffi::c_char,
        b"bt709\0" as *const u8 as *const ::core::ffi::c_char,
        b"undef\0" as *const u8 as *const ::core::ffi::c_char,
        b"\0" as *const u8 as *const ::core::ffi::c_char,
        b"bt470m\0" as *const u8 as *const ::core::ffi::c_char,
        b"bt470bg\0" as *const u8 as *const ::core::ffi::c_char,
        b"smpte170m\0" as *const u8 as *const ::core::ffi::c_char,
        b"smpte240m\0" as *const u8 as *const ::core::ffi::c_char,
        b"film\0" as *const u8 as *const ::core::ffi::c_char,
        b"bt2020\0" as *const u8 as *const ::core::ffi::c_char,
        b"smpte428\0" as *const u8 as *const ::core::ffi::c_char,
        b"smpte431\0" as *const u8 as *const ::core::ffi::c_char,
        b"smpte432\0" as *const u8 as *const ::core::ffi::c_char,
        0 as *const ::core::ffi::c_char,
    ];
    #[c2rust::src_loc = "246:27"]
    pub static mut x264_transfer_names: [*const ::core::ffi::c_char; 20] = [
        b"\0" as *const u8 as *const ::core::ffi::c_char,
        b"bt709\0" as *const u8 as *const ::core::ffi::c_char,
        b"undef\0" as *const u8 as *const ::core::ffi::c_char,
        b"\0" as *const u8 as *const ::core::ffi::c_char,
        b"bt470m\0" as *const u8 as *const ::core::ffi::c_char,
        b"bt470bg\0" as *const u8 as *const ::core::ffi::c_char,
        b"smpte170m\0" as *const u8 as *const ::core::ffi::c_char,
        b"smpte240m\0" as *const u8 as *const ::core::ffi::c_char,
        b"linear\0" as *const u8 as *const ::core::ffi::c_char,
        b"log100\0" as *const u8 as *const ::core::ffi::c_char,
        b"log316\0" as *const u8 as *const ::core::ffi::c_char,
        b"iec61966-2-4\0" as *const u8 as *const ::core::ffi::c_char,
        b"bt1361e\0" as *const u8 as *const ::core::ffi::c_char,
        b"iec61966-2-1\0" as *const u8 as *const ::core::ffi::c_char,
        b"bt2020-10\0" as *const u8 as *const ::core::ffi::c_char,
        b"bt2020-12\0" as *const u8 as *const ::core::ffi::c_char,
        b"smpte2084\0" as *const u8 as *const ::core::ffi::c_char,
        b"smpte428\0" as *const u8 as *const ::core::ffi::c_char,
        b"arib-std-b67\0" as *const u8 as *const ::core::ffi::c_char,
        0 as *const ::core::ffi::c_char,
    ];
    #[c2rust::src_loc = "248:27"]
    pub static mut x264_colmatrix_names: [*const ::core::ffi::c_char; 16] = [
        b"GBR\0" as *const u8 as *const ::core::ffi::c_char,
        b"bt709\0" as *const u8 as *const ::core::ffi::c_char,
        b"undef\0" as *const u8 as *const ::core::ffi::c_char,
        b"\0" as *const u8 as *const ::core::ffi::c_char,
        b"fcc\0" as *const u8 as *const ::core::ffi::c_char,
        b"bt470bg\0" as *const u8 as *const ::core::ffi::c_char,
        b"smpte170m\0" as *const u8 as *const ::core::ffi::c_char,
        b"smpte240m\0" as *const u8 as *const ::core::ffi::c_char,
        b"YCgCo\0" as *const u8 as *const ::core::ffi::c_char,
        b"bt2020nc\0" as *const u8 as *const ::core::ffi::c_char,
        b"bt2020c\0" as *const u8 as *const ::core::ffi::c_char,
        b"smpte2085\0" as *const u8 as *const ::core::ffi::c_char,
        b"chroma-derived-nc\0" as *const u8 as *const ::core::ffi::c_char,
        b"chroma-derived-c\0" as *const u8 as *const ::core::ffi::c_char,
        b"ICtCp\0" as *const u8 as *const ::core::ffi::c_char,
        0 as *const ::core::ffi::c_char,
    ];
    #[c2rust::src_loc = "251:27"]
    pub static mut x264_avcintra_flavor_names: [*const ::core::ffi::c_char; 3] = [
        b"panasonic\0" as *const u8 as *const ::core::ffi::c_char,
        b"sony\0" as *const u8 as *const ::core::ffi::c_char,
        0 as *const ::core::ffi::c_char,
    ];
    #[c2rust::src_loc = "254:9"]
    pub const X264_CSP_MASK: ::core::ffi::c_int = 0xff as ::core::ffi::c_int;
    #[c2rust::src_loc = "255:9"]
    pub const X264_CSP_NONE: ::core::ffi::c_int = 0 as ::core::ffi::c_int;
    #[c2rust::src_loc = "256:9"]
    pub const X264_CSP_I400: ::core::ffi::c_int = 0x1 as ::core::ffi::c_int;
    #[c2rust::src_loc = "257:9"]
    pub const X264_CSP_I420: ::core::ffi::c_int = 0x2 as ::core::ffi::c_int;
    #[c2rust::src_loc = "261:9"]
    pub const X264_CSP_I422: ::core::ffi::c_int = 0x6 as ::core::ffi::c_int;
    #[c2rust::src_loc = "267:9"]
    pub const X264_CSP_I444: ::core::ffi::c_int = 0xc as ::core::ffi::c_int;
    #[c2rust::src_loc = "269:9"]
    pub const X264_CSP_BGR: ::core::ffi::c_int = 0xe as ::core::ffi::c_int;
    #[c2rust::src_loc = "271:9"]
    pub const X264_CSP_RGB: ::core::ffi::c_int = 0x10 as ::core::ffi::c_int;
    #[c2rust::src_loc = "272:9"]
    pub const X264_CSP_MAX: ::core::ffi::c_int = 0x11 as ::core::ffi::c_int;
    #[c2rust::src_loc = "274:9"]
    pub const X264_CSP_HIGH_DEPTH: ::core::ffi::c_int = 0x2000 as ::core::ffi::c_int;
    #[c2rust::src_loc = "277:9"]
    pub const X264_TYPE_AUTO: ::core::ffi::c_int = 0 as ::core::ffi::c_int;
    #[c2rust::src_loc = "278:9"]
    pub const X264_TYPE_IDR: ::core::ffi::c_int = 0x1 as ::core::ffi::c_int;
    #[c2rust::src_loc = "279:9"]
    pub const X264_TYPE_I: ::core::ffi::c_int = 0x2 as ::core::ffi::c_int;
    #[c2rust::src_loc = "280:9"]
    pub const X264_TYPE_P: ::core::ffi::c_int = 0x3 as ::core::ffi::c_int;
    #[c2rust::src_loc = "281:9"]
    pub const X264_TYPE_BREF: ::core::ffi::c_int = 0x4 as ::core::ffi::c_int;
    #[c2rust::src_loc = "282:9"]
    pub const X264_TYPE_B: ::core::ffi::c_int = 0x5 as ::core::ffi::c_int;
    #[c2rust::src_loc = "283:9"]
    pub const X264_TYPE_KEYFRAME: ::core::ffi::c_int = 0x6 as ::core::ffi::c_int;
    #[c2rust::src_loc = "288:9"]
    pub const X264_LOG_NONE: ::core::ffi::c_int = -(1 as ::core::ffi::c_int);
    #[c2rust::src_loc = "289:9"]
    pub const X264_LOG_ERROR: ::core::ffi::c_int = 0;
    #[c2rust::src_loc = "290:9"]
    pub const X264_LOG_WARNING: ::core::ffi::c_int = 1;
    #[c2rust::src_loc = "291:9"]
    pub const X264_LOG_INFO: ::core::ffi::c_int = 2;
    #[c2rust::src_loc = "292:9"]
    pub const X264_LOG_DEBUG: ::core::ffi::c_int = 3;
    #[c2rust::src_loc = "295:9"]
    pub const X264_THREADS_AUTO: ::core::ffi::c_int = 0 as ::core::ffi::c_int;
    #[c2rust::src_loc = "300:9"]
    pub const X264_NAL_HRD_VBR: ::core::ffi::c_int = 1 as ::core::ffi::c_int;
    #[c2rust::src_loc = "301:9"]
    pub const X264_NAL_HRD_CBR: ::core::ffi::c_int = 2 as ::core::ffi::c_int;
    use super::stdint_intn_h::{int32_t, int64_t};
    use super::stdint_uintn_h::{uint16_t, uint32_t, uint8_t};
    extern "C" {
        #[c2rust::src_loc = "80:16"]
        pub type x264_t;
        #[c2rust::src_loc = "651:36"]
        pub static x264_levels: [x264_level_t; 0];
        #[c2rust::src_loc = "659:10"]
        pub fn x264_param_default(_: *mut x264_param_t);
        #[c2rust::src_loc = "672:10"]
        pub fn x264_param_parse(
            _: *mut x264_param_t,
            name: *const ::core::ffi::c_char,
            value: *const ::core::ffi::c_char,
        ) -> ::core::ffi::c_int;
        #[c2rust::src_loc = "679:10"]
        pub fn x264_param_cleanup(param: *mut x264_param_t);
        #[c2rust::src_loc = "723:10"]
        pub fn x264_param_default_preset(
            _: *mut x264_param_t,
            preset: *const ::core::ffi::c_char,
            tune: *const ::core::ffi::c_char,
        ) -> ::core::ffi::c_int;
        #[c2rust::src_loc = "729:10"]
        pub fn x264_param_apply_fastfirstpass(_: *mut x264_param_t);
        #[c2rust::src_loc = "744:10"]
        pub fn x264_param_apply_profile(
            _: *mut x264_param_t,
            profile: *const ::core::ffi::c_char,
        ) -> ::core::ffi::c_int;
        #[c2rust::src_loc = "755:27"]
        pub static x264_chroma_format: ::core::ffi::c_int;
        #[c2rust::src_loc = "914:10"]
        pub fn x264_picture_init(pic: *mut x264_picture_t);
        #[c2rust::src_loc = "939:10"]
        pub fn x264_encoder_open_165(_: *mut x264_param_t) -> *mut x264_t;
        #[c2rust::src_loc = "962:10"]
        pub fn x264_encoder_parameters(_: *mut x264_t, _: *mut x264_param_t);
        #[c2rust::src_loc = "969:10"]
        pub fn x264_encoder_headers(
            _: *mut x264_t,
            pp_nal: *mut *mut x264_nal_t,
            pi_nal: *mut ::core::ffi::c_int,
        ) -> ::core::ffi::c_int;
        #[c2rust::src_loc = "976:10"]
        pub fn x264_encoder_encode(
            _: *mut x264_t,
            pp_nal: *mut *mut x264_nal_t,
            pi_nal: *mut ::core::ffi::c_int,
            pic_in: *mut x264_picture_t,
            pic_out: *mut x264_picture_t,
        ) -> ::core::ffi::c_int;
        #[c2rust::src_loc = "979:10"]
        pub fn x264_encoder_close(_: *mut x264_t);
        #[c2rust::src_loc = "983:10"]
        pub fn x264_encoder_delayed_frames(_: *mut x264_t) -> ::core::ffi::c_int;
    }

    #[c2rust::src_loc = "250:27"]
    pub static mut x264_nal_hrd_names: [*const ::core::ffi::c_char; 4] = [
        b"none\0" as *const u8 as *const ::core::ffi::c_char,
        b"vbr\0" as *const u8 as *const ::core::ffi::c_char,
        b"cbr\0" as *const u8 as *const ::core::ffi::c_char,
        0 as *const ::core::ffi::c_char,
    ];
    #[c2rust::src_loc = "704:27"]
    pub static mut x264_preset_names: [*const ::core::ffi::c_char; 11] = [
        b"ultrafast\0" as *const u8 as *const ::core::ffi::c_char,
        b"superfast\0" as *const u8 as *const ::core::ffi::c_char,
        b"veryfast\0" as *const u8 as *const ::core::ffi::c_char,
        b"faster\0" as *const u8 as *const ::core::ffi::c_char,
        b"fast\0" as *const u8 as *const ::core::ffi::c_char,
        b"medium\0" as *const u8 as *const ::core::ffi::c_char,
        b"slow\0" as *const u8 as *const ::core::ffi::c_char,
        b"slower\0" as *const u8 as *const ::core::ffi::c_char,
        b"veryslow\0" as *const u8 as *const ::core::ffi::c_char,
        b"placebo\0" as *const u8 as *const ::core::ffi::c_char,
        0 as *const ::core::ffi::c_char,
    ];
    #[c2rust::src_loc = "716:27"]
    pub static mut x264_tune_names: [*const ::core::ffi::c_char; 9] = [
        b"film\0" as *const u8 as *const ::core::ffi::c_char,
        b"animation\0" as *const u8 as *const ::core::ffi::c_char,
        b"grain\0" as *const u8 as *const ::core::ffi::c_char,
        b"stillimage\0" as *const u8 as *const ::core::ffi::c_char,
        b"psnr\0" as *const u8 as *const ::core::ffi::c_char,
        b"ssim\0" as *const u8 as *const ::core::ffi::c_char,
        b"fastdecode\0" as *const u8 as *const ::core::ffi::c_char,
        b"zerolatency\0" as *const u8 as *const ::core::ffi::c_char,
        0 as *const ::core::ffi::c_char,
    ];

    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "342:5"]
    pub struct C2RustUnnamed_5 {
        pub i_sar_height: ::core::ffi::c_int,
        pub i_sar_width: ::core::ffi::c_int,
        pub i_overscan: ::core::ffi::c_int,
        pub i_vidformat: ::core::ffi::c_int,
        pub b_fullrange: ::core::ffi::c_int,
        pub i_colorprim: ::core::ffi::c_int,
        pub i_transfer: ::core::ffi::c_int,
        pub i_colmatrix: ::core::ffi::c_int,
        pub i_chroma_loc: ::core::ffi::c_int,
    }
    #[c2rust::src_loc = "196:9"]
    pub const X264_ANALYSE_I4x4: ::core::ffi::c_uint = 0x1 as ::core::ffi::c_uint;
    #[c2rust::src_loc = "197:9"]
    pub const X264_ANALYSE_I8x8: ::core::ffi::c_uint = 0x2 as ::core::ffi::c_uint;
    #[c2rust::src_loc = "198:9"]
    pub const X264_ANALYSE_PSUB16x16: ::core::ffi::c_uint = 0x10 as ::core::ffi::c_uint;
    #[c2rust::src_loc = "199:9"]
    pub const X264_ANALYSE_PSUB8x8: ::core::ffi::c_uint = 0x20 as ::core::ffi::c_uint;
    #[c2rust::src_loc = "200:9"]
    pub const X264_ANALYSE_BSUB16x16: ::core::ffi::c_uint = 0x100 as ::core::ffi::c_uint;
    #[c2rust::src_loc = "206:9"]
    pub const X264_ME_DIA: ::core::ffi::c_int = 0 as ::core::ffi::c_int;
    #[c2rust::src_loc = "209:9"]
    pub const X264_ME_ESA: ::core::ffi::c_int = 3 as ::core::ffi::c_int;
    #[c2rust::src_loc = "214:9"]
    pub const X264_RC_CQP: ::core::ffi::c_int = 0 as ::core::ffi::c_int;
    #[c2rust::src_loc = "223:9"]
    pub const X264_B_ADAPT_FAST: ::core::ffi::c_int = 1 as ::core::ffi::c_int;
    #[c2rust::src_loc = "224:9"]
    pub const X264_B_ADAPT_TRELLIS: ::core::ffi::c_int = 2 as ::core::ffi::c_int;
    #[c2rust::src_loc = "226:9"]
    pub const X264_WEIGHTP_SIMPLE: ::core::ffi::c_int = 1 as ::core::ffi::c_int;
    #[c2rust::src_loc = "230:9"]
    pub const X264_B_PYRAMID_NORMAL: ::core::ffi::c_int = 2 as ::core::ffi::c_int;
    #[c2rust::src_loc = "853:13"]
    pub const X264_MBINFO_CONSTANT: ::core::ffi::c_uint =
        (1 as ::core::ffi::c_uint) << 0 as ::core::ffi::c_int;
    #[c2rust::src_loc = "86:1"]
    pub type nal_unit_type_e = ::core::ffi::c_uint;
    #[c2rust::src_loc = "98:5"]
    pub const NAL_FILLER: nal_unit_type_e = 12;
    #[c2rust::src_loc = "97:5"]
    pub const NAL_AUD: nal_unit_type_e = 9;
    #[c2rust::src_loc = "96:5"]
    pub const NAL_PPS: nal_unit_type_e = 8;
    #[c2rust::src_loc = "95:5"]
    pub const NAL_SPS: nal_unit_type_e = 7;
    #[c2rust::src_loc = "94:5"]
    pub const NAL_SEI: nal_unit_type_e = 6;
    #[c2rust::src_loc = "93:5"]
    pub const NAL_SLICE_IDR: nal_unit_type_e = 5;
    #[c2rust::src_loc = "92:5"]
    pub const NAL_SLICE_DPC: nal_unit_type_e = 4;
    #[c2rust::src_loc = "91:5"]
    pub const NAL_SLICE_DPB: nal_unit_type_e = 3;
    #[c2rust::src_loc = "90:5"]
    pub const NAL_SLICE_DPA: nal_unit_type_e = 2;
    #[c2rust::src_loc = "89:5"]
    pub const NAL_SLICE: nal_unit_type_e = 1;
    #[c2rust::src_loc = "88:5"]
    pub const NAL_UNKNOWN: nal_unit_type_e = 0;
    #[c2rust::src_loc = "101:1"]
    pub type nal_priority_e = ::core::ffi::c_uint;
    #[c2rust::src_loc = "106:5"]
    pub const NAL_PRIORITY_HIGHEST: nal_priority_e = 3;
    #[c2rust::src_loc = "105:5"]
    pub const NAL_PRIORITY_HIGH: nal_priority_e = 2;
    #[c2rust::src_loc = "104:5"]
    pub const NAL_PRIORITY_LOW: nal_priority_e = 1;
    #[c2rust::src_loc = "103:5"]
    pub const NAL_PRIORITY_DISPOSABLE: nal_priority_e = 0;
    #[c2rust::src_loc = "143:9"]
    pub const X264_CPU_SSE2: ::core::ffi::c_uint =
        (1 as ::core::ffi::c_uint) << 3 as ::core::ffi::c_int;
    #[c2rust::src_loc = "146:9"]
    pub const X264_CPU_SSSE3: ::core::ffi::c_uint =
        (1 as ::core::ffi::c_uint) << 6 as ::core::ffi::c_int;
    #[c2rust::src_loc = "148:9"]
    pub const X264_CPU_SSE42: ::core::ffi::c_uint =
        (1 as ::core::ffi::c_uint) << 8 as ::core::ffi::c_int;
    #[c2rust::src_loc = "152:9"]
    pub const X264_CPU_FMA3: ::core::ffi::c_uint =
        (1 as ::core::ffi::c_uint) << 12 as ::core::ffi::c_int;
    #[c2rust::src_loc = "153:9"]
    pub const X264_CPU_BMI1: ::core::ffi::c_uint =
        (1 as ::core::ffi::c_uint) << 13 as ::core::ffi::c_int;
    #[c2rust::src_loc = "154:9"]
    pub const X264_CPU_BMI2: ::core::ffi::c_uint =
        (1 as ::core::ffi::c_uint) << 14 as ::core::ffi::c_int;
    #[c2rust::src_loc = "156:9"]
    pub const X264_CPU_AVX512: ::core::ffi::c_uint =
        (1 as ::core::ffi::c_uint) << 16 as ::core::ffi::c_int;
    #[c2rust::src_loc = "159:9"]
    pub const X264_CPU_CACHELINE_64: ::core::ffi::c_uint =
        (1 as ::core::ffi::c_uint) << 18 as ::core::ffi::c_int;
    #[c2rust::src_loc = "160:9"]
    pub const X264_CPU_SSE2_IS_SLOW: ::core::ffi::c_uint =
        (1 as ::core::ffi::c_uint) << 19 as ::core::ffi::c_int;
    #[c2rust::src_loc = "161:9"]
    pub const X264_CPU_SSE2_IS_FAST: ::core::ffi::c_uint =
        (1 as ::core::ffi::c_uint) << 20 as ::core::ffi::c_int;
    #[c2rust::src_loc = "202:9"]
    pub const X264_DIRECT_PRED_NONE: ::core::ffi::c_int = 0 as ::core::ffi::c_int;
    #[c2rust::src_loc = "203:9"]
    pub const X264_DIRECT_PRED_SPATIAL: ::core::ffi::c_int = 1 as ::core::ffi::c_int;
    #[c2rust::src_loc = "205:9"]
    pub const X264_DIRECT_PRED_AUTO: ::core::ffi::c_int = 3 as ::core::ffi::c_int;
    #[c2rust::src_loc = "207:9"]
    pub const X264_ME_HEX: ::core::ffi::c_int = 1 as ::core::ffi::c_int;
    #[c2rust::src_loc = "208:9"]
    pub const X264_ME_UMH: ::core::ffi::c_int = 2 as ::core::ffi::c_int;
    #[c2rust::src_loc = "210:9"]
    pub const X264_ME_TESA: ::core::ffi::c_int = 4 as ::core::ffi::c_int;
    #[c2rust::src_loc = "211:9"]
    pub const X264_CQM_FLAT: ::core::ffi::c_int = 0 as ::core::ffi::c_int;
    #[c2rust::src_loc = "213:9"]
    pub const X264_CQM_CUSTOM: ::core::ffi::c_int = 2 as ::core::ffi::c_int;
    #[c2rust::src_loc = "215:9"]
    pub const X264_RC_CRF: ::core::ffi::c_int = 1 as ::core::ffi::c_int;
    #[c2rust::src_loc = "216:9"]
    pub const X264_RC_ABR: ::core::ffi::c_int = 2 as ::core::ffi::c_int;
    #[c2rust::src_loc = "222:9"]
    pub const X264_B_ADAPT_NONE: ::core::ffi::c_int = 0 as ::core::ffi::c_int;
    #[c2rust::src_loc = "225:9"]
    pub const X264_WEIGHTP_NONE: ::core::ffi::c_int = 0 as ::core::ffi::c_int;
    #[c2rust::src_loc = "227:9"]
    pub const X264_WEIGHTP_SMART: ::core::ffi::c_int = 2 as ::core::ffi::c_int;
    #[c2rust::src_loc = "228:9"]
    pub const X264_B_PYRAMID_NONE: ::core::ffi::c_int = 0 as ::core::ffi::c_int;
    #[c2rust::src_loc = "229:9"]
    pub const X264_B_PYRAMID_STRICT: ::core::ffi::c_int = 1 as ::core::ffi::c_int;
    #[c2rust::src_loc = "231:9"]
    pub const X264_KEYINT_MIN_AUTO: ::core::ffi::c_int = 0 as ::core::ffi::c_int;
    #[c2rust::src_loc = "232:9"]
    pub const X264_KEYINT_MAX_INFINITE: ::core::ffi::c_int =
        (1 as ::core::ffi::c_int) << 30 as ::core::ffi::c_int;
    #[c2rust::src_loc = "236:9"]
    pub const X264_AVCINTRA_FLAVOR_SONY: ::core::ffi::c_int = 1 as ::core::ffi::c_int;
    #[c2rust::src_loc = "299:9"]
    pub const X264_NAL_HRD_NONE: ::core::ffi::c_int = 0 as ::core::ffi::c_int;
}
#[c2rust::header_src = "/home/nwplayer123/Hacks/hex264/x264/x264cli.h:37"]
pub mod x264cli_h {
    #[c2rust::src_loc = "37:1"]
    pub type hnd_t = *mut ::core::ffi::c_void;
    #[c2rust::src_loc = "99:9"]
    pub type C2RustUnnamed_5 = ::core::ffi::c_int;
    #[c2rust::src_loc = "103:5"]
    pub const RANGE_PC: C2RustUnnamed_5 = 1;
    #[c2rust::src_loc = "102:5"]
    pub const RANGE_TV: C2RustUnnamed_5 = 0;
    #[c2rust::src_loc = "101:5"]
    pub const RANGE_AUTO: C2RustUnnamed_5 = -1;
    #[c2rust::src_loc = "33:9"]
    pub const UPDATE_INTERVAL: ::core::ffi::c_int = 250000 as ::core::ffi::c_int;
    #[inline]
    #[c2rust::src_loc = "67:1"]
    pub unsafe extern "C" fn get_filename_extension(
        mut filename: *mut ::core::ffi::c_char,
    ) -> *mut ::core::ffi::c_char {
        let mut ext: *mut ::core::ffi::c_char = filename.offset(strlen(filename) as isize);
        while *ext as ::core::ffi::c_int != '.' as i32 && ext > filename {
            ext = ext.offset(-1);
        }
        ext = ext.offset((*ext as ::core::ffi::c_int == '.' as i32) as ::core::ffi::c_int as isize);
        return ext;
    }
    use super::string_h::strlen;
    extern "C" {
        #[c2rust::src_loc = "78:1"]
        pub fn x264_cli_autocomplete(
            prev: *const ::core::ffi::c_char,
            cur: *const ::core::ffi::c_char,
        ) -> ::core::ffi::c_int;
    }
    extern "C" {
        #[c2rust::src_loc = "39:27"]
        pub static x264_avcintra_class_names: [*const ::core::ffi::c_char; 0];
        #[c2rust::src_loc = "40:27"]
        pub static x264_cqm_names: [*const ::core::ffi::c_char; 0];
        #[c2rust::src_loc = "41:27"]
        pub static x264_log_level_names: [*const ::core::ffi::c_char; 0];
        #[c2rust::src_loc = "42:27"]
        pub static x264_partition_names: [*const ::core::ffi::c_char; 0];
        #[c2rust::src_loc = "43:27"]
        pub static x264_pulldown_names: [*const ::core::ffi::c_char; 0];
        #[c2rust::src_loc = "44:27"]
        pub static x264_range_names: [*const ::core::ffi::c_char; 0];
        #[c2rust::src_loc = "45:27"]
        pub static x264_output_csp_names: [*const ::core::ffi::c_char; 0];
        #[c2rust::src_loc = "46:27"]
        pub static x264_valid_profile_names: [*const ::core::ffi::c_char; 0];
        #[c2rust::src_loc = "47:27"]
        pub static x264_demuxer_names: [*const ::core::ffi::c_char; 0];
        #[c2rust::src_loc = "48:27"]
        pub static x264_muxer_names: [*const ::core::ffi::c_char; 0];
    }
}
#[c2rust::header_src = "/usr/include/signal.h:37"]
pub mod signal_h {
    #[c2rust::src_loc = "72:1"]
    pub type __sighandler_t = Option<unsafe extern "C" fn(::core::ffi::c_int) -> ()>;
    extern "C" {
        #[c2rust::src_loc = "88:1"]
        pub fn signal(__sig: ::core::ffi::c_int, __handler: __sighandler_t) -> __sighandler_t;
    }
}
#[c2rust::header_src = "/usr/include/bits/getopt_ext.h:37"]
pub mod getopt_ext_h {
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "50:8"]
    pub struct option {
        pub name: *const ::core::ffi::c_char,
        pub has_arg: ::core::ffi::c_int,
        pub flag: *mut ::core::ffi::c_int,
        pub val: ::core::ffi::c_int,
    }
    #[c2rust::src_loc = "62:9"]
    pub const no_argument: ::core::ffi::c_int = 0 as ::core::ffi::c_int;
    #[c2rust::src_loc = "63:9"]
    pub const required_argument: ::core::ffi::c_int = 1 as ::core::ffi::c_int;
    extern "C" {
        #[c2rust::src_loc = "66:1"]
        pub fn getopt_long(
            ___argc: ::core::ffi::c_int,
            ___argv: *const *mut ::core::ffi::c_char,
            __shortopts: *const ::core::ffi::c_char,
            __longopts: *const option,
            __longind: *mut ::core::ffi::c_int,
        ) -> ::core::ffi::c_int;
    }
}
#[c2rust::header_src = "/home/nwplayer123/Hacks/hex264/x264/input/input.h:37"]
pub mod input_h {
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "38:9"]
    pub struct cli_input_opt_t {
        pub index_file: *mut ::core::ffi::c_char,
        pub format: *mut ::core::ffi::c_char,
        pub resolution: *mut ::core::ffi::c_char,
        pub colorspace: *mut ::core::ffi::c_char,
        pub bit_depth: ::core::ffi::c_int,
        pub timebase: *mut ::core::ffi::c_char,
        pub seek: ::core::ffi::c_int,
        pub progress: ::core::ffi::c_int,
        pub output_csp: ::core::ffi::c_int,
        pub output_range: ::core::ffi::c_int,
        pub input_range: ::core::ffi::c_int,
    }
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "54:9"]
    pub struct video_info_t {
        pub csp: ::core::ffi::c_int,
        pub fps_num: uint32_t,
        pub fps_den: uint32_t,
        pub fullrange: ::core::ffi::c_int,
        pub width: ::core::ffi::c_int,
        pub height: ::core::ffi::c_int,
        pub interlaced: ::core::ffi::c_int,
        pub num_frames: ::core::ffi::c_int,
        pub sar_width: uint32_t,
        pub sar_height: uint32_t,
        pub tff: ::core::ffi::c_int,
        pub thread_safe: ::core::ffi::c_int,
        pub timebase_num: uint32_t,
        pub timebase_den: uint32_t,
        pub vfr: ::core::ffi::c_int,
    }
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "74:9"]
    pub struct cli_image_t {
        pub csp: ::core::ffi::c_int,
        pub width: ::core::ffi::c_int,
        pub height: ::core::ffi::c_int,
        pub planes: ::core::ffi::c_int,
        pub plane: [*mut uint8_t; 4],
        pub stride: [::core::ffi::c_int; 4],
    }
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "84:9"]
    pub struct cli_pic_t {
        pub img: cli_image_t,
        pub pts: int64_t,
        pub duration: int64_t,
        pub opaque: *mut ::core::ffi::c_void,
    }
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "92:9"]
    pub struct cli_input_t {
        pub open_file: Option<
            unsafe extern "C" fn(
                *mut ::core::ffi::c_char,
                *mut hnd_t,
                *mut video_info_t,
                *mut cli_input_opt_t,
            ) -> ::core::ffi::c_int,
        >,
        pub picture_alloc: Option<
            unsafe extern "C" fn(
                *mut cli_pic_t,
                hnd_t,
                ::core::ffi::c_int,
                ::core::ffi::c_int,
                ::core::ffi::c_int,
            ) -> ::core::ffi::c_int,
        >,
        pub read_frame: Option<
            unsafe extern "C" fn(*mut cli_pic_t, hnd_t, ::core::ffi::c_int) -> ::core::ffi::c_int,
        >,
        pub release_frame:
            Option<unsafe extern "C" fn(*mut cli_pic_t, hnd_t) -> ::core::ffi::c_int>,
        pub picture_clean: Option<unsafe extern "C" fn(*mut cli_pic_t, hnd_t) -> ()>,
        pub close_file: Option<unsafe extern "C" fn(hnd_t) -> ::core::ffi::c_int>,
    }
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "117:9"]
    pub struct x264_cli_csp_t {
        pub name: *const ::core::ffi::c_char,
        pub planes: ::core::ffi::c_int,
        pub width: [::core::ffi::c_float; 4],
        pub height: [::core::ffi::c_float; 4],
        pub mod_width: ::core::ffi::c_int,
        pub mod_height: ::core::ffi::c_int,
    }
    #[c2rust::src_loc = "114:9"]
    pub const X264_CSP_CLI_MAX: ::core::ffi::c_int = X264_CSP_MAX;
    use super::stdint_intn_h::int64_t;
    use super::stdint_uintn_h::{uint32_t, uint8_t};
    use super::x264_h::X264_CSP_MAX;
    use super::x264cli_h::hnd_t;
    extern "C" {
        #[c2rust::src_loc = "102:26"]
        pub static raw_input: cli_input_t;
        #[c2rust::src_loc = "103:26"]
        pub static y4m_input: cli_input_t;
        #[c2rust::src_loc = "104:26"]
        pub static avs_input: cli_input_t;
        #[c2rust::src_loc = "105:26"]
        pub static thread_8_input: cli_input_t;
        #[c2rust::src_loc = "106:26"]
        pub static thread_10_input: cli_input_t;
        #[c2rust::src_loc = "107:26"]
        pub static lavf_input: cli_input_t;
        #[c2rust::src_loc = "109:26"]
        pub static timecode_input: cli_input_t;
        #[c2rust::src_loc = "127:29"]
        pub static x264_cli_csps: [x264_cli_csp_t; 0];
    }
}
#[c2rust::header_src = "/home/nwplayer123/Hacks/hex264/x264/output/output.h:37"]
pub mod output_h {
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "32:9"]
    pub struct cli_output_opt_t {
        pub use_dts_compress: ::core::ffi::c_int,
    }
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "37:9"]
    pub struct cli_output_t {
        pub open_file: Option<
            unsafe extern "C" fn(
                *mut ::core::ffi::c_char,
                *mut hnd_t,
                *mut cli_output_opt_t,
            ) -> ::core::ffi::c_int,
        >,
        pub set_param: Option<unsafe extern "C" fn(hnd_t, *mut x264_param_t) -> ::core::ffi::c_int>,
        pub write_headers:
            Option<unsafe extern "C" fn(hnd_t, *mut x264_nal_t) -> ::core::ffi::c_int>,
        pub write_frame: Option<
            unsafe extern "C" fn(
                hnd_t,
                *mut uint8_t,
                ::core::ffi::c_int,
                *mut x264_picture_t,
            ) -> ::core::ffi::c_int,
        >,
        pub close_file: Option<unsafe extern "C" fn(hnd_t, int64_t, int64_t) -> ::core::ffi::c_int>,
    }
    use super::stdint_intn_h::int64_t;
    use super::stdint_uintn_h::uint8_t;
    use super::x264_h::{x264_nal_t, x264_param_t, x264_picture_t};
    use super::x264cli_h::hnd_t;
    extern "C" {
        #[c2rust::src_loc = "46:27"]
        pub static raw_output: cli_output_t;
        #[c2rust::src_loc = "47:27"]
        pub static mkv_output: cli_output_t;
        #[c2rust::src_loc = "48:27"]
        pub static mp4_output: cli_output_t;
        #[c2rust::src_loc = "49:27"]
        pub static flv_output: cli_output_t;
    }
}
#[c2rust::header_src = "/home/nwplayer123/Hacks/hex264/x264/filters/video/video.h:0"]
pub mod video_h {
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "34:8"]
    pub struct cli_vid_filter_t {
        pub name: *const ::core::ffi::c_char,
        pub help: Option<unsafe extern "C" fn(::core::ffi::c_int) -> ()>,
        pub init: Option<
            unsafe extern "C" fn(
                *mut hnd_t,
                *mut cli_vid_filter_t,
                *mut video_info_t,
                *mut x264_param_t,
                *mut ::core::ffi::c_char,
            ) -> ::core::ffi::c_int,
        >,
        pub get_frame: Option<
            unsafe extern "C" fn(hnd_t, *mut cli_pic_t, ::core::ffi::c_int) -> ::core::ffi::c_int,
        >,
        pub release_frame: Option<
            unsafe extern "C" fn(hnd_t, *mut cli_pic_t, ::core::ffi::c_int) -> ::core::ffi::c_int,
        >,
        pub free: Option<unsafe extern "C" fn(hnd_t) -> ()>,
        pub next: *mut cli_vid_filter_t,
    }
    use super::input_h::{cli_pic_t, video_info_t};
    use super::x264_h::x264_param_t;
    use super::x264cli_h::hnd_t;
    extern "C" {
        #[c2rust::src_loc = "58:1"]
        pub fn x264_register_vid_filters();
        #[c2rust::src_loc = "59:1"]
        pub fn x264_vid_filter_help(longhelp: ::core::ffi::c_int);
        #[c2rust::src_loc = "60:1"]
        pub fn x264_init_vid_filter(
            name: *const ::core::ffi::c_char,
            handle: *mut hnd_t,
            filter_0: *mut cli_vid_filter_t,
            info: *mut video_info_t,
            param: *mut x264_param_t,
            opt_string: *mut ::core::ffi::c_char,
        ) -> ::core::ffi::c_int;
    }
}
#[c2rust::header_src = "/usr/include/libavutil/pixfmt.h:45"]
pub mod pixfmt_h {
    #[c2rust::src_loc = "71:1"]
    pub type AVPixelFormat = ::core::ffi::c_int;
    #[c2rust::src_loc = "502:5"]
    pub const AV_PIX_FMT_NB: AVPixelFormat = 267;
    #[c2rust::src_loc = "500:5"]
    pub const AV_PIX_FMT_OHCODEC: AVPixelFormat = 266;
    #[c2rust::src_loc = "498:5"]
    pub const AV_PIX_FMT_GBRP12MSBLE: AVPixelFormat = 265;
    #[c2rust::src_loc = "497:5"]
    pub const AV_PIX_FMT_GBRP12MSBBE: AVPixelFormat = 264;
    #[c2rust::src_loc = "496:5"]
    pub const AV_PIX_FMT_GBRP10MSBLE: AVPixelFormat = 263;
    #[c2rust::src_loc = "495:5"]
    pub const AV_PIX_FMT_GBRP10MSBBE: AVPixelFormat = 262;
    #[c2rust::src_loc = "494:5"]
    pub const AV_PIX_FMT_YUV444P12MSBLE: AVPixelFormat = 261;
    #[c2rust::src_loc = "493:5"]
    pub const AV_PIX_FMT_YUV444P12MSBBE: AVPixelFormat = 260;
    #[c2rust::src_loc = "492:5"]
    pub const AV_PIX_FMT_YUV444P10MSBLE: AVPixelFormat = 259;
    #[c2rust::src_loc = "491:5"]
    pub const AV_PIX_FMT_YUV444P10MSBBE: AVPixelFormat = 258;
    #[c2rust::src_loc = "489:5"]
    pub const AV_PIX_FMT_GBRAP32LE: AVPixelFormat = 257;
    #[c2rust::src_loc = "488:5"]
    pub const AV_PIX_FMT_GBRAP32BE: AVPixelFormat = 256;
    #[c2rust::src_loc = "486:5"]
    pub const AV_PIX_FMT_YAF16LE: AVPixelFormat = 255;
    #[c2rust::src_loc = "485:5"]
    pub const AV_PIX_FMT_YAF16BE: AVPixelFormat = 254;
    #[c2rust::src_loc = "483:5"]
    pub const AV_PIX_FMT_YAF32LE: AVPixelFormat = 253;
    #[c2rust::src_loc = "482:5"]
    pub const AV_PIX_FMT_YAF32BE: AVPixelFormat = 252;
    #[c2rust::src_loc = "480:5"]
    pub const AV_PIX_FMT_GRAY32LE: AVPixelFormat = 251;
    #[c2rust::src_loc = "479:5"]
    pub const AV_PIX_FMT_GRAY32BE: AVPixelFormat = 250;
    #[c2rust::src_loc = "477:5"]
    pub const AV_PIX_FMT_AMF_SURFACE: AVPixelFormat = 249;
    #[c2rust::src_loc = "472:5"]
    pub const AV_PIX_FMT_GRAYF16LE: AVPixelFormat = 248;
    #[c2rust::src_loc = "471:5"]
    pub const AV_PIX_FMT_GRAYF16BE: AVPixelFormat = 247;
    #[c2rust::src_loc = "469:5"]
    pub const AV_PIX_FMT_GBRAPF16LE: AVPixelFormat = 246;
    #[c2rust::src_loc = "468:5"]
    pub const AV_PIX_FMT_GBRAPF16BE: AVPixelFormat = 245;
    #[c2rust::src_loc = "467:5"]
    pub const AV_PIX_FMT_GBRPF16LE: AVPixelFormat = 244;
    #[c2rust::src_loc = "466:5"]
    pub const AV_PIX_FMT_GBRPF16BE: AVPixelFormat = 243;
    #[c2rust::src_loc = "464:5"]
    pub const AV_PIX_FMT_XV48LE: AVPixelFormat = 242;
    #[c2rust::src_loc = "463:5"]
    pub const AV_PIX_FMT_XV48BE: AVPixelFormat = 241;
    #[c2rust::src_loc = "461:5"]
    pub const AV_PIX_FMT_Y216LE: AVPixelFormat = 240;
    #[c2rust::src_loc = "460:5"]
    pub const AV_PIX_FMT_Y216BE: AVPixelFormat = 239;
    #[c2rust::src_loc = "458:5"]
    pub const AV_PIX_FMT_RGB96LE: AVPixelFormat = 238;
    #[c2rust::src_loc = "457:5"]
    pub const AV_PIX_FMT_RGB96BE: AVPixelFormat = 237;
    #[c2rust::src_loc = "455:5"]
    pub const AV_PIX_FMT_RGBA128LE: AVPixelFormat = 236;
    #[c2rust::src_loc = "454:5"]
    pub const AV_PIX_FMT_RGBA128BE: AVPixelFormat = 235;
    #[c2rust::src_loc = "452:5"]
    pub const AV_PIX_FMT_RGBF16LE: AVPixelFormat = 234;
    #[c2rust::src_loc = "451:5"]
    pub const AV_PIX_FMT_RGBF16BE: AVPixelFormat = 233;
    #[c2rust::src_loc = "449:5"]
    pub const AV_PIX_FMT_V30XLE: AVPixelFormat = 232;
    #[c2rust::src_loc = "448:5"]
    pub const AV_PIX_FMT_V30XBE: AVPixelFormat = 231;
    #[c2rust::src_loc = "446:5"]
    pub const AV_PIX_FMT_VYU444: AVPixelFormat = 230;
    #[c2rust::src_loc = "444:5"]
    pub const AV_PIX_FMT_UYVA: AVPixelFormat = 229;
    #[c2rust::src_loc = "442:5"]
    pub const AV_PIX_FMT_AYUV: AVPixelFormat = 228;
    #[c2rust::src_loc = "440:5"]
    pub const AV_PIX_FMT_D3D12: AVPixelFormat = 227;
    #[c2rust::src_loc = "433:5"]
    pub const AV_PIX_FMT_GBRAP14LE: AVPixelFormat = 226;
    #[c2rust::src_loc = "432:5"]
    pub const AV_PIX_FMT_GBRAP14BE: AVPixelFormat = 225;
    #[c2rust::src_loc = "430:5"]
    pub const AV_PIX_FMT_P412LE: AVPixelFormat = 224;
    #[c2rust::src_loc = "429:5"]
    pub const AV_PIX_FMT_P412BE: AVPixelFormat = 223;
    #[c2rust::src_loc = "427:5"]
    pub const AV_PIX_FMT_P212LE: AVPixelFormat = 222;
    #[c2rust::src_loc = "426:5"]
    pub const AV_PIX_FMT_P212BE: AVPixelFormat = 221;
    #[c2rust::src_loc = "424:5"]
    pub const AV_PIX_FMT_RGBAF32LE: AVPixelFormat = 220;
    #[c2rust::src_loc = "423:5"]
    pub const AV_PIX_FMT_RGBAF32BE: AVPixelFormat = 219;
    #[c2rust::src_loc = "421:5"]
    pub const AV_PIX_FMT_RGBF32LE: AVPixelFormat = 218;
    #[c2rust::src_loc = "420:5"]
    pub const AV_PIX_FMT_RGBF32BE: AVPixelFormat = 217;
    #[c2rust::src_loc = "418:5"]
    pub const AV_PIX_FMT_XV36LE: AVPixelFormat = 216;
    #[c2rust::src_loc = "417:5"]
    pub const AV_PIX_FMT_XV36BE: AVPixelFormat = 215;
    #[c2rust::src_loc = "415:5"]
    pub const AV_PIX_FMT_XV30LE: AVPixelFormat = 214;
    #[c2rust::src_loc = "414:5"]
    pub const AV_PIX_FMT_XV30BE: AVPixelFormat = 213;
    #[c2rust::src_loc = "412:5"]
    pub const AV_PIX_FMT_Y212LE: AVPixelFormat = 212;
    #[c2rust::src_loc = "411:5"]
    pub const AV_PIX_FMT_Y212BE: AVPixelFormat = 211;
    #[c2rust::src_loc = "409:5"]
    pub const AV_PIX_FMT_P012BE: AVPixelFormat = 210;
    #[c2rust::src_loc = "408:5"]
    pub const AV_PIX_FMT_P012LE: AVPixelFormat = 209;
    #[c2rust::src_loc = "406:5"]
    pub const AV_PIX_FMT_VUYX: AVPixelFormat = 208;
    #[c2rust::src_loc = "404:5"]
    pub const AV_PIX_FMT_RGBAF16LE: AVPixelFormat = 207;
    #[c2rust::src_loc = "403:5"]
    pub const AV_PIX_FMT_RGBAF16BE: AVPixelFormat = 206;
    #[c2rust::src_loc = "401:5"]
    pub const AV_PIX_FMT_VUYA: AVPixelFormat = 205;
    #[c2rust::src_loc = "399:5"]
    pub const AV_PIX_FMT_P416LE: AVPixelFormat = 204;
    #[c2rust::src_loc = "398:5"]
    pub const AV_PIX_FMT_P416BE: AVPixelFormat = 203;
    #[c2rust::src_loc = "396:5"]
    pub const AV_PIX_FMT_P216LE: AVPixelFormat = 202;
    #[c2rust::src_loc = "395:5"]
    pub const AV_PIX_FMT_P216BE: AVPixelFormat = 201;
    #[c2rust::src_loc = "393:5"]
    pub const AV_PIX_FMT_P410LE: AVPixelFormat = 200;
    #[c2rust::src_loc = "392:5"]
    pub const AV_PIX_FMT_P410BE: AVPixelFormat = 199;
    #[c2rust::src_loc = "390:5"]
    pub const AV_PIX_FMT_P210LE: AVPixelFormat = 198;
    #[c2rust::src_loc = "389:5"]
    pub const AV_PIX_FMT_P210BE: AVPixelFormat = 197;
    #[c2rust::src_loc = "387:5"]
    pub const AV_PIX_FMT_X2BGR10BE: AVPixelFormat = 196;
    #[c2rust::src_loc = "386:5"]
    pub const AV_PIX_FMT_X2BGR10LE: AVPixelFormat = 195;
    #[c2rust::src_loc = "385:5"]
    pub const AV_PIX_FMT_X2RGB10BE: AVPixelFormat = 194;
    #[c2rust::src_loc = "384:5"]
    pub const AV_PIX_FMT_X2RGB10LE: AVPixelFormat = 193;
    #[c2rust::src_loc = "382:5"]
    pub const AV_PIX_FMT_Y210LE: AVPixelFormat = 192;
    #[c2rust::src_loc = "381:5"]
    pub const AV_PIX_FMT_Y210BE: AVPixelFormat = 191;
    #[c2rust::src_loc = "379:5"]
    pub const AV_PIX_FMT_VULKAN: AVPixelFormat = 190;
    #[c2rust::src_loc = "372:5"]
    pub const AV_PIX_FMT_NV42: AVPixelFormat = 189;
    #[c2rust::src_loc = "371:5"]
    pub const AV_PIX_FMT_NV24: AVPixelFormat = 188;
    #[c2rust::src_loc = "369:5"]
    pub const AV_PIX_FMT_YUVA444P12LE: AVPixelFormat = 187;
    #[c2rust::src_loc = "368:5"]
    pub const AV_PIX_FMT_YUVA444P12BE: AVPixelFormat = 186;
    #[c2rust::src_loc = "367:5"]
    pub const AV_PIX_FMT_YUVA422P12LE: AVPixelFormat = 185;
    #[c2rust::src_loc = "366:5"]
    pub const AV_PIX_FMT_YUVA422P12BE: AVPixelFormat = 184;
    #[c2rust::src_loc = "364:5"]
    pub const AV_PIX_FMT_GRAYF32LE: AVPixelFormat = 183;
    #[c2rust::src_loc = "363:5"]
    pub const AV_PIX_FMT_GRAYF32BE: AVPixelFormat = 182;
    #[c2rust::src_loc = "361:5"]
    pub const AV_PIX_FMT_GRAY14LE: AVPixelFormat = 181;
    #[c2rust::src_loc = "360:5"]
    pub const AV_PIX_FMT_GRAY14BE: AVPixelFormat = 180;
    #[c2rust::src_loc = "358:5"]
    pub const AV_PIX_FMT_OPENCL: AVPixelFormat = 179;
    #[c2rust::src_loc = "351:5"]
    pub const AV_PIX_FMT_DRM_PRIME: AVPixelFormat = 178;
    #[c2rust::src_loc = "344:5"]
    pub const AV_PIX_FMT_GBRAPF32LE: AVPixelFormat = 177;
    #[c2rust::src_loc = "343:5"]
    pub const AV_PIX_FMT_GBRAPF32BE: AVPixelFormat = 176;
    #[c2rust::src_loc = "342:5"]
    pub const AV_PIX_FMT_GBRPF32LE: AVPixelFormat = 175;
    #[c2rust::src_loc = "341:5"]
    pub const AV_PIX_FMT_GBRPF32BE: AVPixelFormat = 174;
    #[c2rust::src_loc = "339:5"]
    pub const AV_PIX_FMT_GRAY9LE: AVPixelFormat = 173;
    #[c2rust::src_loc = "338:5"]
    pub const AV_PIX_FMT_GRAY9BE: AVPixelFormat = 172;
    #[c2rust::src_loc = "336:5"]
    pub const AV_PIX_FMT_D3D11: AVPixelFormat = 171;
    #[c2rust::src_loc = "324:5"]
    pub const AV_PIX_FMT_P016BE: AVPixelFormat = 170;
    #[c2rust::src_loc = "323:5"]
    pub const AV_PIX_FMT_P016LE: AVPixelFormat = 169;
    #[c2rust::src_loc = "321:5"]
    pub const AV_PIX_FMT_GRAY10LE: AVPixelFormat = 168;
    #[c2rust::src_loc = "320:5"]
    pub const AV_PIX_FMT_GRAY10BE: AVPixelFormat = 167;
    #[c2rust::src_loc = "319:5"]
    pub const AV_PIX_FMT_GRAY12LE: AVPixelFormat = 166;
    #[c2rust::src_loc = "318:5"]
    pub const AV_PIX_FMT_GRAY12BE: AVPixelFormat = 165;
    #[c2rust::src_loc = "316:5"]
    pub const AV_PIX_FMT_MEDIACODEC: AVPixelFormat = 164;
    #[c2rust::src_loc = "314:5"]
    pub const AV_PIX_FMT_GBRAP10LE: AVPixelFormat = 163;
    #[c2rust::src_loc = "313:5"]
    pub const AV_PIX_FMT_GBRAP10BE: AVPixelFormat = 162;
    #[c2rust::src_loc = "311:5"]
    pub const AV_PIX_FMT_GBRAP12LE: AVPixelFormat = 161;
    #[c2rust::src_loc = "310:5"]
    pub const AV_PIX_FMT_GBRAP12BE: AVPixelFormat = 160;
    #[c2rust::src_loc = "308:5"]
    pub const AV_PIX_FMT_P010BE: AVPixelFormat = 159;
    #[c2rust::src_loc = "307:5"]
    pub const AV_PIX_FMT_P010LE: AVPixelFormat = 158;
    #[c2rust::src_loc = "305:5"]
    pub const AV_PIX_FMT_VIDEOTOOLBOX: AVPixelFormat = 157;
    #[c2rust::src_loc = "303:5"]
    pub const AV_PIX_FMT_AYUV64BE: AVPixelFormat = 156;
    #[c2rust::src_loc = "302:5"]
    pub const AV_PIX_FMT_AYUV64LE: AVPixelFormat = 155;
    #[c2rust::src_loc = "301:5"]
    pub const AV_PIX_FMT_YUV440P12BE: AVPixelFormat = 154;
    #[c2rust::src_loc = "300:5"]
    pub const AV_PIX_FMT_YUV440P12LE: AVPixelFormat = 153;
    #[c2rust::src_loc = "299:5"]
    pub const AV_PIX_FMT_YUV440P10BE: AVPixelFormat = 152;
    #[c2rust::src_loc = "298:5"]
    pub const AV_PIX_FMT_YUV440P10LE: AVPixelFormat = 151;
    #[c2rust::src_loc = "296:5"]
    pub const AV_PIX_FMT_BAYER_GRBG16BE: AVPixelFormat = 150;
    #[c2rust::src_loc = "295:5"]
    pub const AV_PIX_FMT_BAYER_GRBG16LE: AVPixelFormat = 149;
    #[c2rust::src_loc = "294:5"]
    pub const AV_PIX_FMT_BAYER_GBRG16BE: AVPixelFormat = 148;
    #[c2rust::src_loc = "293:5"]
    pub const AV_PIX_FMT_BAYER_GBRG16LE: AVPixelFormat = 147;
    #[c2rust::src_loc = "292:5"]
    pub const AV_PIX_FMT_BAYER_RGGB16BE: AVPixelFormat = 146;
    #[c2rust::src_loc = "291:5"]
    pub const AV_PIX_FMT_BAYER_RGGB16LE: AVPixelFormat = 145;
    #[c2rust::src_loc = "290:5"]
    pub const AV_PIX_FMT_BAYER_BGGR16BE: AVPixelFormat = 144;
    #[c2rust::src_loc = "289:5"]
    pub const AV_PIX_FMT_BAYER_BGGR16LE: AVPixelFormat = 143;
    #[c2rust::src_loc = "288:5"]
    pub const AV_PIX_FMT_BAYER_GRBG8: AVPixelFormat = 142;
    #[c2rust::src_loc = "287:5"]
    pub const AV_PIX_FMT_BAYER_GBRG8: AVPixelFormat = 141;
    #[c2rust::src_loc = "286:5"]
    pub const AV_PIX_FMT_BAYER_RGGB8: AVPixelFormat = 140;
    #[c2rust::src_loc = "285:5"]
    pub const AV_PIX_FMT_BAYER_BGGR8: AVPixelFormat = 139;
    #[c2rust::src_loc = "283:5"]
    pub const AV_PIX_FMT_YUVJ411P: AVPixelFormat = 138;
    #[c2rust::src_loc = "282:5"]
    pub const AV_PIX_FMT_GBRP14LE: AVPixelFormat = 137;
    #[c2rust::src_loc = "281:5"]
    pub const AV_PIX_FMT_GBRP14BE: AVPixelFormat = 136;
    #[c2rust::src_loc = "280:5"]
    pub const AV_PIX_FMT_GBRP12LE: AVPixelFormat = 135;
    #[c2rust::src_loc = "279:5"]
    pub const AV_PIX_FMT_GBRP12BE: AVPixelFormat = 134;
    #[c2rust::src_loc = "278:5"]
    pub const AV_PIX_FMT_YUV444P14LE: AVPixelFormat = 133;
    #[c2rust::src_loc = "277:5"]
    pub const AV_PIX_FMT_YUV444P14BE: AVPixelFormat = 132;
    #[c2rust::src_loc = "276:5"]
    pub const AV_PIX_FMT_YUV444P12LE: AVPixelFormat = 131;
    #[c2rust::src_loc = "275:5"]
    pub const AV_PIX_FMT_YUV444P12BE: AVPixelFormat = 130;
    #[c2rust::src_loc = "274:5"]
    pub const AV_PIX_FMT_YUV422P14LE: AVPixelFormat = 129;
    #[c2rust::src_loc = "273:5"]
    pub const AV_PIX_FMT_YUV422P14BE: AVPixelFormat = 128;
    #[c2rust::src_loc = "272:5"]
    pub const AV_PIX_FMT_YUV422P12LE: AVPixelFormat = 127;
    #[c2rust::src_loc = "271:5"]
    pub const AV_PIX_FMT_YUV422P12BE: AVPixelFormat = 126;
    #[c2rust::src_loc = "270:5"]
    pub const AV_PIX_FMT_YUV420P14LE: AVPixelFormat = 125;
    #[c2rust::src_loc = "269:5"]
    pub const AV_PIX_FMT_YUV420P14BE: AVPixelFormat = 124;
    #[c2rust::src_loc = "268:5"]
    pub const AV_PIX_FMT_YUV420P12LE: AVPixelFormat = 123;
    #[c2rust::src_loc = "267:5"]
    pub const AV_PIX_FMT_YUV420P12BE: AVPixelFormat = 122;
    #[c2rust::src_loc = "265:5"]
    pub const AV_PIX_FMT_BGR0: AVPixelFormat = 121;
    #[c2rust::src_loc = "264:5"]
    pub const AV_PIX_FMT_0BGR: AVPixelFormat = 120;
    #[c2rust::src_loc = "263:5"]
    pub const AV_PIX_FMT_RGB0: AVPixelFormat = 119;
    #[c2rust::src_loc = "262:5"]
    pub const AV_PIX_FMT_0RGB: AVPixelFormat = 118;
    #[c2rust::src_loc = "260:5"]
    pub const AV_PIX_FMT_CUDA: AVPixelFormat = 117;
    #[c2rust::src_loc = "254:5"]
    pub const AV_PIX_FMT_D3D11VA_VLD: AVPixelFormat = 116;
    #[c2rust::src_loc = "252:5"]
    pub const AV_PIX_FMT_MMAL: AVPixelFormat = 115;
    #[c2rust::src_loc = "247:5"]
    pub const AV_PIX_FMT_QSV: AVPixelFormat = 114;
    #[c2rust::src_loc = "214:5"]
    pub const AV_PIX_FMT_GBRAP16LE: AVPixelFormat = 113;
    #[c2rust::src_loc = "213:5"]
    pub const AV_PIX_FMT_GBRAP16BE: AVPixelFormat = 112;
    #[c2rust::src_loc = "212:5"]
    pub const AV_PIX_FMT_GBRAP: AVPixelFormat = 111;
    #[c2rust::src_loc = "210:5"]
    pub const AV_PIX_FMT_YA16LE: AVPixelFormat = 110;
    #[c2rust::src_loc = "209:5"]
    pub const AV_PIX_FMT_YA16BE: AVPixelFormat = 109;
    #[c2rust::src_loc = "207:5"]
    pub const AV_PIX_FMT_YVYU422: AVPixelFormat = 108;
    #[c2rust::src_loc = "205:5"]
    pub const AV_PIX_FMT_BGRA64LE: AVPixelFormat = 107;
    #[c2rust::src_loc = "204:5"]
    pub const AV_PIX_FMT_BGRA64BE: AVPixelFormat = 106;
    #[c2rust::src_loc = "203:5"]
    pub const AV_PIX_FMT_RGBA64LE: AVPixelFormat = 105;
    #[c2rust::src_loc = "202:5"]
    pub const AV_PIX_FMT_RGBA64BE: AVPixelFormat = 104;
    #[c2rust::src_loc = "200:5"]
    pub const AV_PIX_FMT_NV20BE: AVPixelFormat = 103;
    #[c2rust::src_loc = "199:5"]
    pub const AV_PIX_FMT_NV20LE: AVPixelFormat = 102;
    #[c2rust::src_loc = "198:5"]
    pub const AV_PIX_FMT_NV16: AVPixelFormat = 101;
    #[c2rust::src_loc = "197:5"]
    pub const AV_PIX_FMT_XYZ12BE: AVPixelFormat = 100;
    #[c2rust::src_loc = "196:5"]
    pub const AV_PIX_FMT_XYZ12LE: AVPixelFormat = 99;
    #[c2rust::src_loc = "194:5"]
    pub const AV_PIX_FMT_VDPAU: AVPixelFormat = 98;
    #[c2rust::src_loc = "192:5"]
    pub const AV_PIX_FMT_YUVA444P16LE: AVPixelFormat = 97;
    #[c2rust::src_loc = "191:5"]
    pub const AV_PIX_FMT_YUVA444P16BE: AVPixelFormat = 96;
    #[c2rust::src_loc = "190:5"]
    pub const AV_PIX_FMT_YUVA422P16LE: AVPixelFormat = 95;
    #[c2rust::src_loc = "189:5"]
    pub const AV_PIX_FMT_YUVA422P16BE: AVPixelFormat = 94;
    #[c2rust::src_loc = "188:5"]
    pub const AV_PIX_FMT_YUVA420P16LE: AVPixelFormat = 93;
    #[c2rust::src_loc = "187:5"]
    pub const AV_PIX_FMT_YUVA420P16BE: AVPixelFormat = 92;
    #[c2rust::src_loc = "186:5"]
    pub const AV_PIX_FMT_YUVA444P10LE: AVPixelFormat = 91;
    #[c2rust::src_loc = "185:5"]
    pub const AV_PIX_FMT_YUVA444P10BE: AVPixelFormat = 90;
    #[c2rust::src_loc = "184:5"]
    pub const AV_PIX_FMT_YUVA422P10LE: AVPixelFormat = 89;
    #[c2rust::src_loc = "183:5"]
    pub const AV_PIX_FMT_YUVA422P10BE: AVPixelFormat = 88;
    #[c2rust::src_loc = "182:5"]
    pub const AV_PIX_FMT_YUVA420P10LE: AVPixelFormat = 87;
    #[c2rust::src_loc = "181:5"]
    pub const AV_PIX_FMT_YUVA420P10BE: AVPixelFormat = 86;
    #[c2rust::src_loc = "180:5"]
    pub const AV_PIX_FMT_YUVA444P9LE: AVPixelFormat = 85;
    #[c2rust::src_loc = "179:5"]
    pub const AV_PIX_FMT_YUVA444P9BE: AVPixelFormat = 84;
    #[c2rust::src_loc = "178:5"]
    pub const AV_PIX_FMT_YUVA422P9LE: AVPixelFormat = 83;
    #[c2rust::src_loc = "177:5"]
    pub const AV_PIX_FMT_YUVA422P9BE: AVPixelFormat = 82;
    #[c2rust::src_loc = "176:5"]
    pub const AV_PIX_FMT_YUVA420P9LE: AVPixelFormat = 81;
    #[c2rust::src_loc = "175:5"]
    pub const AV_PIX_FMT_YUVA420P9BE: AVPixelFormat = 80;
    #[c2rust::src_loc = "174:5"]
    pub const AV_PIX_FMT_YUVA444P: AVPixelFormat = 79;
    #[c2rust::src_loc = "173:5"]
    pub const AV_PIX_FMT_YUVA422P: AVPixelFormat = 78;
    #[c2rust::src_loc = "172:5"]
    pub const AV_PIX_FMT_GBRP16LE: AVPixelFormat = 77;
    #[c2rust::src_loc = "171:5"]
    pub const AV_PIX_FMT_GBRP16BE: AVPixelFormat = 76;
    #[c2rust::src_loc = "170:5"]
    pub const AV_PIX_FMT_GBRP10LE: AVPixelFormat = 75;
    #[c2rust::src_loc = "169:5"]
    pub const AV_PIX_FMT_GBRP10BE: AVPixelFormat = 74;
    #[c2rust::src_loc = "168:5"]
    pub const AV_PIX_FMT_GBRP9LE: AVPixelFormat = 73;
    #[c2rust::src_loc = "167:5"]
    pub const AV_PIX_FMT_GBRP9BE: AVPixelFormat = 72;
    #[c2rust::src_loc = "166:5"]
    pub const AV_PIX_FMT_GBR24P: AVPixelFormat = 71;
    #[c2rust::src_loc = "165:5"]
    pub const AV_PIX_FMT_GBRP: AVPixelFormat = 71;
    #[c2rust::src_loc = "164:5"]
    pub const AV_PIX_FMT_YUV422P9LE: AVPixelFormat = 70;
    #[c2rust::src_loc = "163:5"]
    pub const AV_PIX_FMT_YUV422P9BE: AVPixelFormat = 69;
    #[c2rust::src_loc = "162:5"]
    pub const AV_PIX_FMT_YUV444P10LE: AVPixelFormat = 68;
    #[c2rust::src_loc = "161:5"]
    pub const AV_PIX_FMT_YUV444P10BE: AVPixelFormat = 67;
    #[c2rust::src_loc = "160:5"]
    pub const AV_PIX_FMT_YUV444P9LE: AVPixelFormat = 66;
    #[c2rust::src_loc = "159:5"]
    pub const AV_PIX_FMT_YUV444P9BE: AVPixelFormat = 65;
    #[c2rust::src_loc = "158:5"]
    pub const AV_PIX_FMT_YUV422P10LE: AVPixelFormat = 64;
    #[c2rust::src_loc = "157:5"]
    pub const AV_PIX_FMT_YUV422P10BE: AVPixelFormat = 63;
    #[c2rust::src_loc = "156:5"]
    pub const AV_PIX_FMT_YUV420P10LE: AVPixelFormat = 62;
    #[c2rust::src_loc = "155:5"]
    pub const AV_PIX_FMT_YUV420P10BE: AVPixelFormat = 61;
    #[c2rust::src_loc = "154:5"]
    pub const AV_PIX_FMT_YUV420P9LE: AVPixelFormat = 60;
    #[c2rust::src_loc = "153:5"]
    pub const AV_PIX_FMT_YUV420P9BE: AVPixelFormat = 59;
    #[c2rust::src_loc = "146:5"]
    pub const AV_PIX_FMT_BGR48LE: AVPixelFormat = 58;
    #[c2rust::src_loc = "145:5"]
    pub const AV_PIX_FMT_BGR48BE: AVPixelFormat = 57;
    #[c2rust::src_loc = "143:5"]
    pub const AV_PIX_FMT_GRAY8A: AVPixelFormat = 56;
    #[c2rust::src_loc = "142:5"]
    pub const AV_PIX_FMT_Y400A: AVPixelFormat = 56;
    #[c2rust::src_loc = "140:5"]
    pub const AV_PIX_FMT_YA8: AVPixelFormat = 56;
    #[c2rust::src_loc = "139:5"]
    pub const AV_PIX_FMT_BGR444BE: AVPixelFormat = 55;
    #[c2rust::src_loc = "138:5"]
    pub const AV_PIX_FMT_BGR444LE: AVPixelFormat = 54;
    #[c2rust::src_loc = "137:5"]
    pub const AV_PIX_FMT_RGB444BE: AVPixelFormat = 53;
    #[c2rust::src_loc = "136:5"]
    pub const AV_PIX_FMT_RGB444LE: AVPixelFormat = 52;
    #[c2rust::src_loc = "134:5"]
    pub const AV_PIX_FMT_DXVA2_VLD: AVPixelFormat = 51;
    #[c2rust::src_loc = "133:5"]
    pub const AV_PIX_FMT_YUV444P16BE: AVPixelFormat = 50;
    #[c2rust::src_loc = "132:5"]
    pub const AV_PIX_FMT_YUV444P16LE: AVPixelFormat = 49;
    #[c2rust::src_loc = "131:5"]
    pub const AV_PIX_FMT_YUV422P16BE: AVPixelFormat = 48;
    #[c2rust::src_loc = "130:5"]
    pub const AV_PIX_FMT_YUV422P16LE: AVPixelFormat = 47;
    #[c2rust::src_loc = "129:5"]
    pub const AV_PIX_FMT_YUV420P16BE: AVPixelFormat = 46;
    #[c2rust::src_loc = "128:5"]
    pub const AV_PIX_FMT_YUV420P16LE: AVPixelFormat = 45;
    #[c2rust::src_loc = "126:5"]
    pub const AV_PIX_FMT_VAAPI: AVPixelFormat = 44;
    #[c2rust::src_loc = "120:5"]
    pub const AV_PIX_FMT_BGR555LE: AVPixelFormat = 43;
    #[c2rust::src_loc = "119:5"]
    pub const AV_PIX_FMT_BGR555BE: AVPixelFormat = 42;
    #[c2rust::src_loc = "118:5"]
    pub const AV_PIX_FMT_BGR565LE: AVPixelFormat = 41;
    #[c2rust::src_loc = "117:5"]
    pub const AV_PIX_FMT_BGR565BE: AVPixelFormat = 40;
    #[c2rust::src_loc = "115:5"]
    pub const AV_PIX_FMT_RGB555LE: AVPixelFormat = 39;
    #[c2rust::src_loc = "114:5"]
    pub const AV_PIX_FMT_RGB555BE: AVPixelFormat = 38;
    #[c2rust::src_loc = "113:5"]
    pub const AV_PIX_FMT_RGB565LE: AVPixelFormat = 37;
    #[c2rust::src_loc = "112:5"]
    pub const AV_PIX_FMT_RGB565BE: AVPixelFormat = 36;
    #[c2rust::src_loc = "110:5"]
    pub const AV_PIX_FMT_RGB48LE: AVPixelFormat = 35;
    #[c2rust::src_loc = "109:5"]
    pub const AV_PIX_FMT_RGB48BE: AVPixelFormat = 34;
    #[c2rust::src_loc = "108:5"]
    pub const AV_PIX_FMT_YUVA420P: AVPixelFormat = 33;
    #[c2rust::src_loc = "107:5"]
    pub const AV_PIX_FMT_YUVJ440P: AVPixelFormat = 32;
    #[c2rust::src_loc = "106:5"]
    pub const AV_PIX_FMT_YUV440P: AVPixelFormat = 31;
    #[c2rust::src_loc = "105:5"]
    pub const AV_PIX_FMT_GRAY16LE: AVPixelFormat = 30;
    #[c2rust::src_loc = "104:5"]
    pub const AV_PIX_FMT_GRAY16BE: AVPixelFormat = 29;
    #[c2rust::src_loc = "102:5"]
    pub const AV_PIX_FMT_BGRA: AVPixelFormat = 28;
    #[c2rust::src_loc = "101:5"]
    pub const AV_PIX_FMT_ABGR: AVPixelFormat = 27;
    #[c2rust::src_loc = "100:5"]
    pub const AV_PIX_FMT_RGBA: AVPixelFormat = 26;
    #[c2rust::src_loc = "99:5"]
    pub const AV_PIX_FMT_ARGB: AVPixelFormat = 25;
    #[c2rust::src_loc = "97:5"]
    pub const AV_PIX_FMT_NV21: AVPixelFormat = 24;
    #[c2rust::src_loc = "96:5"]
    pub const AV_PIX_FMT_NV12: AVPixelFormat = 23;
    #[c2rust::src_loc = "95:5"]
    pub const AV_PIX_FMT_RGB4_BYTE: AVPixelFormat = 22;
    #[c2rust::src_loc = "94:5"]
    pub const AV_PIX_FMT_RGB4: AVPixelFormat = 21;
    #[c2rust::src_loc = "93:5"]
    pub const AV_PIX_FMT_RGB8: AVPixelFormat = 20;
    #[c2rust::src_loc = "92:5"]
    pub const AV_PIX_FMT_BGR4_BYTE: AVPixelFormat = 19;
    #[c2rust::src_loc = "91:5"]
    pub const AV_PIX_FMT_BGR4: AVPixelFormat = 18;
    #[c2rust::src_loc = "90:5"]
    pub const AV_PIX_FMT_BGR8: AVPixelFormat = 17;
    #[c2rust::src_loc = "89:5"]
    pub const AV_PIX_FMT_UYYVYY411: AVPixelFormat = 16;
    #[c2rust::src_loc = "88:5"]
    pub const AV_PIX_FMT_UYVY422: AVPixelFormat = 15;
    #[c2rust::src_loc = "87:5"]
    pub const AV_PIX_FMT_YUVJ444P: AVPixelFormat = 14;
    #[c2rust::src_loc = "86:5"]
    pub const AV_PIX_FMT_YUVJ422P: AVPixelFormat = 13;
    #[c2rust::src_loc = "85:5"]
    pub const AV_PIX_FMT_YUVJ420P: AVPixelFormat = 12;
    #[c2rust::src_loc = "84:5"]
    pub const AV_PIX_FMT_PAL8: AVPixelFormat = 11;
    #[c2rust::src_loc = "83:5"]
    pub const AV_PIX_FMT_MONOBLACK: AVPixelFormat = 10;
    #[c2rust::src_loc = "82:5"]
    pub const AV_PIX_FMT_MONOWHITE: AVPixelFormat = 9;
    #[c2rust::src_loc = "81:5"]
    pub const AV_PIX_FMT_GRAY8: AVPixelFormat = 8;
    #[c2rust::src_loc = "80:5"]
    pub const AV_PIX_FMT_YUV411P: AVPixelFormat = 7;
    #[c2rust::src_loc = "79:5"]
    pub const AV_PIX_FMT_YUV410P: AVPixelFormat = 6;
    #[c2rust::src_loc = "78:5"]
    pub const AV_PIX_FMT_YUV444P: AVPixelFormat = 5;
    #[c2rust::src_loc = "77:5"]
    pub const AV_PIX_FMT_YUV422P: AVPixelFormat = 4;
    #[c2rust::src_loc = "76:5"]
    pub const AV_PIX_FMT_BGR24: AVPixelFormat = 3;
    #[c2rust::src_loc = "75:5"]
    pub const AV_PIX_FMT_RGB24: AVPixelFormat = 2;
    #[c2rust::src_loc = "74:5"]
    pub const AV_PIX_FMT_YUYV422: AVPixelFormat = 1;
    #[c2rust::src_loc = "73:5"]
    pub const AV_PIX_FMT_YUV420P: AVPixelFormat = 0;
    #[c2rust::src_loc = "72:5"]
    pub const AV_PIX_FMT_NONE: AVPixelFormat = -1;
}
#[c2rust::header_src = "/usr/include/sys/stat.h:37"]
pub mod stat_h {
    use super::struct_stat_h::stat;
    extern "C" {
        #[c2rust::src_loc = "227:1"]
        pub fn stat(__file: *const ::core::ffi::c_char, __buf: *mut stat) -> ::core::ffi::c_int;
        #[c2rust::src_loc = "230:1"]
        pub fn fstat(__fd: ::core::ffi::c_int, __buf: *mut stat) -> ::core::ffi::c_int;
    }
}
#[c2rust::header_src = "/usr/include/stdlib.h:37"]
pub mod stdlib_h {
    #[inline]
    #[c2rust::src_loc = "480:1"]
    pub unsafe extern "C" fn atoi(mut __nptr: *const ::core::ffi::c_char) -> ::core::ffi::c_int {
        return strtol(
            __nptr,
            NULL as *mut *mut ::core::ffi::c_char,
            10 as ::core::ffi::c_int,
        ) as ::core::ffi::c_int;
    }
    use super::__stddef_null_h::NULL;
    extern "C" {
        #[c2rust::src_loc = "215:1"]
        pub fn strtol(
            __nptr: *const ::core::ffi::c_char,
            __endptr: *mut *mut ::core::ffi::c_char,
            __base: ::core::ffi::c_int,
        ) -> ::core::ffi::c_long;
        #[c2rust::src_loc = "219:1"]
        pub fn strtoul(
            __nptr: *const ::core::ffi::c_char,
            __endptr: *mut *mut ::core::ffi::c_char,
            __base: ::core::ffi::c_int,
        ) -> ::core::ffi::c_ulong;
        #[c2rust::src_loc = "756:1"]
        pub fn exit(__status: ::core::ffi::c_int) -> !;
    }
    extern "C" {
        #[c2rust::src_loc = "980:1"]
        pub fn abs(__x: ::core::ffi::c_int) -> ::core::ffi::c_int;
    }
}
#[c2rust::header_src = "/home/nwplayer123/Hacks/hex264/x264/common/osdep.h:37"]
pub mod osdep_h {
    #[inline]
    #[c2rust::src_loc = "261:1"]
    pub unsafe extern "C" fn x264_is_regular_file_path(
        mut filename: *const ::core::ffi::c_char,
    ) -> ::core::ffi::c_int {
        let mut file_stat: stat = stat {
            st_dev: 0,
            st_ino: 0,
            st_nlink: 0,
            st_mode: 0,
            st_uid: 0,
            st_gid: 0,
            __pad0: 0,
            st_rdev: 0,
            st_size: 0,
            st_blksize: 0,
            st_blocks: 0,
            st_atim: timespec {
                tv_sec: 0,
                tv_nsec: 0,
            },
            st_mtim: timespec {
                tv_sec: 0,
                tv_nsec: 0,
            },
            st_ctim: timespec {
                tv_sec: 0,
                tv_nsec: 0,
            },
            __glibc_reserved: [0; 3],
        };
        if stat(filename, &mut file_stat) != 0 {
            return 1 as ::core::ffi::c_int;
        }
        return (file_stat.st_mode & __S_IFMT as __mode_t == 0o100000 as __mode_t)
            as ::core::ffi::c_int;
    }
    #[inline]
    #[c2rust::src_loc = "270:1"]
    pub unsafe extern "C" fn x264_is_regular_file(mut filehandle: *mut FILE) -> ::core::ffi::c_int {
        let mut file_stat: stat = stat {
            st_dev: 0,
            st_ino: 0,
            st_nlink: 0,
            st_mode: 0,
            st_uid: 0,
            st_gid: 0,
            __pad0: 0,
            st_rdev: 0,
            st_size: 0,
            st_blksize: 0,
            st_blocks: 0,
            st_atim: timespec {
                tv_sec: 0,
                tv_nsec: 0,
            },
            st_mtim: timespec {
                tv_sec: 0,
                tv_nsec: 0,
            },
            st_ctim: timespec {
                tv_sec: 0,
                tv_nsec: 0,
            },
            __glibc_reserved: [0; 3],
        };
        if fstat(fileno(filehandle), &mut file_stat) != 0 {
            return 1 as ::core::ffi::c_int;
        }
        return (file_stat.st_mode & __S_IFMT as __mode_t == 0o100000 as __mode_t)
            as ::core::ffi::c_int;
    }
    use super::bits_stat_h::__S_IFMT;
    use super::stat_h::{fstat, stat};
    use super::stdint_intn_h::int64_t;
    use super::stdio_h::fileno;
    use super::struct_stat_h::stat;
    use super::struct_timespec_h::timespec;
    use super::types_h::__mode_t;
    use super::FILE_h::FILE;
    extern "C" {
        #[c2rust::src_loc = "206:10"]
        pub fn x264_mdate() -> int64_t;
    }
    #[c2rust::src_loc = "452:9"]
    pub const WORD_SIZE: uint64_t = ::core::mem::size_of::<*mut ::core::ffi::c_void>() as uint64_t;
    #[inline(always)]
    #[c2rust::src_loc = "503:1"]
    pub unsafe extern "C" fn x264_ctz_4bit(mut x: uint32_t) -> ::core::ffi::c_int {
        pub static mut lut: [uint8_t; 16] = [
            4 as ::core::ffi::c_int as uint8_t,
            0 as ::core::ffi::c_int as uint8_t,
            1 as ::core::ffi::c_int as uint8_t,
            0 as ::core::ffi::c_int as uint8_t,
            2 as ::core::ffi::c_int as uint8_t,
            0 as ::core::ffi::c_int as uint8_t,
            1 as ::core::ffi::c_int as uint8_t,
            0 as ::core::ffi::c_int as uint8_t,
            3 as ::core::ffi::c_int as uint8_t,
            0 as ::core::ffi::c_int as uint8_t,
            1 as ::core::ffi::c_int as uint8_t,
            0 as ::core::ffi::c_int as uint8_t,
            2 as ::core::ffi::c_int as uint8_t,
            0 as ::core::ffi::c_int as uint8_t,
            1 as ::core::ffi::c_int as uint8_t,
            0 as ::core::ffi::c_int as uint8_t,
        ];
        return lut[x as usize] as ::core::ffi::c_int;
    }
    use super::stdint_uintn_h::{uint32_t, uint64_t, uint8_t};

    #[inline(always)]
    #[c2rust::src_loc = "475:1"]
    pub unsafe extern "C" fn endian_fix32(mut x: uint32_t) -> uint32_t {
        return (x << 24 as ::core::ffi::c_int)
            .wrapping_add(x << 8 as ::core::ffi::c_int & 0xff0000 as uint32_t)
            .wrapping_add(x >> 8 as ::core::ffi::c_int & 0xff00 as uint32_t)
            .wrapping_add(x >> 24 as ::core::ffi::c_int);
    }
    #[inline(always)]
    #[c2rust::src_loc = "487:1"]
    pub unsafe extern "C" fn endian_fix64(mut x: uint64_t) -> uint64_t {
        return (endian_fix32((x >> 32 as ::core::ffi::c_int) as uint32_t) as uint64_t)
            .wrapping_add((endian_fix32(x as uint32_t) as uint64_t) << 32 as ::core::ffi::c_int);
    }
    #[inline(always)]
    #[c2rust::src_loc = "492:1"]
    pub unsafe extern "C" fn endian_fix(mut x: uintptr_t) -> uintptr_t {
        return if WORD_SIZE == 8 as uint64_t {
            endian_fix64(x as uint64_t) as uintptr_t
        } else {
            endian_fix32(x as uint32_t) as uintptr_t
        };
    }
    use super::stdint_h::uintptr_t;
}
#[c2rust::header_src = "/usr/include/string.h:37"]
pub mod string_h {
    use super::__stddef_size_t_h::size_t;
    extern "C" {
        #[c2rust::src_loc = "43:1"]
        pub fn memcpy(
            __dest: *mut ::core::ffi::c_void,
            __src: *const ::core::ffi::c_void,
            __n: size_t,
        ) -> *mut ::core::ffi::c_void;
        #[c2rust::src_loc = "61:1"]
        pub fn memset(
            __s: *mut ::core::ffi::c_void,
            __c: ::core::ffi::c_int,
            __n: size_t,
        ) -> *mut ::core::ffi::c_void;
        #[c2rust::src_loc = "141:1"]
        pub fn strcpy(
            __dest: *mut ::core::ffi::c_char,
            __src: *const ::core::ffi::c_char,
        ) -> *mut ::core::ffi::c_char;
        #[c2rust::src_loc = "156:1"]
        pub fn strcmp(
            __s1: *const ::core::ffi::c_char,
            __s2: *const ::core::ffi::c_char,
        ) -> ::core::ffi::c_int;
        #[c2rust::src_loc = "293:1"]
        pub fn strcspn(
            __s: *const ::core::ffi::c_char,
            __reject: *const ::core::ffi::c_char,
        ) -> ::core::ffi::c_ulong;
        #[c2rust::src_loc = "407:1"]
        pub fn strlen(__s: *const ::core::ffi::c_char) -> size_t;
    }
    extern "C" {
        #[c2rust::src_loc = "159:1"]
        pub fn strncmp(
            __s1: *const ::core::ffi::c_char,
            __s2: *const ::core::ffi::c_char,
            __n: size_t,
        ) -> ::core::ffi::c_int;
        #[c2rust::src_loc = "246:1"]
        pub fn strchr(
            __s: *const ::core::ffi::c_char,
            __c: ::core::ffi::c_int,
        ) -> *mut ::core::ffi::c_char;
    }
    extern "C" {
        #[c2rust::src_loc = "47:1"]
        pub fn memmove(
            __dest: *mut ::core::ffi::c_void,
            __src: *const ::core::ffi::c_void,
            __n: size_t,
        ) -> *mut ::core::ffi::c_void;
    }
    extern "C" {
        #[c2rust::src_loc = "64:1"]
        pub fn memcmp(
            __s1: *const ::core::ffi::c_void,
            __s2: *const ::core::ffi::c_void,
            __n: size_t,
        ) -> ::core::ffi::c_int;
        #[c2rust::src_loc = "323:1"]
        pub fn strpbrk(
            __s: *const ::core::ffi::c_char,
            __accept: *const ::core::ffi::c_char,
        ) -> *mut ::core::ffi::c_char;
        #[c2rust::src_loc = "350:1"]
        pub fn strstr(
            __haystack: *const ::core::ffi::c_char,
            __needle: *const ::core::ffi::c_char,
        ) -> *mut ::core::ffi::c_char;
    }
}
#[c2rust::header_src = "/home/nwplayer123/Hacks/hex264/x264/common/base.h:37"]
pub mod base_h {
    use super::stdint_uintn_h::uint32_t;
    extern "C" {
        #[c2rust::src_loc = "271:10"]
        pub fn x264_reduce_fraction(n: *mut uint32_t, d: *mut uint32_t);
    }
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "64:9"]
    pub union x264_union16_t {
        pub i: uint16_t,
        pub b: [uint8_t; 2],
    }
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "65:9"]
    pub union x264_union32_t {
        pub i: uint32_t,
        pub w: [uint16_t; 2],
        pub b: [uint8_t; 4],
    }
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "66:9"]
    pub union x264_union64_t {
        pub i: uint64_t,
        pub d: [uint32_t; 2],
        pub w: [uint16_t; 4],
        pub b: [uint8_t; 8],
    }
    #[c2rust::src_loc = "111:1"]
    pub type slice_type_e = ::core::ffi::c_uint;
    #[c2rust::src_loc = "115:5"]
    pub const SLICE_TYPE_I: slice_type_e = 2;
    #[c2rust::src_loc = "114:5"]
    pub const SLICE_TYPE_B: slice_type_e = 1;
    #[c2rust::src_loc = "113:5"]
    pub const SLICE_TYPE_P: slice_type_e = 0;
    #[c2rust::src_loc = "155:9"]
    pub const X264_SCAN8_0: ::core::ffi::c_int =
        4 as ::core::ffi::c_int + 1 as ::core::ffi::c_int * 8 as ::core::ffi::c_int;
    #[c2rust::src_loc = "180:22"]
    pub static mut x264_scan8: [uint8_t; 51] = [
        (4 as ::core::ffi::c_int + 1 as ::core::ffi::c_int * 8 as ::core::ffi::c_int) as uint8_t,
        (5 as ::core::ffi::c_int + 1 as ::core::ffi::c_int * 8 as ::core::ffi::c_int) as uint8_t,
        (4 as ::core::ffi::c_int + 2 as ::core::ffi::c_int * 8 as ::core::ffi::c_int) as uint8_t,
        (5 as ::core::ffi::c_int + 2 as ::core::ffi::c_int * 8 as ::core::ffi::c_int) as uint8_t,
        (6 as ::core::ffi::c_int + 1 as ::core::ffi::c_int * 8 as ::core::ffi::c_int) as uint8_t,
        (7 as ::core::ffi::c_int + 1 as ::core::ffi::c_int * 8 as ::core::ffi::c_int) as uint8_t,
        (6 as ::core::ffi::c_int + 2 as ::core::ffi::c_int * 8 as ::core::ffi::c_int) as uint8_t,
        (7 as ::core::ffi::c_int + 2 as ::core::ffi::c_int * 8 as ::core::ffi::c_int) as uint8_t,
        (4 as ::core::ffi::c_int + 3 as ::core::ffi::c_int * 8 as ::core::ffi::c_int) as uint8_t,
        (5 as ::core::ffi::c_int + 3 as ::core::ffi::c_int * 8 as ::core::ffi::c_int) as uint8_t,
        (4 as ::core::ffi::c_int + 4 as ::core::ffi::c_int * 8 as ::core::ffi::c_int) as uint8_t,
        (5 as ::core::ffi::c_int + 4 as ::core::ffi::c_int * 8 as ::core::ffi::c_int) as uint8_t,
        (6 as ::core::ffi::c_int + 3 as ::core::ffi::c_int * 8 as ::core::ffi::c_int) as uint8_t,
        (7 as ::core::ffi::c_int + 3 as ::core::ffi::c_int * 8 as ::core::ffi::c_int) as uint8_t,
        (6 as ::core::ffi::c_int + 4 as ::core::ffi::c_int * 8 as ::core::ffi::c_int) as uint8_t,
        (7 as ::core::ffi::c_int + 4 as ::core::ffi::c_int * 8 as ::core::ffi::c_int) as uint8_t,
        (4 as ::core::ffi::c_int + 6 as ::core::ffi::c_int * 8 as ::core::ffi::c_int) as uint8_t,
        (5 as ::core::ffi::c_int + 6 as ::core::ffi::c_int * 8 as ::core::ffi::c_int) as uint8_t,
        (4 as ::core::ffi::c_int + 7 as ::core::ffi::c_int * 8 as ::core::ffi::c_int) as uint8_t,
        (5 as ::core::ffi::c_int + 7 as ::core::ffi::c_int * 8 as ::core::ffi::c_int) as uint8_t,
        (6 as ::core::ffi::c_int + 6 as ::core::ffi::c_int * 8 as ::core::ffi::c_int) as uint8_t,
        (7 as ::core::ffi::c_int + 6 as ::core::ffi::c_int * 8 as ::core::ffi::c_int) as uint8_t,
        (6 as ::core::ffi::c_int + 7 as ::core::ffi::c_int * 8 as ::core::ffi::c_int) as uint8_t,
        (7 as ::core::ffi::c_int + 7 as ::core::ffi::c_int * 8 as ::core::ffi::c_int) as uint8_t,
        (4 as ::core::ffi::c_int + 8 as ::core::ffi::c_int * 8 as ::core::ffi::c_int) as uint8_t,
        (5 as ::core::ffi::c_int + 8 as ::core::ffi::c_int * 8 as ::core::ffi::c_int) as uint8_t,
        (4 as ::core::ffi::c_int + 9 as ::core::ffi::c_int * 8 as ::core::ffi::c_int) as uint8_t,
        (5 as ::core::ffi::c_int + 9 as ::core::ffi::c_int * 8 as ::core::ffi::c_int) as uint8_t,
        (6 as ::core::ffi::c_int + 8 as ::core::ffi::c_int * 8 as ::core::ffi::c_int) as uint8_t,
        (7 as ::core::ffi::c_int + 8 as ::core::ffi::c_int * 8 as ::core::ffi::c_int) as uint8_t,
        (6 as ::core::ffi::c_int + 9 as ::core::ffi::c_int * 8 as ::core::ffi::c_int) as uint8_t,
        (7 as ::core::ffi::c_int + 9 as ::core::ffi::c_int * 8 as ::core::ffi::c_int) as uint8_t,
        (4 as ::core::ffi::c_int + 11 as ::core::ffi::c_int * 8 as ::core::ffi::c_int) as uint8_t,
        (5 as ::core::ffi::c_int + 11 as ::core::ffi::c_int * 8 as ::core::ffi::c_int) as uint8_t,
        (4 as ::core::ffi::c_int + 12 as ::core::ffi::c_int * 8 as ::core::ffi::c_int) as uint8_t,
        (5 as ::core::ffi::c_int + 12 as ::core::ffi::c_int * 8 as ::core::ffi::c_int) as uint8_t,
        (6 as ::core::ffi::c_int + 11 as ::core::ffi::c_int * 8 as ::core::ffi::c_int) as uint8_t,
        (7 as ::core::ffi::c_int + 11 as ::core::ffi::c_int * 8 as ::core::ffi::c_int) as uint8_t,
        (6 as ::core::ffi::c_int + 12 as ::core::ffi::c_int * 8 as ::core::ffi::c_int) as uint8_t,
        (7 as ::core::ffi::c_int + 12 as ::core::ffi::c_int * 8 as ::core::ffi::c_int) as uint8_t,
        (4 as ::core::ffi::c_int + 13 as ::core::ffi::c_int * 8 as ::core::ffi::c_int) as uint8_t,
        (5 as ::core::ffi::c_int + 13 as ::core::ffi::c_int * 8 as ::core::ffi::c_int) as uint8_t,
        (4 as ::core::ffi::c_int + 14 as ::core::ffi::c_int * 8 as ::core::ffi::c_int) as uint8_t,
        (5 as ::core::ffi::c_int + 14 as ::core::ffi::c_int * 8 as ::core::ffi::c_int) as uint8_t,
        (6 as ::core::ffi::c_int + 13 as ::core::ffi::c_int * 8 as ::core::ffi::c_int) as uint8_t,
        (7 as ::core::ffi::c_int + 13 as ::core::ffi::c_int * 8 as ::core::ffi::c_int) as uint8_t,
        (6 as ::core::ffi::c_int + 14 as ::core::ffi::c_int * 8 as ::core::ffi::c_int) as uint8_t,
        (7 as ::core::ffi::c_int + 14 as ::core::ffi::c_int * 8 as ::core::ffi::c_int) as uint8_t,
        (0 as ::core::ffi::c_int + 0 as ::core::ffi::c_int * 8 as ::core::ffi::c_int) as uint8_t,
        (0 as ::core::ffi::c_int + 5 as ::core::ffi::c_int * 8 as ::core::ffi::c_int) as uint8_t,
        (0 as ::core::ffi::c_int + 10 as ::core::ffi::c_int * 8 as ::core::ffi::c_int) as uint8_t,
    ];
    #[inline(always)]
    #[c2rust::src_loc = "206:1"]
    pub unsafe extern "C" fn x264_clip3(
        mut v: ::core::ffi::c_int,
        mut i_min: ::core::ffi::c_int,
        mut i_max: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int {
        return if v < i_min {
            i_min
        } else if v > i_max {
            i_max
        } else {
            v
        };
    }
    #[inline(always)]
    #[c2rust::src_loc = "232:1"]
    pub unsafe extern "C" fn x264_median(
        mut a: ::core::ffi::c_int,
        mut b: ::core::ffi::c_int,
        mut c: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int {
        let mut t: ::core::ffi::c_int = a - b & a - b >> 31 as ::core::ffi::c_int;
        a -= t;
        b += t;
        b -= b - c & b - c >> 31 as ::core::ffi::c_int;
        b += a - b & a - b >> 31 as ::core::ffi::c_int;
        return b;
    }
    #[inline(always)]
    #[c2rust::src_loc = "242:1"]
    pub unsafe extern "C" fn x264_median_mv(
        mut dst: *mut int16_t,
        mut a: *mut int16_t,
        mut b: *mut int16_t,
        mut c: *mut int16_t,
    ) {
        *dst.offset(0 as ::core::ffi::c_int as isize) = x264_median(
            *a.offset(0 as ::core::ffi::c_int as isize) as ::core::ffi::c_int,
            *b.offset(0 as ::core::ffi::c_int as isize) as ::core::ffi::c_int,
            *c.offset(0 as ::core::ffi::c_int as isize) as ::core::ffi::c_int,
        ) as int16_t;
        *dst.offset(1 as ::core::ffi::c_int as isize) = x264_median(
            *a.offset(1 as ::core::ffi::c_int as isize) as ::core::ffi::c_int,
            *b.offset(1 as ::core::ffi::c_int as isize) as ::core::ffi::c_int,
            *c.offset(1 as ::core::ffi::c_int as isize) as ::core::ffi::c_int,
        ) as int16_t;
    }
    use super::stdint_intn_h::int16_t;
    use super::stdint_uintn_h::{uint16_t, uint64_t, uint8_t};

    #[c2rust::src_loc = "93:1"]
    pub type profile_e = ::core::ffi::c_uint;
    #[c2rust::src_loc = "100:5"]
    pub const PROFILE_HIGH444_PREDICTIVE: profile_e = 244;
    #[c2rust::src_loc = "99:5"]
    pub const PROFILE_HIGH422: profile_e = 122;
    #[c2rust::src_loc = "98:5"]
    pub const PROFILE_HIGH10: profile_e = 110;
    #[c2rust::src_loc = "97:5"]
    pub const PROFILE_HIGH: profile_e = 100;
    #[c2rust::src_loc = "96:5"]
    pub const PROFILE_MAIN: profile_e = 77;
    #[c2rust::src_loc = "95:5"]
    pub const PROFILE_BASELINE: profile_e = 66;
    #[c2rust::src_loc = "103:1"]
    pub type chroma_format_e = ::core::ffi::c_uint;
    #[c2rust::src_loc = "108:5"]
    pub const CHROMA_444: chroma_format_e = 3;
    #[c2rust::src_loc = "107:5"]
    pub const CHROMA_422: chroma_format_e = 2;
    #[c2rust::src_loc = "106:5"]
    pub const CHROMA_420: chroma_format_e = 1;
    #[c2rust::src_loc = "105:5"]
    pub const CHROMA_400: chroma_format_e = 0;
    #[c2rust::src_loc = "136:9"]
    pub const X264_BFRAME_MAX: ::core::ffi::c_int = 16 as ::core::ffi::c_int;
    #[c2rust::src_loc = "151:9"]
    pub const X264_WEIGHTP_FAKE: ::core::ffi::c_int = -(1 as ::core::ffi::c_int);
    #[c2rust::src_loc = "177:9"]
    pub const LUMA_DC: ::core::ffi::c_int = 48 as ::core::ffi::c_int;
    #[c2rust::src_loc = "178:9"]
    pub const CHROMA_DC: ::core::ffi::c_int = 49 as ::core::ffi::c_int;
    #[inline(always)]
    #[c2rust::src_loc = "211:1"]
    pub unsafe extern "C" fn x264_clip3f(
        mut v: ::core::ffi::c_double,
        mut f_min: ::core::ffi::c_double,
        mut f_max: ::core::ffi::c_double,
    ) -> ::core::ffi::c_double {
        return if v < f_min {
            f_min
        } else if v > f_max {
            f_max
        } else {
            v
        };
    }
    #[inline(always)]
    #[c2rust::src_loc = "218:1"]
    pub unsafe extern "C" fn x264_exp2fix8(mut x: ::core::ffi::c_float) -> ::core::ffi::c_int {
        let mut i: ::core::ffi::c_int = (x * (-64.0f32 / 6.0f32) + 512.5f32) as ::core::ffi::c_int;
        if i < 0 as ::core::ffi::c_int {
            return 0 as ::core::ffi::c_int;
        }
        if i > 1023 as ::core::ffi::c_int {
            return 0xffff as ::core::ffi::c_int;
        }
        return (x264_exp2_lut[(i & 63 as ::core::ffi::c_int) as usize] as ::core::ffi::c_int
            + 256 as ::core::ffi::c_int)
            << (i >> 6 as ::core::ffi::c_int)
            >> 8 as ::core::ffi::c_int;
    }
    #[inline(always)]
    #[c2rust::src_loc = "226:1"]
    pub unsafe extern "C" fn x264_log2(mut x: uint32_t) -> ::core::ffi::c_float {
        let mut lz: ::core::ffi::c_int = x.leading_zeros() as i32;
        return x264_log2_lut[(x << lz >> 24 as ::core::ffi::c_int & 0x7f as uint32_t) as usize]
            + x264_log2_lz_lut[lz as usize];
    }
    #[inline(always)]
    #[c2rust::src_loc = "259:1"]
    pub unsafe extern "C" fn x264_cabac_mvd_sum(
        mut mvdleft: *mut uint8_t,
        mut mvdtop: *mut uint8_t,
    ) -> uint16_t {
        let mut amvd0: ::core::ffi::c_int = *mvdleft.offset(0 as ::core::ffi::c_int as isize)
            as ::core::ffi::c_int
            + *mvdtop.offset(0 as ::core::ffi::c_int as isize) as ::core::ffi::c_int;
        let mut amvd1: ::core::ffi::c_int = *mvdleft.offset(1 as ::core::ffi::c_int as isize)
            as ::core::ffi::c_int
            + *mvdtop.offset(1 as ::core::ffi::c_int as isize) as ::core::ffi::c_int;
        amvd0 = (amvd0 > 2 as ::core::ffi::c_int) as ::core::ffi::c_int
            + (amvd0 > 32 as ::core::ffi::c_int) as ::core::ffi::c_int;
        amvd1 = (amvd1 > 2 as ::core::ffi::c_int) as ::core::ffi::c_int
            + (amvd1 > 32 as ::core::ffi::c_int) as ::core::ffi::c_int;
        return (amvd0 + (amvd1 << 8 as ::core::ffi::c_int)) as uint16_t;
    }
    use super::stdint_intn_h::int64_t;
    use super::tables_h::{x264_exp2_lut, x264_log2_lut, x264_log2_lz_lut};
    extern "C" {
        #[c2rust::src_loc = "279:10"]
        pub fn x264_malloc(_: int64_t) -> *mut ::core::ffi::c_void;
        #[c2rust::src_loc = "280:10"]
        pub fn x264_free(_: *mut ::core::ffi::c_void);
    }

    #[c2rust::src_loc = "118:19"]
    pub static mut slice_type_to_char: [::core::ffi::c_char; 3] = [
        'P' as i32 as ::core::ffi::c_char,
        'B' as i32 as ::core::ffi::c_char,
        'I' as i32 as ::core::ffi::c_char,
    ];
    #[c2rust::src_loc = "137:9"]
    pub const X264_REF_MAX: ::core::ffi::c_int = 16 as ::core::ffi::c_int;
    #[c2rust::src_loc = "138:9"]
    pub const X264_THREAD_MAX: ::core::ffi::c_int = 128 as ::core::ffi::c_int;
    #[c2rust::src_loc = "140:9"]
    pub const X264_LOOKAHEAD_MAX: ::core::ffi::c_int = 250 as ::core::ffi::c_int;
    #[c2rust::src_loc = "144:9"]
    pub const X264_THREAD_HEIGHT: ::core::ffi::c_int = 24 as ::core::ffi::c_int;
    use super::x264_h::x264_param_t;
    extern "C" {
        #[c2rust::src_loc = "275:10"]
        pub fn x264_log_internal(
            i_level: ::core::ffi::c_int,
            psz_fmt: *const ::core::ffi::c_char,
            ...
        );
        #[c2rust::src_loc = "287:1"]
        pub fn x264_param_strdup(
            param: *mut x264_param_t,
            src: *const ::core::ffi::c_char,
        ) -> *mut ::core::ffi::c_char;
    }
    extern "C" {
        #[c2rust::src_loc = "283:10"]
        pub fn x264_slurp_file(filename: *const ::core::ffi::c_char) -> *mut ::core::ffi::c_char;
    }
}
#[c2rust::header_src = "/usr/include/libavutil/pixdesc.h:58"]
pub mod pixdesc_h {
    use super::pixfmt_h::AVPixelFormat;
    extern "C" {
        #[c2rust::src_loc = "313:1"]
        pub fn av_get_pix_fmt_name(pix_fmt: AVPixelFormat) -> *const ::core::ffi::c_char;
    }
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "69:16"]
    pub struct AVPixFmtDescriptor {
        pub name: *const ::core::ffi::c_char,
        pub nb_components: uint8_t,
        pub log2_chroma_w: uint8_t,
        pub log2_chroma_h: uint8_t,
        pub flags: uint64_t,
        pub comp: [AVComponentDescriptor; 4],
        pub alias: *const ::core::ffi::c_char,
    }
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "30:16"]
    pub struct AVComponentDescriptor {
        pub plane: ::core::ffi::c_int,
        pub step: ::core::ffi::c_int,
        pub offset: ::core::ffi::c_int,
        pub shift: ::core::ffi::c_int,
        pub depth: ::core::ffi::c_int,
    }
    use super::stdint_uintn_h::{uint64_t, uint8_t};
    extern "C" {
        #[c2rust::src_loc = "195:1"]
        pub fn av_pix_fmt_desc_next(prev: *const AVPixFmtDescriptor) -> *const AVPixFmtDescriptor;
    }
}
#[c2rust::header_src = "/usr/include/bits/mathcalls.h:37"]
pub mod mathcalls_h {
    extern "C" {
        #[c2rust::src_loc = "222:1"]
        pub fn fmod(
            __x: ::core::ffi::c_double,
            __y: ::core::ffi::c_double,
        ) -> ::core::ffi::c_double;
    }
    extern "C" {
        #[c2rust::src_loc = "355:1"]
        pub fn round(__x: ::core::ffi::c_double) -> ::core::ffi::c_double;
        #[c2rust::src_loc = "170:1"]
        pub fn log2f(__x: ::core::ffi::c_float) -> ::core::ffi::c_float;
        #[c2rust::src_loc = "180:1"]
        pub fn sqrtf(__x: ::core::ffi::c_float) -> ::core::ffi::c_float;
        #[c2rust::src_loc = "216:1"]
        pub fn fabsf(__x: ::core::ffi::c_float) -> ::core::ffi::c_float;
    }
    extern "C" {
        #[c2rust::src_loc = "129:1"]
        pub fn log10(__x: ::core::ffi::c_double) -> ::core::ffi::c_double;
        #[c2rust::src_loc = "177:1"]
        pub fn pow(__x: ::core::ffi::c_double, __y: ::core::ffi::c_double)
            -> ::core::ffi::c_double;
        #[c2rust::src_loc = "216:1"]
        pub fn fabs(__x: ::core::ffi::c_double) -> ::core::ffi::c_double;
    }
}
#[c2rust::header_src = "/usr/include/strings.h:37"]
pub mod strings_h {
    extern "C" {
        #[c2rust::src_loc = "116:1"]
        pub fn strcasecmp(
            __s1: *const ::core::ffi::c_char,
            __s2: *const ::core::ffi::c_char,
        ) -> ::core::ffi::c_int;
    }
    use super::__stddef_size_t_h::size_t;
    extern "C" {
        #[c2rust::src_loc = "120:1"]
        pub fn strncasecmp(
            __s1: *const ::core::ffi::c_char,
            __s2: *const ::core::ffi::c_char,
            __n: size_t,
        ) -> ::core::ffi::c_int;
    }
}
#[c2rust::header_src = "/home/nwplayer123/Hacks/hex264/x264/common/cpu.h:37"]
pub mod cpu_h {
    extern "C" {
        #[c2rust::src_loc = "30:10"]
        pub fn x264_cpu_num_processors() -> ::core::ffi::c_int;
    }
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "49:9"]
    pub struct x264_cpu_name_t {
        pub name: *const ::core::ffi::c_char,
        pub flags: uint32_t,
    }
    use super::stdint_uintn_h::uint32_t;
    extern "C" {
        #[c2rust::src_loc = "54:39"]
        pub static x264_cpu_names: [x264_cpu_name_t; 0];
    }
}
#[c2rust::header_src = "/usr/include/bits/getopt_core.h:37"]
pub mod getopt_core_h {
    extern "C" {
        #[c2rust::src_loc = "36:14"]
        pub static mut optarg: *mut ::core::ffi::c_char;
        #[c2rust::src_loc = "50:12"]
        pub static mut optind: ::core::ffi::c_int;
    }
}
#[c2rust::header_src = "/usr/include/libswscale/swscale.h:58"]
pub mod swscale_h {
    extern "C" {
        #[c2rust::src_loc = "63:1"]
        pub fn swscale_license() -> *const ::core::ffi::c_char;
    }
}
#[c2rust::header_src = "/usr/include/lsmash.h:58"]
pub mod lsmash_h {
    #[c2rust::src_loc = "49:9"]
    pub const LSMASH_VERSION_MAJOR: ::core::ffi::c_int = 2 as ::core::ffi::c_int;
    #[c2rust::src_loc = "50:9"]
    pub const LSMASH_VERSION_MINOR: ::core::ffi::c_int = 14 as ::core::ffi::c_int;
    #[c2rust::src_loc = "51:9"]
    pub const LSMASH_VERSION_MICRO: ::core::ffi::c_int = 5 as ::core::ffi::c_int;
}
#[c2rust::header_src = "/usr/include/bits/stat.h:58"]
pub mod bits_stat_h {
    #[c2rust::src_loc = "29:9"]
    pub const __S_IFMT: ::core::ffi::c_int = 0o170000 as ::core::ffi::c_int;
}
#[c2rust::header_src = "/usr/lib/clang/21/include/__stddef_null.h:58"]
pub mod __stddef_null_h {
    #[c2rust::src_loc = "26:9"]
    pub const NULL: *mut ::core::ffi::c_void = 0 as *mut ::core::ffi::c_void;
    #[c2rust::src_loc = "26:9"]
    pub const NULL_0: *mut ::core::ffi::c_void = 0 as *mut ::core::ffi::c_void;
}
#[c2rust::header_src = "/home/nwplayer123/Hacks/hex264/x264/config.h:58"]
pub mod config_h {
    #[c2rust::src_loc = "17:9"]
    pub const HAVE_LAVF: ::core::ffi::c_int = 1 as ::core::ffi::c_int;
    #[c2rust::src_loc = "25:9"]
    pub const HAVE_GPL: ::core::ffi::c_int = 1 as ::core::ffi::c_int;
    #[c2rust::src_loc = "26:9"]
    pub const HAVE_INTERLACED: ::core::ffi::c_int = 1 as ::core::ffi::c_int;
    #[c2rust::src_loc = "36:9"]
    pub const HAVE_FFMS: ::core::ffi::c_int = 0 as ::core::ffi::c_int;
}
#[c2rust::header_src = "/home/nwplayer123/Hacks/hex264/x264/x264_config.h:58"]
pub mod x264_config_h {
    #[c2rust::src_loc = "4:9"]
    pub const X264_CHROMA_FORMAT: ::core::ffi::c_int = 0 as ::core::ffi::c_int;
    #[c2rust::src_loc = "7:9"]
    pub const X264_VERSION: [::core::ffi::c_char; 16] = unsafe {
        ::core::mem::transmute::<[u8; 16], [::core::ffi::c_char; 16]>(*b" r3223M 0480cb0\0")
    };
}
#[c2rust::header_src = "/usr/include/libswscale/version.h:58"]
pub mod version_h {
    #[c2rust::src_loc = "31:9"]
    pub const LIBSWSCALE_VERSION_MINOR: ::core::ffi::c_int = 1 as ::core::ffi::c_int;
    #[c2rust::src_loc = "32:9"]
    pub const LIBSWSCALE_VERSION_MICRO: ::core::ffi::c_int = 100 as ::core::ffi::c_int;
}
#[c2rust::header_src = "/usr/include/bits/signum-generic.h:58"]
pub mod signum_generic_h {
    #[c2rust::src_loc = "48:9"]
    pub const SIGINT: ::core::ffi::c_int = 2 as ::core::ffi::c_int;
}
#[c2rust::header_src = "/usr/include/libswscale/version_major.h:58"]
pub mod version_major_h {
    #[c2rust::src_loc = "27:9"]
    pub const LIBSWSCALE_VERSION_MAJOR: ::core::ffi::c_int = 9 as ::core::ffi::c_int;
}
#[c2rust::header_src = "/usr/include/libavformat/version_major.h:58"]
pub mod libavformat_version_major_h {
    #[c2rust::src_loc = "32:9"]
    pub const LIBAVFORMAT_VERSION_MAJOR: ::core::ffi::c_int = 62 as ::core::ffi::c_int;
}
#[c2rust::header_src = "/usr/include/libavformat/version.h:58"]
pub mod libavformat_version_h {
    #[c2rust::src_loc = "34:9"]
    pub const LIBAVFORMAT_VERSION_MINOR: ::core::ffi::c_int = 3 as ::core::ffi::c_int;
    #[c2rust::src_loc = "35:9"]
    pub const LIBAVFORMAT_VERSION_MICRO: ::core::ffi::c_int = 100 as ::core::ffi::c_int;
}
#[c2rust::header_src = "/usr/include/libavformat/avformat.h:31"]
pub mod avformat_h {
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "544:16"]
    pub struct AVInputFormat {
        pub name: *const ::core::ffi::c_char,
        pub long_name: *const ::core::ffi::c_char,
        pub flags: ::core::ffi::c_int,
        pub extensions: *const ::core::ffi::c_char,
        pub codec_tag: *const *const AVCodecTag,
        pub priv_class: *const AVClass,
        pub mime_type: *const ::core::ffi::c_char,
    }
    use super::log_h::AVClass;
    extern "C" {
        #[c2rust::src_loc = "446:8"]
        pub type AVCodecTag;
        #[c2rust::src_loc = "1959:1"]
        pub fn av_demuxer_iterate(opaque: *mut *mut ::core::ffi::c_void) -> *const AVInputFormat;
    }
}
#[c2rust::header_src = "/usr/include/libavutil/log.h:26"]
pub mod log_h {
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "76:16"]
    pub struct AVClass {
        pub class_name: *const ::core::ffi::c_char,
        pub item_name:
            Option<unsafe extern "C" fn(*mut ::core::ffi::c_void) -> *const ::core::ffi::c_char>,
        pub option: *const AVOption,
        pub version: ::core::ffi::c_int,
        pub log_level_offset_offset: ::core::ffi::c_int,
        pub parent_log_context_offset: ::core::ffi::c_int,
        pub category: AVClassCategory,
        pub get_category: Option<unsafe extern "C" fn(*mut ::core::ffi::c_void) -> AVClassCategory>,
        pub query_ranges: Option<
            unsafe extern "C" fn(
                *mut *mut AVOptionRanges,
                *mut ::core::ffi::c_void,
                *const ::core::ffi::c_char,
                ::core::ffi::c_int,
            ) -> ::core::ffi::c_int,
        >,
        pub child_next: Option<
            unsafe extern "C" fn(
                *mut ::core::ffi::c_void,
                *mut ::core::ffi::c_void,
            ) -> *mut ::core::ffi::c_void,
        >,
        pub child_class_iterate:
            Option<unsafe extern "C" fn(*mut *mut ::core::ffi::c_void) -> *const AVClass>,
        pub state_flags_offset: ::core::ffi::c_int,
    }
    #[c2rust::src_loc = "28:9"]
    pub type AVClassCategory = ::core::ffi::c_uint;
    #[c2rust::src_loc = "47:5"]
    pub const AV_CLASS_CATEGORY_NB: AVClassCategory = 46;
    #[c2rust::src_loc = "46:5"]
    pub const AV_CLASS_CATEGORY_DEVICE_INPUT: AVClassCategory = 45;
    #[c2rust::src_loc = "45:5"]
    pub const AV_CLASS_CATEGORY_DEVICE_OUTPUT: AVClassCategory = 44;
    #[c2rust::src_loc = "44:5"]
    pub const AV_CLASS_CATEGORY_DEVICE_AUDIO_INPUT: AVClassCategory = 43;
    #[c2rust::src_loc = "43:5"]
    pub const AV_CLASS_CATEGORY_DEVICE_AUDIO_OUTPUT: AVClassCategory = 42;
    #[c2rust::src_loc = "42:5"]
    pub const AV_CLASS_CATEGORY_DEVICE_VIDEO_INPUT: AVClassCategory = 41;
    #[c2rust::src_loc = "41:5"]
    pub const AV_CLASS_CATEGORY_DEVICE_VIDEO_OUTPUT: AVClassCategory = 40;
    #[c2rust::src_loc = "40:5"]
    pub const AV_CLASS_CATEGORY_HWDEVICE: AVClassCategory = 11;
    #[c2rust::src_loc = "39:5"]
    pub const AV_CLASS_CATEGORY_SWRESAMPLER: AVClassCategory = 10;
    #[c2rust::src_loc = "38:5"]
    pub const AV_CLASS_CATEGORY_SWSCALER: AVClassCategory = 9;
    #[c2rust::src_loc = "37:5"]
    pub const AV_CLASS_CATEGORY_BITSTREAM_FILTER: AVClassCategory = 8;
    #[c2rust::src_loc = "36:5"]
    pub const AV_CLASS_CATEGORY_FILTER: AVClassCategory = 7;
    #[c2rust::src_loc = "35:5"]
    pub const AV_CLASS_CATEGORY_DECODER: AVClassCategory = 6;
    #[c2rust::src_loc = "34:5"]
    pub const AV_CLASS_CATEGORY_ENCODER: AVClassCategory = 5;
    #[c2rust::src_loc = "33:5"]
    pub const AV_CLASS_CATEGORY_DEMUXER: AVClassCategory = 4;
    #[c2rust::src_loc = "32:5"]
    pub const AV_CLASS_CATEGORY_MUXER: AVClassCategory = 3;
    #[c2rust::src_loc = "31:5"]
    pub const AV_CLASS_CATEGORY_OUTPUT: AVClassCategory = 2;
    #[c2rust::src_loc = "30:5"]
    pub const AV_CLASS_CATEGORY_INPUT: AVClassCategory = 1;
    #[c2rust::src_loc = "29:5"]
    pub const AV_CLASS_CATEGORY_NA: AVClassCategory = 0;
    extern "C" {
        #[c2rust::src_loc = "69:8"]
        pub type AVOptionRanges;
        #[c2rust::src_loc = "96:18"]
        pub type AVOption;
    }
}
#[c2rust::header_src = "/usr/include/bits/stdio.h:26"]
pub mod bits_stdio_h {
    #[inline]
    #[c2rust::src_loc = "81:1"]
    pub unsafe extern "C" fn putchar(mut __c: ::core::ffi::c_int) -> ::core::ffi::c_int {
        return putc(__c, stdout);
    }
    use super::stdio_h::{putc, stdout};
}

#[c2rust::header_src = "/usr/include/assert.h:28"]
pub mod assert_h {
    #[c2rust::src_loc = "137:12"]
    pub const __ASSERT_FUNCTION: [::core::ffi::c_char; 65] = unsafe {
        ::core::mem::transmute::<[u8; 65], [::core::ffi::c_char; 65]>(
            *b"void x264_macroblock_cache_rect(void *, int, int, int, uint32_t)\0",
        )
    };
    extern "C" {
        #[c2rust::src_loc = "67:1"]
        pub fn __assert_fail(
            __assertion: *const ::core::ffi::c_char,
            __file: *const ::core::ffi::c_char,
            __line: ::core::ffi::c_uint,
            __function: *const ::core::ffi::c_char,
        ) -> !;
    }
}
#[c2rust::header_src = "/usr/include/bits/atomic_wide_counter.h:28"]
pub mod atomic_wide_counter_h {
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "25:9"]
    pub union __atomic_wide_counter {
        pub __value64: ::core::ffi::c_ulonglong,
        pub __value32: C2RustUnnamed,
    }
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "28:3"]
    pub struct C2RustUnnamed {
        pub __low: ::core::ffi::c_uint,
        pub __high: ::core::ffi::c_uint,
    }
}

#[c2rust::header_src = "/usr/include/stdint.h:28"]
pub mod stdint_h {
    #[c2rust::src_loc = "76:1"]
    pub type intptr_t = isize;
    #[c2rust::src_loc = "79:1"]
    pub type uintptr_t = usize;
    #[c2rust::src_loc = "117:10"]
    pub const UINT16_MAX: ::core::ffi::c_int = 65535 as ::core::ffi::c_int;
    #[c2rust::src_loc = "118:10"]
    pub const UINT32_MAX: ::core::ffi::c_uint = 4294967295 as ::core::ffi::c_uint;
}
#[c2rust::header_src = "/usr/include/bits/thread-shared-types.h:28"]
pub mod thread_shared_types_h {
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "51:16"]
    pub struct __pthread_internal_list {
        pub __prev: *mut __pthread_internal_list,
        pub __next: *mut __pthread_internal_list,
    }
    #[c2rust::src_loc = "51:1"]
    pub type __pthread_list_t = __pthread_internal_list;
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "94:8"]
    pub struct __pthread_cond_s {
        pub __wseq: __atomic_wide_counter,
        pub __g1_start: __atomic_wide_counter,
        pub __g_size: [::core::ffi::c_uint; 2],
        pub __g1_orig_size: ::core::ffi::c_uint,
        pub __wrefs: ::core::ffi::c_uint,
        pub __g_signals: [::core::ffi::c_uint; 2],
        pub __unused_initialized_1: ::core::ffi::c_uint,
        pub __unused_initialized_2: ::core::ffi::c_uint,
    }
    use super::atomic_wide_counter_h::__atomic_wide_counter;
}
#[c2rust::header_src = "/usr/include/bits/struct_mutex.h:28"]
pub mod struct_mutex_h {
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "22:8"]
    pub struct __pthread_mutex_s {
        pub __lock: ::core::ffi::c_int,
        pub __count: ::core::ffi::c_uint,
        pub __owner: ::core::ffi::c_int,
        pub __nusers: ::core::ffi::c_uint,
        pub __kind: ::core::ffi::c_int,
        pub __spins: ::core::ffi::c_short,
        pub __elision: ::core::ffi::c_short,
        pub __list: __pthread_list_t,
    }
    use super::thread_shared_types_h::__pthread_list_t;
}
#[c2rust::header_src = "/usr/include/bits/pthreadtypes.h:28"]
pub mod pthreadtypes_h {
    #[c2rust::src_loc = "27:1"]
    pub type pthread_t = ::core::ffi::c_ulong;
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "67:9"]
    pub union pthread_mutex_t {
        pub __data: __pthread_mutex_s,
        pub __size: [::core::ffi::c_char; 40],
        pub __align: ::core::ffi::c_long,
    }
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "75:9"]
    pub union pthread_cond_t {
        pub __data: __pthread_cond_s,
        pub __size: [::core::ffi::c_char; 48],
        pub __align: ::core::ffi::c_longlong,
    }
    use super::struct_mutex_h::__pthread_mutex_s;
    use super::thread_shared_types_h::__pthread_cond_s;
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "32:9"]
    pub union pthread_mutexattr_t {
        pub __size: [::core::ffi::c_char; 4],
        pub __align: ::core::ffi::c_int,
    }
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "41:9"]
    pub union pthread_condattr_t {
        pub __size: [::core::ffi::c_char; 4],
        pub __align: ::core::ffi::c_int,
    }

    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "56:7"]
    pub union pthread_attr_t {
        pub __size: [::core::ffi::c_char; 56],
        pub __align: ::core::ffi::c_long,
    }
}
#[c2rust::header_src = "/home/nwplayer123/Hacks/hex264/x264/common/common.h:28"]
pub mod common_h {
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "270:8"]
    pub struct x264_t {
        pub param: x264_param_t,
        pub api: *mut ::core::ffi::c_void,
        pub thread: [*mut x264_t; 129],
        pub lookahead_thread: [*mut x264_t; 16],
        pub b_thread_active: ::core::ffi::c_int,
        pub i_thread_phase: ::core::ffi::c_int,
        pub i_thread_idx: ::core::ffi::c_int,
        pub i_threadslice_start: ::core::ffi::c_int,
        pub i_threadslice_end: ::core::ffi::c_int,
        pub i_threadslice_pass: ::core::ffi::c_int,
        pub threadpool: *mut x264_threadpool_t,
        pub lookaheadpool: *mut x264_threadpool_t,
        pub mutex: pthread_mutex_t,
        pub cv: pthread_cond_t,
        pub out: C2RustUnnamed_18,
        pub nal_buffer: *mut uint8_t,
        pub nal_buffer_size: ::core::ffi::c_int,
        pub reconfig_h: *mut x264_t,
        pub reconfig: ::core::ffi::c_int,
        pub i_frame: ::core::ffi::c_int,
        pub i_frame_num: ::core::ffi::c_int,
        pub i_thread_frames: ::core::ffi::c_int,
        pub i_nal_type: ::core::ffi::c_int,
        pub i_nal_ref_idc: ::core::ffi::c_int,
        pub i_disp_fields: int64_t,
        pub i_disp_fields_last_frame: ::core::ffi::c_int,
        pub i_prev_duration: int64_t,
        pub i_coded_fields: int64_t,
        pub i_cpb_delay: int64_t,
        pub i_coded_fields_lookahead: int64_t,
        pub i_cpb_delay_lookahead: int64_t,
        pub i_cpb_delay_pir_offset: int64_t,
        pub i_cpb_delay_pir_offset_next: int64_t,
        pub b_queued_intra_refresh: ::core::ffi::c_int,
        pub i_last_idr_pts: int64_t,
        pub i_idr_pic_id: ::core::ffi::c_int,
        pub dequant4_mf: [*mut [::core::ffi::c_int; 16]; 4],
        pub dequant8_mf: [*mut [::core::ffi::c_int; 64]; 4],
        pub unquant4_mf: [*mut [::core::ffi::c_int; 16]; 4],
        pub unquant8_mf: [*mut [::core::ffi::c_int; 64]; 4],
        pub quant4_mf: [*mut [udctcoef; 16]; 4],
        pub quant8_mf: [*mut [udctcoef; 64]; 4],
        pub quant4_bias: [*mut [udctcoef; 16]; 4],
        pub quant8_bias: [*mut [udctcoef; 64]; 4],
        pub quant4_bias0: [*mut [udctcoef; 16]; 4],
        pub quant8_bias0: [*mut [udctcoef; 64]; 4],
        pub nr_offset_emergency: *mut [[udctcoef; 64]; 4],
        pub cost_mv: [*mut uint16_t; 82],
        pub cost_mv_fpel: [[*mut uint16_t; 4]; 82],
        pub cost_table: *mut C2RustUnnamed_17,
        pub chroma_qp_table: *const uint8_t,
        pub sh: x264_slice_header_t,
        pub sps: [x264_sps_t; 1],
        pub pps: [x264_pps_t; 1],
        pub b_sh_backup: ::core::ffi::c_int,
        pub sh_backup: x264_slice_header_t,
        pub cabac: x264_cabac_t,
        pub frames: C2RustUnnamed_11,
        pub fenc: *mut x264_frame_t,
        pub fdec: *mut x264_frame_t,
        pub i_ref: [::core::ffi::c_int; 2],
        pub fref: [[*mut x264_frame_t; 19]; 2],
        pub fref_nearest: [*mut x264_frame_t; 2],
        pub b_ref_reorder: [::core::ffi::c_int; 2],
        pub initial_cpb_removal_delay: ::core::ffi::c_int,
        pub initial_cpb_removal_delay_offset: ::core::ffi::c_int,
        pub i_reordered_pts_delay: int64_t,
        pub dct: C2RustUnnamed_10,
        pub mb: C2RustUnnamed_7,
        pub rc: *mut x264_ratecontrol_t,
        pub stat: C2RustUnnamed_6,
        pub nr_offset: *mut [udctcoef; 64],
        pub nr_residual_sum: *mut [uint32_t; 64],
        pub nr_count: *mut uint32_t,
        pub nr_offset_denoise: [[udctcoef; 64]; 4],
        pub nr_residual_sum_buf: [[[uint32_t; 64]; 4]; 2],
        pub nr_count_buf: [[uint32_t; 4]; 2],
        pub luma2chroma_pixel: [uint8_t; 7],
        pub scratch_buffer: *mut ::core::ffi::c_void,
        pub scratch_buffer2: *mut ::core::ffi::c_void,
        pub intra_border_backup: [[*mut pixel; 3]; 5],
        pub deblock_strength: [*mut [[[uint8_t; 4]; 8]; 2]; 2],
        pub predict_16x16: [x264_predict_t; 7],
        pub predict_8x8: [x264_predict8x8_t; 12],
        pub predict_4x4: [x264_predict_t; 12],
        pub predict_chroma: [x264_predict_t; 7],
        pub predict_8x8c: [x264_predict_t; 7],
        pub predict_8x16c: [x264_predict_t; 7],
        pub predict_8x8_filter: x264_predict_8x8_filter_t,
        pub pixf: x264_pixel_function_t,
        pub mc: x264_mc_functions_t,
        pub dctf: x264_dct_function_t,
        pub zigzagf: x264_zigzag_function_t,
        pub zigzagf_interlaced: x264_zigzag_function_t,
        pub zigzagf_progressive: x264_zigzag_function_t,
        pub quantf: x264_quant_function_t,
        pub loopf: x264_deblock_function_t,
        pub bsf: x264_bitstream_function_t,
        pub lookahead: *mut x264_lookahead_t,
    }
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "217:16"]
    pub struct x264_lookahead_t {
        pub b_exit_thread: uint8_t,
        pub b_thread_active: uint8_t,
        pub b_analyse_keyframe: uint8_t,
        pub i_last_keyframe: ::core::ffi::c_int,
        pub i_slicetype_length: ::core::ffi::c_int,
        pub last_nonb: *mut x264_frame_t,
        pub thread_handle: pthread_t,
        pub ifbuf: x264_sync_frame_list_t,
        pub next: x264_sync_frame_list_t,
        pub ofbuf: x264_sync_frame_list_t,
    }
    #[c2rust::src_loc = "94:5"]
    pub type pixel = uint16_t;
    #[c2rust::src_loc = "96:5"]
    pub type dctcoef = int32_t;
    #[c2rust::src_loc = "97:5"]
    pub type udctcoef = uint32_t;
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "685:5"]
    pub struct C2RustUnnamed_6 {
        pub i_frame_count: [::core::ffi::c_int; 3],
        pub i_frame_size: [int64_t; 3],
        pub f_frame_qp: [::core::ffi::c_double; 3],
        pub i_consecutive_bframes: [::core::ffi::c_int; 17],
        pub f_ssd_global: [::core::ffi::c_double; 3],
        pub f_psnr_average: [::core::ffi::c_double; 3],
        pub f_psnr_mean_y: [::core::ffi::c_double; 3],
        pub f_psnr_mean_u: [::core::ffi::c_double; 3],
        pub f_psnr_mean_v: [::core::ffi::c_double; 3],
        pub f_ssim_mean_y: [::core::ffi::c_double; 3],
        pub f_frame_duration: [::core::ffi::c_double; 3],
        pub i_mb_count: [[int64_t; 19]; 3],
        pub i_mb_partition: [[int64_t; 17]; 2],
        pub i_mb_count_8x8dct: [int64_t; 2],
        pub i_mb_count_ref: [[[int64_t; 32]; 2]; 2],
        pub i_mb_cbp: [int64_t; 6],
        pub i_mb_pred_mode: [[int64_t; 13]; 4],
        pub i_mb_field: [int64_t; 3],
        pub i_direct_score: [::core::ffi::c_int; 2],
        pub i_direct_frames: [::core::ffi::c_int; 2],
        pub i_wpred: [::core::ffi::c_int; 2],
        pub frame: x264_frame_stat_t,
    }
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "243:9"]
    pub struct x264_frame_stat_t {
        pub i_mv_bits: ::core::ffi::c_int,
        pub i_tex_bits: ::core::ffi::c_int,
        pub i_misc_bits: ::core::ffi::c_int,
        pub i_mb_count: [::core::ffi::c_int; 19],
        pub i_mb_count_i: ::core::ffi::c_int,
        pub i_mb_count_p: ::core::ffi::c_int,
        pub i_mb_count_skip: ::core::ffi::c_int,
        pub i_mb_count_8x8dct: [::core::ffi::c_int; 2],
        pub i_mb_count_ref: [[::core::ffi::c_int; 32]; 2],
        pub i_mb_partition: [::core::ffi::c_int; 17],
        pub i_mb_cbp: [::core::ffi::c_int; 6],
        pub i_mb_pred_mode: [[::core::ffi::c_int; 13]; 4],
        pub i_mb_field: [::core::ffi::c_int; 3],
        pub i_direct_score: [::core::ffi::c_int; 2],
        pub i_ssd: [int64_t; 3],
        pub f_ssim: ::core::ffi::c_double,
        pub i_ssim_cnt: ::core::ffi::c_int,
    }
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "438:5"]
    pub struct C2RustUnnamed_7 {
        pub i_mb_width: ::core::ffi::c_int,
        pub i_mb_height: ::core::ffi::c_int,
        pub i_mb_count: ::core::ffi::c_int,
        pub chroma_h_shift: ::core::ffi::c_int,
        pub chroma_v_shift: ::core::ffi::c_int,
        pub i_mb_stride: ::core::ffi::c_int,
        pub i_b8_stride: ::core::ffi::c_int,
        pub i_b4_stride: ::core::ffi::c_int,
        pub left_b8: [::core::ffi::c_int; 2],
        pub left_b4: [::core::ffi::c_int; 2],
        pub i_mb_x: ::core::ffi::c_int,
        pub i_mb_y: ::core::ffi::c_int,
        pub i_mb_xy: ::core::ffi::c_int,
        pub i_b8_xy: ::core::ffi::c_int,
        pub i_b4_xy: ::core::ffi::c_int,
        pub i_me_method: ::core::ffi::c_int,
        pub i_subpel_refine: ::core::ffi::c_int,
        pub b_chroma_me: ::core::ffi::c_int,
        pub b_trellis: ::core::ffi::c_int,
        pub b_noise_reduction: ::core::ffi::c_int,
        pub b_dct_decimate: ::core::ffi::c_int,
        pub i_psy_rd: ::core::ffi::c_int,
        pub i_psy_trellis: ::core::ffi::c_int,
        pub b_interlaced: ::core::ffi::c_int,
        pub b_adaptive_mbaff: ::core::ffi::c_int,
        pub mv_min: [::core::ffi::c_int; 2],
        pub mv_max: [::core::ffi::c_int; 2],
        pub mv_miny_row: [::core::ffi::c_int; 3],
        pub mv_maxy_row: [::core::ffi::c_int; 3],
        pub mv_min_spel: [::core::ffi::c_int; 2],
        pub mv_max_spel: [::core::ffi::c_int; 2],
        pub mv_miny_spel_row: [::core::ffi::c_int; 3],
        pub mv_maxy_spel_row: [::core::ffi::c_int; 3],
        pub mv_limit_fpel: [[int16_t; 2]; 2],
        pub mv_miny_fpel_row: [::core::ffi::c_int; 3],
        pub mv_maxy_fpel_row: [::core::ffi::c_int; 3],
        pub i_neighbour: ::core::ffi::c_uint,
        pub i_neighbour8: [::core::ffi::c_uint; 4],
        pub i_neighbour4: [::core::ffi::c_uint; 16],
        pub i_neighbour_intra: ::core::ffi::c_uint,
        pub i_neighbour_frame: ::core::ffi::c_uint,
        pub i_mb_type_top: ::core::ffi::c_int,
        pub i_mb_type_left: [::core::ffi::c_int; 2],
        pub i_mb_type_topleft: ::core::ffi::c_int,
        pub i_mb_type_topright: ::core::ffi::c_int,
        pub i_mb_prev_xy: ::core::ffi::c_int,
        pub i_mb_left_xy: [::core::ffi::c_int; 2],
        pub i_mb_top_xy: ::core::ffi::c_int,
        pub i_mb_topleft_xy: ::core::ffi::c_int,
        pub i_mb_topright_xy: ::core::ffi::c_int,
        pub i_mb_top_y: ::core::ffi::c_int,
        pub i_mb_topleft_y: ::core::ffi::c_int,
        pub i_mb_topright_y: ::core::ffi::c_int,
        pub left_index_table: *const x264_left_table_t,
        pub i_mb_top_mbpair_xy: ::core::ffi::c_int,
        pub topleft_partition: ::core::ffi::c_int,
        pub b_allow_skip: ::core::ffi::c_int,
        pub field_decoding_flag: ::core::ffi::c_int,
        pub base: *mut uint8_t,
        pub type_0: *mut int8_t,
        pub partition: *mut uint8_t,
        pub qp: *mut int8_t,
        pub cbp: *mut int16_t,
        pub intra4x4_pred_mode: *mut [int8_t; 8],
        pub non_zero_count: *mut [uint8_t; 48],
        pub chroma_pred_mode: *mut int8_t,
        pub mv: [*mut [int16_t; 2]; 2],
        pub mvd: [*mut [[uint8_t; 2]; 8]; 2],
        pub ref_0: [*mut int8_t; 2],
        pub mvr: [[*mut [int16_t; 2]; 32]; 2],
        pub skipbp: *mut int8_t,
        pub mb_transform_size: *mut int8_t,
        pub slice_table: *mut int32_t,
        pub field: *mut uint8_t,
        pub p_weight_buf: [*mut pixel; 16],
        pub i_type: ::core::ffi::c_int,
        pub i_partition: ::core::ffi::c_int,
        pub i_sub_partition: [uint8_t; 4],
        pub b_transform_8x8: ::core::ffi::c_int,
        pub i_cbp_luma: ::core::ffi::c_int,
        pub i_cbp_chroma: ::core::ffi::c_int,
        pub i_intra16x16_pred_mode: ::core::ffi::c_int,
        pub i_chroma_pred_mode: ::core::ffi::c_int,
        pub i_skip_intra: ::core::ffi::c_int,
        pub b_skip_mc: ::core::ffi::c_int,
        pub b_reencode_mb: ::core::ffi::c_int,
        pub ip_offset: ::core::ffi::c_int,
        pub b_deblock_rdo: ::core::ffi::c_int,
        pub b_overflow: ::core::ffi::c_int,
        pub pic: C2RustUnnamed_9,
        pub cache: C2RustUnnamed_8,
        pub i_qp: ::core::ffi::c_int,
        pub i_chroma_qp: ::core::ffi::c_int,
        pub i_last_qp: ::core::ffi::c_int,
        pub i_last_dqp: ::core::ffi::c_int,
        pub b_variable_qp: ::core::ffi::c_int,
        pub b_lossless: ::core::ffi::c_int,
        pub b_direct_auto_read: ::core::ffi::c_int,
        pub b_direct_auto_write: ::core::ffi::c_int,
        pub i_trellis_lambda2: [[::core::ffi::c_int; 2]; 2],
        pub i_psy_rd_lambda: ::core::ffi::c_int,
        pub i_chroma_lambda2_offset: ::core::ffi::c_int,
        pub dist_scale_factor_buf: [[[[int16_t; 4]; 32]; 2]; 2],
        pub dist_scale_factor: *mut [int16_t; 4],
        pub bipred_weight_buf: [[[[int8_t; 4]; 32]; 2]; 2],
        pub bipred_weight: *mut [int8_t; 4],
        pub map_col_to_list0: [int8_t; 18],
        pub ref_blind_dupe: ::core::ffi::c_int,
        pub deblock_ref_table: [int8_t; 34],
    }
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "614:9"]
    pub struct C2RustUnnamed_8 {
        pub intra4x4_pred_mode: [int8_t; 40],
        pub non_zero_count: [uint8_t; 120],
        pub ref_0: [[int8_t; 40]; 2],
        pub mv: [[[int16_t; 2]; 40]; 2],
        pub mvd: [[[uint8_t; 2]; 40]; 2],
        pub skip: [int8_t; 40],
        pub direct_mv: [[[int16_t; 2]; 4]; 2],
        pub direct_ref: [[int8_t; 4]; 2],
        pub direct_partition: ::core::ffi::c_int,
        pub pskip_mv: [int16_t; 2],
        pub i_neighbour_transform_size: ::core::ffi::c_int,
        pub i_neighbour_skip: ::core::ffi::c_int,
        pub i_cbp_top: ::core::ffi::c_int,
        pub i_cbp_left: ::core::ffi::c_int,
        pub topright_mv: [[[int16_t; 2]; 3]; 2],
        pub topright_ref: [[int8_t; 3]; 2],
        pub deblock_strength: *mut [[uint8_t; 4]; 8],
    }
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "567:9"]
    pub struct C2RustUnnamed_9 {
        pub fenc_buf: [pixel; 768],
        pub fdec_buf: [pixel; 1728],
        pub i4x4_fdec_buf: [pixel; 256],
        pub i8x8_fdec_buf: [pixel; 256],
        pub i8x8_dct_buf: [[dctcoef; 64]; 3],
        pub i4x4_dct_buf: [[dctcoef; 16]; 15],
        pub i4x4_nnz_buf: [uint32_t; 4],
        pub i8x8_nnz_buf: [uint32_t; 4],
        pub fenc_dct8: [[dctcoef; 64]; 4],
        pub fenc_dct4: [[dctcoef; 16]; 16],
        pub fenc_satd_cache: [uint32_t; 32],
        pub fenc_hadamard_cache: [uint64_t; 9],
        pub i4x4_cbp: ::core::ffi::c_int,
        pub i8x8_cbp: ::core::ffi::c_int,
        pub p_fenc: [*mut pixel; 3],
        pub p_fenc_plane: [*mut pixel; 3],
        pub p_fdec: [*mut pixel; 3],
        pub i_fref: [::core::ffi::c_int; 2],
        pub p_fref: [[[*mut pixel; 12]; 32]; 2],
        pub p_fref_w: [*mut pixel; 32],
        pub p_integral: [[*mut uint16_t; 16]; 2],
        pub i_stride: [::core::ffi::c_int; 3],
    }
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "233:16"]
    pub struct x264_left_table_t {
        pub intra: [uint8_t; 4],
        pub nnz: [uint8_t; 4],
        pub nnz_chroma: [uint8_t; 4],
        pub mv: [uint8_t; 4],
        pub ref_0: [uint8_t; 4],
    }
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "428:5"]
    pub struct C2RustUnnamed_10 {
        pub luma16x16_dc: [[dctcoef; 16]; 3],
        pub chroma_dc: [[dctcoef; 8]; 2],
        pub luma8x8: [[dctcoef; 64]; 12],
        pub luma4x4: [[dctcoef; 16]; 48],
    }
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "375:5"]
    pub struct C2RustUnnamed_11 {
        pub current: *mut *mut x264_frame_t,
        pub unused: [*mut *mut x264_frame_t; 2],
        pub blank_unused: *mut *mut x264_frame_t,
        pub reference: [*mut x264_frame_t; 18],
        pub i_last_keyframe: ::core::ffi::c_int,
        pub i_last_idr: ::core::ffi::c_int,
        pub i_poc_last_open_gop: ::core::ffi::c_int,
        pub i_input: ::core::ffi::c_int,
        pub i_max_dpb: ::core::ffi::c_int,
        pub i_max_ref0: ::core::ffi::c_int,
        pub i_max_ref1: ::core::ffi::c_int,
        pub i_delay: ::core::ffi::c_int,
        pub i_bframe_delay: ::core::ffi::c_int,
        pub i_bframe_delay_time: int64_t,
        pub i_first_pts: int64_t,
        pub i_prev_reordered_pts: [int64_t; 2],
        pub i_largest_pts: int64_t,
        pub i_second_largest_pts: int64_t,
        pub b_have_lowres: ::core::ffi::c_int,
        pub b_have_sub8x8_esa: ::core::ffi::c_int,
    }
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "153:9"]
    pub struct x264_slice_header_t {
        pub sps: *mut x264_sps_t,
        pub pps: *mut x264_pps_t,
        pub i_type: ::core::ffi::c_int,
        pub i_first_mb: ::core::ffi::c_int,
        pub i_last_mb: ::core::ffi::c_int,
        pub i_pps_id: ::core::ffi::c_int,
        pub i_frame_num: ::core::ffi::c_int,
        pub b_mbaff: ::core::ffi::c_int,
        pub b_field_pic: ::core::ffi::c_int,
        pub b_bottom_field: ::core::ffi::c_int,
        pub i_idr_pic_id: ::core::ffi::c_int,
        pub i_poc: ::core::ffi::c_int,
        pub i_delta_poc_bottom: ::core::ffi::c_int,
        pub i_delta_poc: [::core::ffi::c_int; 2],
        pub i_redundant_pic_cnt: ::core::ffi::c_int,
        pub b_direct_spatial_mv_pred: ::core::ffi::c_int,
        pub b_num_ref_idx_override: ::core::ffi::c_int,
        pub i_num_ref_idx_l0_active: ::core::ffi::c_int,
        pub i_num_ref_idx_l1_active: ::core::ffi::c_int,
        pub b_ref_pic_list_reordering: [::core::ffi::c_int; 2],
        pub ref_pic_list_order: [[C2RustUnnamed_13; 16]; 2],
        pub b_weighted_pred: ::core::ffi::c_int,
        pub weight: [[x264_weight_t; 3]; 32],
        pub i_mmco_remove_from_end: ::core::ffi::c_int,
        pub i_mmco_command_count: ::core::ffi::c_int,
        pub mmco: [C2RustUnnamed_12; 16],
        pub i_cabac_init_idc: ::core::ffi::c_int,
        pub i_qp: ::core::ffi::c_int,
        pub i_qp_delta: ::core::ffi::c_int,
        pub b_sp_for_swidth: ::core::ffi::c_int,
        pub i_qs_delta: ::core::ffi::c_int,
        pub i_disable_deblocking_filter_idc: ::core::ffi::c_int,
        pub i_alpha_c0_offset: ::core::ffi::c_int,
        pub i_beta_offset: ::core::ffi::c_int,
    }
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "197:5"]
    pub struct C2RustUnnamed_12 {
        pub i_difference_of_pic_nums: ::core::ffi::c_int,
        pub i_poc: ::core::ffi::c_int,
    }
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "185:5"]
    pub struct C2RustUnnamed_13 {
        pub idc: ::core::ffi::c_int,
        pub arg: ::core::ffi::c_int,
    }
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "353:5"]
    pub struct C2RustUnnamed_17 {
        pub ref_0: [[[uint16_t; 33]; 3]; 82],
        pub i4x4_mode: [[uint16_t; 17]; 82],
    }
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "291:5"]
    pub struct C2RustUnnamed_18 {
        pub i_nal: ::core::ffi::c_int,
        pub i_nals_allocated: ::core::ffi::c_int,
        pub nal: *mut x264_nal_t,
        pub i_bitstream: ::core::ffi::c_int,
        pub p_bitstream: *mut uint8_t,
        pub bs: bs_t,
    }
    #[c2rust::src_loc = "95:5"]
    pub type pixel4 = uint64_t;
    #[c2rust::src_loc = "58:9"]
    pub const QP_BD_OFFSET: ::core::ffi::c_int =
        6 as ::core::ffi::c_int * (BIT_DEPTH - 8 as ::core::ffi::c_int);
    #[c2rust::src_loc = "59:9"]
    pub const QP_MAX_SPEC: ::core::ffi::c_int = 51 as ::core::ffi::c_int + QP_BD_OFFSET;
    #[c2rust::src_loc = "60:9"]
    pub const QP_MAX: ::core::ffi::c_int = QP_MAX_SPEC + 18 as ::core::ffi::c_int;
    #[c2rust::src_loc = "63:9"]
    pub const X264_LOOKAHEAD_QP: ::core::ffi::c_int = 12 as ::core::ffi::c_int + QP_BD_OFFSET;
    #[c2rust::src_loc = "111:9"]
    pub const SIZEOF_PIXEL: ::core::ffi::c_int =
        ::core::mem::size_of::<pixel>() as ::core::ffi::c_int;
    #[c2rust::src_loc = "570:9"]
    pub const FENC_STRIDE: ::core::ffi::c_int = 16 as ::core::ffi::c_int;
    #[c2rust::src_loc = "571:9"]
    pub const FDEC_STRIDE: ::core::ffi::c_int = 32 as ::core::ffi::c_int;
    use super::bitstream_h::{bs_t, x264_bitstream_function_t};
    use super::cabac_h::x264_cabac_t;
    use super::dct_h::{x264_dct_function_t, x264_zigzag_function_t};
    use super::frame_h::{x264_deblock_function_t, x264_frame_t, x264_sync_frame_list_t};
    use super::internal::BIT_DEPTH;
    use super::mc_h::{x264_mc_functions_t, x264_weight_t};
    use super::pixel_h::x264_pixel_function_t;
    use super::predict_h::{x264_predict8x8_t, x264_predict_8x8_filter_t, x264_predict_t};
    use super::pthreadtypes_h::{pthread_cond_t, pthread_mutex_t, pthread_t};
    use super::quant_h::x264_quant_function_t;
    use super::set_h::{x264_pps_t, x264_sps_t};
    use super::stdint_intn_h::{int16_t, int32_t, int64_t, int8_t};
    use super::stdint_uintn_h::{uint16_t, uint32_t, uint64_t, uint8_t};
    use super::threadpool_h::x264_threadpool_t;
    use super::x264_h::{x264_nal_t, x264_param_t};
    extern "C" {
        #[c2rust::src_loc = "231:16"]
        pub type x264_ratecontrol_t;
        #[c2rust::src_loc = "138:1"]
        pub fn x264_10_log(
            h: *mut x264_t,
            i_level: ::core::ffi::c_int,
            psz_fmt: *const ::core::ffi::c_char,
            ...
        );
    }
    #[c2rust::src_loc = "61:9"]
    pub const PIXEL_MAX: ::core::ffi::c_int =
        ((1 as ::core::ffi::c_int) << BIT_DEPTH) - 1 as ::core::ffi::c_int;
    #[c2rust::src_loc = "66:9"]
    pub const NALU_OVERHEAD: ::core::ffi::c_int = 5 as ::core::ffi::c_int;
    #[c2rust::src_loc = "67:9"]
    pub const FILLER_OVERHEAD: ::core::ffi::c_int = NALU_OVERHEAD + 1 as ::core::ffi::c_int;
    extern "C" {
        #[c2rust::src_loc = "141:1"]
        pub fn x264_10_cavlc_init(h: *mut x264_t);
        #[c2rust::src_loc = "143:1"]
        pub fn x264_10_cabac_init(h: *mut x264_t);
    }

    #[inline(always)]
    #[c2rust::src_loc = "145:1"]
    pub unsafe extern "C" fn x264_clip_pixel(mut x: ::core::ffi::c_int) -> pixel {
        return (if x & !PIXEL_MAX != 0 {
            -x >> 31 as ::core::ffi::c_int & PIXEL_MAX
        } else {
            x
        }) as pixel;
    }
}
#[c2rust::header_src = "/home/nwplayer123/Hacks/hex264/x264/common/frame.h:28"]
pub mod frame_h {
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "186:9"]
    pub struct x264_sync_frame_list_t {
        pub list: *mut *mut x264_frame_t,
        pub i_max_size: ::core::ffi::c_int,
        pub i_size: ::core::ffi::c_int,
        pub mutex: pthread_mutex_t,
        pub cv_fill: pthread_cond_t,
        pub cv_empty: pthread_cond_t,
    }
    #[c2rust::src_loc = "37:1"]
    pub type x264_frame_t = x264_frame;
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "37:16"]
    pub struct x264_frame {
        pub base: *mut uint8_t,
        pub i_poc: ::core::ffi::c_int,
        pub i_delta_poc: [::core::ffi::c_int; 2],
        pub i_type: ::core::ffi::c_int,
        pub i_forced_type: ::core::ffi::c_int,
        pub i_qpplus1: ::core::ffi::c_int,
        pub i_pts: int64_t,
        pub i_dts: int64_t,
        pub i_reordered_pts: int64_t,
        pub i_duration: int64_t,
        pub f_duration: ::core::ffi::c_float,
        pub i_cpb_duration: int64_t,
        pub i_cpb_delay: int64_t,
        pub i_dpb_output_delay: int64_t,
        pub param: *mut x264_param_t,
        pub i_frame: ::core::ffi::c_int,
        pub i_coded: ::core::ffi::c_int,
        pub i_field_cnt: int64_t,
        pub i_frame_num: ::core::ffi::c_int,
        pub b_kept_as_ref: ::core::ffi::c_int,
        pub i_pic_struct: ::core::ffi::c_int,
        pub b_keyframe: ::core::ffi::c_int,
        pub b_fdec: uint8_t,
        pub b_last_minigop_bframe: uint8_t,
        pub i_bframes: uint8_t,
        pub f_qp_avg_rc: ::core::ffi::c_float,
        pub f_qp_avg_aq: ::core::ffi::c_float,
        pub f_crf_avg: ::core::ffi::c_float,
        pub i_poc_l0ref0: ::core::ffi::c_int,
        pub i_csp: ::core::ffi::c_int,
        pub i_plane: ::core::ffi::c_int,
        pub i_stride: [::core::ffi::c_int; 3],
        pub i_width: [::core::ffi::c_int; 3],
        pub i_lines: [::core::ffi::c_int; 3],
        pub i_stride_lowres: ::core::ffi::c_int,
        pub i_width_lowres: ::core::ffi::c_int,
        pub i_lines_lowres: ::core::ffi::c_int,
        pub plane: [*mut pixel; 3],
        pub plane_fld: [*mut pixel; 3],
        pub filtered: [[*mut pixel; 4]; 3],
        pub filtered_fld: [[*mut pixel; 4]; 3],
        pub lowres: [*mut pixel; 4],
        pub integral: *mut uint16_t,
        pub buffer: [*mut pixel; 4],
        pub buffer_fld: [*mut pixel; 4],
        pub buffer_lowres: *mut pixel,
        pub weight: [[x264_weight_t; 3]; 16],
        pub weighted: [*mut pixel; 16],
        pub b_duplicate: ::core::ffi::c_int,
        pub orig: *mut x264_frame,
        pub mb_type: *mut int8_t,
        pub mb_partition: *mut uint8_t,
        pub mv: [*mut [int16_t; 2]; 2],
        pub mv16x16: *mut [int16_t; 2],
        pub lowres_mvs: [[*mut [int16_t; 2]; 17]; 2],
        pub field: *mut uint8_t,
        pub effective_qp: *mut uint8_t,
        pub lowres_costs: [[*mut uint16_t; 18]; 18],
        pub lowres_mv_costs: [[*mut ::core::ffi::c_int; 17]; 2],
        pub ref_0: [*mut int8_t; 2],
        pub i_ref: [::core::ffi::c_int; 2],
        pub ref_poc: [[::core::ffi::c_int; 16]; 2],
        pub inv_ref_poc: [int16_t; 2],
        pub i_cost_est: [[::core::ffi::c_int; 18]; 18],
        pub i_cost_est_aq: [[::core::ffi::c_int; 18]; 18],
        pub i_satd: ::core::ffi::c_int,
        pub i_intra_mbs: [::core::ffi::c_int; 18],
        pub i_row_satds: [[*mut ::core::ffi::c_int; 18]; 18],
        pub i_row_satd: *mut ::core::ffi::c_int,
        pub i_row_bits: *mut ::core::ffi::c_int,
        pub f_row_qp: *mut ::core::ffi::c_float,
        pub f_row_qscale: *mut ::core::ffi::c_float,
        pub f_qp_offset: *mut ::core::ffi::c_float,
        pub f_qp_offset_aq: *mut ::core::ffi::c_float,
        pub b_intra_calculated: ::core::ffi::c_int,
        pub i_intra_cost: *mut uint16_t,
        pub i_propagate_cost: *mut uint16_t,
        pub i_inv_qscale_factor: *mut uint16_t,
        pub b_scenecut: ::core::ffi::c_int,
        pub f_weighted_cost_delta: [::core::ffi::c_float; 18],
        pub i_pixel_sum: [uint32_t; 3],
        pub i_pixel_ssd: [uint64_t; 3],
        pub hrd_timing: x264_hrd_t,
        pub i_planned_type: [uint8_t; 251],
        pub i_planned_satd: [::core::ffi::c_int; 251],
        pub f_planned_cpb_duration: [::core::ffi::c_double; 251],
        pub i_coded_fields_lookahead: int64_t,
        pub i_cpb_delay_lookahead: int64_t,
        pub i_lines_completed: ::core::ffi::c_int,
        pub i_lines_weighted: ::core::ffi::c_int,
        pub i_reference_count: ::core::ffi::c_int,
        pub mutex: pthread_mutex_t,
        pub cv: pthread_cond_t,
        pub i_slice_count: ::core::ffi::c_int,
        pub f_pir_position: ::core::ffi::c_float,
        pub i_pir_start_col: ::core::ffi::c_int,
        pub i_pir_end_col: ::core::ffi::c_int,
        pub i_frames_since_pir: ::core::ffi::c_int,
        pub b_corrupt: ::core::ffi::c_int,
        pub extra_sei: x264_sei_t,
        pub opaque: *mut ::core::ffi::c_void,
        pub mb_info: *mut uint8_t,
        pub mb_info_free: Option<unsafe extern "C" fn(*mut ::core::ffi::c_void) -> ()>,
    }
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "198:9"]
    pub struct x264_deblock_function_t {
        pub deblock_luma: [x264_deblock_inter_t; 2],
        pub deblock_chroma: [x264_deblock_inter_t; 2],
        pub deblock_h_chroma_420: x264_deblock_inter_t,
        pub deblock_h_chroma_422: x264_deblock_inter_t,
        pub deblock_luma_intra: [x264_deblock_intra_t; 2],
        pub deblock_chroma_intra: [x264_deblock_intra_t; 2],
        pub deblock_h_chroma_420_intra: x264_deblock_intra_t,
        pub deblock_h_chroma_422_intra: x264_deblock_intra_t,
        pub deblock_luma_mbaff: x264_deblock_inter_t,
        pub deblock_chroma_mbaff: x264_deblock_inter_t,
        pub deblock_chroma_420_mbaff: x264_deblock_inter_t,
        pub deblock_chroma_422_mbaff: x264_deblock_inter_t,
        pub deblock_luma_intra_mbaff: x264_deblock_intra_t,
        pub deblock_chroma_intra_mbaff: x264_deblock_intra_t,
        pub deblock_chroma_420_intra_mbaff: x264_deblock_intra_t,
        pub deblock_chroma_422_intra_mbaff: x264_deblock_intra_t,
        pub deblock_strength: Option<
            unsafe extern "C" fn(
                *mut uint8_t,
                *mut [int8_t; 40],
                *mut [[int16_t; 2]; 40],
                *mut [[uint8_t; 4]; 8],
                ::core::ffi::c_int,
                ::core::ffi::c_int,
            ) -> (),
        >,
    }
    #[c2rust::src_loc = "197:1"]
    pub type x264_deblock_intra_t = Option<
        unsafe extern "C" fn(*mut pixel, intptr_t, ::core::ffi::c_int, ::core::ffi::c_int) -> (),
    >;
    #[c2rust::src_loc = "196:1"]
    pub type x264_deblock_inter_t = Option<
        unsafe extern "C" fn(
            *mut pixel,
            intptr_t,
            ::core::ffi::c_int,
            ::core::ffi::c_int,
            *mut int8_t,
        ) -> (),
    >;
    #[c2rust::src_loc = "32:9"]
    pub const PADH: ::core::ffi::c_int = 32 as ::core::ffi::c_int;
    #[c2rust::src_loc = "33:9"]
    pub const PADV: ::core::ffi::c_int = 32 as ::core::ffi::c_int;
    #[c2rust::src_loc = "111:13"]
    pub const LOWRES_COST_MASK: ::core::ffi::c_int =
        ((1 as ::core::ffi::c_int) << 14 as ::core::ffi::c_int) - 1 as ::core::ffi::c_int;
    #[c2rust::src_loc = "112:13"]
    pub const LOWRES_COST_SHIFT: ::core::ffi::c_int = 14 as ::core::ffi::c_int;
    use super::common_h::{pixel, x264_t};
    use super::mc_h::x264_weight_t;
    use super::pthreadtypes_h::{pthread_cond_t, pthread_mutex_t};
    use super::stdint_h::intptr_t;
    use super::stdint_intn_h::{int16_t, int64_t, int8_t};
    use super::stdint_uintn_h::{uint16_t, uint32_t, uint64_t, uint8_t};
    use super::x264_h::{x264_hrd_t, x264_param_t, x264_sei_t};
    extern "C" {
        #[c2rust::src_loc = "234:1"]
        pub fn x264_10_frame_expand_border_chroma(
            h: *mut x264_t,
            frame: *mut x264_frame_t,
            plane: ::core::ffi::c_int,
        );
        #[c2rust::src_loc = "243:1"]
        pub fn x264_10_macroblock_deblock(h: *mut x264_t);
        #[c2rust::src_loc = "256:1"]
        pub fn x264_10_frame_cond_wait(
            frame: *mut x264_frame_t,
            i_lines_completed: ::core::ffi::c_int,
        ) -> ::core::ffi::c_int;
        #[c2rust::src_loc = "281:1"]
        pub fn x264_10_weight_scale_plane(
            h: *mut x264_t,
            dst: *mut pixel,
            i_dst_stride: intptr_t,
            src: *mut pixel,
            i_src_stride: intptr_t,
            i_width: ::core::ffi::c_int,
            i_height: ::core::ffi::c_int,
            w: *mut x264_weight_t,
        );
    }

    use super::x264_h::x264_picture_t;
    extern "C" {
        #[c2rust::src_loc = "222:1"]
        pub fn x264_10_frame_delete(frame: *mut x264_frame_t);
        #[c2rust::src_loc = "225:1"]
        pub fn x264_10_frame_copy_picture(
            h: *mut x264_t,
            dst: *mut x264_frame_t,
            src: *mut x264_picture_t,
        ) -> ::core::ffi::c_int;
        #[c2rust::src_loc = "228:1"]
        pub fn x264_10_frame_expand_border(
            h: *mut x264_t,
            frame: *mut x264_frame_t,
            mb_y: ::core::ffi::c_int,
        );
        #[c2rust::src_loc = "230:1"]
        pub fn x264_10_frame_expand_border_filtered(
            h: *mut x264_t,
            frame: *mut x264_frame_t,
            mb_y: ::core::ffi::c_int,
            b_end: ::core::ffi::c_int,
        );
        #[c2rust::src_loc = "236:1"]
        pub fn x264_10_frame_expand_border_mod16(h: *mut x264_t, frame: *mut x264_frame_t);
        #[c2rust::src_loc = "238:1"]
        pub fn x264_10_expand_border_mbpair(
            h: *mut x264_t,
            mb_x: ::core::ffi::c_int,
            mb_y: ::core::ffi::c_int,
        );
        #[c2rust::src_loc = "241:1"]
        pub fn x264_10_frame_deblock_row(h: *mut x264_t, mb_y: ::core::ffi::c_int);
        #[c2rust::src_loc = "246:1"]
        pub fn x264_10_frame_filter(
            h: *mut x264_t,
            frame: *mut x264_frame_t,
            mb_y: ::core::ffi::c_int,
            b_end: ::core::ffi::c_int,
        );
        #[c2rust::src_loc = "248:1"]
        pub fn x264_10_frame_init_lowres(h: *mut x264_t, frame: *mut x264_frame_t);
        #[c2rust::src_loc = "251:1"]
        pub fn x264_10_deblock_init(
            cpu: uint32_t,
            pf: *mut x264_deblock_function_t,
            b_mbaff: ::core::ffi::c_int,
        );
        #[c2rust::src_loc = "254:1"]
        pub fn x264_10_frame_cond_broadcast(
            frame: *mut x264_frame_t,
            i_lines_completed: ::core::ffi::c_int,
        );
        #[c2rust::src_loc = "258:1"]
        pub fn x264_10_frame_new_slice(
            h: *mut x264_t,
            frame: *mut x264_frame_t,
        ) -> ::core::ffi::c_int;
        #[c2rust::src_loc = "261:1"]
        pub fn x264_10_threadslice_cond_broadcast(h: *mut x264_t, pass: ::core::ffi::c_int);
        #[c2rust::src_loc = "263:1"]
        pub fn x264_10_threadslice_cond_wait(h: *mut x264_t, pass: ::core::ffi::c_int);
        #[c2rust::src_loc = "266:10"]
        pub fn x264_10_frame_push(list: *mut *mut x264_frame_t, frame: *mut x264_frame_t);
        #[c2rust::src_loc = "268:10"]
        pub fn x264_10_frame_pop(list: *mut *mut x264_frame_t) -> *mut x264_frame_t;
        #[c2rust::src_loc = "270:10"]
        pub fn x264_10_frame_unshift(list: *mut *mut x264_frame_t, frame: *mut x264_frame_t);
        #[c2rust::src_loc = "272:10"]
        pub fn x264_10_frame_shift(list: *mut *mut x264_frame_t) -> *mut x264_frame_t;
        #[c2rust::src_loc = "275:1"]
        pub fn x264_10_frame_push_unused(h: *mut x264_t, frame: *mut x264_frame_t);
        #[c2rust::src_loc = "277:1"]
        pub fn x264_10_frame_push_blank_unused(h: *mut x264_t, frame: *mut x264_frame_t);
        #[c2rust::src_loc = "279:1"]
        pub fn x264_10_frame_pop_blank_unused(h: *mut x264_t) -> *mut x264_frame_t;
        #[c2rust::src_loc = "284:1"]
        pub fn x264_10_frame_pop_unused(
            h: *mut x264_t,
            b_fdec: ::core::ffi::c_int,
        ) -> *mut x264_frame_t;
        #[c2rust::src_loc = "286:1"]
        pub fn x264_10_frame_delete_list(list: *mut *mut x264_frame_t);
    }

    extern "C" {
        #[c2rust::src_loc = "289:1"]
        pub fn x264_10_sync_frame_list_init(
            slist: *mut x264_sync_frame_list_t,
            nelem: ::core::ffi::c_int,
        ) -> ::core::ffi::c_int;
        #[c2rust::src_loc = "291:1"]
        pub fn x264_10_sync_frame_list_delete(slist: *mut x264_sync_frame_list_t);
        #[c2rust::src_loc = "293:1"]
        pub fn x264_10_sync_frame_list_push(
            slist: *mut x264_sync_frame_list_t,
            frame: *mut x264_frame_t,
        );
        #[c2rust::src_loc = "295:1"]
        pub fn x264_10_sync_frame_list_pop(slist: *mut x264_sync_frame_list_t)
            -> *mut x264_frame_t;
    }
}
#[c2rust::header_src = "/home/nwplayer123/Hacks/hex264/x264/common/mc.h:28"]
pub mod mc_h {
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "235:16"]
    pub struct x264_weight_t {
        pub cachea: [int16_t; 8],
        pub cacheb: [int16_t; 8],
        pub i_denom: int32_t,
        pub i_scale: int32_t,
        pub i_offset: int32_t,
        pub weightfn: *mut weight_fn_t,
    }
    #[c2rust::src_loc = "234:1"]
    pub type weight_fn_t = Option<
        unsafe extern "C" fn(
            *mut pixel,
            intptr_t,
            *mut pixel,
            intptr_t,
            *const x264_weight_t,
            ::core::ffi::c_int,
        ) -> (),
    >;
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "267:9"]
    pub struct x264_mc_functions_t {
        pub mc_luma: Option<
            unsafe extern "C" fn(
                *mut pixel,
                intptr_t,
                *mut *mut pixel,
                intptr_t,
                ::core::ffi::c_int,
                ::core::ffi::c_int,
                ::core::ffi::c_int,
                ::core::ffi::c_int,
                *const x264_weight_t,
            ) -> (),
        >,
        pub get_ref: Option<
            unsafe extern "C" fn(
                *mut pixel,
                *mut intptr_t,
                *mut *mut pixel,
                intptr_t,
                ::core::ffi::c_int,
                ::core::ffi::c_int,
                ::core::ffi::c_int,
                ::core::ffi::c_int,
                *const x264_weight_t,
            ) -> *mut pixel,
        >,
        pub mc_chroma: Option<
            unsafe extern "C" fn(
                *mut pixel,
                *mut pixel,
                intptr_t,
                *mut pixel,
                intptr_t,
                ::core::ffi::c_int,
                ::core::ffi::c_int,
                ::core::ffi::c_int,
                ::core::ffi::c_int,
            ) -> (),
        >,
        pub avg: [Option<
            unsafe extern "C" fn(
                *mut pixel,
                intptr_t,
                *mut pixel,
                intptr_t,
                *mut pixel,
                intptr_t,
                ::core::ffi::c_int,
            ) -> (),
        >; 12],
        pub copy: [Option<
            unsafe extern "C" fn(
                *mut pixel,
                intptr_t,
                *mut pixel,
                intptr_t,
                ::core::ffi::c_int,
            ) -> (),
        >; 7],
        pub copy_16x16_unaligned: Option<
            unsafe extern "C" fn(
                *mut pixel,
                intptr_t,
                *mut pixel,
                intptr_t,
                ::core::ffi::c_int,
            ) -> (),
        >,
        pub store_interleave_chroma: Option<
            unsafe extern "C" fn(
                *mut pixel,
                intptr_t,
                *mut pixel,
                *mut pixel,
                ::core::ffi::c_int,
            ) -> (),
        >,
        pub load_deinterleave_chroma_fenc: Option<
            unsafe extern "C" fn(*mut pixel, *mut pixel, intptr_t, ::core::ffi::c_int) -> (),
        >,
        pub load_deinterleave_chroma_fdec: Option<
            unsafe extern "C" fn(*mut pixel, *mut pixel, intptr_t, ::core::ffi::c_int) -> (),
        >,
        pub plane_copy: Option<
            unsafe extern "C" fn(
                *mut pixel,
                intptr_t,
                *mut pixel,
                intptr_t,
                ::core::ffi::c_int,
                ::core::ffi::c_int,
            ) -> (),
        >,
        pub plane_copy_swap: Option<
            unsafe extern "C" fn(
                *mut pixel,
                intptr_t,
                *mut pixel,
                intptr_t,
                ::core::ffi::c_int,
                ::core::ffi::c_int,
            ) -> (),
        >,
        pub plane_copy_interleave: Option<
            unsafe extern "C" fn(
                *mut pixel,
                intptr_t,
                *mut pixel,
                intptr_t,
                *mut pixel,
                intptr_t,
                ::core::ffi::c_int,
                ::core::ffi::c_int,
            ) -> (),
        >,
        pub plane_copy_deinterleave: Option<
            unsafe extern "C" fn(
                *mut pixel,
                intptr_t,
                *mut pixel,
                intptr_t,
                *mut pixel,
                intptr_t,
                ::core::ffi::c_int,
                ::core::ffi::c_int,
            ) -> (),
        >,
        pub plane_copy_deinterleave_yuyv: Option<
            unsafe extern "C" fn(
                *mut pixel,
                intptr_t,
                *mut pixel,
                intptr_t,
                *mut pixel,
                intptr_t,
                ::core::ffi::c_int,
                ::core::ffi::c_int,
            ) -> (),
        >,
        pub plane_copy_deinterleave_rgb: Option<
            unsafe extern "C" fn(
                *mut pixel,
                intptr_t,
                *mut pixel,
                intptr_t,
                *mut pixel,
                intptr_t,
                *mut pixel,
                intptr_t,
                ::core::ffi::c_int,
                ::core::ffi::c_int,
                ::core::ffi::c_int,
            ) -> (),
        >,
        pub plane_copy_deinterleave_v210: Option<
            unsafe extern "C" fn(
                *mut pixel,
                intptr_t,
                *mut pixel,
                intptr_t,
                *mut uint32_t,
                intptr_t,
                ::core::ffi::c_int,
                ::core::ffi::c_int,
            ) -> (),
        >,
        pub hpel_filter: Option<
            unsafe extern "C" fn(
                *mut pixel,
                *mut pixel,
                *mut pixel,
                *mut pixel,
                intptr_t,
                ::core::ffi::c_int,
                ::core::ffi::c_int,
                *mut int16_t,
            ) -> (),
        >,
        pub prefetch_fenc: Option<
            unsafe extern "C" fn(
                *mut pixel,
                intptr_t,
                *mut pixel,
                intptr_t,
                ::core::ffi::c_int,
            ) -> (),
        >,
        pub prefetch_fenc_400: Option<
            unsafe extern "C" fn(
                *mut pixel,
                intptr_t,
                *mut pixel,
                intptr_t,
                ::core::ffi::c_int,
            ) -> (),
        >,
        pub prefetch_fenc_420: Option<
            unsafe extern "C" fn(
                *mut pixel,
                intptr_t,
                *mut pixel,
                intptr_t,
                ::core::ffi::c_int,
            ) -> (),
        >,
        pub prefetch_fenc_422: Option<
            unsafe extern "C" fn(
                *mut pixel,
                intptr_t,
                *mut pixel,
                intptr_t,
                ::core::ffi::c_int,
            ) -> (),
        >,
        pub prefetch_ref:
            Option<unsafe extern "C" fn(*mut pixel, intptr_t, ::core::ffi::c_int) -> ()>,
        pub memcpy_aligned: Option<
            unsafe extern "C" fn(
                *mut ::core::ffi::c_void,
                *const ::core::ffi::c_void,
                size_t,
            ) -> *mut ::core::ffi::c_void,
        >,
        pub memzero_aligned: Option<unsafe extern "C" fn(*mut ::core::ffi::c_void, size_t) -> ()>,
        pub integral_init4h:
            Option<unsafe extern "C" fn(*mut uint16_t, *mut pixel, intptr_t) -> ()>,
        pub integral_init8h:
            Option<unsafe extern "C" fn(*mut uint16_t, *mut pixel, intptr_t) -> ()>,
        pub integral_init4v:
            Option<unsafe extern "C" fn(*mut uint16_t, *mut uint16_t, intptr_t) -> ()>,
        pub integral_init8v: Option<unsafe extern "C" fn(*mut uint16_t, intptr_t) -> ()>,
        pub frame_init_lowres_core: Option<
            unsafe extern "C" fn(
                *mut pixel,
                *mut pixel,
                *mut pixel,
                *mut pixel,
                *mut pixel,
                intptr_t,
                intptr_t,
                ::core::ffi::c_int,
                ::core::ffi::c_int,
            ) -> (),
        >,
        pub weight: *mut weight_fn_t,
        pub offsetadd: *mut weight_fn_t,
        pub offsetsub: *mut weight_fn_t,
        pub weight_cache: Option<unsafe extern "C" fn(*mut x264_t, *mut x264_weight_t) -> ()>,
        pub mbtree_propagate_cost: Option<
            unsafe extern "C" fn(
                *mut int16_t,
                *mut uint16_t,
                *mut uint16_t,
                *mut uint16_t,
                *mut uint16_t,
                *mut ::core::ffi::c_float,
                ::core::ffi::c_int,
            ) -> (),
        >,
        pub mbtree_propagate_list: Option<
            unsafe extern "C" fn(
                *mut x264_t,
                *mut uint16_t,
                *mut [int16_t; 2],
                *mut int16_t,
                *mut uint16_t,
                ::core::ffi::c_int,
                ::core::ffi::c_int,
                ::core::ffi::c_int,
                ::core::ffi::c_int,
            ) -> (),
        >,
        pub mbtree_fix8_pack: Option<
            unsafe extern "C" fn(
                *mut uint16_t,
                *mut ::core::ffi::c_float,
                ::core::ffi::c_int,
            ) -> (),
        >,
        pub mbtree_fix8_unpack: Option<
            unsafe extern "C" fn(
                *mut ::core::ffi::c_float,
                *mut uint16_t,
                ::core::ffi::c_int,
            ) -> (),
        >,
    }
    use super::__stddef_size_t_h::size_t;
    use super::common_h::{pixel, x264_t};
    use super::stdint_h::intptr_t;
    use super::stdint_intn_h::{int16_t, int32_t};
    use super::stdint_uintn_h::{uint16_t, uint32_t};
    extern "C" {
        #[c2rust::src_loc = "343:1"]
        pub fn x264_10_mc_init(
            cpu: uint32_t,
            pf: *mut x264_mc_functions_t,
            cpu_independent: ::core::ffi::c_int,
        );
    }
}
#[c2rust::header_src = "/home/nwplayer123/Hacks/hex264/x264/common/bitstream.h:28"]
pub mod bitstream_h {
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "57:9"]
    pub struct x264_bitstream_function_t {
        pub nal_escape:
            Option<unsafe extern "C" fn(*mut uint8_t, *mut uint8_t, *mut uint8_t) -> *mut uint8_t>,
        pub cabac_block_residual_internal: Option<
            unsafe extern "C" fn(
                *mut dctcoef,
                ::core::ffi::c_int,
                intptr_t,
                *mut x264_cabac_t,
            ) -> (),
        >,
        pub cabac_block_residual_rd_internal: Option<
            unsafe extern "C" fn(
                *mut dctcoef,
                ::core::ffi::c_int,
                intptr_t,
                *mut x264_cabac_t,
            ) -> (),
        >,
        pub cabac_block_residual_8x8_rd_internal: Option<
            unsafe extern "C" fn(
                *mut dctcoef,
                ::core::ffi::c_int,
                intptr_t,
                *mut x264_cabac_t,
            ) -> (),
        >,
    }
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "50:9"]
    pub struct x264_run_level_t {
        pub last: int32_t,
        pub mask: int32_t,
        pub level: [dctcoef; 18],
    }
    #[c2rust::src_loc = "39:1"]
    pub type bs_t = bs_s;
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "39:16"]
    pub struct bs_s {
        pub p_start: *mut uint8_t,
        pub p: *mut uint8_t,
        pub p_end: *mut uint8_t,
        pub cur_bits: uintptr_t,
        pub i_left: ::core::ffi::c_int,
        pub i_bits_encoded: ::core::ffi::c_int,
    }
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "31:9"]
    pub struct vlc_large_t {
        pub i_bits: uint16_t,
        pub i_size: uint8_t,
        pub i_next: uint8_t,
    }
    #[c2rust::src_loc = "76:9"]
    pub const LEVEL_TABLE_SIZE: ::core::ffi::c_int = 128 as ::core::ffi::c_int;
    #[c2rust::src_loc = "201:22"]
    pub static mut x264_ue_size_tab: [uint8_t; 256] = [
        1 as ::core::ffi::c_int as uint8_t,
        1 as ::core::ffi::c_int as uint8_t,
        3 as ::core::ffi::c_int as uint8_t,
        3 as ::core::ffi::c_int as uint8_t,
        5 as ::core::ffi::c_int as uint8_t,
        5 as ::core::ffi::c_int as uint8_t,
        5 as ::core::ffi::c_int as uint8_t,
        5 as ::core::ffi::c_int as uint8_t,
        7 as ::core::ffi::c_int as uint8_t,
        7 as ::core::ffi::c_int as uint8_t,
        7 as ::core::ffi::c_int as uint8_t,
        7 as ::core::ffi::c_int as uint8_t,
        7 as ::core::ffi::c_int as uint8_t,
        7 as ::core::ffi::c_int as uint8_t,
        7 as ::core::ffi::c_int as uint8_t,
        7 as ::core::ffi::c_int as uint8_t,
        9 as ::core::ffi::c_int as uint8_t,
        9 as ::core::ffi::c_int as uint8_t,
        9 as ::core::ffi::c_int as uint8_t,
        9 as ::core::ffi::c_int as uint8_t,
        9 as ::core::ffi::c_int as uint8_t,
        9 as ::core::ffi::c_int as uint8_t,
        9 as ::core::ffi::c_int as uint8_t,
        9 as ::core::ffi::c_int as uint8_t,
        9 as ::core::ffi::c_int as uint8_t,
        9 as ::core::ffi::c_int as uint8_t,
        9 as ::core::ffi::c_int as uint8_t,
        9 as ::core::ffi::c_int as uint8_t,
        9 as ::core::ffi::c_int as uint8_t,
        9 as ::core::ffi::c_int as uint8_t,
        9 as ::core::ffi::c_int as uint8_t,
        9 as ::core::ffi::c_int as uint8_t,
        11 as ::core::ffi::c_int as uint8_t,
        11 as ::core::ffi::c_int as uint8_t,
        11 as ::core::ffi::c_int as uint8_t,
        11 as ::core::ffi::c_int as uint8_t,
        11 as ::core::ffi::c_int as uint8_t,
        11 as ::core::ffi::c_int as uint8_t,
        11 as ::core::ffi::c_int as uint8_t,
        11 as ::core::ffi::c_int as uint8_t,
        11 as ::core::ffi::c_int as uint8_t,
        11 as ::core::ffi::c_int as uint8_t,
        11 as ::core::ffi::c_int as uint8_t,
        11 as ::core::ffi::c_int as uint8_t,
        11 as ::core::ffi::c_int as uint8_t,
        11 as ::core::ffi::c_int as uint8_t,
        11 as ::core::ffi::c_int as uint8_t,
        11 as ::core::ffi::c_int as uint8_t,
        11 as ::core::ffi::c_int as uint8_t,
        11 as ::core::ffi::c_int as uint8_t,
        11 as ::core::ffi::c_int as uint8_t,
        11 as ::core::ffi::c_int as uint8_t,
        11 as ::core::ffi::c_int as uint8_t,
        11 as ::core::ffi::c_int as uint8_t,
        11 as ::core::ffi::c_int as uint8_t,
        11 as ::core::ffi::c_int as uint8_t,
        11 as ::core::ffi::c_int as uint8_t,
        11 as ::core::ffi::c_int as uint8_t,
        11 as ::core::ffi::c_int as uint8_t,
        11 as ::core::ffi::c_int as uint8_t,
        11 as ::core::ffi::c_int as uint8_t,
        11 as ::core::ffi::c_int as uint8_t,
        11 as ::core::ffi::c_int as uint8_t,
        11 as ::core::ffi::c_int as uint8_t,
        13 as ::core::ffi::c_int as uint8_t,
        13 as ::core::ffi::c_int as uint8_t,
        13 as ::core::ffi::c_int as uint8_t,
        13 as ::core::ffi::c_int as uint8_t,
        13 as ::core::ffi::c_int as uint8_t,
        13 as ::core::ffi::c_int as uint8_t,
        13 as ::core::ffi::c_int as uint8_t,
        13 as ::core::ffi::c_int as uint8_t,
        13 as ::core::ffi::c_int as uint8_t,
        13 as ::core::ffi::c_int as uint8_t,
        13 as ::core::ffi::c_int as uint8_t,
        13 as ::core::ffi::c_int as uint8_t,
        13 as ::core::ffi::c_int as uint8_t,
        13 as ::core::ffi::c_int as uint8_t,
        13 as ::core::ffi::c_int as uint8_t,
        13 as ::core::ffi::c_int as uint8_t,
        13 as ::core::ffi::c_int as uint8_t,
        13 as ::core::ffi::c_int as uint8_t,
        13 as ::core::ffi::c_int as uint8_t,
        13 as ::core::ffi::c_int as uint8_t,
        13 as ::core::ffi::c_int as uint8_t,
        13 as ::core::ffi::c_int as uint8_t,
        13 as ::core::ffi::c_int as uint8_t,
        13 as ::core::ffi::c_int as uint8_t,
        13 as ::core::ffi::c_int as uint8_t,
        13 as ::core::ffi::c_int as uint8_t,
        13 as ::core::ffi::c_int as uint8_t,
        13 as ::core::ffi::c_int as uint8_t,
        13 as ::core::ffi::c_int as uint8_t,
        13 as ::core::ffi::c_int as uint8_t,
        13 as ::core::ffi::c_int as uint8_t,
        13 as ::core::ffi::c_int as uint8_t,
        13 as ::core::ffi::c_int as uint8_t,
        13 as ::core::ffi::c_int as uint8_t,
        13 as ::core::ffi::c_int as uint8_t,
        13 as ::core::ffi::c_int as uint8_t,
        13 as ::core::ffi::c_int as uint8_t,
        13 as ::core::ffi::c_int as uint8_t,
        13 as ::core::ffi::c_int as uint8_t,
        13 as ::core::ffi::c_int as uint8_t,
        13 as ::core::ffi::c_int as uint8_t,
        13 as ::core::ffi::c_int as uint8_t,
        13 as ::core::ffi::c_int as uint8_t,
        13 as ::core::ffi::c_int as uint8_t,
        13 as ::core::ffi::c_int as uint8_t,
        13 as ::core::ffi::c_int as uint8_t,
        13 as ::core::ffi::c_int as uint8_t,
        13 as ::core::ffi::c_int as uint8_t,
        13 as ::core::ffi::c_int as uint8_t,
        13 as ::core::ffi::c_int as uint8_t,
        13 as ::core::ffi::c_int as uint8_t,
        13 as ::core::ffi::c_int as uint8_t,
        13 as ::core::ffi::c_int as uint8_t,
        13 as ::core::ffi::c_int as uint8_t,
        13 as ::core::ffi::c_int as uint8_t,
        13 as ::core::ffi::c_int as uint8_t,
        13 as ::core::ffi::c_int as uint8_t,
        13 as ::core::ffi::c_int as uint8_t,
        13 as ::core::ffi::c_int as uint8_t,
        13 as ::core::ffi::c_int as uint8_t,
        13 as ::core::ffi::c_int as uint8_t,
        13 as ::core::ffi::c_int as uint8_t,
        13 as ::core::ffi::c_int as uint8_t,
        13 as ::core::ffi::c_int as uint8_t,
        15 as ::core::ffi::c_int as uint8_t,
        15 as ::core::ffi::c_int as uint8_t,
        15 as ::core::ffi::c_int as uint8_t,
        15 as ::core::ffi::c_int as uint8_t,
        15 as ::core::ffi::c_int as uint8_t,
        15 as ::core::ffi::c_int as uint8_t,
        15 as ::core::ffi::c_int as uint8_t,
        15 as ::core::ffi::c_int as uint8_t,
        15 as ::core::ffi::c_int as uint8_t,
        15 as ::core::ffi::c_int as uint8_t,
        15 as ::core::ffi::c_int as uint8_t,
        15 as ::core::ffi::c_int as uint8_t,
        15 as ::core::ffi::c_int as uint8_t,
        15 as ::core::ffi::c_int as uint8_t,
        15 as ::core::ffi::c_int as uint8_t,
        15 as ::core::ffi::c_int as uint8_t,
        15 as ::core::ffi::c_int as uint8_t,
        15 as ::core::ffi::c_int as uint8_t,
        15 as ::core::ffi::c_int as uint8_t,
        15 as ::core::ffi::c_int as uint8_t,
        15 as ::core::ffi::c_int as uint8_t,
        15 as ::core::ffi::c_int as uint8_t,
        15 as ::core::ffi::c_int as uint8_t,
        15 as ::core::ffi::c_int as uint8_t,
        15 as ::core::ffi::c_int as uint8_t,
        15 as ::core::ffi::c_int as uint8_t,
        15 as ::core::ffi::c_int as uint8_t,
        15 as ::core::ffi::c_int as uint8_t,
        15 as ::core::ffi::c_int as uint8_t,
        15 as ::core::ffi::c_int as uint8_t,
        15 as ::core::ffi::c_int as uint8_t,
        15 as ::core::ffi::c_int as uint8_t,
        15 as ::core::ffi::c_int as uint8_t,
        15 as ::core::ffi::c_int as uint8_t,
        15 as ::core::ffi::c_int as uint8_t,
        15 as ::core::ffi::c_int as uint8_t,
        15 as ::core::ffi::c_int as uint8_t,
        15 as ::core::ffi::c_int as uint8_t,
        15 as ::core::ffi::c_int as uint8_t,
        15 as ::core::ffi::c_int as uint8_t,
        15 as ::core::ffi::c_int as uint8_t,
        15 as ::core::ffi::c_int as uint8_t,
        15 as ::core::ffi::c_int as uint8_t,
        15 as ::core::ffi::c_int as uint8_t,
        15 as ::core::ffi::c_int as uint8_t,
        15 as ::core::ffi::c_int as uint8_t,
        15 as ::core::ffi::c_int as uint8_t,
        15 as ::core::ffi::c_int as uint8_t,
        15 as ::core::ffi::c_int as uint8_t,
        15 as ::core::ffi::c_int as uint8_t,
        15 as ::core::ffi::c_int as uint8_t,
        15 as ::core::ffi::c_int as uint8_t,
        15 as ::core::ffi::c_int as uint8_t,
        15 as ::core::ffi::c_int as uint8_t,
        15 as ::core::ffi::c_int as uint8_t,
        15 as ::core::ffi::c_int as uint8_t,
        15 as ::core::ffi::c_int as uint8_t,
        15 as ::core::ffi::c_int as uint8_t,
        15 as ::core::ffi::c_int as uint8_t,
        15 as ::core::ffi::c_int as uint8_t,
        15 as ::core::ffi::c_int as uint8_t,
        15 as ::core::ffi::c_int as uint8_t,
        15 as ::core::ffi::c_int as uint8_t,
        15 as ::core::ffi::c_int as uint8_t,
        15 as ::core::ffi::c_int as uint8_t,
        15 as ::core::ffi::c_int as uint8_t,
        15 as ::core::ffi::c_int as uint8_t,
        15 as ::core::ffi::c_int as uint8_t,
        15 as ::core::ffi::c_int as uint8_t,
        15 as ::core::ffi::c_int as uint8_t,
        15 as ::core::ffi::c_int as uint8_t,
        15 as ::core::ffi::c_int as uint8_t,
        15 as ::core::ffi::c_int as uint8_t,
        15 as ::core::ffi::c_int as uint8_t,
        15 as ::core::ffi::c_int as uint8_t,
        15 as ::core::ffi::c_int as uint8_t,
        15 as ::core::ffi::c_int as uint8_t,
        15 as ::core::ffi::c_int as uint8_t,
        15 as ::core::ffi::c_int as uint8_t,
        15 as ::core::ffi::c_int as uint8_t,
        15 as ::core::ffi::c_int as uint8_t,
        15 as ::core::ffi::c_int as uint8_t,
        15 as ::core::ffi::c_int as uint8_t,
        15 as ::core::ffi::c_int as uint8_t,
        15 as ::core::ffi::c_int as uint8_t,
        15 as ::core::ffi::c_int as uint8_t,
        15 as ::core::ffi::c_int as uint8_t,
        15 as ::core::ffi::c_int as uint8_t,
        15 as ::core::ffi::c_int as uint8_t,
        15 as ::core::ffi::c_int as uint8_t,
        15 as ::core::ffi::c_int as uint8_t,
        15 as ::core::ffi::c_int as uint8_t,
        15 as ::core::ffi::c_int as uint8_t,
        15 as ::core::ffi::c_int as uint8_t,
        15 as ::core::ffi::c_int as uint8_t,
        15 as ::core::ffi::c_int as uint8_t,
        15 as ::core::ffi::c_int as uint8_t,
        15 as ::core::ffi::c_int as uint8_t,
        15 as ::core::ffi::c_int as uint8_t,
        15 as ::core::ffi::c_int as uint8_t,
        15 as ::core::ffi::c_int as uint8_t,
        15 as ::core::ffi::c_int as uint8_t,
        15 as ::core::ffi::c_int as uint8_t,
        15 as ::core::ffi::c_int as uint8_t,
        15 as ::core::ffi::c_int as uint8_t,
        15 as ::core::ffi::c_int as uint8_t,
        15 as ::core::ffi::c_int as uint8_t,
        15 as ::core::ffi::c_int as uint8_t,
        15 as ::core::ffi::c_int as uint8_t,
        15 as ::core::ffi::c_int as uint8_t,
        15 as ::core::ffi::c_int as uint8_t,
        15 as ::core::ffi::c_int as uint8_t,
        15 as ::core::ffi::c_int as uint8_t,
        15 as ::core::ffi::c_int as uint8_t,
        15 as ::core::ffi::c_int as uint8_t,
        15 as ::core::ffi::c_int as uint8_t,
        15 as ::core::ffi::c_int as uint8_t,
        15 as ::core::ffi::c_int as uint8_t,
        15 as ::core::ffi::c_int as uint8_t,
        15 as ::core::ffi::c_int as uint8_t,
        15 as ::core::ffi::c_int as uint8_t,
        15 as ::core::ffi::c_int as uint8_t,
        15 as ::core::ffi::c_int as uint8_t,
        15 as ::core::ffi::c_int as uint8_t,
        15 as ::core::ffi::c_int as uint8_t,
        15 as ::core::ffi::c_int as uint8_t,
        15 as ::core::ffi::c_int as uint8_t,
        15 as ::core::ffi::c_int as uint8_t,
    ];
    #[inline(always)]
    #[c2rust::src_loc = "278:1"]
    pub unsafe extern "C" fn bs_size_ue(mut val: ::core::ffi::c_uint) -> ::core::ffi::c_int {
        return x264_ue_size_tab[val.wrapping_add(1 as ::core::ffi::c_uint) as usize]
            as ::core::ffi::c_int;
    }
    #[inline(always)]
    #[c2rust::src_loc = "283:1"]
    pub unsafe extern "C" fn bs_size_ue_big(mut val: ::core::ffi::c_uint) -> ::core::ffi::c_int {
        if val < 255 as ::core::ffi::c_uint {
            return x264_ue_size_tab[val.wrapping_add(1 as ::core::ffi::c_uint) as usize]
                as ::core::ffi::c_int;
        } else {
            return x264_ue_size_tab
                [(val.wrapping_add(1 as ::core::ffi::c_uint) >> 8 as ::core::ffi::c_int) as usize]
                as ::core::ffi::c_int
                + 16 as ::core::ffi::c_int;
        };
    }
    #[inline(always)]
    #[c2rust::src_loc = "291:1"]
    pub unsafe extern "C" fn bs_size_se(mut val: ::core::ffi::c_int) -> ::core::ffi::c_int {
        let mut tmp: ::core::ffi::c_int = 1 as ::core::ffi::c_int - val * 2 as ::core::ffi::c_int;
        if tmp < 0 as ::core::ffi::c_int {
            tmp = val * 2 as ::core::ffi::c_int;
        }
        if tmp < 256 as ::core::ffi::c_int {
            return x264_ue_size_tab[tmp as usize] as ::core::ffi::c_int;
        } else {
            return x264_ue_size_tab[(tmp >> 8 as ::core::ffi::c_int) as usize]
                as ::core::ffi::c_int
                + 16 as ::core::ffi::c_int;
        };
    }
    #[inline(always)]
    #[c2rust::src_loc = "301:1"]
    pub unsafe extern "C" fn bs_size_te(
        mut x: ::core::ffi::c_int,
        mut val: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int {
        if x == 1 as ::core::ffi::c_int {
            return 1 as ::core::ffi::c_int;
        } else {
            return x264_ue_size_tab[(val + 1 as ::core::ffi::c_int) as usize]
                as ::core::ffi::c_int;
        };
    }
    use super::cabac_h::x264_cabac_t;
    use super::common_h::dctcoef;
    use super::stdint_h::{intptr_t, uintptr_t};
    use super::stdint_intn_h::int32_t;
    use super::stdint_uintn_h::{uint16_t, uint32_t, uint8_t};
    extern "C" {
        #[c2rust::src_loc = "78:20"]
        pub static mut x264_10_level_token: [[vlc_large_t; 128]; 7];
        #[c2rust::src_loc = "84:17"]
        pub static mut x264_10_run_before: [uint32_t; 65536];
    }

    #[inline]
    #[c2rust::src_loc = "86:1"]
    pub unsafe extern "C" fn bs_init(
        mut s: *mut bs_t,
        mut p_data: *mut ::core::ffi::c_void,
        mut i_data: ::core::ffi::c_int,
    ) {
        let mut offset: ::core::ffi::c_int =
            (p_data as intptr_t & 3 as intptr_t) as ::core::ffi::c_int;
        (*s).p_start = (p_data as *mut uint8_t).offset(-(offset as isize));
        (*s).p = (*s).p_start;
        (*s).p_end = (p_data as *mut uint8_t).offset(i_data as isize);
        (*s).i_left = WORD_SIZE
            .wrapping_sub(offset as uint64_t)
            .wrapping_mul(8 as uint64_t) as ::core::ffi::c_int;
        if offset != 0 {
            (*s).cur_bits = endian_fix32((*((*s).p as *mut x264_union32_t)).i) as uintptr_t;
            (*s).cur_bits >>= (4 as ::core::ffi::c_int - offset) * 8 as ::core::ffi::c_int;
        } else {
            (*s).cur_bits = 0 as uintptr_t;
        };
    }
    #[inline]
    #[c2rust::src_loc = "100:1"]
    pub unsafe extern "C" fn bs_pos(mut s: *mut bs_t) -> ::core::ffi::c_int {
        return ((8 as ::core::ffi::c_long * (*s).p.offset_from((*s).p_start) as ::core::ffi::c_long)
            as uint64_t)
            .wrapping_add(WORD_SIZE.wrapping_mul(8 as uint64_t))
            .wrapping_sub((*s).i_left as uint64_t) as ::core::ffi::c_int;
    }
    #[inline]
    #[c2rust::src_loc = "106:1"]
    pub unsafe extern "C" fn bs_flush(mut s: *mut bs_t) {
        (*((*s).p as *mut x264_union32_t)).i =
            endian_fix32(((*s).cur_bits << ((*s).i_left & 31 as ::core::ffi::c_int)) as uint32_t);
        (*s).p = (*s).p.offset(
            WORD_SIZE.wrapping_sub(((*s).i_left >> 3 as ::core::ffi::c_int) as uint64_t) as isize,
        );
        (*s).i_left = WORD_SIZE.wrapping_mul(8 as uint64_t) as ::core::ffi::c_int;
    }
    #[inline]
    #[c2rust::src_loc = "113:1"]
    pub unsafe extern "C" fn bs_realign(mut s: *mut bs_t) {
        let mut offset: ::core::ffi::c_int =
            ((*s).p as intptr_t & 3 as intptr_t) as ::core::ffi::c_int;
        if offset != 0 {
            (*s).p = (*s).p.offset(-(offset as isize));
            (*s).i_left = WORD_SIZE
                .wrapping_sub(offset as uint64_t)
                .wrapping_mul(8 as uint64_t) as ::core::ffi::c_int;
            (*s).cur_bits = endian_fix32((*((*s).p as *mut x264_union32_t)).i) as uintptr_t;
            (*s).cur_bits >>= (4 as ::core::ffi::c_int - offset) * 8 as ::core::ffi::c_int;
        }
    }
    #[inline]
    #[c2rust::src_loc = "125:1"]
    pub unsafe extern "C" fn bs_write(
        mut s: *mut bs_t,
        mut i_count: ::core::ffi::c_int,
        mut i_bits: uint32_t,
    ) {
        if WORD_SIZE == 8 as uint64_t {
            (*s).cur_bits = (*s).cur_bits << i_count | i_bits as uintptr_t;
            (*s).i_left -= i_count;
            if (*s).i_left <= 32 as ::core::ffi::c_int {
                (*((*s).p as *mut x264_union32_t)).i =
                    endian_fix((*s).cur_bits << (*s).i_left) as uint32_t;
                (*s).i_left += 32 as ::core::ffi::c_int;
                (*s).p = (*s).p.offset(4 as ::core::ffi::c_int as isize);
            }
        } else if i_count < (*s).i_left {
            (*s).cur_bits = (*s).cur_bits << i_count | i_bits as uintptr_t;
            (*s).i_left -= i_count;
        } else {
            i_count -= (*s).i_left;
            (*s).cur_bits = (*s).cur_bits << (*s).i_left | (i_bits >> i_count) as uintptr_t;
            (*((*s).p as *mut x264_union32_t)).i = endian_fix((*s).cur_bits) as uint32_t;
            (*s).p = (*s).p.offset(4 as ::core::ffi::c_int as isize);
            (*s).cur_bits = i_bits as uintptr_t;
            (*s).i_left = 32 as ::core::ffi::c_int - i_count;
        };
    }
    #[inline]
    #[c2rust::src_loc = "169:1"]
    pub unsafe extern "C" fn bs_write1(mut s: *mut bs_t, mut i_bit: uint32_t) {
        (*s).cur_bits <<= 1 as ::core::ffi::c_int;
        (*s).cur_bits |= i_bit as uintptr_t;
        (*s).i_left -= 1;
        if (*s).i_left as uint64_t
            == WORD_SIZE
                .wrapping_mul(8 as uint64_t)
                .wrapping_sub(32 as uint64_t)
        {
            (*((*s).p as *mut x264_union32_t)).i = endian_fix32((*s).cur_bits as uint32_t);
            (*s).p = (*s).p.offset(4 as ::core::ffi::c_int as isize);
            (*s).i_left = WORD_SIZE.wrapping_mul(8 as uint64_t) as ::core::ffi::c_int;
        }
    }
    #[inline]
    #[c2rust::src_loc = "187:1"]
    pub unsafe extern "C" fn bs_align_1(mut s: *mut bs_t) {
        bs_write(
            s,
            (*s).i_left & 7 as ::core::ffi::c_int,
            (((1 as ::core::ffi::c_int) << ((*s).i_left & 7 as ::core::ffi::c_int))
                - 1 as ::core::ffi::c_int) as uint32_t,
        );
        bs_flush(s);
    }
    #[inline]
    #[c2rust::src_loc = "221:1"]
    pub unsafe extern "C" fn bs_write_ue_big(mut s: *mut bs_t, mut val: ::core::ffi::c_uint) {
        let mut size: ::core::ffi::c_int = 0 as ::core::ffi::c_int;
        val = val.wrapping_add(1);
        let mut tmp: ::core::ffi::c_int = val as ::core::ffi::c_int;
        if tmp >= 0x10000 as ::core::ffi::c_int {
            size = 32 as ::core::ffi::c_int;
            tmp >>= 16 as ::core::ffi::c_int;
        }
        if tmp >= 0x100 as ::core::ffi::c_int {
            size += 16 as ::core::ffi::c_int;
            tmp >>= 8 as ::core::ffi::c_int;
        }
        size += x264_ue_size_tab[tmp as usize] as ::core::ffi::c_int;
        bs_write(s, size >> 1 as ::core::ffi::c_int, 0 as uint32_t);
        bs_write(
            s,
            (size >> 1 as ::core::ffi::c_int) + 1 as ::core::ffi::c_int,
            val as uint32_t,
        );
    }
    #[inline]
    #[c2rust::src_loc = "246:1"]
    pub unsafe extern "C" fn bs_write_se(mut s: *mut bs_t, mut val: ::core::ffi::c_int) {
        let mut size: ::core::ffi::c_int = 0 as ::core::ffi::c_int;
        let mut tmp: ::core::ffi::c_int = 1 as ::core::ffi::c_int - val * 2 as ::core::ffi::c_int;
        if tmp < 0 as ::core::ffi::c_int {
            tmp = val * 2 as ::core::ffi::c_int;
        }
        val = tmp;
        if tmp >= 0x100 as ::core::ffi::c_int {
            size = 16 as ::core::ffi::c_int;
            tmp >>= 8 as ::core::ffi::c_int;
        }
        size += x264_ue_size_tab[tmp as usize] as ::core::ffi::c_int;
        bs_write(s, size, val as uint32_t);
    }
    #[inline]
    #[c2rust::src_loc = "272:1"]
    pub unsafe extern "C" fn bs_rbsp_trailing(mut s: *mut bs_t) {
        bs_write1(s, 1 as uint32_t);
        bs_write(s, (*s).i_left & 7 as ::core::ffi::c_int, 0 as uint32_t);
    }
    use super::base_h::x264_union32_t;
    use super::osdep_h::{endian_fix, endian_fix32, WORD_SIZE};
    use super::stdint_uintn_h::uint64_t;
    extern "C" {
        #[c2rust::src_loc = "69:1"]
        pub fn x264_10_bitstream_init(cpu: uint32_t, pf: *mut x264_bitstream_function_t);
    }
}
#[c2rust::header_src = "/home/nwplayer123/Hacks/hex264/x264/common/cabac.h:28"]
pub mod cabac_h {
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "30:9"]
    pub struct x264_cabac_t {
        pub i_low: ::core::ffi::c_int,
        pub i_range: ::core::ffi::c_int,
        pub i_queue: ::core::ffi::c_int,
        pub i_bytes_outstanding: ::core::ffi::c_int,
        pub p_start: *mut uint8_t,
        pub p: *mut uint8_t,
        pub p_end: *mut uint8_t,
        pub f8_bits_encoded: ::core::ffi::c_int,
        pub state: [uint8_t; 1024],
        pub padding: [uint8_t; 12],
    }
    #[inline(always)]
    #[c2rust::src_loc = "101:1"]
    pub unsafe extern "C" fn x264_cabac_size_decision(
        mut cb: *mut x264_cabac_t,
        mut i_ctx: ::core::ffi::c_long,
        mut b: ::core::ffi::c_long,
    ) {
        let mut i_state: ::core::ffi::c_int = (*cb).state[i_ctx as usize] as ::core::ffi::c_int;
        (*cb).state[i_ctx as usize] = x264_cabac_transition[i_state as usize][b as usize];
        (*cb).f8_bits_encoded +=
            x264_cabac_entropy[(i_state as ::core::ffi::c_long ^ b) as usize] as ::core::ffi::c_int;
    }
    #[inline(always)]
    #[c2rust::src_loc = "108:1"]
    pub unsafe extern "C" fn x264_cabac_size_decision2(
        mut state: *mut uint8_t,
        mut b: ::core::ffi::c_long,
    ) -> ::core::ffi::c_int {
        let mut i_state: ::core::ffi::c_int = *state as ::core::ffi::c_int;
        *state = x264_cabac_transition[i_state as usize][b as usize];
        return x264_cabac_entropy[(i_state as ::core::ffi::c_long ^ b) as usize]
            as ::core::ffi::c_int;
    }
    #[inline(always)]
    #[c2rust::src_loc = "115:1"]
    pub unsafe extern "C" fn x264_cabac_size_decision_noup(
        mut cb: *mut x264_cabac_t,
        mut i_ctx: ::core::ffi::c_long,
        mut b: ::core::ffi::c_long,
    ) {
        let mut i_state: ::core::ffi::c_int = (*cb).state[i_ctx as usize] as ::core::ffi::c_int;
        (*cb).f8_bits_encoded +=
            x264_cabac_entropy[(i_state as ::core::ffi::c_long ^ b) as usize] as ::core::ffi::c_int;
    }
    #[inline(always)]
    #[c2rust::src_loc = "121:1"]
    pub unsafe extern "C" fn x264_cabac_size_decision_noup2(
        mut state: *mut uint8_t,
        mut b: ::core::ffi::c_long,
    ) -> ::core::ffi::c_int {
        return x264_cabac_entropy[(*state as ::core::ffi::c_long ^ b) as usize]
            as ::core::ffi::c_int;
    }
    use super::stdint_uintn_h::{uint16_t, uint8_t};
    use super::tables_h::{x264_cabac_entropy, x264_cabac_transition};
    #[inline(always)]
    #[c2rust::src_loc = "94:1"]
    pub unsafe extern "C" fn x264_cabac_pos(mut cb: *mut x264_cabac_t) -> ::core::ffi::c_int {
        return (((*cb).p.offset_from((*cb).p_start) as ::core::ffi::c_long
            + (*cb).i_bytes_outstanding as ::core::ffi::c_long)
            * 8 as ::core::ffi::c_long
            + (*cb).i_queue as ::core::ffi::c_long) as ::core::ffi::c_int;
    }
    use super::common_h::x264_t;
    extern "C" {
        #[c2rust::src_loc = "56:1"]
        pub fn x264_10_cabac_context_init(
            h: *mut x264_t,
            cb: *mut x264_cabac_t,
            i_slice_type: ::core::ffi::c_int,
            i_qp: ::core::ffi::c_int,
            i_model: ::core::ffi::c_int,
        );
        #[c2rust::src_loc = "61:1"]
        pub fn x264_10_cabac_encode_init(
            cb: *mut x264_cabac_t,
            p_data: *mut uint8_t,
            p_end: *mut uint8_t,
        );
        #[c2rust::src_loc = "71:1"]
        pub fn x264_10_cabac_encode_terminal_c(cb: *mut x264_cabac_t);
        #[c2rust::src_loc = "77:1"]
        pub fn x264_10_cabac_encode_flush(h: *mut x264_t, cb: *mut x264_cabac_t);
    }
}
#[c2rust::header_src = "/home/nwplayer123/Hacks/hex264/x264/common/quant.h:28"]
pub mod quant_h {
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "30:9"]
    pub struct x264_quant_function_t {
        pub quant_8x8: Option<
            unsafe extern "C" fn(*mut dctcoef, *mut udctcoef, *mut udctcoef) -> ::core::ffi::c_int,
        >,
        pub quant_4x4: Option<
            unsafe extern "C" fn(*mut dctcoef, *mut udctcoef, *mut udctcoef) -> ::core::ffi::c_int,
        >,
        pub quant_4x4x4: Option<
            unsafe extern "C" fn(
                *mut [dctcoef; 16],
                *mut udctcoef,
                *mut udctcoef,
            ) -> ::core::ffi::c_int,
        >,
        pub quant_4x4_dc: Option<
            unsafe extern "C" fn(
                *mut dctcoef,
                ::core::ffi::c_int,
                ::core::ffi::c_int,
            ) -> ::core::ffi::c_int,
        >,
        pub quant_2x2_dc: Option<
            unsafe extern "C" fn(
                *mut dctcoef,
                ::core::ffi::c_int,
                ::core::ffi::c_int,
            ) -> ::core::ffi::c_int,
        >,
        pub dequant_8x8: Option<
            unsafe extern "C" fn(
                *mut dctcoef,
                *mut [::core::ffi::c_int; 64],
                ::core::ffi::c_int,
            ) -> (),
        >,
        pub dequant_4x4: Option<
            unsafe extern "C" fn(
                *mut dctcoef,
                *mut [::core::ffi::c_int; 16],
                ::core::ffi::c_int,
            ) -> (),
        >,
        pub dequant_4x4_dc: Option<
            unsafe extern "C" fn(
                *mut dctcoef,
                *mut [::core::ffi::c_int; 16],
                ::core::ffi::c_int,
            ) -> (),
        >,
        pub idct_dequant_2x4_dc: Option<
            unsafe extern "C" fn(
                *mut dctcoef,
                *mut [dctcoef; 16],
                *mut [::core::ffi::c_int; 16],
                ::core::ffi::c_int,
            ) -> (),
        >,
        pub idct_dequant_2x4_dconly: Option<
            unsafe extern "C" fn(
                *mut dctcoef,
                *mut [::core::ffi::c_int; 16],
                ::core::ffi::c_int,
            ) -> (),
        >,
        pub optimize_chroma_2x2_dc:
            Option<unsafe extern "C" fn(*mut dctcoef, ::core::ffi::c_int) -> ::core::ffi::c_int>,
        pub optimize_chroma_2x4_dc:
            Option<unsafe extern "C" fn(*mut dctcoef, ::core::ffi::c_int) -> ::core::ffi::c_int>,
        pub denoise_dct: Option<
            unsafe extern "C" fn(
                *mut dctcoef,
                *mut uint32_t,
                *mut udctcoef,
                ::core::ffi::c_int,
            ) -> (),
        >,
        pub decimate_score15: Option<unsafe extern "C" fn(*mut dctcoef) -> ::core::ffi::c_int>,
        pub decimate_score16: Option<unsafe extern "C" fn(*mut dctcoef) -> ::core::ffi::c_int>,
        pub decimate_score64: Option<unsafe extern "C" fn(*mut dctcoef) -> ::core::ffi::c_int>,
        pub coeff_last: [Option<unsafe extern "C" fn(*mut dctcoef) -> ::core::ffi::c_int>; 14],
        pub coeff_last4: Option<unsafe extern "C" fn(*mut dctcoef) -> ::core::ffi::c_int>,
        pub coeff_last8: Option<unsafe extern "C" fn(*mut dctcoef) -> ::core::ffi::c_int>,
        pub coeff_level_run: [Option<
            unsafe extern "C" fn(*mut dctcoef, *mut x264_run_level_t) -> ::core::ffi::c_int,
        >; 13],
        pub coeff_level_run4:
            Option<unsafe extern "C" fn(*mut dctcoef, *mut x264_run_level_t) -> ::core::ffi::c_int>,
        pub coeff_level_run8:
            Option<unsafe extern "C" fn(*mut dctcoef, *mut x264_run_level_t) -> ::core::ffi::c_int>,
        pub trellis_cabac_4x4: Option<
            unsafe extern "C" fn(
                *const ::core::ffi::c_int,
                *const uint8_t,
                ::core::ffi::c_int,
                ::core::ffi::c_int,
                *mut dctcoef,
                *mut dctcoef,
                *mut dctcoef,
                *mut uint8_t,
                *mut uint8_t,
                uint64_t,
                uint16_t,
                ::core::ffi::c_int,
            ) -> ::core::ffi::c_int,
        >,
        pub trellis_cabac_8x8: Option<
            unsafe extern "C" fn(
                *const ::core::ffi::c_int,
                *const uint8_t,
                ::core::ffi::c_int,
                ::core::ffi::c_int,
                *mut dctcoef,
                *mut dctcoef,
                *mut dctcoef,
                *mut uint8_t,
                *mut uint8_t,
                uint64_t,
                uint16_t,
                ::core::ffi::c_int,
            ) -> ::core::ffi::c_int,
        >,
        pub trellis_cabac_4x4_psy: Option<
            unsafe extern "C" fn(
                *const ::core::ffi::c_int,
                *const uint8_t,
                ::core::ffi::c_int,
                ::core::ffi::c_int,
                *mut dctcoef,
                *mut dctcoef,
                *mut dctcoef,
                *mut uint8_t,
                *mut uint8_t,
                uint64_t,
                uint16_t,
                ::core::ffi::c_int,
                *mut dctcoef,
                ::core::ffi::c_int,
            ) -> ::core::ffi::c_int,
        >,
        pub trellis_cabac_8x8_psy: Option<
            unsafe extern "C" fn(
                *const ::core::ffi::c_int,
                *const uint8_t,
                ::core::ffi::c_int,
                ::core::ffi::c_int,
                *mut dctcoef,
                *mut dctcoef,
                *mut dctcoef,
                *mut uint8_t,
                *mut uint8_t,
                uint64_t,
                uint16_t,
                ::core::ffi::c_int,
                *mut dctcoef,
                ::core::ffi::c_int,
            ) -> ::core::ffi::c_int,
        >,
        pub trellis_cabac_dc: Option<
            unsafe extern "C" fn(
                *const ::core::ffi::c_int,
                *const uint8_t,
                ::core::ffi::c_int,
                ::core::ffi::c_int,
                *mut dctcoef,
                *mut dctcoef,
                *mut dctcoef,
                *mut uint8_t,
                *mut uint8_t,
                uint64_t,
                uint16_t,
                ::core::ffi::c_int,
            ) -> ::core::ffi::c_int,
        >,
        pub trellis_cabac_chroma_422_dc: Option<
            unsafe extern "C" fn(
                *const ::core::ffi::c_int,
                *const uint8_t,
                ::core::ffi::c_int,
                ::core::ffi::c_int,
                *mut dctcoef,
                *mut dctcoef,
                *mut dctcoef,
                *mut uint8_t,
                *mut uint8_t,
                uint64_t,
                uint16_t,
            ) -> ::core::ffi::c_int,
        >,
    }
    use super::bitstream_h::x264_run_level_t;
    use super::common_h::{dctcoef, udctcoef};
    use super::stdint_uintn_h::{uint16_t, uint32_t, uint64_t, uint8_t};

    use super::common_h::x264_t;
    extern "C" {
        #[c2rust::src_loc = "73:1"]
        pub fn x264_10_quant_init(h: *mut x264_t, cpu: uint32_t, pf: *mut x264_quant_function_t);
    }
}
#[c2rust::header_src = "/home/nwplayer123/Hacks/hex264/x264/common/dct.h:28"]
pub mod dct_h {
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "61:9"]
    pub struct x264_zigzag_function_t {
        pub scan_8x8: Option<unsafe extern "C" fn(*mut dctcoef, *mut dctcoef) -> ()>,
        pub scan_4x4: Option<unsafe extern "C" fn(*mut dctcoef, *mut dctcoef) -> ()>,
        pub sub_8x8: Option<
            unsafe extern "C" fn(*mut dctcoef, *const pixel, *mut pixel) -> ::core::ffi::c_int,
        >,
        pub sub_4x4: Option<
            unsafe extern "C" fn(*mut dctcoef, *const pixel, *mut pixel) -> ::core::ffi::c_int,
        >,
        pub sub_4x4ac: Option<
            unsafe extern "C" fn(
                *mut dctcoef,
                *const pixel,
                *mut pixel,
                *mut dctcoef,
            ) -> ::core::ffi::c_int,
        >,
        pub interleave_8x8_cavlc:
            Option<unsafe extern "C" fn(*mut dctcoef, *mut dctcoef, *mut uint8_t) -> ()>,
    }
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "29:9"]
    pub struct x264_dct_function_t {
        pub sub4x4_dct: Option<unsafe extern "C" fn(*mut dctcoef, *mut pixel, *mut pixel) -> ()>,
        pub add4x4_idct: Option<unsafe extern "C" fn(*mut pixel, *mut dctcoef) -> ()>,
        pub sub8x8_dct:
            Option<unsafe extern "C" fn(*mut [dctcoef; 16], *mut pixel, *mut pixel) -> ()>,
        pub sub8x8_dct_dc: Option<unsafe extern "C" fn(*mut dctcoef, *mut pixel, *mut pixel) -> ()>,
        pub add8x8_idct: Option<unsafe extern "C" fn(*mut pixel, *mut [dctcoef; 16]) -> ()>,
        pub add8x8_idct_dc: Option<unsafe extern "C" fn(*mut pixel, *mut dctcoef) -> ()>,
        pub sub8x16_dct_dc:
            Option<unsafe extern "C" fn(*mut dctcoef, *mut pixel, *mut pixel) -> ()>,
        pub sub16x16_dct:
            Option<unsafe extern "C" fn(*mut [dctcoef; 16], *mut pixel, *mut pixel) -> ()>,
        pub add16x16_idct: Option<unsafe extern "C" fn(*mut pixel, *mut [dctcoef; 16]) -> ()>,
        pub add16x16_idct_dc: Option<unsafe extern "C" fn(*mut pixel, *mut dctcoef) -> ()>,
        pub sub8x8_dct8: Option<unsafe extern "C" fn(*mut dctcoef, *mut pixel, *mut pixel) -> ()>,
        pub add8x8_idct8: Option<unsafe extern "C" fn(*mut pixel, *mut dctcoef) -> ()>,
        pub sub16x16_dct8:
            Option<unsafe extern "C" fn(*mut [dctcoef; 64], *mut pixel, *mut pixel) -> ()>,
        pub add16x16_idct8: Option<unsafe extern "C" fn(*mut pixel, *mut [dctcoef; 64]) -> ()>,
        pub dct4x4dc: Option<unsafe extern "C" fn(*mut dctcoef) -> ()>,
        pub idct4x4dc: Option<unsafe extern "C" fn(*mut dctcoef) -> ()>,
        pub dct2x4dc: Option<unsafe extern "C" fn(*mut dctcoef, *mut [dctcoef; 16]) -> ()>,
    }
    use super::common_h::{dctcoef, pixel};
    use super::stdint_uintn_h::uint32_t;
    use super::stdint_uintn_h::uint8_t;
    extern "C" {
        #[c2rust::src_loc = "73:1"]
        pub fn x264_10_dct_init(cpu: uint32_t, dctf: *mut x264_dct_function_t);
        #[c2rust::src_loc = "75:1"]
        pub fn x264_10_zigzag_init(
            cpu: uint32_t,
            pf_progressive: *mut x264_zigzag_function_t,
            pf_interlaced: *mut x264_zigzag_function_t,
        );
    }
}
#[c2rust::header_src = "/home/nwplayer123/Hacks/hex264/x264/common/pixel.h:28"]
pub mod pixel_h {
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "78:9"]
    pub struct x264_pixel_function_t {
        pub sad: [x264_pixel_cmp_t; 8],
        pub ssd: [x264_pixel_cmp_t; 8],
        pub satd: [x264_pixel_cmp_t; 8],
        pub ssim: [x264_pixel_cmp_t; 7],
        pub sa8d: [x264_pixel_cmp_t; 4],
        pub mbcmp: [x264_pixel_cmp_t; 8],
        pub mbcmp_unaligned: [x264_pixel_cmp_t; 8],
        pub fpelcmp: [x264_pixel_cmp_t; 8],
        pub fpelcmp_x3: [x264_pixel_cmp_x3_t; 7],
        pub fpelcmp_x4: [x264_pixel_cmp_x4_t; 7],
        pub sad_aligned: [x264_pixel_cmp_t; 8],
        pub vsad: Option<
            unsafe extern "C" fn(*mut pixel, intptr_t, ::core::ffi::c_int) -> ::core::ffi::c_int,
        >,
        pub asd8: Option<
            unsafe extern "C" fn(
                *mut pixel,
                intptr_t,
                *mut pixel,
                intptr_t,
                ::core::ffi::c_int,
            ) -> ::core::ffi::c_int,
        >,
        pub sa8d_satd: [Option<
            unsafe extern "C" fn(*mut pixel, intptr_t, *mut pixel, intptr_t) -> uint64_t,
        >; 1],
        pub var: [Option<unsafe extern "C" fn(*mut pixel, intptr_t) -> uint64_t>; 4],
        pub var2: [Option<
            unsafe extern "C" fn(
                *mut pixel,
                *mut pixel,
                *mut ::core::ffi::c_int,
            ) -> ::core::ffi::c_int,
        >; 4],
        pub hadamard_ac: [Option<unsafe extern "C" fn(*mut pixel, intptr_t) -> uint64_t>; 4],
        pub ssd_nv12_core: Option<
            unsafe extern "C" fn(
                *mut pixel,
                intptr_t,
                *mut pixel,
                intptr_t,
                ::core::ffi::c_int,
                ::core::ffi::c_int,
                *mut uint64_t,
                *mut uint64_t,
            ) -> (),
        >,
        pub ssim_4x4x2_core: Option<
            unsafe extern "C" fn(
                *const pixel,
                intptr_t,
                *const pixel,
                intptr_t,
                *mut [::core::ffi::c_int; 4],
            ) -> (),
        >,
        pub ssim_end4: Option<
            unsafe extern "C" fn(
                *mut [::core::ffi::c_int; 4],
                *mut [::core::ffi::c_int; 4],
                ::core::ffi::c_int,
            ) -> ::core::ffi::c_float,
        >,
        pub sad_x3: [x264_pixel_cmp_x3_t; 7],
        pub sad_x4: [x264_pixel_cmp_x4_t; 7],
        pub satd_x3: [x264_pixel_cmp_x3_t; 7],
        pub satd_x4: [x264_pixel_cmp_x4_t; 7],
        pub ads: [Option<
            unsafe extern "C" fn(
                *mut ::core::ffi::c_int,
                *mut uint16_t,
                ::core::ffi::c_int,
                *mut uint16_t,
                *mut int16_t,
                ::core::ffi::c_int,
                ::core::ffi::c_int,
            ) -> ::core::ffi::c_int,
        >; 7],
        pub intra_mbcmp_x3_16x16:
            Option<unsafe extern "C" fn(*mut pixel, *mut pixel, *mut ::core::ffi::c_int) -> ()>,
        pub intra_satd_x3_16x16:
            Option<unsafe extern "C" fn(*mut pixel, *mut pixel, *mut ::core::ffi::c_int) -> ()>,
        pub intra_sad_x3_16x16:
            Option<unsafe extern "C" fn(*mut pixel, *mut pixel, *mut ::core::ffi::c_int) -> ()>,
        pub intra_mbcmp_x3_4x4:
            Option<unsafe extern "C" fn(*mut pixel, *mut pixel, *mut ::core::ffi::c_int) -> ()>,
        pub intra_satd_x3_4x4:
            Option<unsafe extern "C" fn(*mut pixel, *mut pixel, *mut ::core::ffi::c_int) -> ()>,
        pub intra_sad_x3_4x4:
            Option<unsafe extern "C" fn(*mut pixel, *mut pixel, *mut ::core::ffi::c_int) -> ()>,
        pub intra_mbcmp_x3_chroma:
            Option<unsafe extern "C" fn(*mut pixel, *mut pixel, *mut ::core::ffi::c_int) -> ()>,
        pub intra_satd_x3_chroma:
            Option<unsafe extern "C" fn(*mut pixel, *mut pixel, *mut ::core::ffi::c_int) -> ()>,
        pub intra_sad_x3_chroma:
            Option<unsafe extern "C" fn(*mut pixel, *mut pixel, *mut ::core::ffi::c_int) -> ()>,
        pub intra_mbcmp_x3_8x16c:
            Option<unsafe extern "C" fn(*mut pixel, *mut pixel, *mut ::core::ffi::c_int) -> ()>,
        pub intra_satd_x3_8x16c:
            Option<unsafe extern "C" fn(*mut pixel, *mut pixel, *mut ::core::ffi::c_int) -> ()>,
        pub intra_sad_x3_8x16c:
            Option<unsafe extern "C" fn(*mut pixel, *mut pixel, *mut ::core::ffi::c_int) -> ()>,
        pub intra_mbcmp_x3_8x8c:
            Option<unsafe extern "C" fn(*mut pixel, *mut pixel, *mut ::core::ffi::c_int) -> ()>,
        pub intra_satd_x3_8x8c:
            Option<unsafe extern "C" fn(*mut pixel, *mut pixel, *mut ::core::ffi::c_int) -> ()>,
        pub intra_sad_x3_8x8c:
            Option<unsafe extern "C" fn(*mut pixel, *mut pixel, *mut ::core::ffi::c_int) -> ()>,
        pub intra_mbcmp_x3_8x8:
            Option<unsafe extern "C" fn(*mut pixel, *mut pixel, *mut ::core::ffi::c_int) -> ()>,
        pub intra_sa8d_x3_8x8:
            Option<unsafe extern "C" fn(*mut pixel, *mut pixel, *mut ::core::ffi::c_int) -> ()>,
        pub intra_sad_x3_8x8:
            Option<unsafe extern "C" fn(*mut pixel, *mut pixel, *mut ::core::ffi::c_int) -> ()>,
        pub intra_mbcmp_x9_4x4: Option<
            unsafe extern "C" fn(*mut pixel, *mut pixel, *mut uint16_t) -> ::core::ffi::c_int,
        >,
        pub intra_satd_x9_4x4: Option<
            unsafe extern "C" fn(*mut pixel, *mut pixel, *mut uint16_t) -> ::core::ffi::c_int,
        >,
        pub intra_sad_x9_4x4: Option<
            unsafe extern "C" fn(*mut pixel, *mut pixel, *mut uint16_t) -> ::core::ffi::c_int,
        >,
        pub intra_mbcmp_x9_8x8: Option<
            unsafe extern "C" fn(
                *mut pixel,
                *mut pixel,
                *mut pixel,
                *mut uint16_t,
                *mut uint16_t,
            ) -> ::core::ffi::c_int,
        >,
        pub intra_sa8d_x9_8x8: Option<
            unsafe extern "C" fn(
                *mut pixel,
                *mut pixel,
                *mut pixel,
                *mut uint16_t,
                *mut uint16_t,
            ) -> ::core::ffi::c_int,
        >,
        pub intra_sad_x9_8x8: Option<
            unsafe extern "C" fn(
                *mut pixel,
                *mut pixel,
                *mut pixel,
                *mut uint16_t,
                *mut uint16_t,
            ) -> ::core::ffi::c_int,
        >,
    }
    #[c2rust::src_loc = "35:1"]
    pub type x264_pixel_cmp_x4_t = Option<
        unsafe extern "C" fn(
            *mut pixel,
            *mut pixel,
            *mut pixel,
            *mut pixel,
            *mut pixel,
            intptr_t,
            *mut ::core::ffi::c_int,
        ) -> (),
    >;
    #[c2rust::src_loc = "34:1"]
    pub type x264_pixel_cmp_x3_t = Option<
        unsafe extern "C" fn(
            *mut pixel,
            *mut pixel,
            *mut pixel,
            *mut pixel,
            intptr_t,
            *mut ::core::ffi::c_int,
        ) -> (),
    >;
    #[c2rust::src_loc = "33:1"]
    pub type x264_pixel_cmp_t = Option<
        unsafe extern "C" fn(*mut pixel, intptr_t, *mut pixel, intptr_t) -> ::core::ffi::c_int,
    >;
    #[c2rust::src_loc = "37:1"]
    pub type C2RustUnnamed_19 = ::core::ffi::c_uint;
    #[c2rust::src_loc = "52:5"]
    pub const PIXEL_2x2: C2RustUnnamed_19 = 11;
    #[c2rust::src_loc = "51:5"]
    pub const PIXEL_2x4: C2RustUnnamed_19 = 10;
    #[c2rust::src_loc = "50:5"]
    pub const PIXEL_2x8: C2RustUnnamed_19 = 9;
    #[c2rust::src_loc = "49:5"]
    pub const PIXEL_4x2: C2RustUnnamed_19 = 8;
    #[c2rust::src_loc = "48:5"]
    pub const PIXEL_4x16: C2RustUnnamed_19 = 7;
    #[c2rust::src_loc = "45:5"]
    pub const PIXEL_4x4: C2RustUnnamed_19 = 6;
    #[c2rust::src_loc = "44:5"]
    pub const PIXEL_4x8: C2RustUnnamed_19 = 5;
    #[c2rust::src_loc = "43:5"]
    pub const PIXEL_8x4: C2RustUnnamed_19 = 4;
    #[c2rust::src_loc = "42:5"]
    pub const PIXEL_8x8: C2RustUnnamed_19 = 3;
    #[c2rust::src_loc = "41:5"]
    pub const PIXEL_8x16: C2RustUnnamed_19 = 2;
    #[c2rust::src_loc = "40:5"]
    pub const PIXEL_16x8: C2RustUnnamed_19 = 1;
    #[c2rust::src_loc = "39:5"]
    pub const PIXEL_16x16: C2RustUnnamed_19 = 0;
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "55:14"]
    pub struct C2RustUnnamed_20 {
        pub w: uint8_t,
        pub h: uint8_t,
    }
    #[c2rust::src_loc = "55:39"]
    pub static mut x264_pixel_size: [C2RustUnnamed_20; 12] = [
        {
            let mut init = C2RustUnnamed_20 {
                w: 16 as uint8_t,
                h: 16 as uint8_t,
            };
            init
        },
        {
            let mut init = C2RustUnnamed_20 {
                w: 16 as uint8_t,
                h: 8 as uint8_t,
            };
            init
        },
        {
            let mut init = C2RustUnnamed_20 {
                w: 8 as uint8_t,
                h: 16 as uint8_t,
            };
            init
        },
        {
            let mut init = C2RustUnnamed_20 {
                w: 8 as uint8_t,
                h: 8 as uint8_t,
            };
            init
        },
        {
            let mut init = C2RustUnnamed_20 {
                w: 8 as uint8_t,
                h: 4 as uint8_t,
            };
            init
        },
        {
            let mut init = C2RustUnnamed_20 {
                w: 4 as uint8_t,
                h: 8 as uint8_t,
            };
            init
        },
        {
            let mut init = C2RustUnnamed_20 {
                w: 4 as uint8_t,
                h: 4 as uint8_t,
            };
            init
        },
        {
            let mut init = C2RustUnnamed_20 {
                w: 4 as uint8_t,
                h: 16 as uint8_t,
            };
            init
        },
        {
            let mut init = C2RustUnnamed_20 {
                w: 4 as uint8_t,
                h: 2 as uint8_t,
            };
            init
        },
        {
            let mut init = C2RustUnnamed_20 {
                w: 2 as uint8_t,
                h: 8 as uint8_t,
            };
            init
        },
        {
            let mut init = C2RustUnnamed_20 {
                w: 2 as uint8_t,
                h: 4 as uint8_t,
            };
            init
        },
        {
            let mut init = C2RustUnnamed_20 {
                w: 2 as uint8_t,
                h: 2 as uint8_t,
            };
            init
        },
    ];
    use super::common_h::pixel;
    use super::stdint_h::intptr_t;
    use super::stdint_intn_h::int16_t;
    use super::stdint_uintn_h::{uint16_t, uint64_t, uint8_t};

    #[c2rust::src_loc = "70:22"]
    pub static mut x264_luma2chroma_pixel: [[uint8_t; 7]; 4] = [
        [0 as ::core::ffi::c_int as uint8_t, 0, 0, 0, 0, 0, 0],
        [
            PIXEL_8x8 as ::core::ffi::c_int as uint8_t,
            PIXEL_8x4 as ::core::ffi::c_int as uint8_t,
            PIXEL_4x8 as ::core::ffi::c_int as uint8_t,
            PIXEL_4x4 as ::core::ffi::c_int as uint8_t,
            PIXEL_4x2 as ::core::ffi::c_int as uint8_t,
            PIXEL_2x4 as ::core::ffi::c_int as uint8_t,
            PIXEL_2x2 as ::core::ffi::c_int as uint8_t,
        ],
        [
            PIXEL_8x16 as ::core::ffi::c_int as uint8_t,
            PIXEL_8x8 as ::core::ffi::c_int as uint8_t,
            PIXEL_4x16 as ::core::ffi::c_int as uint8_t,
            PIXEL_4x8 as ::core::ffi::c_int as uint8_t,
            PIXEL_4x4 as ::core::ffi::c_int as uint8_t,
            PIXEL_2x8 as ::core::ffi::c_int as uint8_t,
            PIXEL_2x4 as ::core::ffi::c_int as uint8_t,
        ],
        [
            PIXEL_16x16 as ::core::ffi::c_int as uint8_t,
            PIXEL_16x8 as ::core::ffi::c_int as uint8_t,
            PIXEL_8x16 as ::core::ffi::c_int as uint8_t,
            PIXEL_8x8 as ::core::ffi::c_int as uint8_t,
            PIXEL_8x4 as ::core::ffi::c_int as uint8_t,
            PIXEL_4x8 as ::core::ffi::c_int as uint8_t,
            PIXEL_4x4 as ::core::ffi::c_int as uint8_t,
        ],
    ];
    use super::common_h::x264_t;
    use super::stdint_uintn_h::uint32_t;
    extern "C" {
        #[c2rust::src_loc = "147:1"]
        pub fn x264_10_pixel_init(cpu: uint32_t, pixf: *mut x264_pixel_function_t);
        #[c2rust::src_loc = "149:1"]
        pub fn x264_10_pixel_ssd_nv12(
            pf: *mut x264_pixel_function_t,
            pix1: *mut pixel,
            i_pix1: intptr_t,
            pix2: *mut pixel,
            i_pix2: intptr_t,
            i_width: ::core::ffi::c_int,
            i_height: ::core::ffi::c_int,
            ssd_u: *mut uint64_t,
            ssd_v: *mut uint64_t,
        );
        #[c2rust::src_loc = "152:1"]
        pub fn x264_10_pixel_ssd_wxh(
            pf: *mut x264_pixel_function_t,
            pix1: *mut pixel,
            i_pix1: intptr_t,
            pix2: *mut pixel,
            i_pix2: intptr_t,
            i_width: ::core::ffi::c_int,
            i_height: ::core::ffi::c_int,
        ) -> uint64_t;
        #[c2rust::src_loc = "155:1"]
        pub fn x264_10_pixel_ssim_wxh(
            pf: *mut x264_pixel_function_t,
            pix1: *mut pixel,
            i_pix1: intptr_t,
            pix2: *mut pixel,
            i_pix2: intptr_t,
            i_width: ::core::ffi::c_int,
            i_height: ::core::ffi::c_int,
            buf: *mut ::core::ffi::c_void,
            cnt: *mut ::core::ffi::c_int,
        ) -> ::core::ffi::c_float;
        #[c2rust::src_loc = "158:1"]
        pub fn x264_10_field_vsad(
            h: *mut x264_t,
            mb_x: ::core::ffi::c_int,
            mb_y: ::core::ffi::c_int,
        ) -> ::core::ffi::c_int;
    }
}
#[c2rust::header_src = "/home/nwplayer123/Hacks/hex264/x264/common/predict.h:28"]
pub mod predict_h {
    #[c2rust::src_loc = "32:1"]
    pub type x264_predict_8x8_filter_t = Option<
        unsafe extern "C" fn(*mut pixel, *mut pixel, ::core::ffi::c_int, ::core::ffi::c_int) -> (),
    >;
    #[c2rust::src_loc = "30:1"]
    pub type x264_predict_t = Option<unsafe extern "C" fn(*mut pixel) -> ()>;
    #[c2rust::src_loc = "31:1"]
    pub type x264_predict8x8_t = Option<unsafe extern "C" fn(*mut pixel, *mut pixel) -> ()>;
    #[c2rust::src_loc = "34:1"]
    pub type intra_chroma_pred_e = ::core::ffi::c_uint;
    #[c2rust::src_loc = "43:5"]
    pub const I_PRED_CHROMA_DC_128: intra_chroma_pred_e = 6;
    #[c2rust::src_loc = "42:5"]
    pub const I_PRED_CHROMA_DC_TOP: intra_chroma_pred_e = 5;
    #[c2rust::src_loc = "41:5"]
    pub const I_PRED_CHROMA_DC_LEFT: intra_chroma_pred_e = 4;
    #[c2rust::src_loc = "39:5"]
    pub const I_PRED_CHROMA_P: intra_chroma_pred_e = 3;
    #[c2rust::src_loc = "38:5"]
    pub const I_PRED_CHROMA_V: intra_chroma_pred_e = 2;
    #[c2rust::src_loc = "37:5"]
    pub const I_PRED_CHROMA_H: intra_chroma_pred_e = 1;
    #[c2rust::src_loc = "36:5"]
    pub const I_PRED_CHROMA_DC: intra_chroma_pred_e = 0;
    #[c2rust::src_loc = "51:1"]
    pub type intra16x16_pred_e = ::core::ffi::c_uint;
    #[c2rust::src_loc = "60:5"]
    pub const I_PRED_16x16_DC_128: intra16x16_pred_e = 6;
    #[c2rust::src_loc = "59:5"]
    pub const I_PRED_16x16_DC_TOP: intra16x16_pred_e = 5;
    #[c2rust::src_loc = "58:5"]
    pub const I_PRED_16x16_DC_LEFT: intra16x16_pred_e = 4;
    #[c2rust::src_loc = "56:5"]
    pub const I_PRED_16x16_P: intra16x16_pred_e = 3;
    #[c2rust::src_loc = "55:5"]
    pub const I_PRED_16x16_DC: intra16x16_pred_e = 2;
    #[c2rust::src_loc = "54:5"]
    pub const I_PRED_16x16_H: intra16x16_pred_e = 1;
    #[c2rust::src_loc = "53:5"]
    pub const I_PRED_16x16_V: intra16x16_pred_e = 0;
    #[c2rust::src_loc = "68:1"]
    pub type intra4x4_pred_e = ::core::ffi::c_uint;
    #[c2rust::src_loc = "82:5"]
    pub const I_PRED_4x4_DC_128: intra4x4_pred_e = 11;
    #[c2rust::src_loc = "81:5"]
    pub const I_PRED_4x4_DC_TOP: intra4x4_pred_e = 10;
    #[c2rust::src_loc = "80:5"]
    pub const I_PRED_4x4_DC_LEFT: intra4x4_pred_e = 9;
    #[c2rust::src_loc = "78:5"]
    pub const I_PRED_4x4_HU: intra4x4_pred_e = 8;
    #[c2rust::src_loc = "77:5"]
    pub const I_PRED_4x4_VL: intra4x4_pred_e = 7;
    #[c2rust::src_loc = "76:5"]
    pub const I_PRED_4x4_HD: intra4x4_pred_e = 6;
    #[c2rust::src_loc = "75:5"]
    pub const I_PRED_4x4_VR: intra4x4_pred_e = 5;
    #[c2rust::src_loc = "74:5"]
    pub const I_PRED_4x4_DDR: intra4x4_pred_e = 4;
    #[c2rust::src_loc = "73:5"]
    pub const I_PRED_4x4_DDL: intra4x4_pred_e = 3;
    #[c2rust::src_loc = "72:5"]
    pub const I_PRED_4x4_DC: intra4x4_pred_e = 2;
    #[c2rust::src_loc = "71:5"]
    pub const I_PRED_4x4_H: intra4x4_pred_e = 1;
    #[c2rust::src_loc = "70:5"]
    pub const I_PRED_4x4_V: intra4x4_pred_e = 0;
    #[c2rust::src_loc = "45:22"]
    pub static mut x264_mb_chroma_pred_mode_fix: [uint8_t; 7] = [
        I_PRED_CHROMA_DC as ::core::ffi::c_int as uint8_t,
        I_PRED_CHROMA_H as ::core::ffi::c_int as uint8_t,
        I_PRED_CHROMA_V as ::core::ffi::c_int as uint8_t,
        I_PRED_CHROMA_P as ::core::ffi::c_int as uint8_t,
        I_PRED_CHROMA_DC as ::core::ffi::c_int as uint8_t,
        I_PRED_CHROMA_DC as ::core::ffi::c_int as uint8_t,
        I_PRED_CHROMA_DC as ::core::ffi::c_int as uint8_t,
    ];
    #[c2rust::src_loc = "62:22"]
    pub static mut x264_mb_pred_mode16x16_fix: [uint8_t; 7] = [
        I_PRED_16x16_V as ::core::ffi::c_int as uint8_t,
        I_PRED_16x16_H as ::core::ffi::c_int as uint8_t,
        I_PRED_16x16_DC as ::core::ffi::c_int as uint8_t,
        I_PRED_16x16_P as ::core::ffi::c_int as uint8_t,
        I_PRED_16x16_DC as ::core::ffi::c_int as uint8_t,
        I_PRED_16x16_DC as ::core::ffi::c_int as uint8_t,
        I_PRED_16x16_DC as ::core::ffi::c_int as uint8_t,
    ];
    #[c2rust::src_loc = "84:21"]
    pub static mut x264_mb_pred_mode4x4_fix: [int8_t; 13] = [
        -(1 as ::core::ffi::c_int) as int8_t,
        I_PRED_4x4_V as ::core::ffi::c_int as int8_t,
        I_PRED_4x4_H as ::core::ffi::c_int as int8_t,
        I_PRED_4x4_DC as ::core::ffi::c_int as int8_t,
        I_PRED_4x4_DDL as ::core::ffi::c_int as int8_t,
        I_PRED_4x4_DDR as ::core::ffi::c_int as int8_t,
        I_PRED_4x4_VR as ::core::ffi::c_int as int8_t,
        I_PRED_4x4_HD as ::core::ffi::c_int as int8_t,
        I_PRED_4x4_VL as ::core::ffi::c_int as int8_t,
        I_PRED_4x4_HU as ::core::ffi::c_int as int8_t,
        I_PRED_4x4_DC as ::core::ffi::c_int as int8_t,
        I_PRED_4x4_DC as ::core::ffi::c_int as int8_t,
        I_PRED_4x4_DC as ::core::ffi::c_int as int8_t,
    ];
    use super::common_h::pixel;
    use super::stdint_intn_h::int8_t;
    use super::stdint_uintn_h::uint8_t;

    #[c2rust::src_loc = "95:1"]
    pub type intra8x8_pred_e = ::core::ffi::c_uint;
    #[c2rust::src_loc = "109:5"]
    pub const I_PRED_8x8_DC_128: intra8x8_pred_e = 11;
    #[c2rust::src_loc = "108:5"]
    pub const I_PRED_8x8_DC_TOP: intra8x8_pred_e = 10;
    #[c2rust::src_loc = "107:5"]
    pub const I_PRED_8x8_DC_LEFT: intra8x8_pred_e = 9;
    #[c2rust::src_loc = "105:5"]
    pub const I_PRED_8x8_HU: intra8x8_pred_e = 8;
    #[c2rust::src_loc = "104:5"]
    pub const I_PRED_8x8_VL: intra8x8_pred_e = 7;
    #[c2rust::src_loc = "103:5"]
    pub const I_PRED_8x8_HD: intra8x8_pred_e = 6;
    #[c2rust::src_loc = "102:5"]
    pub const I_PRED_8x8_VR: intra8x8_pred_e = 5;
    #[c2rust::src_loc = "101:5"]
    pub const I_PRED_8x8_DDR: intra8x8_pred_e = 4;
    #[c2rust::src_loc = "100:5"]
    pub const I_PRED_8x8_DDL: intra8x8_pred_e = 3;
    #[c2rust::src_loc = "99:5"]
    pub const I_PRED_8x8_DC: intra8x8_pred_e = 2;
    #[c2rust::src_loc = "98:5"]
    pub const I_PRED_8x8_H: intra8x8_pred_e = 1;
    #[c2rust::src_loc = "97:5"]
    pub const I_PRED_8x8_V: intra8x8_pred_e = 0;
    use super::stdint_uintn_h::uint32_t;
    extern "C" {
        #[c2rust::src_loc = "150:1"]
        pub fn x264_10_predict_16x16_init(cpu: uint32_t, pf: *mut x264_predict_t);
        #[c2rust::src_loc = "152:1"]
        pub fn x264_10_predict_8x8c_init(cpu: uint32_t, pf: *mut x264_predict_t);
        #[c2rust::src_loc = "154:1"]
        pub fn x264_10_predict_8x16c_init(cpu: uint32_t, pf: *mut x264_predict_t);
        #[c2rust::src_loc = "156:1"]
        pub fn x264_10_predict_4x4_init(cpu: uint32_t, pf: *mut x264_predict_t);
        #[c2rust::src_loc = "158:1"]
        pub fn x264_10_predict_8x8_init(
            cpu: uint32_t,
            pf: *mut x264_predict8x8_t,
            predict_filter: *mut x264_predict_8x8_filter_t,
        );
    }
}
#[c2rust::header_src = "/home/nwplayer123/Hacks/hex264/x264/common/set.h:28"]
pub mod set_h {
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "150:9"]
    pub struct x264_pps_t {
        pub i_id: ::core::ffi::c_int,
        pub i_sps_id: ::core::ffi::c_int,
        pub b_cabac: ::core::ffi::c_int,
        pub b_pic_order: ::core::ffi::c_int,
        pub i_num_slice_groups: ::core::ffi::c_int,
        pub i_num_ref_idx_l0_default_active: ::core::ffi::c_int,
        pub i_num_ref_idx_l1_default_active: ::core::ffi::c_int,
        pub b_weighted_pred: ::core::ffi::c_int,
        pub b_weighted_bipred: ::core::ffi::c_int,
        pub i_pic_init_qp: ::core::ffi::c_int,
        pub i_pic_init_qs: ::core::ffi::c_int,
        pub i_chroma_qp_index_offset: ::core::ffi::c_int,
        pub b_deblocking_filter_control: ::core::ffi::c_int,
        pub b_constrained_intra_pred: ::core::ffi::c_int,
        pub b_redundant_pic_cnt: ::core::ffi::c_int,
        pub b_transform_8x8_mode: ::core::ffi::c_int,
    }
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "45:9"]
    pub struct x264_sps_t {
        pub i_id: ::core::ffi::c_int,
        pub i_profile_idc: ::core::ffi::c_int,
        pub i_level_idc: ::core::ffi::c_int,
        pub b_constraint_set0: ::core::ffi::c_int,
        pub b_constraint_set1: ::core::ffi::c_int,
        pub b_constraint_set2: ::core::ffi::c_int,
        pub b_constraint_set3: ::core::ffi::c_int,
        pub i_log2_max_frame_num: ::core::ffi::c_int,
        pub i_poc_type: ::core::ffi::c_int,
        pub i_log2_max_poc_lsb: ::core::ffi::c_int,
        pub i_num_ref_frames: ::core::ffi::c_int,
        pub b_gaps_in_frame_num_value_allowed: ::core::ffi::c_int,
        pub i_mb_width: ::core::ffi::c_int,
        pub i_mb_height: ::core::ffi::c_int,
        pub b_frame_mbs_only: ::core::ffi::c_int,
        pub b_mb_adaptive_frame_field: ::core::ffi::c_int,
        pub b_direct8x8_inference: ::core::ffi::c_int,
        pub b_crop: ::core::ffi::c_int,
        pub crop: C2RustUnnamed_16,
        pub b_vui: ::core::ffi::c_int,
        pub vui: C2RustUnnamed_14,
        pub b_qpprime_y_zero_transform_bypass: ::core::ffi::c_int,
        pub i_chroma_format_idc: ::core::ffi::c_int,
        pub b_avcintra_hd: ::core::ffi::c_int,
        pub b_avcintra_4k: ::core::ffi::c_int,
        pub i_cqm_preset: ::core::ffi::c_int,
        pub scaling_list: [*const uint8_t; 8],
    }
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "81:5"]
    pub struct C2RustUnnamed_14 {
        pub b_aspect_ratio_info_present: ::core::ffi::c_int,
        pub i_sar_width: ::core::ffi::c_int,
        pub i_sar_height: ::core::ffi::c_int,
        pub b_overscan_info_present: ::core::ffi::c_int,
        pub b_overscan_info: ::core::ffi::c_int,
        pub b_signal_type_present: ::core::ffi::c_int,
        pub i_vidformat: ::core::ffi::c_int,
        pub b_fullrange: ::core::ffi::c_int,
        pub b_color_description_present: ::core::ffi::c_int,
        pub i_colorprim: ::core::ffi::c_int,
        pub i_transfer: ::core::ffi::c_int,
        pub i_colmatrix: ::core::ffi::c_int,
        pub b_chroma_loc_info_present: ::core::ffi::c_int,
        pub i_chroma_loc_top: ::core::ffi::c_int,
        pub i_chroma_loc_bottom: ::core::ffi::c_int,
        pub b_timing_info_present: ::core::ffi::c_int,
        pub i_num_units_in_tick: uint32_t,
        pub i_time_scale: uint32_t,
        pub b_fixed_frame_rate: ::core::ffi::c_int,
        pub b_nal_hrd_parameters_present: ::core::ffi::c_int,
        pub b_vcl_hrd_parameters_present: ::core::ffi::c_int,
        pub hrd: C2RustUnnamed_15,
        pub b_pic_struct_present: ::core::ffi::c_int,
        pub b_bitstream_restriction: ::core::ffi::c_int,
        pub b_motion_vectors_over_pic_boundaries: ::core::ffi::c_int,
        pub i_max_bytes_per_pic_denom: ::core::ffi::c_int,
        pub i_max_bits_per_mb_denom: ::core::ffi::c_int,
        pub i_log2_max_mv_length_horizontal: ::core::ffi::c_int,
        pub i_log2_max_mv_length_vertical: ::core::ffi::c_int,
        pub i_num_reorder_frames: ::core::ffi::c_int,
        pub i_max_dec_frame_buffering: ::core::ffi::c_int,
    }
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "110:9"]
    pub struct C2RustUnnamed_15 {
        pub i_cpb_cnt: ::core::ffi::c_int,
        pub i_bit_rate_scale: ::core::ffi::c_int,
        pub i_cpb_size_scale: ::core::ffi::c_int,
        pub i_bit_rate_value: ::core::ffi::c_int,
        pub i_cpb_size_value: ::core::ffi::c_int,
        pub i_bit_rate_unscaled: ::core::ffi::c_int,
        pub i_cpb_size_unscaled: ::core::ffi::c_int,
        pub b_cbr_hrd: ::core::ffi::c_int,
        pub i_initial_cpb_removal_delay_length: ::core::ffi::c_int,
        pub i_cpb_removal_delay_length: ::core::ffi::c_int,
        pub i_dpb_output_delay_length: ::core::ffi::c_int,
        pub i_time_offset_length: ::core::ffi::c_int,
    }
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "72:5"]
    pub struct C2RustUnnamed_16 {
        pub i_left: ::core::ffi::c_int,
        pub i_right: ::core::ffi::c_int,
        pub i_top: ::core::ffi::c_int,
        pub i_bottom: ::core::ffi::c_int,
    }
    #[c2rust::src_loc = "30:1"]
    pub type cqm4_e = ::core::ffi::c_uint;
    #[c2rust::src_loc = "35:5"]
    pub const CQM_4PC: cqm4_e = 3;
    #[c2rust::src_loc = "34:5"]
    pub const CQM_4IC: cqm4_e = 2;
    #[c2rust::src_loc = "33:5"]
    pub const CQM_4PY: cqm4_e = 1;
    #[c2rust::src_loc = "32:5"]
    pub const CQM_4IY: cqm4_e = 0;
    #[c2rust::src_loc = "37:1"]
    pub type cqm8_e = ::core::ffi::c_uint;
    #[c2rust::src_loc = "42:5"]
    pub const CQM_8PC: cqm8_e = 3;
    #[c2rust::src_loc = "41:5"]
    pub const CQM_8IC: cqm8_e = 2;
    #[c2rust::src_loc = "40:5"]
    pub const CQM_8PY: cqm8_e = 1;
    #[c2rust::src_loc = "39:5"]
    pub const CQM_8IY: cqm8_e = 0;
    use super::stdint_uintn_h::{uint32_t, uint8_t};

    use super::common_h::x264_t;
    extern "C" {
        #[c2rust::src_loc = "180:1"]
        pub fn x264_10_cqm_init(h: *mut x264_t) -> ::core::ffi::c_int;
        #[c2rust::src_loc = "182:1"]
        pub fn x264_10_cqm_delete(h: *mut x264_t);
        #[c2rust::src_loc = "184:1"]
        pub fn x264_10_cqm_parse_file(
            h: *mut x264_t,
            filename: *const ::core::ffi::c_char,
        ) -> ::core::ffi::c_int;
    }
}
#[c2rust::header_src = "/home/nwplayer123/Hacks/hex264/x264/common/threadpool.h:28"]
pub mod threadpool_h {
    extern "C" {
        #[c2rust::src_loc = "29:16"]
        pub type x264_threadpool_t;
        #[c2rust::src_loc = "35:10"]
        pub fn x264_10_threadpool_run(
            pool: *mut x264_threadpool_t,
            func: Option<
                unsafe extern "C" fn(*mut ::core::ffi::c_void) -> *mut ::core::ffi::c_void,
            >,
            arg: *mut ::core::ffi::c_void,
        );
        #[c2rust::src_loc = "37:10"]
        pub fn x264_10_threadpool_wait(
            pool: *mut x264_threadpool_t,
            arg: *mut ::core::ffi::c_void,
        ) -> *mut ::core::ffi::c_void;
    }
    extern "C" {
        #[c2rust::src_loc = "33:10"]
        pub fn x264_10_threadpool_init(
            p_pool: *mut *mut x264_threadpool_t,
            threads: ::core::ffi::c_int,
        ) -> ::core::ffi::c_int;
        #[c2rust::src_loc = "39:10"]
        pub fn x264_10_threadpool_delete(pool: *mut x264_threadpool_t);
    }
}
#[c2rust::header_src = "/home/nwplayer123/Hacks/hex264/x264/common/tables.h:28"]
pub mod tables_h {
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "30:9"]
    pub struct vlc_t {
        pub i_bits: uint8_t,
        pub i_size: uint8_t,
    }
    use super::stdint_uintn_h::{uint16_t, uint32_t, uint8_t};
    extern "C" {
        #[c2rust::src_loc = "38:22"]
        pub static x264_exp2_lut: [uint8_t; 64];
        #[c2rust::src_loc = "39:22"]
        pub static x264_log2_lut: [::core::ffi::c_float; 128];
        #[c2rust::src_loc = "40:22"]
        pub static x264_log2_lz_lut: [::core::ffi::c_float; 32];
        #[c2rust::src_loc = "43:23"]
        pub static x264_lambda_tab: [uint16_t; 82];
        #[c2rust::src_loc = "44:23"]
        pub static x264_lambda2_tab: [::core::ffi::c_int; 82];
        #[c2rust::src_loc = "45:23"]
        pub static x264_trellis_lambda2_tab: [[::core::ffi::c_int; 82]; 2];
        #[c2rust::src_loc = "47:23"]
        pub static x264_chroma_lambda2_offset_tab: [uint16_t; 37];
        #[c2rust::src_loc = "73:23"]
        pub static x264_dct4_weight_tab: [uint32_t; 16];
        #[c2rust::src_loc = "74:23"]
        pub static x264_dct8_weight_tab: [uint32_t; 64];
        #[c2rust::src_loc = "75:23"]
        pub static x264_dct4_weight2_tab: [uint32_t; 16];
        #[c2rust::src_loc = "76:23"]
        pub static x264_dct8_weight2_tab: [uint32_t; 64];
        #[c2rust::src_loc = "81:23"]
        pub static x264_cabac_transition: [[uint8_t; 2]; 128];
        #[c2rust::src_loc = "83:23"]
        pub static x264_cabac_entropy: [uint16_t; 128];
        #[c2rust::src_loc = "85:23"]
        pub static x264_significant_coeff_flag_offset_8x8: [[uint8_t; 64]; 2];
        #[c2rust::src_loc = "86:23"]
        pub static x264_last_coeff_flag_offset_8x8: [uint8_t; 63];
        #[c2rust::src_loc = "87:23"]
        pub static x264_coeff_flag_offset_chroma_422_dc: [uint8_t; 7];
        #[c2rust::src_loc = "88:23"]
        pub static x264_significant_coeff_flag_offset: [[uint16_t; 16]; 2];
        #[c2rust::src_loc = "89:23"]
        pub static x264_last_coeff_flag_offset: [[uint16_t; 16]; 2];
        #[c2rust::src_loc = "90:23"]
        pub static x264_coeff_abs_level_m1_offset: [uint16_t; 16];
        #[c2rust::src_loc = "91:23"]
        pub static x264_count_cat_m1: [uint8_t; 14];
        #[c2rust::src_loc = "93:20"]
        pub static x264_coeff0_token: [vlc_t; 6];
        #[c2rust::src_loc = "94:20"]
        pub static x264_coeff_token: [[[vlc_t; 4]; 16]; 6];
        #[c2rust::src_loc = "95:20"]
        pub static x264_total_zeros: [[vlc_t; 16]; 15];
        #[c2rust::src_loc = "96:20"]
        pub static x264_total_zeros_2x2_dc: [[vlc_t; 4]; 3];
        #[c2rust::src_loc = "97:20"]
        pub static x264_total_zeros_2x4_dc: [[vlc_t; 8]; 7];
        #[c2rust::src_loc = "100:16"]
        pub static mut x264_zero: [uint8_t; 1024];
    }
    extern "C" {
        #[c2rust::src_loc = "52:22"]
        pub static x264_cqm_jvt4i: [uint8_t; 16];
        #[c2rust::src_loc = "58:22"]
        pub static x264_cqm_avci50_4ic: [uint8_t; 16];
        #[c2rust::src_loc = "59:22"]
        pub static x264_cqm_avci50_p_8iy: [uint8_t; 64];
        #[c2rust::src_loc = "60:22"]
        pub static x264_cqm_avci50_1080i_8iy: [uint8_t; 64];
        #[c2rust::src_loc = "61:22"]
        pub static x264_cqm_avci100_720p_4ic: [uint8_t; 16];
        #[c2rust::src_loc = "62:22"]
        pub static x264_cqm_avci100_720p_8iy: [uint8_t; 64];
        #[c2rust::src_loc = "63:22"]
        pub static x264_cqm_avci100_1080_4ic: [uint8_t; 16];
        #[c2rust::src_loc = "64:22"]
        pub static x264_cqm_avci100_1080i_8iy: [uint8_t; 64];
        #[c2rust::src_loc = "65:22"]
        pub static x264_cqm_avci100_1080p_8iy: [uint8_t; 64];
        #[c2rust::src_loc = "66:22"]
        pub static x264_cqm_avci300_2160p_4iy: [uint8_t; 16];
        #[c2rust::src_loc = "67:22"]
        pub static x264_cqm_avci300_2160p_4ic: [uint8_t; 16];
        #[c2rust::src_loc = "68:22"]
        pub static x264_cqm_avci300_2160p_8iy: [uint8_t; 64];
    }
    extern "C" {
        #[c2rust::src_loc = "98:20"]
        pub static x264_run_before_init: [[vlc_t; 16]; 7];
    }
    extern "C" {
        #[c2rust::src_loc = "53:22"]
        pub static x264_cqm_jvt4p: [uint8_t; 16];
        #[c2rust::src_loc = "54:22"]
        pub static x264_cqm_jvt8i: [uint8_t; 64];
        #[c2rust::src_loc = "55:22"]
        pub static x264_cqm_jvt8p: [uint8_t; 64];
    }
    extern "C" {
        #[c2rust::src_loc = "70:22"]
        pub static x264_decimate_table4: [uint8_t; 16];
        #[c2rust::src_loc = "71:22"]
        pub static x264_decimate_table8: [uint8_t; 64];
    }
}
#[c2rust::header_src = "/home/nwplayer123/Hacks/hex264/x264/common/macroblock.h:28"]
pub mod macroblock_h {
    #[c2rust::src_loc = "31:1"]
    pub type macroblock_position_e = ::core::ffi::c_uint;
    #[c2rust::src_loc = "40:5"]
    pub const ALL_NEIGHBORS: macroblock_position_e = 15;
    #[c2rust::src_loc = "38:5"]
    pub const MB_PRIVATE: macroblock_position_e = 16;
    #[c2rust::src_loc = "36:5"]
    pub const MB_TOPLEFT: macroblock_position_e = 8;
    #[c2rust::src_loc = "35:5"]
    pub const MB_TOPRIGHT: macroblock_position_e = 4;
    #[c2rust::src_loc = "34:5"]
    pub const MB_TOP: macroblock_position_e = 2;
    #[c2rust::src_loc = "33:5"]
    pub const MB_LEFT: macroblock_position_e = 1;
    #[c2rust::src_loc = "64:1"]
    pub type mb_class_e = ::core::ffi::c_uint;
    #[c2rust::src_loc = "88:5"]
    pub const X264_MBTYPE_MAX: mb_class_e = 19;
    #[c2rust::src_loc = "86:5"]
    pub const B_SKIP: mb_class_e = 18;
    #[c2rust::src_loc = "85:5"]
    pub const B_8x8: mb_class_e = 17;
    #[c2rust::src_loc = "84:5"]
    pub const B_BI_BI: mb_class_e = 16;
    #[c2rust::src_loc = "83:5"]
    pub const B_BI_L1: mb_class_e = 15;
    #[c2rust::src_loc = "82:5"]
    pub const B_BI_L0: mb_class_e = 14;
    #[c2rust::src_loc = "81:5"]
    pub const B_L1_BI: mb_class_e = 13;
    #[c2rust::src_loc = "80:5"]
    pub const B_L1_L1: mb_class_e = 12;
    #[c2rust::src_loc = "79:5"]
    pub const B_L1_L0: mb_class_e = 11;
    #[c2rust::src_loc = "78:5"]
    pub const B_L0_BI: mb_class_e = 10;
    #[c2rust::src_loc = "77:5"]
    pub const B_L0_L1: mb_class_e = 9;
    #[c2rust::src_loc = "76:5"]
    pub const B_L0_L0: mb_class_e = 8;
    #[c2rust::src_loc = "75:5"]
    pub const B_DIRECT: mb_class_e = 7;
    #[c2rust::src_loc = "73:5"]
    pub const P_SKIP: mb_class_e = 6;
    #[c2rust::src_loc = "72:5"]
    pub const P_8x8: mb_class_e = 5;
    #[c2rust::src_loc = "71:5"]
    pub const P_L0: mb_class_e = 4;
    #[c2rust::src_loc = "69:5"]
    pub const I_PCM: mb_class_e = 3;
    #[c2rust::src_loc = "68:5"]
    pub const I_16x16: mb_class_e = 2;
    #[c2rust::src_loc = "67:5"]
    pub const I_8x8: mb_class_e = 1;
    #[c2rust::src_loc = "66:5"]
    pub const I_4x4: mb_class_e = 0;
    #[c2rust::src_loc = "115:1"]
    pub type mb_partition_e = ::core::ffi::c_uint;
    #[c2rust::src_loc = "140:5"]
    pub const X264_PARTTYPE_MAX: mb_partition_e = 17;
    #[c2rust::src_loc = "139:5"]
    pub const D_16x16: mb_partition_e = 16;
    #[c2rust::src_loc = "138:5"]
    pub const D_8x16: mb_partition_e = 15;
    #[c2rust::src_loc = "137:5"]
    pub const D_16x8: mb_partition_e = 14;
    #[c2rust::src_loc = "136:5"]
    pub const D_8x8: mb_partition_e = 13;
    #[c2rust::src_loc = "133:5"]
    pub const D_DIRECT_8x8: mb_partition_e = 12;
    #[c2rust::src_loc = "132:5"]
    pub const D_BI_8x8: mb_partition_e = 11;
    #[c2rust::src_loc = "131:5"]
    pub const D_BI_4x8: mb_partition_e = 10;
    #[c2rust::src_loc = "130:5"]
    pub const D_BI_8x4: mb_partition_e = 9;
    #[c2rust::src_loc = "129:5"]
    pub const D_BI_4x4: mb_partition_e = 8;
    #[c2rust::src_loc = "127:5"]
    pub const D_L1_8x8: mb_partition_e = 7;
    #[c2rust::src_loc = "126:5"]
    pub const D_L1_4x8: mb_partition_e = 6;
    #[c2rust::src_loc = "125:5"]
    pub const D_L1_8x4: mb_partition_e = 5;
    #[c2rust::src_loc = "124:5"]
    pub const D_L1_4x4: mb_partition_e = 4;
    #[c2rust::src_loc = "121:5"]
    pub const D_L0_8x8: mb_partition_e = 3;
    #[c2rust::src_loc = "120:5"]
    pub const D_L0_4x8: mb_partition_e = 2;
    #[c2rust::src_loc = "119:5"]
    pub const D_L0_8x4: mb_partition_e = 1;
    #[c2rust::src_loc = "118:5"]
    pub const D_L0_4x4: mb_partition_e = 0;
    #[c2rust::src_loc = "273:1"]
    pub type cabac_ctx_block_cat_e = ::core::ffi::c_uint;
    #[c2rust::src_loc = "288:5"]
    pub const DCT_CHROMAV_8x8: cabac_ctx_block_cat_e = 13;
    #[c2rust::src_loc = "287:5"]
    pub const DCT_CHROMAV_4x4: cabac_ctx_block_cat_e = 12;
    #[c2rust::src_loc = "286:5"]
    pub const DCT_CHROMAV_AC: cabac_ctx_block_cat_e = 11;
    #[c2rust::src_loc = "285:5"]
    pub const DCT_CHROMAV_DC: cabac_ctx_block_cat_e = 10;
    #[c2rust::src_loc = "284:5"]
    pub const DCT_CHROMAU_8x8: cabac_ctx_block_cat_e = 9;
    #[c2rust::src_loc = "283:5"]
    pub const DCT_CHROMAU_4x4: cabac_ctx_block_cat_e = 8;
    #[c2rust::src_loc = "282:5"]
    pub const DCT_CHROMAU_AC: cabac_ctx_block_cat_e = 7;
    #[c2rust::src_loc = "281:5"]
    pub const DCT_CHROMAU_DC: cabac_ctx_block_cat_e = 6;
    #[c2rust::src_loc = "280:5"]
    pub const DCT_LUMA_8x8: cabac_ctx_block_cat_e = 5;
    #[c2rust::src_loc = "279:5"]
    pub const DCT_CHROMA_AC: cabac_ctx_block_cat_e = 4;
    #[c2rust::src_loc = "278:5"]
    pub const DCT_CHROMA_DC: cabac_ctx_block_cat_e = 3;
    #[c2rust::src_loc = "277:5"]
    pub const DCT_LUMA_4x4: cabac_ctx_block_cat_e = 2;
    #[c2rust::src_loc = "276:5"]
    pub const DCT_LUMA_AC: cabac_ctx_block_cat_e = 1;
    #[c2rust::src_loc = "275:5"]
    pub const DCT_LUMA_DC: cabac_ctx_block_cat_e = 0;
    #[c2rust::src_loc = "43:22"]
    pub static mut x264_pred_i4x4_neighbors: [uint8_t; 12] = [
        MB_TOP as ::core::ffi::c_int as uint8_t,
        MB_LEFT as ::core::ffi::c_int as uint8_t,
        (MB_LEFT as ::core::ffi::c_int | MB_TOP as ::core::ffi::c_int) as uint8_t,
        (MB_TOP as ::core::ffi::c_int | MB_TOPRIGHT as ::core::ffi::c_int) as uint8_t,
        (MB_LEFT as ::core::ffi::c_int
            | MB_TOPLEFT as ::core::ffi::c_int
            | MB_TOP as ::core::ffi::c_int) as uint8_t,
        (MB_LEFT as ::core::ffi::c_int
            | MB_TOPLEFT as ::core::ffi::c_int
            | MB_TOP as ::core::ffi::c_int) as uint8_t,
        (MB_LEFT as ::core::ffi::c_int
            | MB_TOPLEFT as ::core::ffi::c_int
            | MB_TOP as ::core::ffi::c_int) as uint8_t,
        (MB_TOP as ::core::ffi::c_int | MB_TOPRIGHT as ::core::ffi::c_int) as uint8_t,
        MB_LEFT as ::core::ffi::c_int as uint8_t,
        MB_LEFT as ::core::ffi::c_int as uint8_t,
        MB_TOP as ::core::ffi::c_int as uint8_t,
        0 as ::core::ffi::c_int as uint8_t,
    ];
    #[c2rust::src_loc = "97:22"]
    pub static mut x264_mb_type_list_table: [[[uint8_t; 2]; 2]; 19] = [
        [
            [
                0 as ::core::ffi::c_int as uint8_t,
                0 as ::core::ffi::c_int as uint8_t,
            ],
            [
                0 as ::core::ffi::c_int as uint8_t,
                0 as ::core::ffi::c_int as uint8_t,
            ],
        ],
        [
            [
                0 as ::core::ffi::c_int as uint8_t,
                0 as ::core::ffi::c_int as uint8_t,
            ],
            [
                0 as ::core::ffi::c_int as uint8_t,
                0 as ::core::ffi::c_int as uint8_t,
            ],
        ],
        [
            [
                0 as ::core::ffi::c_int as uint8_t,
                0 as ::core::ffi::c_int as uint8_t,
            ],
            [
                0 as ::core::ffi::c_int as uint8_t,
                0 as ::core::ffi::c_int as uint8_t,
            ],
        ],
        [
            [
                0 as ::core::ffi::c_int as uint8_t,
                0 as ::core::ffi::c_int as uint8_t,
            ],
            [
                0 as ::core::ffi::c_int as uint8_t,
                0 as ::core::ffi::c_int as uint8_t,
            ],
        ],
        [
            [
                1 as ::core::ffi::c_int as uint8_t,
                1 as ::core::ffi::c_int as uint8_t,
            ],
            [
                0 as ::core::ffi::c_int as uint8_t,
                0 as ::core::ffi::c_int as uint8_t,
            ],
        ],
        [
            [
                0 as ::core::ffi::c_int as uint8_t,
                0 as ::core::ffi::c_int as uint8_t,
            ],
            [
                0 as ::core::ffi::c_int as uint8_t,
                0 as ::core::ffi::c_int as uint8_t,
            ],
        ],
        [
            [
                1 as ::core::ffi::c_int as uint8_t,
                1 as ::core::ffi::c_int as uint8_t,
            ],
            [
                0 as ::core::ffi::c_int as uint8_t,
                0 as ::core::ffi::c_int as uint8_t,
            ],
        ],
        [
            [
                0 as ::core::ffi::c_int as uint8_t,
                0 as ::core::ffi::c_int as uint8_t,
            ],
            [
                0 as ::core::ffi::c_int as uint8_t,
                0 as ::core::ffi::c_int as uint8_t,
            ],
        ],
        [
            [
                1 as ::core::ffi::c_int as uint8_t,
                1 as ::core::ffi::c_int as uint8_t,
            ],
            [
                0 as ::core::ffi::c_int as uint8_t,
                0 as ::core::ffi::c_int as uint8_t,
            ],
        ],
        [
            [
                1 as ::core::ffi::c_int as uint8_t,
                0 as ::core::ffi::c_int as uint8_t,
            ],
            [
                0 as ::core::ffi::c_int as uint8_t,
                1 as ::core::ffi::c_int as uint8_t,
            ],
        ],
        [
            [
                1 as ::core::ffi::c_int as uint8_t,
                1 as ::core::ffi::c_int as uint8_t,
            ],
            [
                0 as ::core::ffi::c_int as uint8_t,
                1 as ::core::ffi::c_int as uint8_t,
            ],
        ],
        [
            [
                0 as ::core::ffi::c_int as uint8_t,
                1 as ::core::ffi::c_int as uint8_t,
            ],
            [
                1 as ::core::ffi::c_int as uint8_t,
                0 as ::core::ffi::c_int as uint8_t,
            ],
        ],
        [
            [
                0 as ::core::ffi::c_int as uint8_t,
                0 as ::core::ffi::c_int as uint8_t,
            ],
            [
                1 as ::core::ffi::c_int as uint8_t,
                1 as ::core::ffi::c_int as uint8_t,
            ],
        ],
        [
            [
                0 as ::core::ffi::c_int as uint8_t,
                1 as ::core::ffi::c_int as uint8_t,
            ],
            [
                1 as ::core::ffi::c_int as uint8_t,
                1 as ::core::ffi::c_int as uint8_t,
            ],
        ],
        [
            [
                1 as ::core::ffi::c_int as uint8_t,
                1 as ::core::ffi::c_int as uint8_t,
            ],
            [
                1 as ::core::ffi::c_int as uint8_t,
                0 as ::core::ffi::c_int as uint8_t,
            ],
        ],
        [
            [
                1 as ::core::ffi::c_int as uint8_t,
                0 as ::core::ffi::c_int as uint8_t,
            ],
            [
                1 as ::core::ffi::c_int as uint8_t,
                1 as ::core::ffi::c_int as uint8_t,
            ],
        ],
        [
            [
                1 as ::core::ffi::c_int as uint8_t,
                1 as ::core::ffi::c_int as uint8_t,
            ],
            [
                1 as ::core::ffi::c_int as uint8_t,
                1 as ::core::ffi::c_int as uint8_t,
            ],
        ],
        [
            [
                0 as ::core::ffi::c_int as uint8_t,
                0 as ::core::ffi::c_int as uint8_t,
            ],
            [
                0 as ::core::ffi::c_int as uint8_t,
                0 as ::core::ffi::c_int as uint8_t,
            ],
        ],
        [
            [
                0 as ::core::ffi::c_int as uint8_t,
                0 as ::core::ffi::c_int as uint8_t,
            ],
            [
                0 as ::core::ffi::c_int as uint8_t,
                0 as ::core::ffi::c_int as uint8_t,
            ],
        ],
    ];
    #[c2rust::src_loc = "143:22"]
    pub static mut x264_mb_partition_listX_table: [[uint8_t; 17]; 2] = [
        [
            1 as ::core::ffi::c_int as uint8_t,
            1 as ::core::ffi::c_int as uint8_t,
            1 as ::core::ffi::c_int as uint8_t,
            1 as ::core::ffi::c_int as uint8_t,
            0 as ::core::ffi::c_int as uint8_t,
            0 as ::core::ffi::c_int as uint8_t,
            0 as ::core::ffi::c_int as uint8_t,
            0 as ::core::ffi::c_int as uint8_t,
            1 as ::core::ffi::c_int as uint8_t,
            1 as ::core::ffi::c_int as uint8_t,
            1 as ::core::ffi::c_int as uint8_t,
            1 as ::core::ffi::c_int as uint8_t,
            0 as ::core::ffi::c_int as uint8_t,
            0 as ::core::ffi::c_int as uint8_t,
            0 as ::core::ffi::c_int as uint8_t,
            0 as ::core::ffi::c_int as uint8_t,
            0 as ::core::ffi::c_int as uint8_t,
        ],
        [
            0 as ::core::ffi::c_int as uint8_t,
            0 as ::core::ffi::c_int as uint8_t,
            0 as ::core::ffi::c_int as uint8_t,
            0 as ::core::ffi::c_int as uint8_t,
            1 as ::core::ffi::c_int as uint8_t,
            1 as ::core::ffi::c_int as uint8_t,
            1 as ::core::ffi::c_int as uint8_t,
            1 as ::core::ffi::c_int as uint8_t,
            1 as ::core::ffi::c_int as uint8_t,
            1 as ::core::ffi::c_int as uint8_t,
            1 as ::core::ffi::c_int as uint8_t,
            1 as ::core::ffi::c_int as uint8_t,
            0 as ::core::ffi::c_int as uint8_t,
            0 as ::core::ffi::c_int as uint8_t,
            0 as ::core::ffi::c_int as uint8_t,
            0 as ::core::ffi::c_int as uint8_t,
            0 as ::core::ffi::c_int as uint8_t,
        ],
    ];
    #[c2rust::src_loc = "181:22"]
    pub static mut x264_zigzag_scan4: [[uint8_t; 16]; 2] = [
        [
            0 as ::core::ffi::c_int as uint8_t,
            4 as ::core::ffi::c_int as uint8_t,
            1 as ::core::ffi::c_int as uint8_t,
            2 as ::core::ffi::c_int as uint8_t,
            5 as ::core::ffi::c_int as uint8_t,
            8 as ::core::ffi::c_int as uint8_t,
            12 as ::core::ffi::c_int as uint8_t,
            9 as ::core::ffi::c_int as uint8_t,
            6 as ::core::ffi::c_int as uint8_t,
            3 as ::core::ffi::c_int as uint8_t,
            7 as ::core::ffi::c_int as uint8_t,
            10 as ::core::ffi::c_int as uint8_t,
            13 as ::core::ffi::c_int as uint8_t,
            14 as ::core::ffi::c_int as uint8_t,
            11 as ::core::ffi::c_int as uint8_t,
            15 as ::core::ffi::c_int as uint8_t,
        ],
        [
            0 as ::core::ffi::c_int as uint8_t,
            1 as ::core::ffi::c_int as uint8_t,
            4 as ::core::ffi::c_int as uint8_t,
            2 as ::core::ffi::c_int as uint8_t,
            3 as ::core::ffi::c_int as uint8_t,
            5 as ::core::ffi::c_int as uint8_t,
            6 as ::core::ffi::c_int as uint8_t,
            7 as ::core::ffi::c_int as uint8_t,
            8 as ::core::ffi::c_int as uint8_t,
            9 as ::core::ffi::c_int as uint8_t,
            10 as ::core::ffi::c_int as uint8_t,
            11 as ::core::ffi::c_int as uint8_t,
            12 as ::core::ffi::c_int as uint8_t,
            13 as ::core::ffi::c_int as uint8_t,
            14 as ::core::ffi::c_int as uint8_t,
            15 as ::core::ffi::c_int as uint8_t,
        ],
    ];
    #[c2rust::src_loc = "188:22"]
    pub static mut x264_zigzag_scan8: [[uint8_t; 64]; 2] = [
        [
            0 as ::core::ffi::c_int as uint8_t,
            8 as ::core::ffi::c_int as uint8_t,
            1 as ::core::ffi::c_int as uint8_t,
            2 as ::core::ffi::c_int as uint8_t,
            9 as ::core::ffi::c_int as uint8_t,
            16 as ::core::ffi::c_int as uint8_t,
            24 as ::core::ffi::c_int as uint8_t,
            17 as ::core::ffi::c_int as uint8_t,
            10 as ::core::ffi::c_int as uint8_t,
            3 as ::core::ffi::c_int as uint8_t,
            4 as ::core::ffi::c_int as uint8_t,
            11 as ::core::ffi::c_int as uint8_t,
            18 as ::core::ffi::c_int as uint8_t,
            25 as ::core::ffi::c_int as uint8_t,
            32 as ::core::ffi::c_int as uint8_t,
            40 as ::core::ffi::c_int as uint8_t,
            33 as ::core::ffi::c_int as uint8_t,
            26 as ::core::ffi::c_int as uint8_t,
            19 as ::core::ffi::c_int as uint8_t,
            12 as ::core::ffi::c_int as uint8_t,
            5 as ::core::ffi::c_int as uint8_t,
            6 as ::core::ffi::c_int as uint8_t,
            13 as ::core::ffi::c_int as uint8_t,
            20 as ::core::ffi::c_int as uint8_t,
            27 as ::core::ffi::c_int as uint8_t,
            34 as ::core::ffi::c_int as uint8_t,
            41 as ::core::ffi::c_int as uint8_t,
            48 as ::core::ffi::c_int as uint8_t,
            56 as ::core::ffi::c_int as uint8_t,
            49 as ::core::ffi::c_int as uint8_t,
            42 as ::core::ffi::c_int as uint8_t,
            35 as ::core::ffi::c_int as uint8_t,
            28 as ::core::ffi::c_int as uint8_t,
            21 as ::core::ffi::c_int as uint8_t,
            14 as ::core::ffi::c_int as uint8_t,
            7 as ::core::ffi::c_int as uint8_t,
            15 as ::core::ffi::c_int as uint8_t,
            22 as ::core::ffi::c_int as uint8_t,
            29 as ::core::ffi::c_int as uint8_t,
            36 as ::core::ffi::c_int as uint8_t,
            43 as ::core::ffi::c_int as uint8_t,
            50 as ::core::ffi::c_int as uint8_t,
            57 as ::core::ffi::c_int as uint8_t,
            58 as ::core::ffi::c_int as uint8_t,
            51 as ::core::ffi::c_int as uint8_t,
            44 as ::core::ffi::c_int as uint8_t,
            37 as ::core::ffi::c_int as uint8_t,
            30 as ::core::ffi::c_int as uint8_t,
            23 as ::core::ffi::c_int as uint8_t,
            31 as ::core::ffi::c_int as uint8_t,
            38 as ::core::ffi::c_int as uint8_t,
            45 as ::core::ffi::c_int as uint8_t,
            52 as ::core::ffi::c_int as uint8_t,
            59 as ::core::ffi::c_int as uint8_t,
            60 as ::core::ffi::c_int as uint8_t,
            53 as ::core::ffi::c_int as uint8_t,
            46 as ::core::ffi::c_int as uint8_t,
            39 as ::core::ffi::c_int as uint8_t,
            47 as ::core::ffi::c_int as uint8_t,
            54 as ::core::ffi::c_int as uint8_t,
            61 as ::core::ffi::c_int as uint8_t,
            62 as ::core::ffi::c_int as uint8_t,
            55 as ::core::ffi::c_int as uint8_t,
            63 as ::core::ffi::c_int as uint8_t,
        ],
        [
            0 as ::core::ffi::c_int as uint8_t,
            1 as ::core::ffi::c_int as uint8_t,
            2 as ::core::ffi::c_int as uint8_t,
            8 as ::core::ffi::c_int as uint8_t,
            9 as ::core::ffi::c_int as uint8_t,
            3 as ::core::ffi::c_int as uint8_t,
            4 as ::core::ffi::c_int as uint8_t,
            10 as ::core::ffi::c_int as uint8_t,
            16 as ::core::ffi::c_int as uint8_t,
            11 as ::core::ffi::c_int as uint8_t,
            5 as ::core::ffi::c_int as uint8_t,
            6 as ::core::ffi::c_int as uint8_t,
            7 as ::core::ffi::c_int as uint8_t,
            12 as ::core::ffi::c_int as uint8_t,
            17 as ::core::ffi::c_int as uint8_t,
            24 as ::core::ffi::c_int as uint8_t,
            18 as ::core::ffi::c_int as uint8_t,
            13 as ::core::ffi::c_int as uint8_t,
            14 as ::core::ffi::c_int as uint8_t,
            15 as ::core::ffi::c_int as uint8_t,
            19 as ::core::ffi::c_int as uint8_t,
            25 as ::core::ffi::c_int as uint8_t,
            32 as ::core::ffi::c_int as uint8_t,
            26 as ::core::ffi::c_int as uint8_t,
            20 as ::core::ffi::c_int as uint8_t,
            21 as ::core::ffi::c_int as uint8_t,
            22 as ::core::ffi::c_int as uint8_t,
            23 as ::core::ffi::c_int as uint8_t,
            27 as ::core::ffi::c_int as uint8_t,
            33 as ::core::ffi::c_int as uint8_t,
            40 as ::core::ffi::c_int as uint8_t,
            34 as ::core::ffi::c_int as uint8_t,
            28 as ::core::ffi::c_int as uint8_t,
            29 as ::core::ffi::c_int as uint8_t,
            30 as ::core::ffi::c_int as uint8_t,
            31 as ::core::ffi::c_int as uint8_t,
            35 as ::core::ffi::c_int as uint8_t,
            41 as ::core::ffi::c_int as uint8_t,
            48 as ::core::ffi::c_int as uint8_t,
            42 as ::core::ffi::c_int as uint8_t,
            36 as ::core::ffi::c_int as uint8_t,
            37 as ::core::ffi::c_int as uint8_t,
            38 as ::core::ffi::c_int as uint8_t,
            39 as ::core::ffi::c_int as uint8_t,
            43 as ::core::ffi::c_int as uint8_t,
            49 as ::core::ffi::c_int as uint8_t,
            50 as ::core::ffi::c_int as uint8_t,
            44 as ::core::ffi::c_int as uint8_t,
            45 as ::core::ffi::c_int as uint8_t,
            46 as ::core::ffi::c_int as uint8_t,
            47 as ::core::ffi::c_int as uint8_t,
            51 as ::core::ffi::c_int as uint8_t,
            56 as ::core::ffi::c_int as uint8_t,
            57 as ::core::ffi::c_int as uint8_t,
            52 as ::core::ffi::c_int as uint8_t,
            53 as ::core::ffi::c_int as uint8_t,
            54 as ::core::ffi::c_int as uint8_t,
            55 as ::core::ffi::c_int as uint8_t,
            58 as ::core::ffi::c_int as uint8_t,
            59 as ::core::ffi::c_int as uint8_t,
            60 as ::core::ffi::c_int as uint8_t,
            61 as ::core::ffi::c_int as uint8_t,
            62 as ::core::ffi::c_int as uint8_t,
            63 as ::core::ffi::c_int as uint8_t,
        ],
    ];
    #[c2rust::src_loc = "202:22"]
    pub static mut block_idx_x: [uint8_t; 16] = [
        0 as ::core::ffi::c_int as uint8_t,
        1 as ::core::ffi::c_int as uint8_t,
        0 as ::core::ffi::c_int as uint8_t,
        1 as ::core::ffi::c_int as uint8_t,
        2 as ::core::ffi::c_int as uint8_t,
        3 as ::core::ffi::c_int as uint8_t,
        2 as ::core::ffi::c_int as uint8_t,
        3 as ::core::ffi::c_int as uint8_t,
        0 as ::core::ffi::c_int as uint8_t,
        1 as ::core::ffi::c_int as uint8_t,
        0 as ::core::ffi::c_int as uint8_t,
        1 as ::core::ffi::c_int as uint8_t,
        2 as ::core::ffi::c_int as uint8_t,
        3 as ::core::ffi::c_int as uint8_t,
        2 as ::core::ffi::c_int as uint8_t,
        3 as ::core::ffi::c_int as uint8_t,
    ];
    #[c2rust::src_loc = "206:22"]
    pub static mut block_idx_y: [uint8_t; 16] = [
        0 as ::core::ffi::c_int as uint8_t,
        0 as ::core::ffi::c_int as uint8_t,
        1 as ::core::ffi::c_int as uint8_t,
        1 as ::core::ffi::c_int as uint8_t,
        0 as ::core::ffi::c_int as uint8_t,
        0 as ::core::ffi::c_int as uint8_t,
        1 as ::core::ffi::c_int as uint8_t,
        1 as ::core::ffi::c_int as uint8_t,
        2 as ::core::ffi::c_int as uint8_t,
        2 as ::core::ffi::c_int as uint8_t,
        3 as ::core::ffi::c_int as uint8_t,
        3 as ::core::ffi::c_int as uint8_t,
        2 as ::core::ffi::c_int as uint8_t,
        2 as ::core::ffi::c_int as uint8_t,
        3 as ::core::ffi::c_int as uint8_t,
        3 as ::core::ffi::c_int as uint8_t,
    ];
    #[c2rust::src_loc = "225:22"]
    pub static mut block_idx_xy_fenc: [uint8_t; 16] = [
        (0 as ::core::ffi::c_int * 4 as ::core::ffi::c_int
            + 0 as ::core::ffi::c_int * 4 as ::core::ffi::c_int * FENC_STRIDE) as uint8_t,
        (1 as ::core::ffi::c_int * 4 as ::core::ffi::c_int
            + 0 as ::core::ffi::c_int * 4 as ::core::ffi::c_int * FENC_STRIDE) as uint8_t,
        (0 as ::core::ffi::c_int * 4 as ::core::ffi::c_int
            + 1 as ::core::ffi::c_int * 4 as ::core::ffi::c_int * FENC_STRIDE) as uint8_t,
        (1 as ::core::ffi::c_int * 4 as ::core::ffi::c_int
            + 1 as ::core::ffi::c_int * 4 as ::core::ffi::c_int * FENC_STRIDE) as uint8_t,
        (2 as ::core::ffi::c_int * 4 as ::core::ffi::c_int
            + 0 as ::core::ffi::c_int * 4 as ::core::ffi::c_int * FENC_STRIDE) as uint8_t,
        (3 as ::core::ffi::c_int * 4 as ::core::ffi::c_int
            + 0 as ::core::ffi::c_int * 4 as ::core::ffi::c_int * FENC_STRIDE) as uint8_t,
        (2 as ::core::ffi::c_int * 4 as ::core::ffi::c_int
            + 1 as ::core::ffi::c_int * 4 as ::core::ffi::c_int * FENC_STRIDE) as uint8_t,
        (3 as ::core::ffi::c_int * 4 as ::core::ffi::c_int
            + 1 as ::core::ffi::c_int * 4 as ::core::ffi::c_int * FENC_STRIDE) as uint8_t,
        (0 as ::core::ffi::c_int * 4 as ::core::ffi::c_int
            + 2 as ::core::ffi::c_int * 4 as ::core::ffi::c_int * FENC_STRIDE) as uint8_t,
        (1 as ::core::ffi::c_int * 4 as ::core::ffi::c_int
            + 2 as ::core::ffi::c_int * 4 as ::core::ffi::c_int * FENC_STRIDE) as uint8_t,
        (0 as ::core::ffi::c_int * 4 as ::core::ffi::c_int
            + 3 as ::core::ffi::c_int * 4 as ::core::ffi::c_int * FENC_STRIDE) as uint8_t,
        (1 as ::core::ffi::c_int * 4 as ::core::ffi::c_int
            + 3 as ::core::ffi::c_int * 4 as ::core::ffi::c_int * FENC_STRIDE) as uint8_t,
        (2 as ::core::ffi::c_int * 4 as ::core::ffi::c_int
            + 2 as ::core::ffi::c_int * 4 as ::core::ffi::c_int * FENC_STRIDE) as uint8_t,
        (3 as ::core::ffi::c_int * 4 as ::core::ffi::c_int
            + 2 as ::core::ffi::c_int * 4 as ::core::ffi::c_int * FENC_STRIDE) as uint8_t,
        (2 as ::core::ffi::c_int * 4 as ::core::ffi::c_int
            + 3 as ::core::ffi::c_int * 4 as ::core::ffi::c_int * FENC_STRIDE) as uint8_t,
        (3 as ::core::ffi::c_int * 4 as ::core::ffi::c_int
            + 3 as ::core::ffi::c_int * 4 as ::core::ffi::c_int * FENC_STRIDE) as uint8_t,
    ];
    #[c2rust::src_loc = "236:23"]
    pub static mut block_idx_xy_fdec: [uint16_t; 16] = [
        (0 as ::core::ffi::c_int * 4 as ::core::ffi::c_int
            + 0 as ::core::ffi::c_int * 4 as ::core::ffi::c_int * FDEC_STRIDE) as uint16_t,
        (1 as ::core::ffi::c_int * 4 as ::core::ffi::c_int
            + 0 as ::core::ffi::c_int * 4 as ::core::ffi::c_int * FDEC_STRIDE) as uint16_t,
        (0 as ::core::ffi::c_int * 4 as ::core::ffi::c_int
            + 1 as ::core::ffi::c_int * 4 as ::core::ffi::c_int * FDEC_STRIDE) as uint16_t,
        (1 as ::core::ffi::c_int * 4 as ::core::ffi::c_int
            + 1 as ::core::ffi::c_int * 4 as ::core::ffi::c_int * FDEC_STRIDE) as uint16_t,
        (2 as ::core::ffi::c_int * 4 as ::core::ffi::c_int
            + 0 as ::core::ffi::c_int * 4 as ::core::ffi::c_int * FDEC_STRIDE) as uint16_t,
        (3 as ::core::ffi::c_int * 4 as ::core::ffi::c_int
            + 0 as ::core::ffi::c_int * 4 as ::core::ffi::c_int * FDEC_STRIDE) as uint16_t,
        (2 as ::core::ffi::c_int * 4 as ::core::ffi::c_int
            + 1 as ::core::ffi::c_int * 4 as ::core::ffi::c_int * FDEC_STRIDE) as uint16_t,
        (3 as ::core::ffi::c_int * 4 as ::core::ffi::c_int
            + 1 as ::core::ffi::c_int * 4 as ::core::ffi::c_int * FDEC_STRIDE) as uint16_t,
        (0 as ::core::ffi::c_int * 4 as ::core::ffi::c_int
            + 2 as ::core::ffi::c_int * 4 as ::core::ffi::c_int * FDEC_STRIDE) as uint16_t,
        (1 as ::core::ffi::c_int * 4 as ::core::ffi::c_int
            + 2 as ::core::ffi::c_int * 4 as ::core::ffi::c_int * FDEC_STRIDE) as uint16_t,
        (0 as ::core::ffi::c_int * 4 as ::core::ffi::c_int
            + 3 as ::core::ffi::c_int * 4 as ::core::ffi::c_int * FDEC_STRIDE) as uint16_t,
        (1 as ::core::ffi::c_int * 4 as ::core::ffi::c_int
            + 3 as ::core::ffi::c_int * 4 as ::core::ffi::c_int * FDEC_STRIDE) as uint16_t,
        (2 as ::core::ffi::c_int * 4 as ::core::ffi::c_int
            + 2 as ::core::ffi::c_int * 4 as ::core::ffi::c_int * FDEC_STRIDE) as uint16_t,
        (3 as ::core::ffi::c_int * 4 as ::core::ffi::c_int
            + 2 as ::core::ffi::c_int * 4 as ::core::ffi::c_int * FDEC_STRIDE) as uint16_t,
        (2 as ::core::ffi::c_int * 4 as ::core::ffi::c_int
            + 3 as ::core::ffi::c_int * 4 as ::core::ffi::c_int * FDEC_STRIDE) as uint16_t,
        (3 as ::core::ffi::c_int * 4 as ::core::ffi::c_int
            + 3 as ::core::ffi::c_int * 4 as ::core::ffi::c_int * FDEC_STRIDE) as uint16_t,
    ];
    #[c2rust::src_loc = "291:22"]
    pub static mut ctx_cat_plane: [[uint8_t; 3]; 6] = [
        [
            DCT_LUMA_DC as ::core::ffi::c_int as uint8_t,
            DCT_CHROMAU_DC as ::core::ffi::c_int as uint8_t,
            DCT_CHROMAV_DC as ::core::ffi::c_int as uint8_t,
        ],
        [
            DCT_LUMA_AC as ::core::ffi::c_int as uint8_t,
            DCT_CHROMAU_AC as ::core::ffi::c_int as uint8_t,
            DCT_CHROMAV_AC as ::core::ffi::c_int as uint8_t,
        ],
        [
            DCT_LUMA_4x4 as ::core::ffi::c_int as uint8_t,
            DCT_CHROMAU_4x4 as ::core::ffi::c_int as uint8_t,
            DCT_CHROMAV_4x4 as ::core::ffi::c_int as uint8_t,
        ],
        [0 as ::core::ffi::c_int as uint8_t, 0, 0],
        [0 as ::core::ffi::c_int as uint8_t, 0, 0],
        [
            DCT_LUMA_8x8 as ::core::ffi::c_int as uint8_t,
            DCT_CHROMAU_8x8 as ::core::ffi::c_int as uint8_t,
            DCT_CHROMAV_8x8 as ::core::ffi::c_int as uint8_t,
        ],
    ];
    #[inline(always)]
    #[c2rust::src_loc = "371:1"]
    pub unsafe extern "C" fn pack16to32(mut a: uint32_t, mut b: uint32_t) -> uint32_t {
        return a.wrapping_add(b << 16 as ::core::ffi::c_int);
    }
    #[inline(always)]
    #[c2rust::src_loc = "379:1"]
    pub unsafe extern "C" fn pack8to16(mut a: uint32_t, mut b: uint32_t) -> uint32_t {
        return a.wrapping_add(b << 8 as ::core::ffi::c_int);
    }
    #[inline(always)]
    #[c2rust::src_loc = "420:1"]
    pub unsafe extern "C" fn x264_mb_predict_intra4x4_mode(
        mut h: *mut x264_t,
        mut idx: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int {
        let ma: ::core::ffi::c_int = (*h).mb.cache.intra4x4_pred_mode
            [(x264_scan8[idx as usize] as ::core::ffi::c_int - 1 as ::core::ffi::c_int) as usize]
            as ::core::ffi::c_int;
        let mb: ::core::ffi::c_int = (*h).mb.cache.intra4x4_pred_mode
            [(x264_scan8[idx as usize] as ::core::ffi::c_int - 8 as ::core::ffi::c_int) as usize]
            as ::core::ffi::c_int;
        let m: ::core::ffi::c_int = if (x264_mb_pred_mode4x4_fix
            [(ma + 1 as ::core::ffi::c_int) as usize]
            as ::core::ffi::c_int)
            < x264_mb_pred_mode4x4_fix[(mb + 1 as ::core::ffi::c_int) as usize]
                as ::core::ffi::c_int
        {
            x264_mb_pred_mode4x4_fix[(ma + 1 as ::core::ffi::c_int) as usize] as ::core::ffi::c_int
        } else {
            x264_mb_pred_mode4x4_fix[(mb + 1 as ::core::ffi::c_int) as usize] as ::core::ffi::c_int
        };
        if m < 0 as ::core::ffi::c_int {
            return I_PRED_4x4_DC as ::core::ffi::c_int;
        }
        return m;
    }
    #[inline(always)]
    #[c2rust::src_loc = "432:1"]
    pub unsafe extern "C" fn x264_mb_predict_non_zero_code(
        mut h: *mut x264_t,
        mut idx: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int {
        let za: ::core::ffi::c_int = (*h).mb.cache.non_zero_count
            [(x264_scan8[idx as usize] as ::core::ffi::c_int - 1 as ::core::ffi::c_int) as usize]
            as ::core::ffi::c_int;
        let zb: ::core::ffi::c_int = (*h).mb.cache.non_zero_count
            [(x264_scan8[idx as usize] as ::core::ffi::c_int - 8 as ::core::ffi::c_int) as usize]
            as ::core::ffi::c_int;
        let mut i_ret: ::core::ffi::c_int = za + zb;
        if i_ret < 0x80 as ::core::ffi::c_int {
            i_ret = i_ret + 1 as ::core::ffi::c_int >> 1 as ::core::ffi::c_int;
        }
        return i_ret & 0x7f as ::core::ffi::c_int;
    }
    #[c2rust::src_loc = "445:22"]
    pub static mut x264_transform_allowed: [uint8_t; 19] = [
        0 as ::core::ffi::c_int as uint8_t,
        0 as ::core::ffi::c_int as uint8_t,
        0 as ::core::ffi::c_int as uint8_t,
        0 as ::core::ffi::c_int as uint8_t,
        1 as ::core::ffi::c_int as uint8_t,
        2 as ::core::ffi::c_int as uint8_t,
        0 as ::core::ffi::c_int as uint8_t,
        1 as ::core::ffi::c_int as uint8_t,
        1 as ::core::ffi::c_int as uint8_t,
        1 as ::core::ffi::c_int as uint8_t,
        1 as ::core::ffi::c_int as uint8_t,
        1 as ::core::ffi::c_int as uint8_t,
        1 as ::core::ffi::c_int as uint8_t,
        1 as ::core::ffi::c_int as uint8_t,
        1 as ::core::ffi::c_int as uint8_t,
        1 as ::core::ffi::c_int as uint8_t,
        1 as ::core::ffi::c_int as uint8_t,
        1 as ::core::ffi::c_int as uint8_t,
        0 as ::core::ffi::c_int as uint8_t,
    ];
    #[inline(always)]
    #[c2rust::src_loc = "454:1"]
    pub unsafe extern "C" fn x264_mb_transform_8x8_allowed(
        mut h: *mut x264_t,
    ) -> ::core::ffi::c_int {
        if (*(*h).pps.as_mut_ptr()).b_transform_8x8_mode == 0 {
            return 0 as ::core::ffi::c_int;
        }
        if (*h).mb.i_type != P_8x8 as ::core::ffi::c_int {
            return x264_transform_allowed[(*h).mb.i_type as usize] as ::core::ffi::c_int;
        }
        return ((*((*h).mb.i_sub_partition.as_mut_ptr() as *mut x264_union32_t)).i
            == (D_L0_8x8 as ::core::ffi::c_int * 0x1010101 as ::core::ffi::c_int) as uint32_t)
            as ::core::ffi::c_int;
    }
    use super::base_h::{x264_scan8, x264_union32_t};
    use super::common_h::{x264_t, FDEC_STRIDE, FENC_STRIDE};
    use super::predict_h::{x264_mb_pred_mode4x4_fix, I_PRED_4x4_DC};
    use super::stdint_intn_h::{int16_t, int8_t};
    use super::stdint_uintn_h::{uint16_t, uint32_t, uint8_t};
    extern "C" {
        #[c2rust::src_loc = "339:1"]
        pub fn x264_10_mb_predict_mv_16x16(
            h: *mut x264_t,
            i_list: ::core::ffi::c_int,
            i_ref: ::core::ffi::c_int,
            mvp: *mut int16_t,
        );
        #[c2rust::src_loc = "350:1"]
        pub fn x264_10_mb_predict_mv(
            h: *mut x264_t,
            i_list: ::core::ffi::c_int,
            idx: ::core::ffi::c_int,
            i_width: ::core::ffi::c_int,
            mvp: *mut int16_t,
        );
        #[c2rust::src_loc = "358:1"]
        pub fn x264_10_mb_predict_mv_direct16x16(
            h: *mut x264_t,
            b_changed: *mut ::core::ffi::c_int,
        ) -> ::core::ffi::c_int;
        #[c2rust::src_loc = "364:1"]
        pub fn x264_10_mb_predict_mv_ref16x16(
            h: *mut x264_t,
            i_list: ::core::ffi::c_int,
            i_ref: ::core::ffi::c_int,
            mvc: *mut [int16_t; 2],
            i_mvc: *mut ::core::ffi::c_int,
        );
        #[c2rust::src_loc = "367:1"]
        pub fn x264_10_mb_mc(h: *mut x264_t);
    }

    #[c2rust::src_loc = "171:22"]
    pub static mut x264_mb_partition_pixel_table: [uint8_t; 17] = [
        PIXEL_4x4 as ::core::ffi::c_int as uint8_t,
        PIXEL_8x4 as ::core::ffi::c_int as uint8_t,
        PIXEL_4x8 as ::core::ffi::c_int as uint8_t,
        PIXEL_8x8 as ::core::ffi::c_int as uint8_t,
        PIXEL_4x4 as ::core::ffi::c_int as uint8_t,
        PIXEL_8x4 as ::core::ffi::c_int as uint8_t,
        PIXEL_4x8 as ::core::ffi::c_int as uint8_t,
        PIXEL_8x8 as ::core::ffi::c_int as uint8_t,
        PIXEL_4x4 as ::core::ffi::c_int as uint8_t,
        PIXEL_8x4 as ::core::ffi::c_int as uint8_t,
        PIXEL_4x8 as ::core::ffi::c_int as uint8_t,
        PIXEL_8x8 as ::core::ffi::c_int as uint8_t,
        PIXEL_8x8 as ::core::ffi::c_int as uint8_t,
        PIXEL_8x8 as ::core::ffi::c_int as uint8_t,
        PIXEL_16x8 as ::core::ffi::c_int as uint8_t,
        PIXEL_8x16 as ::core::ffi::c_int as uint8_t,
        PIXEL_16x16 as ::core::ffi::c_int as uint8_t,
    ];
    #[c2rust::src_loc = "249:22"]
    pub static mut i_chroma_qp_table: [uint8_t; 106] = [
        0 as ::core::ffi::c_int as uint8_t,
        0 as ::core::ffi::c_int as uint8_t,
        0 as ::core::ffi::c_int as uint8_t,
        0 as ::core::ffi::c_int as uint8_t,
        0 as ::core::ffi::c_int as uint8_t,
        0 as ::core::ffi::c_int as uint8_t,
        0 as ::core::ffi::c_int as uint8_t,
        0 as ::core::ffi::c_int as uint8_t,
        0 as ::core::ffi::c_int as uint8_t,
        0 as ::core::ffi::c_int as uint8_t,
        0 as ::core::ffi::c_int as uint8_t,
        0 as ::core::ffi::c_int as uint8_t,
        (-(12 as ::core::ffi::c_int) + QP_BD_OFFSET) as uint8_t,
        (-(11 as ::core::ffi::c_int) + QP_BD_OFFSET) as uint8_t,
        (-(10 as ::core::ffi::c_int) + QP_BD_OFFSET) as uint8_t,
        (-(9 as ::core::ffi::c_int) + QP_BD_OFFSET) as uint8_t,
        (-(8 as ::core::ffi::c_int) + QP_BD_OFFSET) as uint8_t,
        (-(7 as ::core::ffi::c_int) + QP_BD_OFFSET) as uint8_t,
        (-(6 as ::core::ffi::c_int) + QP_BD_OFFSET) as uint8_t,
        (-(5 as ::core::ffi::c_int) + QP_BD_OFFSET) as uint8_t,
        (-(4 as ::core::ffi::c_int) + QP_BD_OFFSET) as uint8_t,
        (-(3 as ::core::ffi::c_int) + QP_BD_OFFSET) as uint8_t,
        (-(2 as ::core::ffi::c_int) + QP_BD_OFFSET) as uint8_t,
        (-(1 as ::core::ffi::c_int) + QP_BD_OFFSET) as uint8_t,
        (0 as ::core::ffi::c_int + QP_BD_OFFSET) as uint8_t,
        (1 as ::core::ffi::c_int + QP_BD_OFFSET) as uint8_t,
        (2 as ::core::ffi::c_int + QP_BD_OFFSET) as uint8_t,
        (3 as ::core::ffi::c_int + QP_BD_OFFSET) as uint8_t,
        (4 as ::core::ffi::c_int + QP_BD_OFFSET) as uint8_t,
        (5 as ::core::ffi::c_int + QP_BD_OFFSET) as uint8_t,
        (6 as ::core::ffi::c_int + QP_BD_OFFSET) as uint8_t,
        (7 as ::core::ffi::c_int + QP_BD_OFFSET) as uint8_t,
        (8 as ::core::ffi::c_int + QP_BD_OFFSET) as uint8_t,
        (9 as ::core::ffi::c_int + QP_BD_OFFSET) as uint8_t,
        (10 as ::core::ffi::c_int + QP_BD_OFFSET) as uint8_t,
        (11 as ::core::ffi::c_int + QP_BD_OFFSET) as uint8_t,
        (12 as ::core::ffi::c_int + QP_BD_OFFSET) as uint8_t,
        (13 as ::core::ffi::c_int + QP_BD_OFFSET) as uint8_t,
        (14 as ::core::ffi::c_int + QP_BD_OFFSET) as uint8_t,
        (15 as ::core::ffi::c_int + QP_BD_OFFSET) as uint8_t,
        (16 as ::core::ffi::c_int + QP_BD_OFFSET) as uint8_t,
        (17 as ::core::ffi::c_int + QP_BD_OFFSET) as uint8_t,
        (18 as ::core::ffi::c_int + QP_BD_OFFSET) as uint8_t,
        (19 as ::core::ffi::c_int + QP_BD_OFFSET) as uint8_t,
        (20 as ::core::ffi::c_int + QP_BD_OFFSET) as uint8_t,
        (21 as ::core::ffi::c_int + QP_BD_OFFSET) as uint8_t,
        (22 as ::core::ffi::c_int + QP_BD_OFFSET) as uint8_t,
        (23 as ::core::ffi::c_int + QP_BD_OFFSET) as uint8_t,
        (24 as ::core::ffi::c_int + QP_BD_OFFSET) as uint8_t,
        (25 as ::core::ffi::c_int + QP_BD_OFFSET) as uint8_t,
        (26 as ::core::ffi::c_int + QP_BD_OFFSET) as uint8_t,
        (27 as ::core::ffi::c_int + QP_BD_OFFSET) as uint8_t,
        (28 as ::core::ffi::c_int + QP_BD_OFFSET) as uint8_t,
        (29 as ::core::ffi::c_int + QP_BD_OFFSET) as uint8_t,
        (29 as ::core::ffi::c_int + QP_BD_OFFSET) as uint8_t,
        (30 as ::core::ffi::c_int + QP_BD_OFFSET) as uint8_t,
        (31 as ::core::ffi::c_int + QP_BD_OFFSET) as uint8_t,
        (32 as ::core::ffi::c_int + QP_BD_OFFSET) as uint8_t,
        (32 as ::core::ffi::c_int + QP_BD_OFFSET) as uint8_t,
        (33 as ::core::ffi::c_int + QP_BD_OFFSET) as uint8_t,
        (34 as ::core::ffi::c_int + QP_BD_OFFSET) as uint8_t,
        (34 as ::core::ffi::c_int + QP_BD_OFFSET) as uint8_t,
        (35 as ::core::ffi::c_int + QP_BD_OFFSET) as uint8_t,
        (35 as ::core::ffi::c_int + QP_BD_OFFSET) as uint8_t,
        (36 as ::core::ffi::c_int + QP_BD_OFFSET) as uint8_t,
        (36 as ::core::ffi::c_int + QP_BD_OFFSET) as uint8_t,
        (37 as ::core::ffi::c_int + QP_BD_OFFSET) as uint8_t,
        (37 as ::core::ffi::c_int + QP_BD_OFFSET) as uint8_t,
        (37 as ::core::ffi::c_int + QP_BD_OFFSET) as uint8_t,
        (38 as ::core::ffi::c_int + QP_BD_OFFSET) as uint8_t,
        (38 as ::core::ffi::c_int + QP_BD_OFFSET) as uint8_t,
        (38 as ::core::ffi::c_int + QP_BD_OFFSET) as uint8_t,
        (39 as ::core::ffi::c_int + QP_BD_OFFSET) as uint8_t,
        (39 as ::core::ffi::c_int + QP_BD_OFFSET) as uint8_t,
        (39 as ::core::ffi::c_int + QP_BD_OFFSET) as uint8_t,
        (39 as ::core::ffi::c_int + QP_BD_OFFSET) as uint8_t,
        (39 as ::core::ffi::c_int + QP_BD_OFFSET) as uint8_t,
        (39 as ::core::ffi::c_int + QP_BD_OFFSET) as uint8_t,
        (39 as ::core::ffi::c_int + QP_BD_OFFSET) as uint8_t,
        (39 as ::core::ffi::c_int + QP_BD_OFFSET) as uint8_t,
        (39 as ::core::ffi::c_int + QP_BD_OFFSET) as uint8_t,
        (39 as ::core::ffi::c_int + QP_BD_OFFSET) as uint8_t,
        (39 as ::core::ffi::c_int + QP_BD_OFFSET) as uint8_t,
        (39 as ::core::ffi::c_int + QP_BD_OFFSET) as uint8_t,
        (39 as ::core::ffi::c_int + QP_BD_OFFSET) as uint8_t,
        (39 as ::core::ffi::c_int + QP_BD_OFFSET) as uint8_t,
        (39 as ::core::ffi::c_int + QP_BD_OFFSET) as uint8_t,
        (39 as ::core::ffi::c_int + QP_BD_OFFSET) as uint8_t,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
    ];
    use super::common_h::QP_BD_OFFSET;
    use super::pixel_h::{
        PIXEL_16x16, PIXEL_16x8, PIXEL_4x4, PIXEL_4x8, PIXEL_8x16, PIXEL_8x4, PIXEL_8x8,
    };
    extern "C" {
        #[c2rust::src_loc = "303:1"]
        pub fn x264_10_macroblock_cache_allocate(h: *mut x264_t) -> ::core::ffi::c_int;
        #[c2rust::src_loc = "305:1"]
        pub fn x264_10_macroblock_cache_free(h: *mut x264_t);
        #[c2rust::src_loc = "309:1"]
        pub fn x264_10_macroblock_thread_allocate(
            h: *mut x264_t,
            b_lookahead: ::core::ffi::c_int,
        ) -> ::core::ffi::c_int;
        #[c2rust::src_loc = "311:1"]
        pub fn x264_10_macroblock_thread_free(h: *mut x264_t, b_lookahead: ::core::ffi::c_int);
        #[c2rust::src_loc = "314:1"]
        pub fn x264_10_macroblock_slice_init(h: *mut x264_t);
        #[c2rust::src_loc = "316:1"]
        pub fn x264_10_macroblock_thread_init(h: *mut x264_t);
        #[c2rust::src_loc = "320:1"]
        pub fn x264_10_macroblock_cache_load_interlaced(
            h: *mut x264_t,
            mb_x: ::core::ffi::c_int,
            mb_y: ::core::ffi::c_int,
        );
        #[c2rust::src_loc = "322:1"]
        pub fn x264_10_macroblock_deblock_strength(h: *mut x264_t);
        #[c2rust::src_loc = "324:1"]
        pub fn x264_10_macroblock_cache_save(h: *mut x264_t);
        #[c2rust::src_loc = "327:1"]
        pub fn x264_10_macroblock_bipred_init(h: *mut x264_t);
    }

    #[inline(always)]
    #[c2rust::src_loc = "403:1"]
    pub unsafe extern "C" fn pack32to64(mut a: uint32_t, mut b: uint32_t) -> uint64_t {
        return (a as uint64_t).wrapping_add((b as uint64_t) << 32 as ::core::ffi::c_int);
    }
    use super::stdint_uintn_h::uint64_t;
}
#[c2rust::header_src = "/usr/lib/clang/21/include/xmmintrin.h:28"]
pub mod xmmintrin_h {
    #[cfg(target_arch = "x86")]
    pub use ::core::arch::x86::__m128;
    #[cfg(target_arch = "x86_64")]
    pub use ::core::arch::x86_64::__m128;
}
#[c2rust::header_src = "/home/nwplayer123/Hacks/hex264/x264/common/x86/util.h:28"]
pub mod util_h {
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "36:9"]
    pub union x264_union128_sse_t {
        pub i: __m128,
        pub q: [uint64_t; 2],
        pub d: [uint32_t; 4],
        pub w: [uint16_t; 8],
        pub b: [uint8_t; 16],
    }
    #[c2rust::src_loc = "34:9"]
    pub const M128_ZERO: __m128 = unsafe { core::mem::transmute([0.0f32, 0.0f32, 0.0f32, 0.0f32]) };
    use super::stdint_uintn_h::{uint16_t, uint32_t, uint64_t, uint8_t};
    use super::xmmintrin_h::__m128;
    #[cfg(target_arch = "x86")]
    pub use ::core::arch::x86::_mm_setr_ps;
    #[cfg(target_arch = "x86_64")]
    pub use ::core::arch::x86_64::_mm_setr_ps;
}
#[c2rust::header_src = "/home/nwplayer123/Hacks/hex264/x264/encoder/rdo.c:28"]
pub mod rdo_c {
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "424:9"]
    pub struct trellis_level_t {
        pub next: uint16_t,
        pub abs_level: uint16_t,
    }
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "417:9"]
    pub struct trellis_node_t {
        pub score: uint64_t,
        pub level_idx: ::core::ffi::c_int,
        pub cabac_state: [uint8_t; 4],
    }
    #[no_mangle]
    #[c2rust::src_loc = "36:9"]
    pub static mut x264_10_cabac_transition_unary: [[uint8_t; 128]; 15] = [[0; 128]; 15];
    #[no_mangle]
    #[c2rust::src_loc = "38:10"]
    pub static mut x264_10_cabac_size_unary: [[uint16_t; 128]; 15] = [[0; 128]; 15];
    #[c2rust::src_loc = "41:16"]
    pub static mut cabac_transition_5ones: [uint8_t; 128] = [0; 128];
    #[c2rust::src_loc = "42:17"]
    pub static mut cabac_size_5ones: [uint16_t; 128] = [0; 128];
    #[inline(always)]
    #[c2rust::src_loc = "75:1"]
    pub unsafe extern "C" fn cached_hadamard(
        mut h: *mut x264_t,
        mut size: ::core::ffi::c_int,
        mut x: ::core::ffi::c_int,
        mut y: ::core::ffi::c_int,
    ) -> uint64_t {
        pub static mut hadamard_shift_x: [uint8_t; 4] = [
            4 as ::core::ffi::c_int as uint8_t,
            4 as ::core::ffi::c_int as uint8_t,
            3 as ::core::ffi::c_int as uint8_t,
            3 as ::core::ffi::c_int as uint8_t,
        ];
        pub static mut hadamard_shift_y: [uint8_t; 4] = [
            (4 as ::core::ffi::c_int - 0 as ::core::ffi::c_int) as uint8_t,
            (3 as ::core::ffi::c_int - 0 as ::core::ffi::c_int) as uint8_t,
            (4 as ::core::ffi::c_int - 1 as ::core::ffi::c_int) as uint8_t,
            (3 as ::core::ffi::c_int - 1 as ::core::ffi::c_int) as uint8_t,
        ];
        pub static mut hadamard_offset: [uint8_t; 4] = [
            0 as ::core::ffi::c_int as uint8_t,
            1 as ::core::ffi::c_int as uint8_t,
            3 as ::core::ffi::c_int as uint8_t,
            5 as ::core::ffi::c_int as uint8_t,
        ];
        let mut cache_index: ::core::ffi::c_int = (x
            >> hadamard_shift_x[size as usize] as ::core::ffi::c_int)
            + (y >> hadamard_shift_y[size as usize] as ::core::ffi::c_int)
            + hadamard_offset[size as usize] as ::core::ffi::c_int;
        let mut res: uint64_t = (*h).mb.pic.fenc_hadamard_cache[cache_index as usize];
        if res != 0 {
            return res.wrapping_sub(1 as uint64_t);
        } else {
            let mut fenc: *mut pixel = (*h).mb.pic.p_fenc[0 as ::core::ffi::c_int as usize]
                .offset(x as isize)
                .offset((y * FENC_STRIDE) as isize);
            res = (*h).pixf.hadamard_ac[size as usize].expect("non-null function pointer")(
                fenc,
                FENC_STRIDE as intptr_t,
            );
            (*h).mb.pic.fenc_hadamard_cache[cache_index as usize] = res.wrapping_add(1 as uint64_t);
            return res;
        };
    }
    #[inline(always)]
    #[c2rust::src_loc = "94:1"]
    pub unsafe extern "C" fn cached_satd(
        mut h: *mut x264_t,
        mut size: ::core::ffi::c_int,
        mut x: ::core::ffi::c_int,
        mut y: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int {
        pub static mut satd_shift_x: [uint8_t; 3] = [
            3 as ::core::ffi::c_int as uint8_t,
            2 as ::core::ffi::c_int as uint8_t,
            2 as ::core::ffi::c_int as uint8_t,
        ];
        pub static mut satd_shift_y: [uint8_t; 3] = [
            (2 as ::core::ffi::c_int - 1 as ::core::ffi::c_int) as uint8_t,
            (3 as ::core::ffi::c_int - 2 as ::core::ffi::c_int) as uint8_t,
            (2 as ::core::ffi::c_int - 2 as ::core::ffi::c_int) as uint8_t,
        ];
        pub static mut satd_offset: [uint8_t; 3] = [
            0 as ::core::ffi::c_int as uint8_t,
            8 as ::core::ffi::c_int as uint8_t,
            16 as ::core::ffi::c_int as uint8_t,
        ];
        let mut cache_index: ::core::ffi::c_int = (x
            >> satd_shift_x[(size - PIXEL_8x4 as ::core::ffi::c_int) as usize]
                as ::core::ffi::c_int)
            + (y >> satd_shift_y[(size - PIXEL_8x4 as ::core::ffi::c_int) as usize]
                as ::core::ffi::c_int)
            + satd_offset[(size - PIXEL_8x4 as ::core::ffi::c_int) as usize] as ::core::ffi::c_int;
        let mut res: ::core::ffi::c_int =
            (*h).mb.pic.fenc_satd_cache[cache_index as usize] as ::core::ffi::c_int;
        if res != 0 {
            return res - 1 as ::core::ffi::c_int;
        } else {
            let mut fenc: *mut pixel = (*h).mb.pic.p_fenc[0 as ::core::ffi::c_int as usize]
                .offset(x as isize)
                .offset((y * FENC_STRIDE) as isize);
            let mut dc: ::core::ffi::c_int = (*h).pixf.sad[size as usize]
                .expect("non-null function pointer")(
                fenc,
                FENC_STRIDE as intptr_t,
                x264_zero.as_mut_ptr() as *mut pixel,
                0 as intptr_t,
            ) >> 1 as ::core::ffi::c_int;
            res = (*h).pixf.satd[size as usize].expect("non-null function pointer")(
                fenc,
                FENC_STRIDE as intptr_t,
                x264_zero.as_mut_ptr() as *mut pixel,
                0 as intptr_t,
            ) - dc;
            (*h).mb.pic.fenc_satd_cache[cache_index as usize] =
                (res + 1 as ::core::ffi::c_int) as uint32_t;
            return res;
        };
    }
    #[inline]
    #[c2rust::src_loc = "123:1"]
    pub unsafe extern "C" fn ssd_plane(
        mut h: *mut x264_t,
        mut size: ::core::ffi::c_int,
        mut p: ::core::ffi::c_int,
        mut x: ::core::ffi::c_int,
        mut y: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int {
        let mut satd: ::core::ffi::c_int = 0 as ::core::ffi::c_int;
        let mut fdec: *mut pixel = (*h).mb.pic.p_fdec[p as usize]
            .offset(x as isize)
            .offset((y * FDEC_STRIDE) as isize);
        let mut fenc: *mut pixel = (*h).mb.pic.p_fenc[p as usize]
            .offset(x as isize)
            .offset((y * FENC_STRIDE) as isize);
        if p == 0 as ::core::ffi::c_int && (*h).mb.i_psy_rd != 0 {
            if size <= PIXEL_8x8 as ::core::ffi::c_int {
                let mut fdec_acs: uint64_t = (*h).pixf.hadamard_ac[size as usize]
                    .expect("non-null function pointer")(
                    fdec, FDEC_STRIDE as intptr_t
                );
                let mut fenc_acs: uint64_t = cached_hadamard(h, size, x, y);
                satd = abs(fdec_acs as ::core::ffi::c_int - fenc_acs as ::core::ffi::c_int)
                    + abs((fdec_acs >> 32 as ::core::ffi::c_int) as ::core::ffi::c_int
                        - (fenc_acs >> 32 as ::core::ffi::c_int) as ::core::ffi::c_int);
                satd >>= 1 as ::core::ffi::c_int;
            } else {
                let mut dc: ::core::ffi::c_int = (*h).pixf.sad[size as usize]
                    .expect("non-null function pointer")(
                    fdec,
                    FDEC_STRIDE as intptr_t,
                    x264_zero.as_mut_ptr() as *mut pixel,
                    0 as intptr_t,
                ) >> 1 as ::core::ffi::c_int;
                satd = abs(
                    (*h).pixf.satd[size as usize].expect("non-null function pointer")(
                        fdec,
                        FDEC_STRIDE as intptr_t,
                        x264_zero.as_mut_ptr() as *mut pixel,
                        0 as intptr_t,
                    ) - dc
                        - cached_satd(h, size, x, y),
                );
            }
            let mut tmp: int64_t =
                satd as int64_t * (*h).mb.i_psy_rd as int64_t * (*h).mb.i_psy_rd_lambda as int64_t
                    + 128 as int64_t
                    >> 8 as ::core::ffi::c_int;
            satd = (if tmp < ((1 as ::core::ffi::c_int) << 28 as ::core::ffi::c_int) as int64_t {
                tmp
            } else {
                ((1 as ::core::ffi::c_int) << 28 as ::core::ffi::c_int) as int64_t
            }) as ::core::ffi::c_int;
        }
        return (*h).pixf.ssd[size as usize].expect("non-null function pointer")(
            fenc,
            FENC_STRIDE as intptr_t,
            fdec,
            FDEC_STRIDE as intptr_t,
        ) + satd;
    }
    #[inline]
    #[c2rust::src_loc = "150:1"]
    pub unsafe extern "C" fn ssd_mb(mut h: *mut x264_t) -> ::core::ffi::c_int {
        let mut i_ssd: ::core::ffi::c_int = ssd_plane(
            h,
            PIXEL_16x16 as ::core::ffi::c_int,
            0 as ::core::ffi::c_int,
            0 as ::core::ffi::c_int,
            0 as ::core::ffi::c_int,
        );
        if (*(*h).sps.as_mut_ptr()).i_chroma_format_idc != 0 {
            let mut chroma_size: ::core::ffi::c_int = (*h).luma2chroma_pixel
                [PIXEL_16x16 as ::core::ffi::c_int as usize]
                as ::core::ffi::c_int;
            let mut chroma_ssd: ::core::ffi::c_int = ssd_plane(
                h,
                chroma_size,
                1 as ::core::ffi::c_int,
                0 as ::core::ffi::c_int,
                0 as ::core::ffi::c_int,
            ) + ssd_plane(
                h,
                chroma_size,
                2 as ::core::ffi::c_int,
                0 as ::core::ffi::c_int,
                0 as ::core::ffi::c_int,
            );
            i_ssd = (i_ssd as uint64_t).wrapping_add(
                (chroma_ssd as uint64_t)
                    .wrapping_mul((*h).mb.i_chroma_lambda2_offset as uint64_t)
                    .wrapping_add(128 as uint64_t)
                    >> 8 as ::core::ffi::c_int,
            ) as ::core::ffi::c_int as ::core::ffi::c_int;
        }
        return i_ssd;
    }
    #[c2rust::src_loc = "162:1"]
    pub unsafe extern "C" fn rd_cost_mb(
        mut h: *mut x264_t,
        mut i_lambda2: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int {
        let mut b_transform_bak: ::core::ffi::c_int = (*h).mb.b_transform_8x8;
        let mut i_ssd: ::core::ffi::c_int = 0;
        let mut i_bits: ::core::ffi::c_int = 0;
        let mut type_bak: ::core::ffi::c_int = (*h).mb.i_type;
        x264_10_macroblock_encode(h);
        if (*h).mb.b_deblock_rdo != 0 {
            x264_10_macroblock_deblock(h);
        }
        i_ssd = ssd_mb(h);
        if (*h).mb.i_type == P_SKIP as ::core::ffi::c_int
            || (*h).mb.i_type == B_SKIP as ::core::ffi::c_int
        {
            i_bits = 1 as ::core::ffi::c_int * i_lambda2 + 128 as ::core::ffi::c_int
                >> 8 as ::core::ffi::c_int;
        } else if (*h).param.b_cabac != 0 {
            let mut cabac_tmp: x264_cabac_t = x264_cabac_t {
                i_low: 0,
                i_range: 0,
                i_queue: 0,
                i_bytes_outstanding: 0,
                p_start: 0 as *mut uint8_t,
                p: 0 as *mut uint8_t,
                p_end: 0 as *mut uint8_t,
                f8_bits_encoded: 0,
                state: [0; 1024],
                padding: [0; 12],
            };
            (*h).mc.memcpy_aligned.expect("non-null function pointer")(
                &mut cabac_tmp.f8_bits_encoded as *mut ::core::ffi::c_int
                    as *mut ::core::ffi::c_void,
                &mut (*h).cabac.f8_bits_encoded as *mut ::core::ffi::c_int
                    as *const ::core::ffi::c_void,
                (::core::mem::size_of::<::core::ffi::c_int>() as size_t).wrapping_add(
                    (if (*(*h).sps.as_mut_ptr()).i_chroma_format_idc
                        == CHROMA_444 as ::core::ffi::c_int
                    {
                        1024 as ::core::ffi::c_int + 12 as ::core::ffi::c_int
                    } else {
                        460 as ::core::ffi::c_int
                    }) as size_t,
                ),
            );
            macroblock_size_cabac(h, &mut cabac_tmp);
            i_bits = ((cabac_tmp.f8_bits_encoded as uint64_t)
                .wrapping_mul(i_lambda2 as uint64_t)
                .wrapping_add(32768 as uint64_t)
                >> 16 as ::core::ffi::c_int) as ::core::ffi::c_int;
        } else {
            macroblock_size_cavlc(h);
            i_bits = (((*h).out.bs.i_bits_encoded as uint64_t)
                .wrapping_mul(i_lambda2 as uint64_t)
                .wrapping_add(128 as uint64_t)
                >> 8 as ::core::ffi::c_int) as ::core::ffi::c_int;
        }
        (*h).mb.b_transform_8x8 = b_transform_bak;
        (*h).mb.i_type = type_bak;
        return if i_ssd + i_bits < (1 as ::core::ffi::c_int) << 28 as ::core::ffi::c_int {
            i_ssd + i_bits
        } else {
            (1 as ::core::ffi::c_int) << 28 as ::core::ffi::c_int
        };
    }
    #[c2rust::src_loc = "201:1"]
    pub unsafe extern "C" fn rd_cost_subpart(
        mut h: *mut x264_t,
        mut i_lambda2: ::core::ffi::c_int,
        mut i4: ::core::ffi::c_int,
        mut i_pixel: ::core::ffi::c_int,
    ) -> uint64_t {
        let mut i_ssd: uint64_t = 0;
        let mut i_bits: uint64_t = 0;
        x264_10_macroblock_encode_p4x4(h, i4);
        if i_pixel == PIXEL_8x4 as ::core::ffi::c_int {
            x264_10_macroblock_encode_p4x4(h, i4 + 1 as ::core::ffi::c_int);
        }
        if i_pixel == PIXEL_4x8 as ::core::ffi::c_int {
            x264_10_macroblock_encode_p4x4(h, i4 + 2 as ::core::ffi::c_int);
        }
        i_ssd = ssd_plane(
            h,
            i_pixel,
            0 as ::core::ffi::c_int,
            block_idx_x[i4 as usize] as ::core::ffi::c_int * 4 as ::core::ffi::c_int,
            block_idx_y[i4 as usize] as ::core::ffi::c_int * 4 as ::core::ffi::c_int,
        ) as uint64_t;
        if (*(*h).sps.as_mut_ptr()).i_chroma_format_idc == CHROMA_444 as ::core::ffi::c_int {
            let mut chromassd: ::core::ffi::c_int = ssd_plane(
                h,
                i_pixel,
                1 as ::core::ffi::c_int,
                block_idx_x[i4 as usize] as ::core::ffi::c_int * 4 as ::core::ffi::c_int,
                block_idx_y[i4 as usize] as ::core::ffi::c_int * 4 as ::core::ffi::c_int,
            ) + ssd_plane(
                h,
                i_pixel,
                2 as ::core::ffi::c_int,
                block_idx_x[i4 as usize] as ::core::ffi::c_int * 4 as ::core::ffi::c_int,
                block_idx_y[i4 as usize] as ::core::ffi::c_int * 4 as ::core::ffi::c_int,
            );
            chromassd = ((chromassd as uint64_t)
                .wrapping_mul((*h).mb.i_chroma_lambda2_offset as uint64_t)
                .wrapping_add(128 as uint64_t)
                >> 8 as ::core::ffi::c_int) as ::core::ffi::c_int;
            i_ssd = i_ssd.wrapping_add(chromassd as uint64_t);
        }
        if (*h).param.b_cabac != 0 {
            let mut cabac_tmp: x264_cabac_t = x264_cabac_t {
                i_low: 0,
                i_range: 0,
                i_queue: 0,
                i_bytes_outstanding: 0,
                p_start: 0 as *mut uint8_t,
                p: 0 as *mut uint8_t,
                p_end: 0 as *mut uint8_t,
                f8_bits_encoded: 0,
                state: [0; 1024],
                padding: [0; 12],
            };
            (*h).mc.memcpy_aligned.expect("non-null function pointer")(
                &mut cabac_tmp.f8_bits_encoded as *mut ::core::ffi::c_int
                    as *mut ::core::ffi::c_void,
                &mut (*h).cabac.f8_bits_encoded as *mut ::core::ffi::c_int
                    as *const ::core::ffi::c_void,
                (::core::mem::size_of::<::core::ffi::c_int>() as size_t).wrapping_add(
                    (if (*(*h).sps.as_mut_ptr()).i_chroma_format_idc
                        == CHROMA_444 as ::core::ffi::c_int
                    {
                        1024 as ::core::ffi::c_int + 12 as ::core::ffi::c_int
                    } else {
                        460 as ::core::ffi::c_int
                    }) as size_t,
                ),
            );
            subpartition_size_cabac(h, &mut cabac_tmp, i4, i_pixel);
            i_bits = (cabac_tmp.f8_bits_encoded as uint64_t)
                .wrapping_mul(i_lambda2 as uint64_t)
                .wrapping_add(128 as uint64_t)
                >> 8 as ::core::ffi::c_int;
        } else {
            i_bits = subpartition_size_cavlc(h, i4, i_pixel) as uint64_t;
        }
        return (i_ssd << 8 as ::core::ffi::c_int).wrapping_add(i_bits);
    }
    #[no_mangle]
    #[c2rust::src_loc = "233:1"]
    pub unsafe extern "C" fn x264_10_rd_cost_part(
        mut h: *mut x264_t,
        mut i_lambda2: ::core::ffi::c_int,
        mut i4: ::core::ffi::c_int,
        mut i_pixel: ::core::ffi::c_int,
    ) -> uint64_t {
        let mut i_ssd: uint64_t = 0;
        let mut i_bits: uint64_t = 0;
        let mut i8: ::core::ffi::c_int = i4 >> 2 as ::core::ffi::c_int;
        if i_pixel == PIXEL_16x16 as ::core::ffi::c_int {
            let mut i_cost: ::core::ffi::c_int = rd_cost_mb(h, i_lambda2);
            return i_cost as uint64_t;
        }
        if i_pixel > PIXEL_8x8 as ::core::ffi::c_int {
            return rd_cost_subpart(h, i_lambda2, i4, i_pixel);
        }
        (*h).mb.i_cbp_luma = 0 as ::core::ffi::c_int;
        x264_10_macroblock_encode_p8x8(h, i8);
        if i_pixel == PIXEL_16x8 as ::core::ffi::c_int {
            x264_10_macroblock_encode_p8x8(h, i8 + 1 as ::core::ffi::c_int);
        }
        if i_pixel == PIXEL_8x16 as ::core::ffi::c_int {
            x264_10_macroblock_encode_p8x8(h, i8 + 2 as ::core::ffi::c_int);
        }
        let mut ssd_x: ::core::ffi::c_int =
            8 as ::core::ffi::c_int * (i8 & 1 as ::core::ffi::c_int);
        let mut ssd_y: ::core::ffi::c_int =
            8 as ::core::ffi::c_int * (i8 >> 1 as ::core::ffi::c_int);
        i_ssd = ssd_plane(h, i_pixel, 0 as ::core::ffi::c_int, ssd_x, ssd_y) as uint64_t;
        if (*(*h).sps.as_mut_ptr()).i_chroma_format_idc != 0 {
            let mut chroma_size: ::core::ffi::c_int =
                (*h).luma2chroma_pixel[i_pixel as usize] as ::core::ffi::c_int;
            let mut chroma_ssd: ::core::ffi::c_int = ssd_plane(
                h,
                chroma_size,
                1 as ::core::ffi::c_int,
                ssd_x >> (*h).mb.chroma_h_shift,
                ssd_y >> (*h).mb.chroma_v_shift,
            ) + ssd_plane(
                h,
                chroma_size,
                2 as ::core::ffi::c_int,
                ssd_x >> (*h).mb.chroma_h_shift,
                ssd_y >> (*h).mb.chroma_v_shift,
            );
            i_ssd = i_ssd.wrapping_add(
                (chroma_ssd as uint64_t)
                    .wrapping_mul((*h).mb.i_chroma_lambda2_offset as uint64_t)
                    .wrapping_add(128 as uint64_t)
                    >> 8 as ::core::ffi::c_int,
            );
        }
        if (*h).param.b_cabac != 0 {
            let mut cabac_tmp: x264_cabac_t = x264_cabac_t {
                i_low: 0,
                i_range: 0,
                i_queue: 0,
                i_bytes_outstanding: 0,
                p_start: 0 as *mut uint8_t,
                p: 0 as *mut uint8_t,
                p_end: 0 as *mut uint8_t,
                f8_bits_encoded: 0,
                state: [0; 1024],
                padding: [0; 12],
            };
            (*h).mc.memcpy_aligned.expect("non-null function pointer")(
                &mut cabac_tmp.f8_bits_encoded as *mut ::core::ffi::c_int
                    as *mut ::core::ffi::c_void,
                &mut (*h).cabac.f8_bits_encoded as *mut ::core::ffi::c_int
                    as *const ::core::ffi::c_void,
                (::core::mem::size_of::<::core::ffi::c_int>() as size_t).wrapping_add(
                    (if (*(*h).sps.as_mut_ptr()).i_chroma_format_idc
                        == CHROMA_444 as ::core::ffi::c_int
                    {
                        1024 as ::core::ffi::c_int + 12 as ::core::ffi::c_int
                    } else {
                        460 as ::core::ffi::c_int
                    }) as size_t,
                ),
            );
            partition_size_cabac(h, &mut cabac_tmp, i8, i_pixel);
            i_bits = (cabac_tmp.f8_bits_encoded as uint64_t)
                .wrapping_mul(i_lambda2 as uint64_t)
                .wrapping_add(128 as uint64_t)
                >> 8 as ::core::ffi::c_int;
        } else {
            i_bits = (partition_size_cavlc(h, i8, i_pixel) as uint64_t)
                .wrapping_mul(i_lambda2 as uint64_t);
        }
        return (i_ssd << 8 as ::core::ffi::c_int).wrapping_add(i_bits);
    }
    #[c2rust::src_loc = "279:1"]
    pub unsafe extern "C" fn rd_cost_i8x8(
        mut h: *mut x264_t,
        mut i_lambda2: ::core::ffi::c_int,
        mut i8: ::core::ffi::c_int,
        mut i_mode: ::core::ffi::c_int,
        mut edge: *mut [pixel; 32],
    ) -> uint64_t {
        let mut i_ssd: uint64_t = 0;
        let mut i_bits: uint64_t = 0;
        let mut plane_count: ::core::ffi::c_int =
            if (*(*h).sps.as_mut_ptr()).i_chroma_format_idc == CHROMA_444 as ::core::ffi::c_int {
                3 as ::core::ffi::c_int
            } else {
                1 as ::core::ffi::c_int
            };
        let mut i_qp: ::core::ffi::c_int = (*h).mb.i_qp;
        (*h).mb.i_cbp_luma &= !((1 as ::core::ffi::c_int) << i8);
        (*h).mb.b_transform_8x8 = 1 as ::core::ffi::c_int;
        let mut p: ::core::ffi::c_int = 0 as ::core::ffi::c_int;
        while p < plane_count {
            x264_mb_encode_i8x8(
                h,
                p,
                i8,
                i_qp,
                i_mode,
                (*edge.offset(p as isize)).as_mut_ptr(),
                1 as ::core::ffi::c_int,
            );
            i_qp = (*h).mb.i_chroma_qp;
            p += 1;
        }
        i_ssd = ssd_plane(
            h,
            PIXEL_8x8 as ::core::ffi::c_int,
            0 as ::core::ffi::c_int,
            (i8 & 1 as ::core::ffi::c_int) * 8 as ::core::ffi::c_int,
            (i8 >> 1 as ::core::ffi::c_int) * 8 as ::core::ffi::c_int,
        ) as uint64_t;
        if (*(*h).sps.as_mut_ptr()).i_chroma_format_idc == CHROMA_444 as ::core::ffi::c_int {
            let mut chromassd: ::core::ffi::c_int = ssd_plane(
                h,
                PIXEL_8x8 as ::core::ffi::c_int,
                1 as ::core::ffi::c_int,
                (i8 & 1 as ::core::ffi::c_int) * 8 as ::core::ffi::c_int,
                (i8 >> 1 as ::core::ffi::c_int) * 8 as ::core::ffi::c_int,
            ) + ssd_plane(
                h,
                PIXEL_8x8 as ::core::ffi::c_int,
                2 as ::core::ffi::c_int,
                (i8 & 1 as ::core::ffi::c_int) * 8 as ::core::ffi::c_int,
                (i8 >> 1 as ::core::ffi::c_int) * 8 as ::core::ffi::c_int,
            );
            chromassd = ((chromassd as uint64_t)
                .wrapping_mul((*h).mb.i_chroma_lambda2_offset as uint64_t)
                .wrapping_add(128 as uint64_t)
                >> 8 as ::core::ffi::c_int) as ::core::ffi::c_int;
            i_ssd = i_ssd.wrapping_add(chromassd as uint64_t);
        }
        if (*h).param.b_cabac != 0 {
            let mut cabac_tmp: x264_cabac_t = x264_cabac_t {
                i_low: 0,
                i_range: 0,
                i_queue: 0,
                i_bytes_outstanding: 0,
                p_start: 0 as *mut uint8_t,
                p: 0 as *mut uint8_t,
                p_end: 0 as *mut uint8_t,
                f8_bits_encoded: 0,
                state: [0; 1024],
                padding: [0; 12],
            };
            (*h).mc.memcpy_aligned.expect("non-null function pointer")(
                &mut cabac_tmp.f8_bits_encoded as *mut ::core::ffi::c_int
                    as *mut ::core::ffi::c_void,
                &mut (*h).cabac.f8_bits_encoded as *mut ::core::ffi::c_int
                    as *const ::core::ffi::c_void,
                (::core::mem::size_of::<::core::ffi::c_int>() as size_t).wrapping_add(
                    (if (*(*h).sps.as_mut_ptr()).i_chroma_format_idc
                        == CHROMA_444 as ::core::ffi::c_int
                    {
                        1024 as ::core::ffi::c_int + 12 as ::core::ffi::c_int
                    } else {
                        460 as ::core::ffi::c_int
                    }) as size_t,
                ),
            );
            partition_i8x8_size_cabac(h, &mut cabac_tmp, i8, i_mode);
            i_bits = (cabac_tmp.f8_bits_encoded as uint64_t)
                .wrapping_mul(i_lambda2 as uint64_t)
                .wrapping_add(128 as uint64_t)
                >> 8 as ::core::ffi::c_int;
        } else {
            i_bits = (partition_i8x8_size_cavlc(h, i8, i_mode) as uint64_t)
                .wrapping_mul(i_lambda2 as uint64_t);
        }
        return (i_ssd << 8 as ::core::ffi::c_int).wrapping_add(i_bits);
    }
    #[c2rust::src_loc = "315:1"]
    pub unsafe extern "C" fn rd_cost_i4x4(
        mut h: *mut x264_t,
        mut i_lambda2: ::core::ffi::c_int,
        mut i4: ::core::ffi::c_int,
        mut i_mode: ::core::ffi::c_int,
    ) -> uint64_t {
        let mut i_ssd: uint64_t = 0;
        let mut i_bits: uint64_t = 0;
        let mut plane_count: ::core::ffi::c_int =
            if (*(*h).sps.as_mut_ptr()).i_chroma_format_idc == CHROMA_444 as ::core::ffi::c_int {
                3 as ::core::ffi::c_int
            } else {
                1 as ::core::ffi::c_int
            };
        let mut i_qp: ::core::ffi::c_int = (*h).mb.i_qp;
        let mut p: ::core::ffi::c_int = 0 as ::core::ffi::c_int;
        while p < plane_count {
            x264_mb_encode_i4x4(h, p, i4, i_qp, i_mode, 1 as ::core::ffi::c_int);
            i_qp = (*h).mb.i_chroma_qp;
            p += 1;
        }
        i_ssd = ssd_plane(
            h,
            PIXEL_4x4 as ::core::ffi::c_int,
            0 as ::core::ffi::c_int,
            block_idx_x[i4 as usize] as ::core::ffi::c_int * 4 as ::core::ffi::c_int,
            block_idx_y[i4 as usize] as ::core::ffi::c_int * 4 as ::core::ffi::c_int,
        ) as uint64_t;
        if (*(*h).sps.as_mut_ptr()).i_chroma_format_idc == CHROMA_444 as ::core::ffi::c_int {
            let mut chromassd: ::core::ffi::c_int = ssd_plane(
                h,
                PIXEL_4x4 as ::core::ffi::c_int,
                1 as ::core::ffi::c_int,
                block_idx_x[i4 as usize] as ::core::ffi::c_int * 4 as ::core::ffi::c_int,
                block_idx_y[i4 as usize] as ::core::ffi::c_int * 4 as ::core::ffi::c_int,
            ) + ssd_plane(
                h,
                PIXEL_4x4 as ::core::ffi::c_int,
                2 as ::core::ffi::c_int,
                block_idx_x[i4 as usize] as ::core::ffi::c_int * 4 as ::core::ffi::c_int,
                block_idx_y[i4 as usize] as ::core::ffi::c_int * 4 as ::core::ffi::c_int,
            );
            chromassd = ((chromassd as uint64_t)
                .wrapping_mul((*h).mb.i_chroma_lambda2_offset as uint64_t)
                .wrapping_add(128 as uint64_t)
                >> 8 as ::core::ffi::c_int) as ::core::ffi::c_int;
            i_ssd = i_ssd.wrapping_add(chromassd as uint64_t);
        }
        if (*h).param.b_cabac != 0 {
            let mut cabac_tmp: x264_cabac_t = x264_cabac_t {
                i_low: 0,
                i_range: 0,
                i_queue: 0,
                i_bytes_outstanding: 0,
                p_start: 0 as *mut uint8_t,
                p: 0 as *mut uint8_t,
                p_end: 0 as *mut uint8_t,
                f8_bits_encoded: 0,
                state: [0; 1024],
                padding: [0; 12],
            };
            (*h).mc.memcpy_aligned.expect("non-null function pointer")(
                &mut cabac_tmp.f8_bits_encoded as *mut ::core::ffi::c_int
                    as *mut ::core::ffi::c_void,
                &mut (*h).cabac.f8_bits_encoded as *mut ::core::ffi::c_int
                    as *const ::core::ffi::c_void,
                (::core::mem::size_of::<::core::ffi::c_int>() as size_t).wrapping_add(
                    (if (*(*h).sps.as_mut_ptr()).i_chroma_format_idc
                        == CHROMA_444 as ::core::ffi::c_int
                    {
                        1024 as ::core::ffi::c_int + 12 as ::core::ffi::c_int
                    } else {
                        460 as ::core::ffi::c_int
                    }) as size_t,
                ),
            );
            partition_i4x4_size_cabac(h, &mut cabac_tmp, i4, i_mode);
            i_bits = (cabac_tmp.f8_bits_encoded as uint64_t)
                .wrapping_mul(i_lambda2 as uint64_t)
                .wrapping_add(128 as uint64_t)
                >> 8 as ::core::ffi::c_int;
        } else {
            i_bits = (partition_i4x4_size_cavlc(h, i4, i_mode) as uint64_t)
                .wrapping_mul(i_lambda2 as uint64_t);
        }
        return (i_ssd << 8 as ::core::ffi::c_int).wrapping_add(i_bits);
    }
    #[c2rust::src_loc = "349:1"]
    pub unsafe extern "C" fn rd_cost_chroma(
        mut h: *mut x264_t,
        mut i_lambda2: ::core::ffi::c_int,
        mut i_mode: ::core::ffi::c_int,
        mut b_dct: ::core::ffi::c_int,
    ) -> uint64_t {
        let mut i_ssd: uint64_t = 0;
        let mut i_bits: uint64_t = 0;
        if b_dct != 0 {
            x264_10_mb_encode_chroma(h, 0 as ::core::ffi::c_int, (*h).mb.i_chroma_qp);
        }
        let mut chromapix: ::core::ffi::c_int = (*h).luma2chroma_pixel
            [PIXEL_16x16 as ::core::ffi::c_int as usize]
            as ::core::ffi::c_int;
        i_ssd = (ssd_plane(
            h,
            chromapix,
            1 as ::core::ffi::c_int,
            0 as ::core::ffi::c_int,
            0 as ::core::ffi::c_int,
        ) + ssd_plane(
            h,
            chromapix,
            2 as ::core::ffi::c_int,
            0 as ::core::ffi::c_int,
            0 as ::core::ffi::c_int,
        )) as uint64_t;
        (*h).mb.i_chroma_pred_mode = i_mode;
        if (*h).param.b_cabac != 0 {
            let mut cabac_tmp: x264_cabac_t = x264_cabac_t {
                i_low: 0,
                i_range: 0,
                i_queue: 0,
                i_bytes_outstanding: 0,
                p_start: 0 as *mut uint8_t,
                p: 0 as *mut uint8_t,
                p_end: 0 as *mut uint8_t,
                f8_bits_encoded: 0,
                state: [0; 1024],
                padding: [0; 12],
            };
            (*h).mc.memcpy_aligned.expect("non-null function pointer")(
                &mut cabac_tmp.f8_bits_encoded as *mut ::core::ffi::c_int
                    as *mut ::core::ffi::c_void,
                &mut (*h).cabac.f8_bits_encoded as *mut ::core::ffi::c_int
                    as *const ::core::ffi::c_void,
                (::core::mem::size_of::<::core::ffi::c_int>() as size_t).wrapping_add(
                    (if (*(*h).sps.as_mut_ptr()).i_chroma_format_idc
                        == CHROMA_444 as ::core::ffi::c_int
                    {
                        1024 as ::core::ffi::c_int + 12 as ::core::ffi::c_int
                    } else {
                        460 as ::core::ffi::c_int
                    }) as size_t,
                ),
            );
            chroma_size_cabac(h, &mut cabac_tmp);
            i_bits = (cabac_tmp.f8_bits_encoded as uint64_t)
                .wrapping_mul(i_lambda2 as uint64_t)
                .wrapping_add(128 as uint64_t)
                >> 8 as ::core::ffi::c_int;
        } else {
            i_bits = (chroma_size_cavlc(h) as uint64_t).wrapping_mul(i_lambda2 as uint64_t);
        }
        return (i_ssd << 8 as ::core::ffi::c_int).wrapping_add(i_bits);
    }
    #[c2rust::src_loc = "378:9"]
    pub const TRELLIS_SCORE_MAX: ::core::ffi::c_ulonglong = !(0 as ::core::ffi::c_ulonglong);
    #[c2rust::src_loc = "379:9"]
    pub const TRELLIS_SCORE_BIAS: ::core::ffi::c_ulonglong =
        (1 as ::core::ffi::c_ulonglong) << 60 as ::core::ffi::c_int;
    #[c2rust::src_loc = "380:9"]
    pub const CABAC_SIZE_BITS: ::core::ffi::c_int = 8 as ::core::ffi::c_int;
    #[c2rust::src_loc = "381:9"]
    pub const LAMBDA_BITS: ::core::ffi::c_int = 4 as ::core::ffi::c_int;
    #[no_mangle]
    #[c2rust::src_loc = "384:1"]
    pub unsafe extern "C" fn x264_10_rdo_init() {
        let mut i_prefix: ::core::ffi::c_int = 0 as ::core::ffi::c_int;
        while i_prefix < 15 as ::core::ffi::c_int {
            let mut i_ctx: ::core::ffi::c_int = 0 as ::core::ffi::c_int;
            while i_ctx < 128 as ::core::ffi::c_int {
                let mut f8_bits: ::core::ffi::c_int = 0 as ::core::ffi::c_int;
                let mut ctx: uint8_t = i_ctx as uint8_t;
                let mut i: ::core::ffi::c_int = 1 as ::core::ffi::c_int;
                while i < i_prefix {
                    f8_bits += x264_cabac_size_decision2(&mut ctx, 1 as ::core::ffi::c_long);
                    i += 1;
                }
                if i_prefix > 0 as ::core::ffi::c_int && i_prefix < 14 as ::core::ffi::c_int {
                    f8_bits += x264_cabac_size_decision2(&mut ctx, 0 as ::core::ffi::c_long);
                }
                f8_bits += (1 as ::core::ffi::c_int) << CABAC_SIZE_BITS;
                x264_10_cabac_size_unary[i_prefix as usize][i_ctx as usize] = f8_bits as uint16_t;
                x264_10_cabac_transition_unary[i_prefix as usize][i_ctx as usize] = ctx;
                i_ctx += 1;
            }
            i_prefix += 1;
        }
        let mut i_ctx_0: ::core::ffi::c_int = 0 as ::core::ffi::c_int;
        while i_ctx_0 < 128 as ::core::ffi::c_int {
            let mut f8_bits_0: ::core::ffi::c_int = 0 as ::core::ffi::c_int;
            let mut ctx_0: uint8_t = i_ctx_0 as uint8_t;
            let mut i_0: ::core::ffi::c_int = 0 as ::core::ffi::c_int;
            while i_0 < 5 as ::core::ffi::c_int {
                f8_bits_0 += x264_cabac_size_decision2(&mut ctx_0, 1 as ::core::ffi::c_long);
                i_0 += 1;
            }
            f8_bits_0 += (1 as ::core::ffi::c_int) << CABAC_SIZE_BITS;
            cabac_size_5ones[i_ctx_0 as usize] = f8_bits_0 as uint16_t;
            cabac_transition_5ones[i_ctx_0 as usize] = ctx_0;
            i_ctx_0 += 1;
        }
    }
    #[inline(never)]
    #[c2rust::src_loc = "462:1"]
    pub unsafe extern "C" fn trellis_dc_shortcut(
        mut sign_coef: ::core::ffi::c_int,
        mut quant_coef: ::core::ffi::c_int,
        mut unquant_mf: ::core::ffi::c_int,
        mut coef_weight: ::core::ffi::c_int,
        mut lambda2: ::core::ffi::c_int,
        mut cabac_state: *mut uint8_t,
        mut cost_sig: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int {
        let mut bscore: uint64_t = TRELLIS_SCORE_MAX as uint64_t;
        let mut ret: ::core::ffi::c_int = 0 as ::core::ffi::c_int;
        let mut q: ::core::ffi::c_int = abs(quant_coef);
        let mut abs_level: ::core::ffi::c_int = q - 1 as ::core::ffi::c_int;
        while abs_level <= q {
            let mut unquant_abs_level: ::core::ffi::c_int =
                unquant_mf * abs_level + 128 as ::core::ffi::c_int >> 8 as ::core::ffi::c_int;
            let mut d: ::core::ffi::c_int = sign_coef
                - ((unquant_abs_level ^ sign_coef >> 31 as ::core::ffi::c_int)
                    - (sign_coef >> 31 as ::core::ffi::c_int)
                    + 8 as ::core::ffi::c_int
                    & !(15 as ::core::ffi::c_int));
            let mut score: uint64_t =
                (d as int64_t * d as int64_t * coef_weight as int64_t) as uint64_t;
            if abs_level != 0 {
                let mut f8_bits: ::core::ffi::c_uint = cost_sig as ::core::ffi::c_uint;
                let mut prefix: ::core::ffi::c_int =
                    if (abs_level - 1 as ::core::ffi::c_int) < 14 as ::core::ffi::c_int {
                        abs_level - 1 as ::core::ffi::c_int
                    } else {
                        14 as ::core::ffi::c_int
                    };
                f8_bits = f8_bits.wrapping_add(x264_cabac_size_decision_noup2(
                    cabac_state.offset(1 as ::core::ffi::c_int as isize),
                    (prefix > 0 as ::core::ffi::c_int) as ::core::ffi::c_int as ::core::ffi::c_long,
                ) as ::core::ffi::c_uint);
                f8_bits = f8_bits.wrapping_add(
                    x264_10_cabac_size_unary[prefix as usize]
                        [*cabac_state.offset(5 as ::core::ffi::c_int as isize) as usize]
                        as ::core::ffi::c_uint,
                );
                if abs_level >= 15 as ::core::ffi::c_int {
                    f8_bits = f8_bits.wrapping_add(
                        (bs_size_ue_big(
                            (abs_level - 15 as ::core::ffi::c_int) as ::core::ffi::c_uint,
                        ) << CABAC_SIZE_BITS) as ::core::ffi::c_uint,
                    );
                }
                score = score.wrapping_add(
                    (f8_bits as uint64_t).wrapping_mul(lambda2 as uint64_t)
                        >> CABAC_SIZE_BITS - LAMBDA_BITS,
                );
            }
            if score < bscore {
                bscore = score;
                ret = abs_level;
            }
            abs_level += 1;
        }
        return (ret ^ sign_coef >> 31 as ::core::ffi::c_int)
            - (sign_coef >> 31 as ::core::ffi::c_int);
    }
    #[inline(always)]
    #[c2rust::src_loc = "494:1"]
    pub unsafe extern "C" fn trellis_coef(
        mut j: ::core::ffi::c_int,
        mut const_level: ::core::ffi::c_int,
        mut abs_level: ::core::ffi::c_int,
        mut prefix: ::core::ffi::c_int,
        mut suffix_cost: ::core::ffi::c_int,
        mut node_ctx: ::core::ffi::c_int,
        mut level1_ctx: ::core::ffi::c_int,
        mut levelgt1_ctx: ::core::ffi::c_int,
        mut ssd: uint64_t,
        mut cost_siglast: *mut ::core::ffi::c_int,
        mut nodes_cur: *mut trellis_node_t,
        mut nodes_prev: *mut trellis_node_t,
        mut level_tree: *mut trellis_level_t,
        mut levels_used: ::core::ffi::c_int,
        mut lambda2: ::core::ffi::c_int,
        mut level_state: *mut uint8_t,
    ) -> ::core::ffi::c_int {
        let mut score: uint64_t = (*nodes_prev.offset(j as isize)).score.wrapping_add(ssd);
        let mut f8_bits: ::core::ffi::c_uint = *cost_siglast.offset(
            (if j != 0 {
                1 as ::core::ffi::c_int
            } else {
                2 as ::core::ffi::c_int
            }) as isize,
        ) as ::core::ffi::c_uint;
        let mut level1_state: uint8_t = (if j >= 3 as ::core::ffi::c_int {
            (*nodes_prev.offset(j as isize)).cabac_state
                [(level1_ctx >> 2 as ::core::ffi::c_int) as usize] as ::core::ffi::c_int
        } else {
            *level_state.offset(level1_ctx as isize) as ::core::ffi::c_int
        }) as uint8_t;
        f8_bits = f8_bits.wrapping_add(
            x264_cabac_entropy[(level1_state as ::core::ffi::c_int
                ^ (const_level > 1 as ::core::ffi::c_int) as ::core::ffi::c_int)
                as usize] as ::core::ffi::c_uint,
        );
        let mut levelgt1_state: uint8_t = 0;
        if const_level > 1 as ::core::ffi::c_int {
            levelgt1_state = (if j >= 6 as ::core::ffi::c_int {
                (*nodes_prev.offset(j as isize)).cabac_state
                    [(levelgt1_ctx - 6 as ::core::ffi::c_int) as usize]
                    as ::core::ffi::c_int
            } else {
                *level_state.offset(levelgt1_ctx as isize) as ::core::ffi::c_int
            }) as uint8_t;
            f8_bits = f8_bits.wrapping_add(
                (x264_10_cabac_size_unary[prefix as usize][levelgt1_state as usize]
                    as ::core::ffi::c_int
                    + suffix_cost) as ::core::ffi::c_uint,
            );
        } else {
            f8_bits = f8_bits.wrapping_add(
                ((1 as ::core::ffi::c_int) << CABAC_SIZE_BITS) as ::core::ffi::c_uint,
            );
        }
        score = score.wrapping_add(
            (f8_bits as uint64_t).wrapping_mul(lambda2 as uint64_t)
                >> CABAC_SIZE_BITS - LAMBDA_BITS,
        );
        if score < (*nodes_cur.offset(node_ctx as isize)).score {
            (*nodes_cur.offset(node_ctx as isize)).score = score;
            if j == 2 as ::core::ffi::c_int
                || j <= 3 as ::core::ffi::c_int && node_ctx == 4 as ::core::ffi::c_int
            {
                (*((*nodes_cur.offset(node_ctx as isize))
                    .cabac_state
                    .as_mut_ptr() as *mut x264_union32_t))
                    .i = (*(level_state.offset(12 as ::core::ffi::c_int as isize)
                    as *mut x264_union32_t))
                    .i;
            } else if j >= 3 as ::core::ffi::c_int {
                (*((*nodes_cur.offset(node_ctx as isize))
                    .cabac_state
                    .as_mut_ptr() as *mut x264_union32_t))
                    .i = (*((*nodes_prev.offset(j as isize)).cabac_state.as_mut_ptr()
                    as *mut x264_union32_t))
                    .i;
            }
            if j >= 3 as ::core::ffi::c_int {
                (*nodes_cur.offset(node_ctx as isize)).cabac_state
                    [(level1_ctx >> 2 as ::core::ffi::c_int) as usize] = x264_cabac_transition
                    [level1_state as usize]
                    [(const_level > 1 as ::core::ffi::c_int) as ::core::ffi::c_int as usize];
            }
            if const_level > 1 as ::core::ffi::c_int && node_ctx == 7 as ::core::ffi::c_int {
                (*nodes_cur.offset(node_ctx as isize)).cabac_state
                    [(levelgt1_ctx - 6 as ::core::ffi::c_int) as usize] =
                    x264_10_cabac_transition_unary[prefix as usize][levelgt1_state as usize];
            }
            (*nodes_cur.offset(node_ctx as isize)).level_idx =
                (*nodes_prev.offset(j as isize)).level_idx;
            if ::core::mem::size_of::<trellis_level_t>() as usize
                == ::core::mem::size_of::<uint32_t>() as usize
            {
                (*(&mut *level_tree.offset(levels_used as isize) as *mut trellis_level_t
                    as *mut x264_union32_t))
                    .i = pack16to32(
                    (*nodes_prev.offset(j as isize)).level_idx as uint32_t,
                    abs_level as uint32_t,
                );
            } else {
                *level_tree.offset(levels_used as isize) = {
                    let mut init = trellis_level_t {
                        next: (*nodes_prev.offset(j as isize)).level_idx as uint16_t,
                        abs_level: abs_level as uint16_t,
                    };
                    init
                };
            }
            (*nodes_cur.offset(node_ctx as isize)).level_idx = levels_used;
            levels_used += 1;
        }
        return levels_used;
    }
    #[inline(never)]
    #[c2rust::src_loc = "537:1"]
    pub unsafe extern "C" fn trellis_coef0_0(
        mut ssd0: uint64_t,
        mut nodes_cur: *mut trellis_node_t,
        mut nodes_prev: *mut trellis_node_t,
        mut level_tree: *mut trellis_level_t,
        mut levels_used: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int {
        (*nodes_cur.offset(0 as ::core::ffi::c_int as isize)).score = (*nodes_prev
            .offset(0 as ::core::ffi::c_int as isize))
        .score
        .wrapping_add(ssd0);
        (*nodes_cur.offset(0 as ::core::ffi::c_int as isize)).level_idx =
            (*nodes_prev.offset(0 as ::core::ffi::c_int as isize)).level_idx;
        let mut j: ::core::ffi::c_int = 1 as ::core::ffi::c_int;
        while j < 4 as ::core::ffi::c_int
            && (*nodes_prev.offset(j as isize)).score as int64_t >= 0 as int64_t
        {
            (*nodes_cur.offset(j as isize)).score = (*nodes_prev.offset(j as isize)).score;
            if j >= 3 as ::core::ffi::c_int {
                (*((*nodes_cur.offset(j as isize)).cabac_state.as_mut_ptr()
                    as *mut x264_union32_t))
                    .i = (*((*nodes_prev.offset(j as isize)).cabac_state.as_mut_ptr()
                    as *mut x264_union32_t))
                    .i;
            }
            if ::core::mem::size_of::<trellis_level_t>() as usize
                == ::core::mem::size_of::<uint32_t>() as usize
            {
                (*(&mut *level_tree.offset(levels_used as isize) as *mut trellis_level_t
                    as *mut x264_union32_t))
                    .i = pack16to32(
                    (*nodes_prev.offset(j as isize)).level_idx as uint32_t,
                    0 as uint32_t,
                );
            } else {
                *level_tree.offset(levels_used as isize) = {
                    let mut init = trellis_level_t {
                        next: (*nodes_prev.offset(j as isize)).level_idx as uint16_t,
                        abs_level: 0 as uint16_t,
                    };
                    init
                };
            }
            (*nodes_cur.offset(j as isize)).level_idx = levels_used;
            levels_used += 1;
            j += 1;
        }
        return levels_used;
    }
    #[inline(never)]
    #[c2rust::src_loc = "553:1"]
    pub unsafe extern "C" fn trellis_coef0_1(
        mut ssd0: uint64_t,
        mut nodes_cur: *mut trellis_node_t,
        mut nodes_prev: *mut trellis_node_t,
        mut level_tree: *mut trellis_level_t,
        mut levels_used: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int {
        let mut j: ::core::ffi::c_int = 1 as ::core::ffi::c_int;
        while j < 8 as ::core::ffi::c_int {
            if (*nodes_prev.offset(j as isize)).score as int64_t >= 0 as int64_t {
                (*nodes_cur.offset(j as isize)).score = (*nodes_prev.offset(j as isize)).score;
                if j >= 3 as ::core::ffi::c_int {
                    (*((*nodes_cur.offset(j as isize)).cabac_state.as_mut_ptr()
                        as *mut x264_union32_t))
                        .i = (*((*nodes_prev.offset(j as isize)).cabac_state.as_mut_ptr()
                        as *mut x264_union32_t))
                        .i;
                }
                if ::core::mem::size_of::<trellis_level_t>() as usize
                    == ::core::mem::size_of::<uint32_t>() as usize
                {
                    (*(&mut *level_tree.offset(levels_used as isize) as *mut trellis_level_t
                        as *mut x264_union32_t))
                        .i = pack16to32(
                        (*nodes_prev.offset(j as isize)).level_idx as uint32_t,
                        0 as uint32_t,
                    );
                } else {
                    *level_tree.offset(levels_used as isize) = {
                        let mut init = trellis_level_t {
                            next: (*nodes_prev.offset(j as isize)).level_idx as uint16_t,
                            abs_level: 0 as uint16_t,
                        };
                        init
                    };
                }
                (*nodes_cur.offset(j as isize)).level_idx = levels_used;
                levels_used += 1;
            }
            j += 1;
        }
        return levels_used;
    }
    #[inline(never)]
    #[c2rust::src_loc = "577:1"]
    pub unsafe extern "C" fn trellis_coef1_0(
        mut ssd0: uint64_t,
        mut ssd1: uint64_t,
        mut cost_siglast: *mut ::core::ffi::c_int,
        mut nodes_cur: *mut trellis_node_t,
        mut nodes_prev: *mut trellis_node_t,
        mut level_tree: *mut trellis_level_t,
        mut levels_used: ::core::ffi::c_int,
        mut lambda2: ::core::ffi::c_int,
        mut level_state: *mut uint8_t,
    ) -> ::core::ffi::c_int {
        let mut abs_level: ::core::ffi::c_int = 1 as ::core::ffi::c_int;
        let mut prefix: ::core::ffi::c_int = 1 as ::core::ffi::c_int;
        let mut suffix_cost: ::core::ffi::c_int = 0 as ::core::ffi::c_int;
        if 0 as ::core::ffi::c_int == 0
            || (*nodes_prev.offset(0 as ::core::ffi::c_int as isize)).score as int64_t
                >= 0 as int64_t
        {
            levels_used = trellis_coef(
                0 as ::core::ffi::c_int,
                1 as ::core::ffi::c_int,
                abs_level,
                prefix,
                suffix_cost,
                1 as ::core::ffi::c_int,
                1 as ::core::ffi::c_int,
                0 as ::core::ffi::c_int,
                if 0 as ::core::ffi::c_int != 0 {
                    ssd1
                } else {
                    ssd0
                },
                cost_siglast,
                nodes_cur,
                nodes_prev,
                level_tree,
                levels_used,
                lambda2,
                level_state,
            );
        } else if 0 as ::core::ffi::c_int == 0 {
            return levels_used;
        }
        if 1 as ::core::ffi::c_int == 0
            || (*nodes_prev.offset(1 as ::core::ffi::c_int as isize)).score as int64_t
                >= 0 as int64_t
        {
            levels_used = trellis_coef(
                1 as ::core::ffi::c_int,
                1 as ::core::ffi::c_int,
                abs_level,
                prefix,
                suffix_cost,
                2 as ::core::ffi::c_int,
                2 as ::core::ffi::c_int,
                0 as ::core::ffi::c_int,
                if 1 as ::core::ffi::c_int != 0 {
                    ssd1
                } else {
                    ssd0
                },
                cost_siglast,
                nodes_cur,
                nodes_prev,
                level_tree,
                levels_used,
                lambda2,
                level_state,
            );
        } else if 0 as ::core::ffi::c_int == 0 {
            return levels_used;
        }
        if 2 as ::core::ffi::c_int == 0
            || (*nodes_prev.offset(2 as ::core::ffi::c_int as isize)).score as int64_t
                >= 0 as int64_t
        {
            levels_used = trellis_coef(
                2 as ::core::ffi::c_int,
                1 as ::core::ffi::c_int,
                abs_level,
                prefix,
                suffix_cost,
                3 as ::core::ffi::c_int,
                3 as ::core::ffi::c_int,
                0 as ::core::ffi::c_int,
                if 2 as ::core::ffi::c_int != 0 {
                    ssd1
                } else {
                    ssd0
                },
                cost_siglast,
                nodes_cur,
                nodes_prev,
                level_tree,
                levels_used,
                lambda2,
                level_state,
            );
        } else if 0 as ::core::ffi::c_int == 0 {
            return levels_used;
        }
        if 3 as ::core::ffi::c_int == 0
            || (*nodes_prev.offset(3 as ::core::ffi::c_int as isize)).score as int64_t
                >= 0 as int64_t
        {
            levels_used = trellis_coef(
                3 as ::core::ffi::c_int,
                1 as ::core::ffi::c_int,
                abs_level,
                prefix,
                suffix_cost,
                3 as ::core::ffi::c_int,
                4 as ::core::ffi::c_int,
                0 as ::core::ffi::c_int,
                if 3 as ::core::ffi::c_int != 0 {
                    ssd1
                } else {
                    ssd0
                },
                cost_siglast,
                nodes_cur,
                nodes_prev,
                level_tree,
                levels_used,
                lambda2,
                level_state,
            );
        } else if 0 as ::core::ffi::c_int == 0 {
            return levels_used;
        }
        return levels_used;
    }
    #[inline(never)]
    #[c2rust::src_loc = "591:1"]
    pub unsafe extern "C" fn trellis_coef1_1(
        mut ssd0: uint64_t,
        mut ssd1: uint64_t,
        mut cost_siglast: *mut ::core::ffi::c_int,
        mut nodes_cur: *mut trellis_node_t,
        mut nodes_prev: *mut trellis_node_t,
        mut level_tree: *mut trellis_level_t,
        mut levels_used: ::core::ffi::c_int,
        mut lambda2: ::core::ffi::c_int,
        mut level_state: *mut uint8_t,
    ) -> ::core::ffi::c_int {
        let mut abs_level: ::core::ffi::c_int = 1 as ::core::ffi::c_int;
        let mut prefix: ::core::ffi::c_int = 1 as ::core::ffi::c_int;
        let mut suffix_cost: ::core::ffi::c_int = 0 as ::core::ffi::c_int;
        if 1 as ::core::ffi::c_int == 0
            || (*nodes_prev.offset(1 as ::core::ffi::c_int as isize)).score as int64_t
                >= 0 as int64_t
        {
            levels_used = trellis_coef(
                1 as ::core::ffi::c_int,
                1 as ::core::ffi::c_int,
                abs_level,
                prefix,
                suffix_cost,
                2 as ::core::ffi::c_int,
                2 as ::core::ffi::c_int,
                0 as ::core::ffi::c_int,
                if 1 as ::core::ffi::c_int != 0 {
                    ssd1
                } else {
                    ssd0
                },
                cost_siglast,
                nodes_cur,
                nodes_prev,
                level_tree,
                levels_used,
                lambda2,
                level_state,
            );
        } else if 1 as ::core::ffi::c_int == 0 {
            return levels_used;
        }
        if 2 as ::core::ffi::c_int == 0
            || (*nodes_prev.offset(2 as ::core::ffi::c_int as isize)).score as int64_t
                >= 0 as int64_t
        {
            levels_used = trellis_coef(
                2 as ::core::ffi::c_int,
                1 as ::core::ffi::c_int,
                abs_level,
                prefix,
                suffix_cost,
                3 as ::core::ffi::c_int,
                3 as ::core::ffi::c_int,
                0 as ::core::ffi::c_int,
                if 2 as ::core::ffi::c_int != 0 {
                    ssd1
                } else {
                    ssd0
                },
                cost_siglast,
                nodes_cur,
                nodes_prev,
                level_tree,
                levels_used,
                lambda2,
                level_state,
            );
        } else if 1 as ::core::ffi::c_int == 0 {
            return levels_used;
        }
        if 3 as ::core::ffi::c_int == 0
            || (*nodes_prev.offset(3 as ::core::ffi::c_int as isize)).score as int64_t
                >= 0 as int64_t
        {
            levels_used = trellis_coef(
                3 as ::core::ffi::c_int,
                1 as ::core::ffi::c_int,
                abs_level,
                prefix,
                suffix_cost,
                3 as ::core::ffi::c_int,
                4 as ::core::ffi::c_int,
                0 as ::core::ffi::c_int,
                if 3 as ::core::ffi::c_int != 0 {
                    ssd1
                } else {
                    ssd0
                },
                cost_siglast,
                nodes_cur,
                nodes_prev,
                level_tree,
                levels_used,
                lambda2,
                level_state,
            );
        } else if 1 as ::core::ffi::c_int == 0 {
            return levels_used;
        }
        if 4 as ::core::ffi::c_int == 0
            || (*nodes_prev.offset(4 as ::core::ffi::c_int as isize)).score as int64_t
                >= 0 as int64_t
        {
            levels_used = trellis_coef(
                4 as ::core::ffi::c_int,
                1 as ::core::ffi::c_int,
                abs_level,
                prefix,
                suffix_cost,
                4 as ::core::ffi::c_int,
                0 as ::core::ffi::c_int,
                0 as ::core::ffi::c_int,
                if 4 as ::core::ffi::c_int != 0 {
                    ssd1
                } else {
                    ssd0
                },
                cost_siglast,
                nodes_cur,
                nodes_prev,
                level_tree,
                levels_used,
                lambda2,
                level_state,
            );
        } else if 1 as ::core::ffi::c_int == 0 {
            return levels_used;
        }
        if 5 as ::core::ffi::c_int == 0
            || (*nodes_prev.offset(5 as ::core::ffi::c_int as isize)).score as int64_t
                >= 0 as int64_t
        {
            levels_used = trellis_coef(
                5 as ::core::ffi::c_int,
                1 as ::core::ffi::c_int,
                abs_level,
                prefix,
                suffix_cost,
                5 as ::core::ffi::c_int,
                0 as ::core::ffi::c_int,
                0 as ::core::ffi::c_int,
                if 5 as ::core::ffi::c_int != 0 {
                    ssd1
                } else {
                    ssd0
                },
                cost_siglast,
                nodes_cur,
                nodes_prev,
                level_tree,
                levels_used,
                lambda2,
                level_state,
            );
        } else if 1 as ::core::ffi::c_int == 0 {
            return levels_used;
        }
        if 6 as ::core::ffi::c_int == 0
            || (*nodes_prev.offset(6 as ::core::ffi::c_int as isize)).score as int64_t
                >= 0 as int64_t
        {
            levels_used = trellis_coef(
                6 as ::core::ffi::c_int,
                1 as ::core::ffi::c_int,
                abs_level,
                prefix,
                suffix_cost,
                6 as ::core::ffi::c_int,
                0 as ::core::ffi::c_int,
                0 as ::core::ffi::c_int,
                if 6 as ::core::ffi::c_int != 0 {
                    ssd1
                } else {
                    ssd0
                },
                cost_siglast,
                nodes_cur,
                nodes_prev,
                level_tree,
                levels_used,
                lambda2,
                level_state,
            );
        } else if 1 as ::core::ffi::c_int == 0 {
            return levels_used;
        }
        if 7 as ::core::ffi::c_int == 0
            || (*nodes_prev.offset(7 as ::core::ffi::c_int as isize)).score as int64_t
                >= 0 as int64_t
        {
            levels_used = trellis_coef(
                7 as ::core::ffi::c_int,
                1 as ::core::ffi::c_int,
                abs_level,
                prefix,
                suffix_cost,
                7 as ::core::ffi::c_int,
                0 as ::core::ffi::c_int,
                0 as ::core::ffi::c_int,
                if 7 as ::core::ffi::c_int != 0 {
                    ssd1
                } else {
                    ssd0
                },
                cost_siglast,
                nodes_cur,
                nodes_prev,
                level_tree,
                levels_used,
                lambda2,
                level_state,
            );
        } else if 1 as ::core::ffi::c_int == 0 {
            return levels_used;
        }
        return levels_used;
    }
    #[inline(never)]
    #[c2rust::src_loc = "608:1"]
    pub unsafe extern "C" fn trellis_coefn_0(
        mut abs_level: ::core::ffi::c_int,
        mut ssd0: uint64_t,
        mut ssd1: uint64_t,
        mut cost_siglast: *mut ::core::ffi::c_int,
        mut nodes_cur: *mut trellis_node_t,
        mut nodes_prev: *mut trellis_node_t,
        mut level_tree: *mut trellis_level_t,
        mut levels_used: ::core::ffi::c_int,
        mut lambda2: ::core::ffi::c_int,
        mut level_state: *mut uint8_t,
        mut levelgt1_ctx: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int {
        let mut prefix: ::core::ffi::c_int =
            if (abs_level - 1 as ::core::ffi::c_int) < 14 as ::core::ffi::c_int {
                abs_level - 1 as ::core::ffi::c_int
            } else {
                14 as ::core::ffi::c_int
            };
        let mut suffix_cost: ::core::ffi::c_int = if abs_level >= 15 as ::core::ffi::c_int {
            bs_size_ue_big((abs_level - 15 as ::core::ffi::c_int) as ::core::ffi::c_uint)
                << CABAC_SIZE_BITS
        } else {
            0 as ::core::ffi::c_int
        };
        if 0 as ::core::ffi::c_int == 0
            || (*nodes_prev.offset(0 as ::core::ffi::c_int as isize)).score as int64_t
                >= 0 as int64_t
        {
            levels_used = trellis_coef(
                0 as ::core::ffi::c_int,
                2 as ::core::ffi::c_int,
                abs_level,
                prefix,
                suffix_cost,
                4 as ::core::ffi::c_int,
                1 as ::core::ffi::c_int,
                5 as ::core::ffi::c_int,
                if 0 as ::core::ffi::c_int != 0 {
                    ssd1
                } else {
                    ssd0
                },
                cost_siglast,
                nodes_cur,
                nodes_prev,
                level_tree,
                levels_used,
                lambda2,
                level_state,
            );
        } else if 0 as ::core::ffi::c_int == 0 {
            return levels_used;
        }
        if 1 as ::core::ffi::c_int == 0
            || (*nodes_prev.offset(1 as ::core::ffi::c_int as isize)).score as int64_t
                >= 0 as int64_t
        {
            levels_used = trellis_coef(
                1 as ::core::ffi::c_int,
                2 as ::core::ffi::c_int,
                abs_level,
                prefix,
                suffix_cost,
                4 as ::core::ffi::c_int,
                2 as ::core::ffi::c_int,
                5 as ::core::ffi::c_int,
                if 1 as ::core::ffi::c_int != 0 {
                    ssd1
                } else {
                    ssd0
                },
                cost_siglast,
                nodes_cur,
                nodes_prev,
                level_tree,
                levels_used,
                lambda2,
                level_state,
            );
        } else if 0 as ::core::ffi::c_int == 0 {
            return levels_used;
        }
        if 2 as ::core::ffi::c_int == 0
            || (*nodes_prev.offset(2 as ::core::ffi::c_int as isize)).score as int64_t
                >= 0 as int64_t
        {
            levels_used = trellis_coef(
                2 as ::core::ffi::c_int,
                2 as ::core::ffi::c_int,
                abs_level,
                prefix,
                suffix_cost,
                4 as ::core::ffi::c_int,
                3 as ::core::ffi::c_int,
                5 as ::core::ffi::c_int,
                if 2 as ::core::ffi::c_int != 0 {
                    ssd1
                } else {
                    ssd0
                },
                cost_siglast,
                nodes_cur,
                nodes_prev,
                level_tree,
                levels_used,
                lambda2,
                level_state,
            );
        } else if 0 as ::core::ffi::c_int == 0 {
            return levels_used;
        }
        if 3 as ::core::ffi::c_int == 0
            || (*nodes_prev.offset(3 as ::core::ffi::c_int as isize)).score as int64_t
                >= 0 as int64_t
        {
            levels_used = trellis_coef(
                3 as ::core::ffi::c_int,
                2 as ::core::ffi::c_int,
                abs_level,
                prefix,
                suffix_cost,
                4 as ::core::ffi::c_int,
                4 as ::core::ffi::c_int,
                5 as ::core::ffi::c_int,
                if 3 as ::core::ffi::c_int != 0 {
                    ssd1
                } else {
                    ssd0
                },
                cost_siglast,
                nodes_cur,
                nodes_prev,
                level_tree,
                levels_used,
                lambda2,
                level_state,
            );
        } else if 0 as ::core::ffi::c_int == 0 {
            return levels_used;
        }
        return levels_used;
    }
    #[inline(never)]
    #[c2rust::src_loc = "623:1"]
    pub unsafe extern "C" fn trellis_coefn_1(
        mut abs_level: ::core::ffi::c_int,
        mut ssd0: uint64_t,
        mut ssd1: uint64_t,
        mut cost_siglast: *mut ::core::ffi::c_int,
        mut nodes_cur: *mut trellis_node_t,
        mut nodes_prev: *mut trellis_node_t,
        mut level_tree: *mut trellis_level_t,
        mut levels_used: ::core::ffi::c_int,
        mut lambda2: ::core::ffi::c_int,
        mut level_state: *mut uint8_t,
        mut levelgt1_ctx: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int {
        let mut prefix: ::core::ffi::c_int =
            if (abs_level - 1 as ::core::ffi::c_int) < 14 as ::core::ffi::c_int {
                abs_level - 1 as ::core::ffi::c_int
            } else {
                14 as ::core::ffi::c_int
            };
        let mut suffix_cost: ::core::ffi::c_int = if abs_level >= 15 as ::core::ffi::c_int {
            bs_size_ue_big((abs_level - 15 as ::core::ffi::c_int) as ::core::ffi::c_uint)
                << CABAC_SIZE_BITS
        } else {
            0 as ::core::ffi::c_int
        };
        if 1 as ::core::ffi::c_int == 0
            || (*nodes_prev.offset(1 as ::core::ffi::c_int as isize)).score as int64_t
                >= 0 as int64_t
        {
            levels_used = trellis_coef(
                1 as ::core::ffi::c_int,
                2 as ::core::ffi::c_int,
                abs_level,
                prefix,
                suffix_cost,
                4 as ::core::ffi::c_int,
                2 as ::core::ffi::c_int,
                5 as ::core::ffi::c_int,
                if 1 as ::core::ffi::c_int != 0 {
                    ssd1
                } else {
                    ssd0
                },
                cost_siglast,
                nodes_cur,
                nodes_prev,
                level_tree,
                levels_used,
                lambda2,
                level_state,
            );
        } else if 1 as ::core::ffi::c_int == 0 {
            return levels_used;
        }
        if 2 as ::core::ffi::c_int == 0
            || (*nodes_prev.offset(2 as ::core::ffi::c_int as isize)).score as int64_t
                >= 0 as int64_t
        {
            levels_used = trellis_coef(
                2 as ::core::ffi::c_int,
                2 as ::core::ffi::c_int,
                abs_level,
                prefix,
                suffix_cost,
                4 as ::core::ffi::c_int,
                3 as ::core::ffi::c_int,
                5 as ::core::ffi::c_int,
                if 2 as ::core::ffi::c_int != 0 {
                    ssd1
                } else {
                    ssd0
                },
                cost_siglast,
                nodes_cur,
                nodes_prev,
                level_tree,
                levels_used,
                lambda2,
                level_state,
            );
        } else if 1 as ::core::ffi::c_int == 0 {
            return levels_used;
        }
        if 3 as ::core::ffi::c_int == 0
            || (*nodes_prev.offset(3 as ::core::ffi::c_int as isize)).score as int64_t
                >= 0 as int64_t
        {
            levels_used = trellis_coef(
                3 as ::core::ffi::c_int,
                2 as ::core::ffi::c_int,
                abs_level,
                prefix,
                suffix_cost,
                4 as ::core::ffi::c_int,
                4 as ::core::ffi::c_int,
                5 as ::core::ffi::c_int,
                if 3 as ::core::ffi::c_int != 0 {
                    ssd1
                } else {
                    ssd0
                },
                cost_siglast,
                nodes_cur,
                nodes_prev,
                level_tree,
                levels_used,
                lambda2,
                level_state,
            );
        } else if 1 as ::core::ffi::c_int == 0 {
            return levels_used;
        }
        if 4 as ::core::ffi::c_int == 0
            || (*nodes_prev.offset(4 as ::core::ffi::c_int as isize)).score as int64_t
                >= 0 as int64_t
        {
            levels_used = trellis_coef(
                4 as ::core::ffi::c_int,
                2 as ::core::ffi::c_int,
                abs_level,
                prefix,
                suffix_cost,
                5 as ::core::ffi::c_int,
                0 as ::core::ffi::c_int,
                6 as ::core::ffi::c_int,
                if 4 as ::core::ffi::c_int != 0 {
                    ssd1
                } else {
                    ssd0
                },
                cost_siglast,
                nodes_cur,
                nodes_prev,
                level_tree,
                levels_used,
                lambda2,
                level_state,
            );
        } else if 1 as ::core::ffi::c_int == 0 {
            return levels_used;
        }
        if 5 as ::core::ffi::c_int == 0
            || (*nodes_prev.offset(5 as ::core::ffi::c_int as isize)).score as int64_t
                >= 0 as int64_t
        {
            levels_used = trellis_coef(
                5 as ::core::ffi::c_int,
                2 as ::core::ffi::c_int,
                abs_level,
                prefix,
                suffix_cost,
                6 as ::core::ffi::c_int,
                0 as ::core::ffi::c_int,
                7 as ::core::ffi::c_int,
                if 5 as ::core::ffi::c_int != 0 {
                    ssd1
                } else {
                    ssd0
                },
                cost_siglast,
                nodes_cur,
                nodes_prev,
                level_tree,
                levels_used,
                lambda2,
                level_state,
            );
        } else if 1 as ::core::ffi::c_int == 0 {
            return levels_used;
        }
        if 6 as ::core::ffi::c_int == 0
            || (*nodes_prev.offset(6 as ::core::ffi::c_int as isize)).score as int64_t
                >= 0 as int64_t
        {
            levels_used = trellis_coef(
                6 as ::core::ffi::c_int,
                2 as ::core::ffi::c_int,
                abs_level,
                prefix,
                suffix_cost,
                7 as ::core::ffi::c_int,
                0 as ::core::ffi::c_int,
                8 as ::core::ffi::c_int,
                if 6 as ::core::ffi::c_int != 0 {
                    ssd1
                } else {
                    ssd0
                },
                cost_siglast,
                nodes_cur,
                nodes_prev,
                level_tree,
                levels_used,
                lambda2,
                level_state,
            );
        } else if 1 as ::core::ffi::c_int == 0 {
            return levels_used;
        }
        if 7 as ::core::ffi::c_int == 0
            || (*nodes_prev.offset(7 as ::core::ffi::c_int as isize)).score as int64_t
                >= 0 as int64_t
        {
            levels_used = trellis_coef(
                7 as ::core::ffi::c_int,
                2 as ::core::ffi::c_int,
                abs_level,
                prefix,
                suffix_cost,
                7 as ::core::ffi::c_int,
                0 as ::core::ffi::c_int,
                levelgt1_ctx,
                if 7 as ::core::ffi::c_int != 0 {
                    ssd1
                } else {
                    ssd0
                },
                cost_siglast,
                nodes_cur,
                nodes_prev,
                level_tree,
                levels_used,
                lambda2,
                level_state,
            );
        } else if 1 as ::core::ffi::c_int == 0 {
            return levels_used;
        }
        return levels_used;
    }
    #[inline(always)]
    #[c2rust::src_loc = "641:1"]
    pub unsafe extern "C" fn quant_trellis_cabac(
        mut h: *mut x264_t,
        mut dct: *mut dctcoef,
        mut quant_mf: *mut udctcoef,
        mut quant_bias: *mut udctcoef,
        mut unquant_mf: *const ::core::ffi::c_int,
        mut zigzag: *const uint8_t,
        mut ctx_block_cat: ::core::ffi::c_int,
        mut lambda2: ::core::ffi::c_int,
        mut b_ac: ::core::ffi::c_int,
        mut b_chroma: ::core::ffi::c_int,
        mut dc: ::core::ffi::c_int,
        mut num_coefs: ::core::ffi::c_int,
        mut idx: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int {
        let mut current_block: u64;
        let mut orig_coefs: [dctcoef; 64] = [0; 64];
        let mut quant_coefs: [dctcoef; 64] = [0; 64];
        let mut coef_weight1: *const uint32_t = if num_coefs == 64 as ::core::ffi::c_int {
            x264_dct8_weight_tab.as_ptr()
        } else {
            x264_dct4_weight_tab.as_ptr()
        };
        let mut coef_weight2: *const uint32_t = if num_coefs == 64 as ::core::ffi::c_int {
            x264_dct8_weight2_tab.as_ptr()
        } else {
            x264_dct4_weight2_tab.as_ptr()
        };
        let b_interlaced: ::core::ffi::c_int = (*h).mb.b_interlaced;
        let mut cabac_state_sig: *mut uint8_t = &mut *(*h).cabac.state.as_mut_ptr().offset(
            *(*x264_significant_coeff_flag_offset
                .as_ptr()
                .offset(b_interlaced as isize))
            .as_ptr()
            .offset(ctx_block_cat as isize) as isize,
        ) as *mut uint8_t;
        let mut cabac_state_last: *mut uint8_t = &mut *(*h).cabac.state.as_mut_ptr().offset(
            *(*x264_last_coeff_flag_offset
                .as_ptr()
                .offset(b_interlaced as isize))
            .as_ptr()
            .offset(ctx_block_cat as isize) as isize,
        ) as *mut uint8_t;
        let mut levelgt1_ctx: ::core::ffi::c_int = if b_chroma != 0 && dc != 0 {
            8 as ::core::ffi::c_int
        } else {
            9 as ::core::ffi::c_int
        };
        if dc != 0 {
            if num_coefs == 16 as ::core::ffi::c_int {
                memcpy(
                    orig_coefs.as_mut_ptr() as *mut ::core::ffi::c_void,
                    dct as *const ::core::ffi::c_void,
                    (::core::mem::size_of::<dctcoef>() as size_t).wrapping_mul(16 as size_t),
                );
                if (*h).quantf.quant_4x4_dc.expect("non-null function pointer")(
                    dct as *mut dctcoef,
                    (*quant_mf.offset(0 as ::core::ffi::c_int as isize) >> 1 as ::core::ffi::c_int)
                        as ::core::ffi::c_int,
                    (*quant_bias.offset(0 as ::core::ffi::c_int as isize)
                        << 1 as ::core::ffi::c_int) as ::core::ffi::c_int,
                ) == 0
                {
                    return 0 as ::core::ffi::c_int;
                }
                (*h).zigzagf.scan_4x4.expect("non-null function pointer")(
                    quant_coefs.as_mut_ptr(),
                    dct as *mut dctcoef,
                );
            } else {
                memcpy(
                    orig_coefs.as_mut_ptr() as *mut ::core::ffi::c_void,
                    dct as *const ::core::ffi::c_void,
                    (::core::mem::size_of::<dctcoef>() as size_t).wrapping_mul(num_coefs as size_t),
                );
                let mut nz: ::core::ffi::c_int = (*h)
                    .quantf
                    .quant_2x2_dc
                    .expect("non-null function pointer")(
                    &mut *dct.offset(0 as ::core::ffi::c_int as isize),
                    (*quant_mf.offset(0 as ::core::ffi::c_int as isize) >> 1 as ::core::ffi::c_int)
                        as ::core::ffi::c_int,
                    (*quant_bias.offset(0 as ::core::ffi::c_int as isize)
                        << 1 as ::core::ffi::c_int) as ::core::ffi::c_int,
                );
                if num_coefs == 8 as ::core::ffi::c_int {
                    nz |= (*h).quantf.quant_2x2_dc.expect("non-null function pointer")(
                        &mut *dct.offset(4 as ::core::ffi::c_int as isize),
                        (*quant_mf.offset(0 as ::core::ffi::c_int as isize)
                            >> 1 as ::core::ffi::c_int)
                            as ::core::ffi::c_int,
                        (*quant_bias.offset(0 as ::core::ffi::c_int as isize)
                            << 1 as ::core::ffi::c_int)
                            as ::core::ffi::c_int,
                    );
                }
                if nz == 0 {
                    return 0 as ::core::ffi::c_int;
                }
                let mut i: ::core::ffi::c_int = 0 as ::core::ffi::c_int;
                while i < num_coefs {
                    quant_coefs[i as usize] = *dct.offset(*zigzag.offset(i as isize) as isize);
                    i += 1;
                }
            }
        } else if num_coefs == 64 as ::core::ffi::c_int {
            (*h).mc.memcpy_aligned.expect("non-null function pointer")(
                orig_coefs.as_mut_ptr() as *mut ::core::ffi::c_void,
                dct as *const ::core::ffi::c_void,
                (::core::mem::size_of::<dctcoef>() as size_t).wrapping_mul(64 as size_t),
            );
            if (*h).quantf.quant_8x8.expect("non-null function pointer")(
                dct as *mut dctcoef,
                quant_mf as *mut udctcoef,
                quant_bias as *mut udctcoef,
            ) == 0
            {
                return 0 as ::core::ffi::c_int;
            }
            (*h).zigzagf.scan_8x8.expect("non-null function pointer")(
                quant_coefs.as_mut_ptr(),
                dct as *mut dctcoef,
            );
        } else {
            memcpy(
                orig_coefs.as_mut_ptr() as *mut ::core::ffi::c_void,
                dct as *const ::core::ffi::c_void,
                (::core::mem::size_of::<dctcoef>() as size_t).wrapping_mul(16 as size_t),
            );
            if (*h).quantf.quant_4x4.expect("non-null function pointer")(
                dct as *mut dctcoef,
                quant_mf as *mut udctcoef,
                quant_bias as *mut udctcoef,
            ) == 0
            {
                return 0 as ::core::ffi::c_int;
            }
            (*h).zigzagf.scan_4x4.expect("non-null function pointer")(
                quant_coefs.as_mut_ptr(),
                dct as *mut dctcoef,
            );
        }
        let mut last_nnz: ::core::ffi::c_int = (*h).quantf.coeff_last[ctx_block_cat as usize]
            .expect("non-null function pointer")(
            quant_coefs.as_mut_ptr().offset(b_ac as isize)
        ) + b_ac;
        let mut cabac_state: *mut uint8_t = &mut *(*h).cabac.state.as_mut_ptr().offset(
            *x264_coeff_abs_level_m1_offset
                .as_ptr()
                .offset(ctx_block_cat as isize) as isize,
        ) as *mut uint8_t;
        if last_nnz == 0 as ::core::ffi::c_int && dc == 0 {
            let mut cost_sig: ::core::ffi::c_int = x264_cabac_size_decision_noup2(
                &mut *cabac_state_sig.offset(0 as ::core::ffi::c_int as isize),
                1 as ::core::ffi::c_long,
            ) + x264_cabac_size_decision_noup2(
                &mut *cabac_state_last.offset(0 as ::core::ffi::c_int as isize),
                1 as ::core::ffi::c_long,
            );
            *dct.offset(0 as ::core::ffi::c_int as isize) = trellis_dc_shortcut(
                orig_coefs[0 as ::core::ffi::c_int as usize],
                quant_coefs[0 as ::core::ffi::c_int as usize],
                *unquant_mf.offset(0 as ::core::ffi::c_int as isize),
                *coef_weight2.offset(0 as ::core::ffi::c_int as isize) as ::core::ffi::c_int,
                lambda2,
                cabac_state,
                cost_sig,
            ) as dctcoef;
            return (*dct.offset(0 as ::core::ffi::c_int as isize) != 0) as ::core::ffi::c_int;
        }
        let mut level_tree: [trellis_level_t; 1024] = [trellis_level_t {
            next: 0,
            abs_level: 0,
        }; 1024];
        let mut levels_used: ::core::ffi::c_int = 1 as ::core::ffi::c_int;
        let mut nodes: [[trellis_node_t; 8]; 2] = [
            [
                {
                    let mut init = trellis_node_t {
                        score: 0 as uint64_t,
                        level_idx: 0,
                        cabac_state: [0; 4],
                    };
                    init
                },
                trellis_node_t {
                    score: 0,
                    level_idx: 0,
                    cabac_state: [0; 4],
                },
                trellis_node_t {
                    score: 0,
                    level_idx: 0,
                    cabac_state: [0; 4],
                },
                trellis_node_t {
                    score: 0,
                    level_idx: 0,
                    cabac_state: [0; 4],
                },
                trellis_node_t {
                    score: 0,
                    level_idx: 0,
                    cabac_state: [0; 4],
                },
                trellis_node_t {
                    score: 0,
                    level_idx: 0,
                    cabac_state: [0; 4],
                },
                trellis_node_t {
                    score: 0,
                    level_idx: 0,
                    cabac_state: [0; 4],
                },
                trellis_node_t {
                    score: 0,
                    level_idx: 0,
                    cabac_state: [0; 4],
                },
            ],
            [trellis_node_t {
                score: 0,
                level_idx: 0,
                cabac_state: [0; 4],
            }; 8],
        ];
        let mut nodes_cur: *mut trellis_node_t =
            (*nodes.as_mut_ptr().offset(0 as ::core::ffi::c_int as isize)).as_mut_ptr();
        let mut nodes_prev: *mut trellis_node_t =
            (*nodes.as_mut_ptr().offset(1 as ::core::ffi::c_int as isize)).as_mut_ptr();
        let mut bnode: *mut trellis_node_t = 0 as *mut trellis_node_t;
        let mut j: ::core::ffi::c_int = 1 as ::core::ffi::c_int;
        while j < 8 as ::core::ffi::c_int {
            (*nodes_cur.offset(j as isize)).score = TRELLIS_SCORE_MAX as uint64_t;
            j += 1;
        }
        (*nodes_cur.offset(0 as ::core::ffi::c_int as isize)).score =
            TRELLIS_SCORE_BIAS as uint64_t;
        (*nodes_cur.offset(0 as ::core::ffi::c_int as isize)).level_idx = 0 as ::core::ffi::c_int;
        level_tree[0 as ::core::ffi::c_int as usize].abs_level = 0 as uint16_t;
        level_tree[0 as ::core::ffi::c_int as usize].next = 0 as uint16_t;
        let mut level_state: [uint8_t; 16] = [0; 16];
        memcpy(
            level_state.as_mut_ptr() as *mut ::core::ffi::c_void,
            cabac_state as *const ::core::ffi::c_void,
            10 as size_t,
        );
        level_state[12 as ::core::ffi::c_int as usize] =
            *cabac_state.offset(0 as ::core::ffi::c_int as isize);
        level_state[13 as ::core::ffi::c_int as usize] =
            *cabac_state.offset(4 as ::core::ffi::c_int as isize);
        level_state[14 as ::core::ffi::c_int as usize] =
            *cabac_state.offset(8 as ::core::ffi::c_int as isize);
        level_state[15 as ::core::ffi::c_int as usize] =
            *cabac_state.offset(9 as ::core::ffi::c_int as isize);
        idx &= if num_coefs == 64 as ::core::ffi::c_int {
            3 as ::core::ffi::c_int
        } else {
            15 as ::core::ffi::c_int
        };
        let mut i_0: ::core::ffi::c_int = last_nnz;
        loop {
            if !(i_0 >= b_ac) {
                current_block = 10369920510435091891;
                break;
            }
            if quant_coefs[i_0 as usize] == 0 {
                if 0 as ::core::ffi::c_int == 0 {
                    let mut sigindex: ::core::ffi::c_int =
                        if dc == 0 && num_coefs == 64 as ::core::ffi::c_int {
                            x264_significant_coeff_flag_offset_8x8[b_interlaced as usize]
                                [i_0 as usize] as ::core::ffi::c_int
                        } else if b_chroma != 0 && dc != 0 && num_coefs == 8 as ::core::ffi::c_int {
                            x264_coeff_flag_offset_chroma_422_dc[i_0 as usize] as ::core::ffi::c_int
                        } else {
                            i_0
                        };
                    let mut cost_sig0: uint64_t = (x264_cabac_size_decision_noup2(
                        &mut *cabac_state_sig.offset(sigindex as isize),
                        0 as ::core::ffi::c_long,
                    ) as uint64_t)
                        .wrapping_mul(lambda2 as uint64_t)
                        >> CABAC_SIZE_BITS - LAMBDA_BITS;
                    let ref mut fresh0 =
                        (*nodes_cur.offset(0 as ::core::ffi::c_int as isize)).score;
                    *fresh0 = (*fresh0).wrapping_sub(cost_sig0);
                }
                let mut j_0: ::core::ffi::c_int = 1 as ::core::ffi::c_int;
                while j_0
                    < (if 0 as ::core::ffi::c_int != 0 {
                        8 as ::core::ffi::c_int
                    } else {
                        4 as ::core::ffi::c_int
                    })
                {
                    if ::core::mem::size_of::<trellis_level_t>() as usize
                        == ::core::mem::size_of::<uint32_t>() as usize
                    {
                        (*(&mut *level_tree.as_mut_ptr().offset(levels_used as isize)
                            as *mut trellis_level_t
                            as *mut x264_union32_t))
                            .i = pack16to32(
                            (*nodes_cur.offset(j_0 as isize)).level_idx as uint32_t,
                            0 as uint32_t,
                        );
                    } else {
                        level_tree[levels_used as usize] = {
                            let mut init = trellis_level_t {
                                next: (*nodes_cur.offset(j_0 as isize)).level_idx as uint16_t,
                                abs_level: 0 as uint16_t,
                            };
                            init
                        };
                    }
                    (*nodes_cur.offset(j_0 as isize)).level_idx = levels_used;
                    levels_used += 1;
                    j_0 += 1;
                }
            } else {
                let mut sign_coef: ::core::ffi::c_int =
                    orig_coefs[*zigzag.offset(i_0 as isize) as usize];
                let mut abs_coef: ::core::ffi::c_int = abs(sign_coef);
                let mut q: ::core::ffi::c_int = abs(quant_coefs[i_0 as usize]);
                let mut cost_siglast: [::core::ffi::c_int; 3] = [0; 3];
                let mut t: *mut trellis_node_t = nodes_cur;
                nodes_cur = nodes_prev;
                nodes_prev = t;
                let mut j_1: ::core::ffi::c_int = 0 as ::core::ffi::c_int;
                while j_1 < 8 as ::core::ffi::c_int {
                    (*nodes_cur.offset(j_1 as isize)).score = TRELLIS_SCORE_MAX as uint64_t;
                    j_1 += 1;
                }
                if i_0 < num_coefs - 1 as ::core::ffi::c_int || 0 as ::core::ffi::c_int != 0 {
                    let mut sigindex_0: ::core::ffi::c_int =
                        if dc == 0 && num_coefs == 64 as ::core::ffi::c_int {
                            x264_significant_coeff_flag_offset_8x8[b_interlaced as usize]
                                [i_0 as usize] as ::core::ffi::c_int
                        } else if b_chroma != 0 && dc != 0 && num_coefs == 8 as ::core::ffi::c_int {
                            x264_coeff_flag_offset_chroma_422_dc[i_0 as usize] as ::core::ffi::c_int
                        } else {
                            i_0
                        };
                    let mut lastindex: ::core::ffi::c_int =
                        if dc == 0 && num_coefs == 64 as ::core::ffi::c_int {
                            x264_last_coeff_flag_offset_8x8[i_0 as usize] as ::core::ffi::c_int
                        } else if b_chroma != 0 && dc != 0 && num_coefs == 8 as ::core::ffi::c_int {
                            x264_coeff_flag_offset_chroma_422_dc[i_0 as usize] as ::core::ffi::c_int
                        } else {
                            i_0
                        };
                    cost_siglast[0 as ::core::ffi::c_int as usize] = x264_cabac_size_decision_noup2(
                        &mut *cabac_state_sig.offset(sigindex_0 as isize),
                        0 as ::core::ffi::c_long,
                    );
                    let mut cost_sig1: ::core::ffi::c_int = x264_cabac_size_decision_noup2(
                        &mut *cabac_state_sig.offset(sigindex_0 as isize),
                        1 as ::core::ffi::c_long,
                    );
                    cost_siglast[1 as ::core::ffi::c_int as usize] = x264_cabac_size_decision_noup2(
                        &mut *cabac_state_last.offset(lastindex as isize),
                        0 as ::core::ffi::c_long,
                    ) + cost_sig1;
                    if 0 as ::core::ffi::c_int == 0 {
                        cost_siglast[2 as ::core::ffi::c_int as usize] =
                            x264_cabac_size_decision_noup2(
                                &mut *cabac_state_last.offset(lastindex as isize),
                                1 as ::core::ffi::c_long,
                            ) + cost_sig1;
                    }
                } else {
                    cost_siglast[2 as ::core::ffi::c_int as usize] = 0 as ::core::ffi::c_int;
                    cost_siglast[1 as ::core::ffi::c_int as usize] =
                        cost_siglast[2 as ::core::ffi::c_int as usize];
                    cost_siglast[0 as ::core::ffi::c_int as usize] =
                        cost_siglast[1 as ::core::ffi::c_int as usize];
                }
                let mut ssd0: [uint64_t; 2] = [0; 2];
                let mut ssd1: [uint64_t; 2] = [0; 2];
                let mut k: ::core::ffi::c_int = 0 as ::core::ffi::c_int;
                while k < 2 as ::core::ffi::c_int {
                    let mut abs_level: ::core::ffi::c_int = q - 1 as ::core::ffi::c_int + k;
                    let mut unquant_abs_level: ::core::ffi::c_int = (if dc != 0 {
                        *unquant_mf.offset(0 as ::core::ffi::c_int as isize)
                            << 1 as ::core::ffi::c_int
                    } else {
                        *unquant_mf.offset(*zigzag.offset(i_0 as isize) as isize)
                    }) * abs_level
                        + 128 as ::core::ffi::c_int
                        >> 8 as ::core::ffi::c_int;
                    let mut d: ::core::ffi::c_int = abs_coef - unquant_abs_level;
                    if (*h).mb.i_psy_trellis != 0 && i_0 != 0 && dc == 0 && b_chroma == 0 {
                        let mut orig_coef: ::core::ffi::c_int =
                            if num_coefs == 64 as ::core::ffi::c_int {
                                (*h).mb.pic.fenc_dct8[idx as usize]
                                    [*zigzag.offset(i_0 as isize) as usize]
                            } else {
                                (*h).mb.pic.fenc_dct4[idx as usize]
                                    [*zigzag.offset(i_0 as isize) as usize]
                            };
                        let mut predicted_coef: ::core::ffi::c_int = orig_coef - sign_coef;
                        let mut psy_value: ::core::ffi::c_int = abs(unquant_abs_level
                            + ((predicted_coef ^ sign_coef >> 31 as ::core::ffi::c_int)
                                - (sign_coef >> 31 as ::core::ffi::c_int)));
                        let mut psy_weight: ::core::ffi::c_int = (*coef_weight1
                            .offset(*zigzag.offset(i_0 as isize) as isize))
                        .wrapping_mul((*h).mb.i_psy_trellis as uint32_t)
                            as ::core::ffi::c_int;
                        let mut tmp: int64_t = d as int64_t
                            * d as int64_t
                            * *coef_weight2.offset(*zigzag.offset(i_0 as isize) as isize)
                                as int64_t
                            - psy_weight as int64_t * psy_value as int64_t;
                        ssd1[k as usize] = tmp as uint64_t;
                    } else {
                        ssd1[k as usize] = (d as int64_t
                            * d as int64_t
                            * (if dc != 0 {
                                256 as uint32_t
                            } else {
                                *coef_weight2.offset(*zigzag.offset(i_0 as isize) as isize)
                            }) as int64_t) as uint64_t;
                    }
                    ssd0[k as usize] = ssd1[k as usize];
                    if i_0 == 0 && dc == 0 && 0 as ::core::ffi::c_int == 0 {
                        d = sign_coef
                            - ((unquant_abs_level ^ sign_coef >> 31 as ::core::ffi::c_int)
                                - (sign_coef >> 31 as ::core::ffi::c_int)
                                + 8 as ::core::ffi::c_int
                                & !(15 as ::core::ffi::c_int));
                        ssd0[k as usize] = (d as int64_t
                            * d as int64_t
                            * *coef_weight2.offset(*zigzag.offset(i_0 as isize) as isize)
                                as int64_t) as uint64_t;
                    }
                    k += 1;
                }
                match q {
                    1 => {
                        ssd1[0 as ::core::ffi::c_int as usize] =
                            ssd1[0 as ::core::ffi::c_int as usize].wrapping_add(
                                (cost_siglast[0 as ::core::ffi::c_int as usize] as uint64_t)
                                    .wrapping_mul(lambda2 as uint64_t)
                                    >> CABAC_SIZE_BITS - LAMBDA_BITS,
                            );
                        levels_used = trellis_coef0_0(
                            ssd0[0 as ::core::ffi::c_int as usize]
                                .wrapping_sub(ssd1[0 as ::core::ffi::c_int as usize]),
                            nodes_cur,
                            nodes_prev,
                            level_tree.as_mut_ptr(),
                            levels_used,
                        );
                        levels_used = trellis_coef1_0(
                            ssd0[1 as ::core::ffi::c_int as usize]
                                .wrapping_sub(ssd1[0 as ::core::ffi::c_int as usize]),
                            ssd1[1 as ::core::ffi::c_int as usize]
                                .wrapping_sub(ssd1[0 as ::core::ffi::c_int as usize]),
                            cost_siglast.as_mut_ptr(),
                            nodes_cur,
                            nodes_prev,
                            level_tree.as_mut_ptr(),
                            levels_used,
                            lambda2,
                            level_state.as_mut_ptr(),
                        );
                    }
                    2 => {
                        levels_used = trellis_coef1_0(
                            ssd0[0 as ::core::ffi::c_int as usize],
                            ssd1[0 as ::core::ffi::c_int as usize],
                            cost_siglast.as_mut_ptr(),
                            nodes_cur,
                            nodes_prev,
                            level_tree.as_mut_ptr(),
                            levels_used,
                            lambda2,
                            level_state.as_mut_ptr(),
                        );
                        levels_used = trellis_coefn_0(
                            q,
                            ssd0[1 as ::core::ffi::c_int as usize],
                            ssd1[1 as ::core::ffi::c_int as usize],
                            cost_siglast.as_mut_ptr(),
                            nodes_cur,
                            nodes_prev,
                            level_tree.as_mut_ptr(),
                            levels_used,
                            lambda2,
                            level_state.as_mut_ptr(),
                            levelgt1_ctx,
                        );
                        current_block = 15622658527355336244;
                        break;
                    }
                    _ => {
                        levels_used = trellis_coefn_0(
                            q - 1 as ::core::ffi::c_int,
                            ssd0[0 as ::core::ffi::c_int as usize],
                            ssd1[0 as ::core::ffi::c_int as usize],
                            cost_siglast.as_mut_ptr(),
                            nodes_cur,
                            nodes_prev,
                            level_tree.as_mut_ptr(),
                            levels_used,
                            lambda2,
                            level_state.as_mut_ptr(),
                            levelgt1_ctx,
                        );
                        levels_used = trellis_coefn_0(
                            q,
                            ssd0[1 as ::core::ffi::c_int as usize],
                            ssd1[1 as ::core::ffi::c_int as usize],
                            cost_siglast.as_mut_ptr(),
                            nodes_cur,
                            nodes_prev,
                            level_tree.as_mut_ptr(),
                            levels_used,
                            lambda2,
                            level_state.as_mut_ptr(),
                            levelgt1_ctx,
                        );
                        current_block = 15622658527355336244;
                        break;
                    }
                }
            }
            i_0 -= 1;
        }
        match current_block {
            15622658527355336244 => {
                loop {
                    i_0 -= 1;
                    if !(i_0 >= b_ac) {
                        break;
                    }
                    if quant_coefs[i_0 as usize] == 0 {
                        if 1 as ::core::ffi::c_int == 0 {
                            let mut sigindex_1: ::core::ffi::c_int =
                                if dc == 0 && num_coefs == 64 as ::core::ffi::c_int {
                                    x264_significant_coeff_flag_offset_8x8[b_interlaced as usize]
                                        [i_0 as usize]
                                        as ::core::ffi::c_int
                                } else if b_chroma != 0
                                    && dc != 0
                                    && num_coefs == 8 as ::core::ffi::c_int
                                {
                                    x264_coeff_flag_offset_chroma_422_dc[i_0 as usize]
                                        as ::core::ffi::c_int
                                } else {
                                    i_0
                                };
                            let mut cost_sig0_0: uint64_t = (x264_cabac_size_decision_noup2(
                                &mut *cabac_state_sig.offset(sigindex_1 as isize),
                                0 as ::core::ffi::c_long,
                            )
                                as uint64_t)
                                .wrapping_mul(lambda2 as uint64_t)
                                >> CABAC_SIZE_BITS - LAMBDA_BITS;
                            let ref mut fresh1 =
                                (*nodes_cur.offset(0 as ::core::ffi::c_int as isize)).score;
                            *fresh1 = (*fresh1).wrapping_sub(cost_sig0_0);
                        }
                        let mut j_3: ::core::ffi::c_int = 1 as ::core::ffi::c_int;
                        while j_3
                            < (if 1 as ::core::ffi::c_int != 0 {
                                8 as ::core::ffi::c_int
                            } else {
                                4 as ::core::ffi::c_int
                            })
                        {
                            if ::core::mem::size_of::<trellis_level_t>() as usize
                                == ::core::mem::size_of::<uint32_t>() as usize
                            {
                                (*(&mut *level_tree.as_mut_ptr().offset(levels_used as isize)
                                    as *mut trellis_level_t
                                    as *mut x264_union32_t))
                                    .i = pack16to32(
                                    (*nodes_cur.offset(j_3 as isize)).level_idx as uint32_t,
                                    0 as uint32_t,
                                );
                            } else {
                                level_tree[levels_used as usize] = {
                                    let mut init = trellis_level_t {
                                        next: (*nodes_cur.offset(j_3 as isize)).level_idx
                                            as uint16_t,
                                        abs_level: 0 as uint16_t,
                                    };
                                    init
                                };
                            }
                            (*nodes_cur.offset(j_3 as isize)).level_idx = levels_used;
                            levels_used += 1;
                            j_3 += 1;
                        }
                    } else {
                        let mut sign_coef_0: ::core::ffi::c_int =
                            orig_coefs[*zigzag.offset(i_0 as isize) as usize];
                        let mut abs_coef_0: ::core::ffi::c_int = abs(sign_coef_0);
                        let mut q_0: ::core::ffi::c_int = abs(quant_coefs[i_0 as usize]);
                        let mut cost_siglast_0: [::core::ffi::c_int; 3] = [0; 3];
                        let mut t_0: *mut trellis_node_t = nodes_cur;
                        nodes_cur = nodes_prev;
                        nodes_prev = t_0;
                        let mut j_4: ::core::ffi::c_int = 1 as ::core::ffi::c_int;
                        while j_4 < 8 as ::core::ffi::c_int {
                            (*nodes_cur.offset(j_4 as isize)).score = TRELLIS_SCORE_MAX as uint64_t;
                            j_4 += 1;
                        }
                        if i_0 < num_coefs - 1 as ::core::ffi::c_int || 1 as ::core::ffi::c_int != 0
                        {
                            let mut sigindex_2: ::core::ffi::c_int =
                                if dc == 0 && num_coefs == 64 as ::core::ffi::c_int {
                                    x264_significant_coeff_flag_offset_8x8[b_interlaced as usize]
                                        [i_0 as usize]
                                        as ::core::ffi::c_int
                                } else if b_chroma != 0
                                    && dc != 0
                                    && num_coefs == 8 as ::core::ffi::c_int
                                {
                                    x264_coeff_flag_offset_chroma_422_dc[i_0 as usize]
                                        as ::core::ffi::c_int
                                } else {
                                    i_0
                                };
                            let mut lastindex_0: ::core::ffi::c_int = if dc == 0
                                && num_coefs == 64 as ::core::ffi::c_int
                            {
                                x264_last_coeff_flag_offset_8x8[i_0 as usize] as ::core::ffi::c_int
                            } else if b_chroma != 0
                                && dc != 0
                                && num_coefs == 8 as ::core::ffi::c_int
                            {
                                x264_coeff_flag_offset_chroma_422_dc[i_0 as usize]
                                    as ::core::ffi::c_int
                            } else {
                                i_0
                            };
                            cost_siglast_0[0 as ::core::ffi::c_int as usize] =
                                x264_cabac_size_decision_noup2(
                                    &mut *cabac_state_sig.offset(sigindex_2 as isize),
                                    0 as ::core::ffi::c_long,
                                );
                            let mut cost_sig1_0: ::core::ffi::c_int =
                                x264_cabac_size_decision_noup2(
                                    &mut *cabac_state_sig.offset(sigindex_2 as isize),
                                    1 as ::core::ffi::c_long,
                                );
                            cost_siglast_0[1 as ::core::ffi::c_int as usize] =
                                x264_cabac_size_decision_noup2(
                                    &mut *cabac_state_last.offset(lastindex_0 as isize),
                                    0 as ::core::ffi::c_long,
                                ) + cost_sig1_0;
                            if 1 as ::core::ffi::c_int == 0 {
                                cost_siglast_0[2 as ::core::ffi::c_int as usize] =
                                    x264_cabac_size_decision_noup2(
                                        &mut *cabac_state_last.offset(lastindex_0 as isize),
                                        1 as ::core::ffi::c_long,
                                    ) + cost_sig1_0;
                            }
                        } else {
                            cost_siglast_0[2 as ::core::ffi::c_int as usize] =
                                0 as ::core::ffi::c_int;
                            cost_siglast_0[1 as ::core::ffi::c_int as usize] =
                                cost_siglast_0[2 as ::core::ffi::c_int as usize];
                            cost_siglast_0[0 as ::core::ffi::c_int as usize] =
                                cost_siglast_0[1 as ::core::ffi::c_int as usize];
                        }
                        let mut ssd0_0: [uint64_t; 2] = [0; 2];
                        let mut ssd1_0: [uint64_t; 2] = [0; 2];
                        let mut k_0: ::core::ffi::c_int = 0 as ::core::ffi::c_int;
                        while k_0 < 2 as ::core::ffi::c_int {
                            let mut abs_level_0: ::core::ffi::c_int =
                                q_0 - 1 as ::core::ffi::c_int + k_0;
                            let mut unquant_abs_level_0: ::core::ffi::c_int = (if dc != 0 {
                                *unquant_mf.offset(0 as ::core::ffi::c_int as isize)
                                    << 1 as ::core::ffi::c_int
                            } else {
                                *unquant_mf.offset(*zigzag.offset(i_0 as isize) as isize)
                            }) * abs_level_0
                                + 128 as ::core::ffi::c_int
                                >> 8 as ::core::ffi::c_int;
                            let mut d_0: ::core::ffi::c_int = abs_coef_0 - unquant_abs_level_0;
                            if (*h).mb.i_psy_trellis != 0 && i_0 != 0 && dc == 0 && b_chroma == 0 {
                                let mut orig_coef_0: ::core::ffi::c_int =
                                    if num_coefs == 64 as ::core::ffi::c_int {
                                        (*h).mb.pic.fenc_dct8[idx as usize]
                                            [*zigzag.offset(i_0 as isize) as usize]
                                    } else {
                                        (*h).mb.pic.fenc_dct4[idx as usize]
                                            [*zigzag.offset(i_0 as isize) as usize]
                                    };
                                let mut predicted_coef_0: ::core::ffi::c_int =
                                    orig_coef_0 - sign_coef_0;
                                let mut psy_value_0: ::core::ffi::c_int = abs(unquant_abs_level_0
                                    + ((predicted_coef_0
                                        ^ sign_coef_0 >> 31 as ::core::ffi::c_int)
                                        - (sign_coef_0 >> 31 as ::core::ffi::c_int)));
                                let mut psy_weight_0: ::core::ffi::c_int = (*coef_weight1
                                    .offset(*zigzag.offset(i_0 as isize) as isize))
                                .wrapping_mul((*h).mb.i_psy_trellis as uint32_t)
                                    as ::core::ffi::c_int;
                                let mut tmp_0: int64_t = d_0 as int64_t
                                    * d_0 as int64_t
                                    * *coef_weight2.offset(*zigzag.offset(i_0 as isize) as isize)
                                        as int64_t
                                    - psy_weight_0 as int64_t * psy_value_0 as int64_t;
                                ssd1_0[k_0 as usize] = tmp_0 as uint64_t;
                            } else {
                                ssd1_0[k_0 as usize] = (d_0 as int64_t
                                    * d_0 as int64_t
                                    * (if dc != 0 {
                                        256 as uint32_t
                                    } else {
                                        *coef_weight2.offset(*zigzag.offset(i_0 as isize) as isize)
                                    }) as int64_t)
                                    as uint64_t;
                            }
                            ssd0_0[k_0 as usize] = ssd1_0[k_0 as usize];
                            if i_0 == 0 && dc == 0 && 1 as ::core::ffi::c_int == 0 {
                                d_0 = sign_coef_0
                                    - ((unquant_abs_level_0
                                        ^ sign_coef_0 >> 31 as ::core::ffi::c_int)
                                        - (sign_coef_0 >> 31 as ::core::ffi::c_int)
                                        + 8 as ::core::ffi::c_int
                                        & !(15 as ::core::ffi::c_int));
                                ssd0_0[k_0 as usize] = (d_0 as int64_t
                                    * d_0 as int64_t
                                    * *coef_weight2.offset(*zigzag.offset(i_0 as isize) as isize)
                                        as int64_t)
                                    as uint64_t;
                            }
                            k_0 += 1;
                        }
                        match q_0 {
                            1 => {
                                ssd1_0[0 as ::core::ffi::c_int as usize] =
                                    ssd1_0[0 as ::core::ffi::c_int as usize].wrapping_add(
                                        (cost_siglast_0[0 as ::core::ffi::c_int as usize]
                                            as uint64_t)
                                            .wrapping_mul(lambda2 as uint64_t)
                                            >> CABAC_SIZE_BITS - LAMBDA_BITS,
                                    );
                                levels_used = trellis_coef0_1(
                                    ssd0_0[0 as ::core::ffi::c_int as usize]
                                        .wrapping_sub(ssd1_0[0 as ::core::ffi::c_int as usize]),
                                    nodes_cur,
                                    nodes_prev,
                                    level_tree.as_mut_ptr(),
                                    levels_used,
                                );
                                levels_used = trellis_coef1_1(
                                    ssd0_0[1 as ::core::ffi::c_int as usize]
                                        .wrapping_sub(ssd1_0[0 as ::core::ffi::c_int as usize]),
                                    ssd1_0[1 as ::core::ffi::c_int as usize]
                                        .wrapping_sub(ssd1_0[0 as ::core::ffi::c_int as usize]),
                                    cost_siglast_0.as_mut_ptr(),
                                    nodes_cur,
                                    nodes_prev,
                                    level_tree.as_mut_ptr(),
                                    levels_used,
                                    lambda2,
                                    level_state.as_mut_ptr(),
                                );
                            }
                            2 => {
                                levels_used = trellis_coef1_1(
                                    ssd0_0[0 as ::core::ffi::c_int as usize],
                                    ssd1_0[0 as ::core::ffi::c_int as usize],
                                    cost_siglast_0.as_mut_ptr(),
                                    nodes_cur,
                                    nodes_prev,
                                    level_tree.as_mut_ptr(),
                                    levels_used,
                                    lambda2,
                                    level_state.as_mut_ptr(),
                                );
                                levels_used = trellis_coefn_1(
                                    q_0,
                                    ssd0_0[1 as ::core::ffi::c_int as usize],
                                    ssd1_0[1 as ::core::ffi::c_int as usize],
                                    cost_siglast_0.as_mut_ptr(),
                                    nodes_cur,
                                    nodes_prev,
                                    level_tree.as_mut_ptr(),
                                    levels_used,
                                    lambda2,
                                    level_state.as_mut_ptr(),
                                    levelgt1_ctx,
                                );
                            }
                            _ => {
                                levels_used = trellis_coefn_1(
                                    q_0 - 1 as ::core::ffi::c_int,
                                    ssd0_0[0 as ::core::ffi::c_int as usize],
                                    ssd1_0[0 as ::core::ffi::c_int as usize],
                                    cost_siglast_0.as_mut_ptr(),
                                    nodes_cur,
                                    nodes_prev,
                                    level_tree.as_mut_ptr(),
                                    levels_used,
                                    lambda2,
                                    level_state.as_mut_ptr(),
                                    levelgt1_ctx,
                                );
                                levels_used = trellis_coefn_1(
                                    q_0,
                                    ssd0_0[1 as ::core::ffi::c_int as usize],
                                    ssd1_0[1 as ::core::ffi::c_int as usize],
                                    cost_siglast_0.as_mut_ptr(),
                                    nodes_cur,
                                    nodes_prev,
                                    level_tree.as_mut_ptr(),
                                    levels_used,
                                    lambda2,
                                    level_state.as_mut_ptr(),
                                    levelgt1_ctx,
                                );
                            }
                        }
                    }
                }
                bnode =
                    &mut *nodes_cur.offset(1 as ::core::ffi::c_int as isize) as *mut trellis_node_t;
                let mut j_5: ::core::ffi::c_int = 1 as ::core::ffi::c_int + 1 as ::core::ffi::c_int;
                while j_5
                    < (if 1 as ::core::ffi::c_int != 0 {
                        8 as ::core::ffi::c_int
                    } else {
                        4 as ::core::ffi::c_int
                    })
                {
                    if (*nodes_cur.offset(j_5 as isize)).score < (*bnode).score {
                        bnode = &mut *nodes_cur.offset(j_5 as isize) as *mut trellis_node_t;
                    }
                    j_5 += 1;
                }
            }
            _ => {
                bnode =
                    &mut *nodes_cur.offset(0 as ::core::ffi::c_int as isize) as *mut trellis_node_t;
                let mut j_2: ::core::ffi::c_int = 0 as ::core::ffi::c_int + 1 as ::core::ffi::c_int;
                while j_2
                    < (if 0 as ::core::ffi::c_int != 0 {
                        8 as ::core::ffi::c_int
                    } else {
                        4 as ::core::ffi::c_int
                    })
                {
                    if (*nodes_cur.offset(j_2 as isize)).score < (*bnode).score {
                        bnode = &mut *nodes_cur.offset(j_2 as isize) as *mut trellis_node_t;
                    }
                    j_2 += 1;
                }
                if bnode
                    == &mut *nodes_cur.offset(0 as ::core::ffi::c_int as isize)
                        as *mut trellis_node_t
                {
                    if num_coefs == 16 as ::core::ffi::c_int && dc == 0 {
                        memset(
                            dct as *mut ::core::ffi::c_void,
                            0 as ::core::ffi::c_int,
                            (16 as size_t)
                                .wrapping_mul(::core::mem::size_of::<dctcoef>() as size_t),
                        );
                    }
                    return 0 as ::core::ffi::c_int;
                }
            }
        }
        let mut level: ::core::ffi::c_int = (*bnode).level_idx;
        i_0 = b_ac;
        while i_0 <= last_nnz {
            *dct.offset(*zigzag.offset(i_0 as isize) as isize) = (level_tree[level as usize]
                .abs_level
                as dctcoef
                ^ *dct.offset(*zigzag.offset(i_0 as isize) as isize) >> 31 as ::core::ffi::c_int)
                - (*dct.offset(*zigzag.offset(i_0 as isize) as isize) >> 31 as ::core::ffi::c_int);
            level = level_tree[level as usize].next as ::core::ffi::c_int;
            i_0 += 1;
        }
        return 1 as ::core::ffi::c_int;
    }
    #[inline(always)]
    #[c2rust::src_loc = "920:1"]
    pub unsafe extern "C" fn quant_trellis_cavlc(
        mut h: *mut x264_t,
        mut dct: *mut dctcoef,
        mut quant_mf: *const udctcoef,
        mut unquant_mf: *const ::core::ffi::c_int,
        mut zigzag: *const uint8_t,
        mut ctx_block_cat: ::core::ffi::c_int,
        mut lambda2: ::core::ffi::c_int,
        mut b_ac: ::core::ffi::c_int,
        mut b_chroma: ::core::ffi::c_int,
        mut dc: ::core::ffi::c_int,
        mut num_coefs: ::core::ffi::c_int,
        mut idx: ::core::ffi::c_int,
        mut b_8x8: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int {
        let mut last_nnz: ::core::ffi::c_int = 0;
        let mut coef_mask: ::core::ffi::c_int = 0;
        let mut round_mask: ::core::ffi::c_int = 0;
        let mut quant_coefs: [[dctcoef; 16]; 2] = [[0; 16]; 2];
        let mut coefs: [dctcoef; 16] = [0; 16];
        let mut coef_weight1: *const uint32_t = if b_8x8 != 0 {
            x264_dct8_weight_tab.as_ptr()
        } else {
            x264_dct4_weight_tab.as_ptr()
        };
        let mut coef_weight2: *const uint32_t = if b_8x8 != 0 {
            x264_dct8_weight2_tab.as_ptr()
        } else {
            x264_dct4_weight2_tab.as_ptr()
        };
        let mut delta_distortion: [int64_t; 16] = [0; 16];
        let mut score: int64_t =
            ((1 as ::core::ffi::c_ulonglong) << 62 as ::core::ffi::c_int) as int64_t;
        let mut i: ::core::ffi::c_int = 0;
        let mut j: ::core::ffi::c_int = 0;
        let f: ::core::ffi::c_int = (1 as ::core::ffi::c_int) << 15 as ::core::ffi::c_int;
        let mut nC: ::core::ffi::c_int = if b_chroma != 0 && dc != 0 {
            3 as ::core::ffi::c_int + (num_coefs >> 2 as ::core::ffi::c_int)
        } else {
            ct_index[x264_mb_predict_non_zero_code(
                h,
                if b_chroma == 0 && dc != 0 {
                    (idx - LUMA_DC) * 16 as ::core::ffi::c_int
                } else {
                    idx
                },
            ) as usize] as ::core::ffi::c_int
        };
        i = 0 as ::core::ffi::c_int;
        while i < 16 as ::core::ffi::c_int {
            (*(&mut *coefs.as_mut_ptr().offset(i as isize) as *mut dctcoef
                as *mut x264_union128_sse_t))
                .i = M128_ZERO;
            i = (i as ::core::ffi::c_ulong).wrapping_add(
                (16 as usize).wrapping_div(::core::mem::size_of::<dctcoef>() as usize)
                    as ::core::ffi::c_ulong,
            ) as ::core::ffi::c_int as ::core::ffi::c_int;
        }
        let mut step: ::core::ffi::c_int = 1 as ::core::ffi::c_int;
        let mut start: ::core::ffi::c_int = b_ac;
        let mut end: ::core::ffi::c_int = num_coefs - 1 as ::core::ffi::c_int;
        if b_8x8 != 0 {
            start = idx & 3 as ::core::ffi::c_int;
            end = 60 as ::core::ffi::c_int + start;
            step = 4 as ::core::ffi::c_int;
        }
        idx &= 15 as ::core::ffi::c_int;
        lambda2 <<= LAMBDA_BITS;
        i = end;
        while i >= start {
            if (abs(*dct.offset(*zigzag.offset(i as isize) as isize)) as udctcoef).wrapping_mul(
                (if dc != 0 {
                    *quant_mf.offset(0 as ::core::ffi::c_int as isize) >> 1 as ::core::ffi::c_int
                } else {
                    *quant_mf.offset(*zigzag.offset(i as isize) as isize)
                }),
            ) >= f as udctcoef
            {
                break;
            }
            i -= step;
        }
        if !(i < start) {
            last_nnz = if b_8x8 != 0 {
                i >> 2 as ::core::ffi::c_int
            } else {
                i
            };
            coef_mask = 0 as ::core::ffi::c_int;
            round_mask = 0 as ::core::ffi::c_int;
            i = b_ac;
            j = start;
            while i <= last_nnz {
                let mut coef: ::core::ffi::c_int = *dct.offset(*zigzag.offset(j as isize) as isize);
                let mut abs_coef: ::core::ffi::c_int = abs(coef);
                let mut sign: ::core::ffi::c_int = if coef < 0 as ::core::ffi::c_int {
                    -(1 as ::core::ffi::c_int)
                } else {
                    1 as ::core::ffi::c_int
                };
                let mut nearest_quant: ::core::ffi::c_int =
                    ((f as udctcoef).wrapping_add((abs_coef as udctcoef).wrapping_mul(
                        (if dc != 0 {
                            *quant_mf.offset(0 as ::core::ffi::c_int as isize)
                                >> 1 as ::core::ffi::c_int
                        } else {
                            *quant_mf.offset(*zigzag.offset(j as isize) as isize)
                        }),
                    )) >> 16 as ::core::ffi::c_int) as ::core::ffi::c_int;
                quant_coefs[0 as ::core::ffi::c_int as usize][i as usize] =
                    (sign * nearest_quant) as dctcoef;
                quant_coefs[1 as ::core::ffi::c_int as usize][i as usize] =
                    quant_coefs[0 as ::core::ffi::c_int as usize][i as usize];
                coefs[i as usize] = quant_coefs[1 as ::core::ffi::c_int as usize][i as usize];
                if nearest_quant != 0 {
                    let mut deadzone_quant: ::core::ffi::c_int = (((f / 2 as ::core::ffi::c_int)
                        as udctcoef)
                        .wrapping_add((abs_coef as udctcoef).wrapping_mul(
                            (if dc != 0 {
                                *quant_mf.offset(0 as ::core::ffi::c_int as isize)
                                    >> 1 as ::core::ffi::c_int
                            } else {
                                *quant_mf.offset(*zigzag.offset(j as isize) as isize)
                            }),
                        ))
                        >> 16 as ::core::ffi::c_int)
                        as ::core::ffi::c_int;
                    let mut unquant1: ::core::ffi::c_int = (if dc != 0 {
                        *unquant_mf.offset(0 as ::core::ffi::c_int as isize)
                            << 1 as ::core::ffi::c_int
                    } else {
                        *unquant_mf.offset(*zigzag.offset(j as isize) as isize)
                    }) * (nearest_quant
                        - 0 as ::core::ffi::c_int)
                        + 128 as ::core::ffi::c_int
                        >> 8 as ::core::ffi::c_int;
                    let mut unquant0: ::core::ffi::c_int = (if dc != 0 {
                        *unquant_mf.offset(0 as ::core::ffi::c_int as isize)
                            << 1 as ::core::ffi::c_int
                    } else {
                        *unquant_mf.offset(*zigzag.offset(j as isize) as isize)
                    }) * (nearest_quant
                        - 1 as ::core::ffi::c_int)
                        + 128 as ::core::ffi::c_int
                        >> 8 as ::core::ffi::c_int;
                    let mut d1: ::core::ffi::c_int = abs_coef - unquant1;
                    let mut d0: ::core::ffi::c_int = abs_coef - unquant0;
                    delta_distortion[i as usize] = (d0 * d0 - d1 * d1) as int64_t
                        * (if dc != 0 {
                            256 as uint32_t
                        } else {
                            *coef_weight2.offset(*zigzag.offset(j as isize) as isize)
                        }) as int64_t;
                    if (*h).mb.i_psy_trellis != 0 && j != 0 && dc == 0 && b_chroma == 0 {
                        let mut orig_coef: ::core::ffi::c_int = if b_8x8 != 0 {
                            (*h).mb.pic.fenc_dct8[(idx >> 2 as ::core::ffi::c_int) as usize]
                                [*zigzag.offset(j as isize) as usize]
                        } else {
                            (*h).mb.pic.fenc_dct4[idx as usize][*zigzag.offset(j as isize) as usize]
                        };
                        let mut predicted_coef: ::core::ffi::c_int = orig_coef - coef;
                        let mut psy_weight: ::core::ffi::c_int = *coef_weight1
                            .offset(*zigzag.offset(j as isize) as isize)
                            as ::core::ffi::c_int;
                        let mut psy_value0: ::core::ffi::c_int =
                            (*h).mb.i_psy_trellis * abs(predicted_coef + unquant0 * sign);
                        let mut psy_value1: ::core::ffi::c_int =
                            (*h).mb.i_psy_trellis * abs(predicted_coef + unquant1 * sign);
                        delta_distortion[i as usize] +=
                            ((psy_value0 - psy_value1) * psy_weight) as int64_t;
                    }
                    quant_coefs[0 as ::core::ffi::c_int as usize][i as usize] =
                        (sign * (nearest_quant - 1 as ::core::ffi::c_int)) as dctcoef;
                    if deadzone_quant != nearest_quant {
                        coefs[i as usize] =
                            quant_coefs[0 as ::core::ffi::c_int as usize][i as usize];
                    } else {
                        round_mask |= (1 as ::core::ffi::c_int) << i;
                    }
                } else {
                    delta_distortion[i as usize] = 0 as int64_t;
                }
                coef_mask |= ((coefs[i as usize] != 0) as ::core::ffi::c_int) << i;
                i += 1;
                j += step;
            }
            (*h).out.bs.i_bits_encoded = 0 as ::core::ffi::c_int;
            if coef_mask == 0 {
                (*h).out.bs.i_bits_encoded +=
                    x264_coeff0_token[nC as usize].i_size as ::core::ffi::c_int;
            } else {
                cavlc_block_residual_internal(
                    h,
                    ctx_block_cat,
                    coefs.as_mut_ptr().offset(b_ac as isize),
                    nC,
                );
            }
            score = (*h).out.bs.i_bits_encoded as int64_t * lambda2 as int64_t;
            loop {
                let mut iter_score: int64_t = score;
                let mut iter_distortion_delta: int64_t = 0 as int64_t;
                let mut iter_coef: ::core::ffi::c_int = -(1 as ::core::ffi::c_int);
                let mut iter_mask: ::core::ffi::c_int = coef_mask;
                let mut iter_round: ::core::ffi::c_int = round_mask;
                i = b_ac;
                while i <= last_nnz {
                    if !(delta_distortion[i as usize] == 0) {
                        let mut cur_round: ::core::ffi::c_int =
                            round_mask ^ (1 as ::core::ffi::c_int) << i;
                        let mut round_change: ::core::ffi::c_int =
                            cur_round >> i & 1 as ::core::ffi::c_int;
                        let mut old_coef: ::core::ffi::c_int = coefs[i as usize];
                        let mut new_coef: ::core::ffi::c_int =
                            quant_coefs[round_change as usize][i as usize];
                        let mut cur_mask: ::core::ffi::c_int = coef_mask
                            & !((1 as ::core::ffi::c_int) << i)
                            | ((new_coef != 0) as ::core::ffi::c_int) << i;
                        let mut cur_distortion_delta: int64_t = delta_distortion[i as usize]
                            * (if round_change != 0 {
                                -(1 as ::core::ffi::c_int)
                            } else {
                                1 as ::core::ffi::c_int
                            }) as int64_t;
                        let mut cur_score: int64_t = cur_distortion_delta;
                        coefs[i as usize] = new_coef as dctcoef;
                        (*h).out.bs.i_bits_encoded = 0 as ::core::ffi::c_int;
                        if cur_mask == 0 {
                            (*h).out.bs.i_bits_encoded +=
                                x264_coeff0_token[nC as usize].i_size as ::core::ffi::c_int;
                        } else {
                            cavlc_block_residual_internal(
                                h,
                                ctx_block_cat,
                                coefs.as_mut_ptr().offset(b_ac as isize),
                                nC,
                            );
                        }
                        cur_score += (*h).out.bs.i_bits_encoded as int64_t * lambda2 as int64_t;
                        coefs[i as usize] = old_coef as dctcoef;
                        if cur_score < iter_score {
                            iter_score = cur_score;
                            iter_coef = i;
                            iter_mask = cur_mask;
                            iter_round = cur_round;
                            iter_distortion_delta = cur_distortion_delta;
                        }
                    }
                    i += 1;
                }
                if !(iter_coef >= 0 as ::core::ffi::c_int) {
                    break;
                }
                score = iter_score - iter_distortion_delta;
                coef_mask = iter_mask;
                round_mask = iter_round;
                coefs[iter_coef as usize] = quant_coefs
                    [(round_mask >> iter_coef & 1 as ::core::ffi::c_int) as usize]
                    [iter_coef as usize];
                delta_distortion[iter_coef as usize] = 0 as int64_t;
            }
            if coef_mask != 0 {
                i = b_ac;
                j = start;
                while i < num_coefs {
                    *dct.offset(*zigzag.offset(j as isize) as isize) = coefs[i as usize];
                    i += 1;
                    j += step;
                }
                return 1 as ::core::ffi::c_int;
            }
        }
        if dc == 0 {
            if b_8x8 != 0 {
                i = start;
                while i <= end {
                    *dct.offset(*zigzag.offset(i as isize) as isize) =
                        0 as ::core::ffi::c_int as dctcoef;
                    i += step;
                }
            } else {
                memset(
                    dct as *mut ::core::ffi::c_void,
                    0 as ::core::ffi::c_int,
                    (16 as size_t).wrapping_mul(::core::mem::size_of::<dctcoef>() as size_t),
                );
            }
        }
        return 0 as ::core::ffi::c_int;
    }
    #[no_mangle]
    #[c2rust::src_loc = "1098:1"]
    pub unsafe extern "C" fn x264_10_quant_luma_dc_trellis(
        mut h: *mut x264_t,
        mut dct: *mut dctcoef,
        mut i_quant_cat: ::core::ffi::c_int,
        mut i_qp: ::core::ffi::c_int,
        mut ctx_block_cat: ::core::ffi::c_int,
        mut b_intra: ::core::ffi::c_int,
        mut idx: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int {
        if (*h).param.b_cabac != 0 {
            return quant_trellis_cabac(
                h,
                dct,
                (*(*(*h).quant4_mf.as_mut_ptr().offset(i_quant_cat as isize))
                    .offset(i_qp as isize))
                .as_mut_ptr(),
                (*(*(*h).quant4_bias0.as_mut_ptr().offset(i_quant_cat as isize))
                    .offset(i_qp as isize))
                .as_mut_ptr(),
                (*(*(*h).unquant4_mf.as_mut_ptr().offset(i_quant_cat as isize))
                    .offset(i_qp as isize))
                .as_mut_ptr(),
                (*x264_zigzag_scan4
                    .as_ptr()
                    .offset((*h).mb.b_interlaced as isize))
                .as_ptr(),
                ctx_block_cat,
                (*h).mb.i_trellis_lambda2[0 as ::core::ffi::c_int as usize][b_intra as usize],
                0 as ::core::ffi::c_int,
                0 as ::core::ffi::c_int,
                1 as ::core::ffi::c_int,
                16 as ::core::ffi::c_int,
                idx,
            );
        }
        return quant_trellis_cavlc(
            h,
            dct,
            (*(*(*h).quant4_mf.as_mut_ptr().offset(i_quant_cat as isize)).offset(i_qp as isize))
                .as_mut_ptr(),
            (*(*(*h).unquant4_mf.as_mut_ptr().offset(i_quant_cat as isize)).offset(i_qp as isize))
                .as_mut_ptr(),
            (*x264_zigzag_scan4
                .as_ptr()
                .offset((*h).mb.b_interlaced as isize))
            .as_ptr(),
            DCT_LUMA_DC as ::core::ffi::c_int,
            (*h).mb.i_trellis_lambda2[0 as ::core::ffi::c_int as usize][b_intra as usize],
            0 as ::core::ffi::c_int,
            0 as ::core::ffi::c_int,
            1 as ::core::ffi::c_int,
            16 as ::core::ffi::c_int,
            idx,
            0 as ::core::ffi::c_int,
        );
    }
    #[c2rust::src_loc = "1111:22"]
    pub static mut zigzag_scan2x2: [uint8_t; 4] = [
        0 as ::core::ffi::c_int as uint8_t,
        1 as ::core::ffi::c_int as uint8_t,
        2 as ::core::ffi::c_int as uint8_t,
        3 as ::core::ffi::c_int as uint8_t,
    ];
    #[c2rust::src_loc = "1112:22"]
    pub static mut zigzag_scan2x4: [uint8_t; 8] = [
        0 as ::core::ffi::c_int as uint8_t,
        2 as ::core::ffi::c_int as uint8_t,
        1 as ::core::ffi::c_int as uint8_t,
        4 as ::core::ffi::c_int as uint8_t,
        6 as ::core::ffi::c_int as uint8_t,
        3 as ::core::ffi::c_int as uint8_t,
        5 as ::core::ffi::c_int as uint8_t,
        7 as ::core::ffi::c_int as uint8_t,
    ];
    #[no_mangle]
    #[c2rust::src_loc = "1114:1"]
    pub unsafe extern "C" fn x264_10_quant_chroma_dc_trellis(
        mut h: *mut x264_t,
        mut dct: *mut dctcoef,
        mut i_qp: ::core::ffi::c_int,
        mut b_intra: ::core::ffi::c_int,
        mut idx: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int {
        let mut zigzag: *const uint8_t = 0 as *const uint8_t;
        let mut num_coefs: ::core::ffi::c_int = 0;
        let mut quant_cat: ::core::ffi::c_int =
            CQM_4IC as ::core::ffi::c_int + 1 as ::core::ffi::c_int - b_intra;
        if (*(*h).sps.as_mut_ptr()).i_chroma_format_idc == CHROMA_422 as ::core::ffi::c_int {
            zigzag = zigzag_scan2x4.as_ptr();
            num_coefs = 8 as ::core::ffi::c_int;
        } else {
            zigzag = zigzag_scan2x2.as_ptr();
            num_coefs = 4 as ::core::ffi::c_int;
        }
        if (*h).param.b_cabac != 0 {
            return quant_trellis_cabac(
                h,
                dct,
                (*(*(*h).quant4_mf.as_mut_ptr().offset(quant_cat as isize)).offset(i_qp as isize))
                    .as_mut_ptr(),
                (*(*(*h).quant4_bias0.as_mut_ptr().offset(quant_cat as isize))
                    .offset(i_qp as isize))
                .as_mut_ptr(),
                (*(*(*h).unquant4_mf.as_mut_ptr().offset(quant_cat as isize))
                    .offset(i_qp as isize))
                .as_mut_ptr(),
                zigzag,
                DCT_CHROMA_DC as ::core::ffi::c_int,
                (*h).mb.i_trellis_lambda2[1 as ::core::ffi::c_int as usize][b_intra as usize],
                0 as ::core::ffi::c_int,
                1 as ::core::ffi::c_int,
                1 as ::core::ffi::c_int,
                num_coefs,
                idx,
            );
        }
        return quant_trellis_cavlc(
            h,
            dct,
            (*(*(*h).quant4_mf.as_mut_ptr().offset(quant_cat as isize)).offset(i_qp as isize))
                .as_mut_ptr(),
            (*(*(*h).unquant4_mf.as_mut_ptr().offset(quant_cat as isize)).offset(i_qp as isize))
                .as_mut_ptr(),
            zigzag,
            DCT_CHROMA_DC as ::core::ffi::c_int,
            (*h).mb.i_trellis_lambda2[1 as ::core::ffi::c_int as usize][b_intra as usize],
            0 as ::core::ffi::c_int,
            1 as ::core::ffi::c_int,
            1 as ::core::ffi::c_int,
            num_coefs,
            idx,
            0 as ::core::ffi::c_int,
        );
    }
    #[no_mangle]
    #[c2rust::src_loc = "1142:1"]
    pub unsafe extern "C" fn x264_10_quant_4x4_trellis(
        mut h: *mut x264_t,
        mut dct: *mut dctcoef,
        mut i_quant_cat: ::core::ffi::c_int,
        mut i_qp: ::core::ffi::c_int,
        mut ctx_block_cat: ::core::ffi::c_int,
        mut b_intra: ::core::ffi::c_int,
        mut b_chroma: ::core::ffi::c_int,
        mut idx: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int {
        pub static mut ctx_ac: [uint8_t; 14] = [
            0 as ::core::ffi::c_int as uint8_t,
            1 as ::core::ffi::c_int as uint8_t,
            0 as ::core::ffi::c_int as uint8_t,
            0 as ::core::ffi::c_int as uint8_t,
            1 as ::core::ffi::c_int as uint8_t,
            0 as ::core::ffi::c_int as uint8_t,
            0 as ::core::ffi::c_int as uint8_t,
            1 as ::core::ffi::c_int as uint8_t,
            0 as ::core::ffi::c_int as uint8_t,
            0 as ::core::ffi::c_int as uint8_t,
            0 as ::core::ffi::c_int as uint8_t,
            1 as ::core::ffi::c_int as uint8_t,
            0 as ::core::ffi::c_int as uint8_t,
            0 as ::core::ffi::c_int as uint8_t,
        ];
        let mut b_ac: ::core::ffi::c_int = ctx_ac[ctx_block_cat as usize] as ::core::ffi::c_int;
        if (*h).param.b_cabac != 0 {
            return quant_trellis_cabac(
                h,
                dct,
                (*(*(*h).quant4_mf.as_mut_ptr().offset(i_quant_cat as isize))
                    .offset(i_qp as isize))
                .as_mut_ptr(),
                (*(*(*h).quant4_bias0.as_mut_ptr().offset(i_quant_cat as isize))
                    .offset(i_qp as isize))
                .as_mut_ptr(),
                (*(*(*h).unquant4_mf.as_mut_ptr().offset(i_quant_cat as isize))
                    .offset(i_qp as isize))
                .as_mut_ptr(),
                (*x264_zigzag_scan4
                    .as_ptr()
                    .offset((*h).mb.b_interlaced as isize))
                .as_ptr(),
                ctx_block_cat,
                (*h).mb.i_trellis_lambda2[b_chroma as usize][b_intra as usize],
                b_ac,
                b_chroma,
                0 as ::core::ffi::c_int,
                16 as ::core::ffi::c_int,
                idx,
            );
        }
        return quant_trellis_cavlc(
            h,
            dct,
            (*(*(*h).quant4_mf.as_mut_ptr().offset(i_quant_cat as isize)).offset(i_qp as isize))
                .as_mut_ptr(),
            (*(*(*h).unquant4_mf.as_mut_ptr().offset(i_quant_cat as isize)).offset(i_qp as isize))
                .as_mut_ptr(),
            (*x264_zigzag_scan4
                .as_ptr()
                .offset((*h).mb.b_interlaced as isize))
            .as_ptr(),
            ctx_block_cat,
            (*h).mb.i_trellis_lambda2[b_chroma as usize][b_intra as usize],
            b_ac,
            b_chroma,
            0 as ::core::ffi::c_int,
            16 as ::core::ffi::c_int,
            idx,
            0 as ::core::ffi::c_int,
        );
    }
    #[no_mangle]
    #[c2rust::src_loc = "1159:1"]
    pub unsafe extern "C" fn x264_10_quant_8x8_trellis(
        mut h: *mut x264_t,
        mut dct: *mut dctcoef,
        mut i_quant_cat: ::core::ffi::c_int,
        mut i_qp: ::core::ffi::c_int,
        mut ctx_block_cat: ::core::ffi::c_int,
        mut b_intra: ::core::ffi::c_int,
        mut b_chroma: ::core::ffi::c_int,
        mut idx: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int {
        if (*h).param.b_cabac != 0 {
            return quant_trellis_cabac(
                h,
                dct,
                (*(*(*h).quant8_mf.as_mut_ptr().offset(i_quant_cat as isize))
                    .offset(i_qp as isize))
                .as_mut_ptr(),
                (*(*(*h).quant8_bias0.as_mut_ptr().offset(i_quant_cat as isize))
                    .offset(i_qp as isize))
                .as_mut_ptr(),
                (*(*(*h).unquant8_mf.as_mut_ptr().offset(i_quant_cat as isize))
                    .offset(i_qp as isize))
                .as_mut_ptr(),
                (*x264_zigzag_scan8
                    .as_ptr()
                    .offset((*h).mb.b_interlaced as isize))
                .as_ptr(),
                ctx_block_cat,
                (*h).mb.i_trellis_lambda2[b_chroma as usize][b_intra as usize],
                0 as ::core::ffi::c_int,
                b_chroma,
                0 as ::core::ffi::c_int,
                64 as ::core::ffi::c_int,
                idx,
            );
        }
        let mut nzaccum: ::core::ffi::c_int = 0 as ::core::ffi::c_int;
        let mut i: ::core::ffi::c_int = 0 as ::core::ffi::c_int;
        while i < 4 as ::core::ffi::c_int {
            let mut nz: ::core::ffi::c_int = quant_trellis_cavlc(
                h,
                dct,
                (*(*(*h).quant8_mf.as_mut_ptr().offset(i_quant_cat as isize))
                    .offset(i_qp as isize))
                .as_mut_ptr(),
                (*(*(*h).unquant8_mf.as_mut_ptr().offset(i_quant_cat as isize))
                    .offset(i_qp as isize))
                .as_mut_ptr(),
                (*x264_zigzag_scan8
                    .as_ptr()
                    .offset((*h).mb.b_interlaced as isize))
                .as_ptr(),
                DCT_LUMA_4x4 as ::core::ffi::c_int,
                (*h).mb.i_trellis_lambda2[b_chroma as usize][b_intra as usize],
                0 as ::core::ffi::c_int,
                b_chroma,
                0 as ::core::ffi::c_int,
                16 as ::core::ffi::c_int,
                idx * 4 as ::core::ffi::c_int + i,
                1 as ::core::ffi::c_int,
            );
            (*h).mb.cache.non_zero_count
                [x264_scan8[(idx * 4 as ::core::ffi::c_int + i) as usize] as usize] = nz as uint8_t;
            nzaccum |= nz;
            i += 1;
        }
        (*(&mut *(*h).mb.cache.non_zero_count.as_mut_ptr().offset(
            (*x264_scan8.as_ptr().offset(
                (0 as ::core::ffi::c_int * 16 as ::core::ffi::c_int + idx * 4 as ::core::ffi::c_int)
                    as isize,
            ) as ::core::ffi::c_int
                + 0 as ::core::ffi::c_int) as isize,
        ) as *mut uint8_t as *mut x264_union16_t))
            .i = (0 as ::core::ffi::c_int * 0x101 as ::core::ffi::c_int) as uint16_t;
        (*(&mut *(*h).mb.cache.non_zero_count.as_mut_ptr().offset(
            (*x264_scan8.as_ptr().offset(
                (0 as ::core::ffi::c_int * 16 as ::core::ffi::c_int + idx * 4 as ::core::ffi::c_int)
                    as isize,
            ) as ::core::ffi::c_int
                + 8 as ::core::ffi::c_int) as isize,
        ) as *mut uint8_t as *mut x264_union16_t))
            .i = (0 as ::core::ffi::c_int * 0x101 as ::core::ffi::c_int) as uint16_t;
        return nzaccum;
    }
    use super::__stddef_size_t_h::size_t;
    use super::base_h::{
        x264_scan8, x264_union16_t, x264_union32_t, CHROMA_422, CHROMA_444, LUMA_DC,
    };
    use super::bitstream_h::bs_size_ue_big;
    use super::cabac_c::{
        chroma_size_cabac, macroblock_size_cabac, partition_i4x4_size_cabac,
        partition_i8x8_size_cabac, partition_size_cabac, subpartition_size_cabac,
    };
    use super::cabac_h::{x264_cabac_size_decision2, x264_cabac_size_decision_noup2, x264_cabac_t};
    use super::cavlc_c::{
        cavlc_block_residual_internal, chroma_size_cavlc, ct_index, macroblock_size_cavlc,
        partition_i4x4_size_cavlc, partition_i8x8_size_cavlc, partition_size_cavlc,
        subpartition_size_cavlc,
    };
    use super::common_h::{dctcoef, pixel, udctcoef, x264_t, FDEC_STRIDE, FENC_STRIDE};
    use super::encoder_macroblock_h::{
        x264_10_macroblock_encode, x264_10_macroblock_encode_p4x4, x264_10_macroblock_encode_p8x8,
        x264_10_mb_encode_chroma, x264_mb_encode_i4x4, x264_mb_encode_i8x8,
    };
    use super::frame_h::x264_10_macroblock_deblock;
    use super::macroblock_h::{
        block_idx_x, block_idx_y, pack16to32, x264_mb_predict_non_zero_code, x264_zigzag_scan4,
        x264_zigzag_scan8, DCT_LUMA_4x4, B_SKIP, DCT_CHROMA_DC, DCT_LUMA_DC, P_SKIP,
    };
    use super::pixel_h::{
        PIXEL_16x16, PIXEL_16x8, PIXEL_4x4, PIXEL_4x8, PIXEL_8x16, PIXEL_8x4, PIXEL_8x8,
    };
    use super::set_h::CQM_4IC;
    use super::stdint_h::intptr_t;
    use super::stdint_intn_h::int64_t;
    use super::stdint_uintn_h::{uint16_t, uint32_t, uint64_t, uint8_t};
    use super::stdlib_h::abs;
    use super::string_h::{memcpy, memset};
    use super::tables_h::{
        x264_cabac_entropy, x264_cabac_transition, x264_coeff0_token,
        x264_coeff_abs_level_m1_offset, x264_coeff_flag_offset_chroma_422_dc,
        x264_dct4_weight2_tab, x264_dct4_weight_tab, x264_dct8_weight2_tab, x264_dct8_weight_tab,
        x264_last_coeff_flag_offset, x264_last_coeff_flag_offset_8x8,
        x264_significant_coeff_flag_offset, x264_significant_coeff_flag_offset_8x8, x264_zero,
    };
    use super::util_h::{x264_union128_sse_t, M128_ZERO};
    use super::xmmintrin_h::__m128;
    #[cfg(target_arch = "x86")]
    pub use ::core::arch::x86::_mm_setr_ps;
    #[cfg(target_arch = "x86_64")]
    pub use ::core::arch::x86_64::_mm_setr_ps;
}
#[c2rust::header_src = "/home/nwplayer123/Hacks/hex264/x264/encoder/me.h:28"]
pub mod me_h {
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "33:9"]
    pub struct x264_me_t {
        pub i_pixel: ::core::ffi::c_int,
        pub p_cost_mv: *mut uint16_t,
        pub i_ref_cost: ::core::ffi::c_int,
        pub i_ref: ::core::ffi::c_int,
        pub weight: *const x264_weight_t,
        pub p_fref: [*mut pixel; 12],
        pub p_fref_w: *mut pixel,
        pub p_fenc: [*mut pixel; 3],
        pub integral: *mut uint16_t,
        pub i_stride: [::core::ffi::c_int; 3],
        pub mvp: [int16_t; 2],
        pub cost_mv: ::core::ffi::c_int,
        pub cost: ::core::ffi::c_int,
        pub mv: [int16_t; 2],
    }
    #[c2rust::src_loc = "30:9"]
    pub const COST_MAX: ::core::ffi::c_int = (1 as ::core::ffi::c_int) << 28 as ::core::ffi::c_int;
    #[c2rust::src_loc = "31:9"]
    pub const COST_MAX64: ::core::ffi::c_ulonglong =
        (1 as ::core::ffi::c_ulonglong) << 60 as ::core::ffi::c_int;
    use super::common_h::{pixel, x264_t};
    use super::mc_h::x264_weight_t;
    use super::stdint_intn_h::int16_t;
    use super::stdint_uintn_h::uint16_t;
    extern "C" {
        #[c2rust::src_loc = "59:1"]
        pub fn x264_10_me_search_ref(
            h: *mut x264_t,
            m: *mut x264_me_t,
            mvc: *mut [int16_t; 2],
            i_mvc: ::core::ffi::c_int,
            p_fullpel_thresh: *mut ::core::ffi::c_int,
        );
        #[c2rust::src_loc = "64:1"]
        pub fn x264_10_me_refine_qpel(h: *mut x264_t, m: *mut x264_me_t);
        #[c2rust::src_loc = "66:1"]
        pub fn x264_10_me_refine_qpel_refdupe(
            h: *mut x264_t,
            m: *mut x264_me_t,
            p_halfpel_thresh: *mut ::core::ffi::c_int,
        );
        #[c2rust::src_loc = "68:1"]
        pub fn x264_10_me_refine_qpel_rd(
            h: *mut x264_t,
            m: *mut x264_me_t,
            i_lambda2: ::core::ffi::c_int,
            i4: ::core::ffi::c_int,
            i_list: ::core::ffi::c_int,
        );
        #[c2rust::src_loc = "70:1"]
        pub fn x264_10_me_refine_bidir_rd(
            h: *mut x264_t,
            m0: *mut x264_me_t,
            m1: *mut x264_me_t,
            i_weight: ::core::ffi::c_int,
            i8: ::core::ffi::c_int,
            i_lambda2: ::core::ffi::c_int,
        );
        #[c2rust::src_loc = "72:1"]
        pub fn x264_10_me_refine_bidir_satd(
            h: *mut x264_t,
            m0: *mut x264_me_t,
            m1: *mut x264_me_t,
            i_weight: ::core::ffi::c_int,
        );
    }
}
#[c2rust::header_src = "/home/nwplayer123/Hacks/hex264/x264/encoder/slicetype.c:28"]
pub mod slicetype_c {
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "799:9"]
    pub struct x264_slicetype_slice_t {
        pub h: *mut x264_t,
        pub a: *mut x264_mb_analysis_t,
        pub frames: *mut *mut x264_frame_t,
        pub p0: ::core::ffi::c_int,
        pub p1: ::core::ffi::c_int,
        pub b: ::core::ffi::c_int,
        pub dist_scale_factor: ::core::ffi::c_int,
        pub do_search: *mut ::core::ffi::c_int,
        pub w: *const x264_weight_t,
        pub output_inter: *mut ::core::ffi::c_int,
        pub output_intra: *mut ::core::ffi::c_int,
    }
    #[c2rust::src_loc = "33:22"]
    pub static mut delta_tfi_divisor: [uint8_t; 10] = [
        0 as ::core::ffi::c_int as uint8_t,
        2 as ::core::ffi::c_int as uint8_t,
        1 as ::core::ffi::c_int as uint8_t,
        1 as ::core::ffi::c_int as uint8_t,
        2 as ::core::ffi::c_int as uint8_t,
        2 as ::core::ffi::c_int as uint8_t,
        3 as ::core::ffi::c_int as uint8_t,
        3 as ::core::ffi::c_int as uint8_t,
        4 as ::core::ffi::c_int as uint8_t,
        6 as ::core::ffi::c_int as uint8_t,
    ];
    #[c2rust::src_loc = "45:1"]
    pub unsafe extern "C" fn lowres_context_init(
        mut h: *mut x264_t,
        mut a: *mut x264_mb_analysis_t,
    ) {
        (*a).i_qp = X264_LOOKAHEAD_QP;
        (*a).i_lambda = x264_lambda_tab[(*a).i_qp as usize] as ::core::ffi::c_int;
        mb_analyse_load_costs(h, a);
        if (*h).param.analyse.i_subpel_refine > 1 as ::core::ffi::c_int {
            (*h).mb.i_me_method = if (1 as ::core::ffi::c_int) < (*h).param.analyse.i_me_method {
                1 as ::core::ffi::c_int
            } else {
                (*h).param.analyse.i_me_method
            };
            (*h).mb.i_subpel_refine = 4 as ::core::ffi::c_int;
        } else {
            (*h).mb.i_me_method = X264_ME_DIA;
            (*h).mb.i_subpel_refine = 2 as ::core::ffi::c_int;
        }
        (*h).mb.b_chroma_me = 0 as ::core::ffi::c_int;
    }
    #[c2rust::src_loc = "64:1"]
    pub unsafe extern "C" fn weight_get_h264(
        mut weight_nonh264: ::core::ffi::c_int,
        mut offset: ::core::ffi::c_int,
        mut w: *mut x264_weight_t,
    ) {
        (*w).i_offset = offset as int32_t;
        (*w).i_denom = 7 as ::core::ffi::c_int as int32_t;
        (*w).i_scale = weight_nonh264 as int32_t;
        while (*w).i_denom > 0 as int32_t && (*w).i_scale > 127 as int32_t {
            (*w).i_denom -= 1;
            (*w).i_scale >>= 1 as ::core::ffi::c_int;
        }
        (*w).i_scale = if (*w).i_scale < 127 as int32_t {
            (*w).i_scale
        } else {
            127 as int32_t
        };
    }
    #[inline(never)]
    #[c2rust::src_loc = "77:1"]
    pub unsafe extern "C" fn weight_cost_init_luma(
        mut h: *mut x264_t,
        mut fenc: *mut x264_frame_t,
        mut ref_0: *mut x264_frame_t,
        mut dest: *mut pixel,
    ) -> *mut pixel {
        let mut ref0_distance: ::core::ffi::c_int =
            (*fenc).i_frame - (*ref_0).i_frame - 1 as ::core::ffi::c_int;
        if (*(*fenc).lowres_mvs[0 as ::core::ffi::c_int as usize][ref0_distance as usize]
            .offset(0 as ::core::ffi::c_int as isize))[0 as ::core::ffi::c_int as usize]
            as ::core::ffi::c_int
            != 0x7fff as ::core::ffi::c_int
        {
            let mut i_stride: ::core::ffi::c_int = (*fenc).i_stride_lowres;
            let mut i_lines: ::core::ffi::c_int = (*fenc).i_lines_lowres;
            let mut i_width: ::core::ffi::c_int = (*fenc).i_width_lowres;
            let mut i_mb_xy: ::core::ffi::c_int = 0 as ::core::ffi::c_int;
            let mut p: *mut pixel = dest;
            let mut y: ::core::ffi::c_int = 0 as ::core::ffi::c_int;
            while y < i_lines {
                let mut x: ::core::ffi::c_int = 0 as ::core::ffi::c_int;
                while x < i_width {
                    let mut mvx: ::core::ffi::c_int = (*(*fenc).lowres_mvs
                        [0 as ::core::ffi::c_int as usize][ref0_distance as usize]
                        .offset(i_mb_xy as isize))[0 as ::core::ffi::c_int as usize]
                        as ::core::ffi::c_int;
                    let mut mvy: ::core::ffi::c_int = (*(*fenc).lowres_mvs
                        [0 as ::core::ffi::c_int as usize][ref0_distance as usize]
                        .offset(i_mb_xy as isize))[1 as ::core::ffi::c_int as usize]
                        as ::core::ffi::c_int;
                    (*h).mc.mc_luma.expect("non-null function pointer")(
                        p.offset(x as isize),
                        i_stride as intptr_t,
                        (*ref_0).lowres.as_mut_ptr(),
                        i_stride as intptr_t,
                        mvx + (x << 2 as ::core::ffi::c_int),
                        mvy + (y << 2 as ::core::ffi::c_int),
                        8 as ::core::ffi::c_int,
                        8 as ::core::ffi::c_int,
                        x264_zero.as_mut_ptr() as *const x264_weight_t,
                    );
                    x += 8 as ::core::ffi::c_int;
                    i_mb_xy += 1;
                }
                y += 8 as ::core::ffi::c_int;
                p = p.offset((i_stride * 8 as ::core::ffi::c_int) as isize);
            }
            return dest;
        }
        return (*ref_0).lowres[0 as ::core::ffi::c_int as usize];
    }
    #[inline(never)]
    #[c2rust::src_loc = "111:1"]
    pub unsafe extern "C" fn weight_cost_init_chroma(
        mut h: *mut x264_t,
        mut fenc: *mut x264_frame_t,
        mut ref_0: *mut x264_frame_t,
        mut dstu: *mut pixel,
        mut dstv: *mut pixel,
    ) {
        let mut ref0_distance: ::core::ffi::c_int =
            (*fenc).i_frame - (*ref_0).i_frame - 1 as ::core::ffi::c_int;
        let mut i_stride: ::core::ffi::c_int = (*fenc).i_stride[1 as ::core::ffi::c_int as usize];
        let mut i_lines: ::core::ffi::c_int = (*fenc).i_lines[1 as ::core::ffi::c_int as usize];
        let mut i_width: ::core::ffi::c_int = (*fenc).i_width[1 as ::core::ffi::c_int as usize];
        let mut v_shift: ::core::ffi::c_int = (*h).mb.chroma_v_shift;
        let mut cw: ::core::ffi::c_int = 8 as ::core::ffi::c_int * (*h).mb.i_mb_width;
        let mut ch: ::core::ffi::c_int = 16 as ::core::ffi::c_int * (*h).mb.i_mb_height >> v_shift;
        let mut height: ::core::ffi::c_int = 16 as ::core::ffi::c_int >> v_shift;
        if (*(*fenc).lowres_mvs[0 as ::core::ffi::c_int as usize][ref0_distance as usize]
            .offset(0 as ::core::ffi::c_int as isize))[0 as ::core::ffi::c_int as usize]
            as ::core::ffi::c_int
            != 0x7fff as ::core::ffi::c_int
        {
            x264_10_frame_expand_border_chroma(h, ref_0, 1 as ::core::ffi::c_int);
            let mut y: ::core::ffi::c_int = 0 as ::core::ffi::c_int;
            let mut mb_xy: ::core::ffi::c_int = 0 as ::core::ffi::c_int;
            let mut pel_offset_y: ::core::ffi::c_int = 0 as ::core::ffi::c_int;
            while y < i_lines {
                let mut x: ::core::ffi::c_int = 0 as ::core::ffi::c_int;
                let mut pel_offset_x: ::core::ffi::c_int = 0 as ::core::ffi::c_int;
                while x < i_width {
                    let mut pixu: *mut pixel = dstu
                        .offset(pel_offset_y as isize)
                        .offset(pel_offset_x as isize);
                    let mut pixv: *mut pixel = dstv
                        .offset(pel_offset_y as isize)
                        .offset(pel_offset_x as isize);
                    let mut src1: *mut pixel = (*ref_0).plane[1 as ::core::ffi::c_int as usize]
                        .offset(pel_offset_y as isize)
                        .offset((pel_offset_x * 2 as ::core::ffi::c_int) as isize);
                    let mut mvx: ::core::ffi::c_int = (*(*fenc).lowres_mvs
                        [0 as ::core::ffi::c_int as usize][ref0_distance as usize]
                        .offset(mb_xy as isize))[0 as ::core::ffi::c_int as usize]
                        as ::core::ffi::c_int;
                    let mut mvy: ::core::ffi::c_int = (*(*fenc).lowres_mvs
                        [0 as ::core::ffi::c_int as usize][ref0_distance as usize]
                        .offset(mb_xy as isize))[1 as ::core::ffi::c_int as usize]
                        as ::core::ffi::c_int;
                    (*h).mc.mc_chroma.expect("non-null function pointer")(
                        pixu,
                        pixv,
                        i_stride as intptr_t,
                        src1,
                        i_stride as intptr_t,
                        mvx,
                        2 as ::core::ffi::c_int * mvy >> v_shift,
                        8 as ::core::ffi::c_int,
                        height,
                    );
                    x += 8 as ::core::ffi::c_int;
                    mb_xy += 1;
                    pel_offset_x += 8 as ::core::ffi::c_int;
                }
                y += height;
                pel_offset_y = y * i_stride;
            }
        } else {
            (*h).mc
                .plane_copy_deinterleave
                .expect("non-null function pointer")(
                dstu,
                i_stride as intptr_t,
                dstv,
                i_stride as intptr_t,
                (*ref_0).plane[1 as ::core::ffi::c_int as usize],
                i_stride as intptr_t,
                cw,
                ch,
            );
        }
        (*h).mc
            .plane_copy_deinterleave
            .expect("non-null function pointer")(
            dstu.offset(i_width as isize),
            i_stride as intptr_t,
            dstv.offset(i_width as isize),
            i_stride as intptr_t,
            (*fenc).plane[1 as ::core::ffi::c_int as usize],
            i_stride as intptr_t,
            cw,
            ch,
        );
    }
    #[inline(never)]
    #[c2rust::src_loc = "142:1"]
    pub unsafe extern "C" fn weight_cost_init_chroma444(
        mut h: *mut x264_t,
        mut fenc: *mut x264_frame_t,
        mut ref_0: *mut x264_frame_t,
        mut dst: *mut pixel,
        mut p: ::core::ffi::c_int,
    ) -> *mut pixel {
        let mut ref0_distance: ::core::ffi::c_int =
            (*fenc).i_frame - (*ref_0).i_frame - 1 as ::core::ffi::c_int;
        let mut i_stride: ::core::ffi::c_int = (*fenc).i_stride[p as usize];
        let mut i_lines: ::core::ffi::c_int = (*fenc).i_lines[p as usize];
        let mut i_width: ::core::ffi::c_int = (*fenc).i_width[p as usize];
        if (*(*fenc).lowres_mvs[0 as ::core::ffi::c_int as usize][ref0_distance as usize]
            .offset(0 as ::core::ffi::c_int as isize))[0 as ::core::ffi::c_int as usize]
            as ::core::ffi::c_int
            != 0x7fff as ::core::ffi::c_int
        {
            x264_10_frame_expand_border_chroma(h, ref_0, p);
            let mut y: ::core::ffi::c_int = 0 as ::core::ffi::c_int;
            let mut mb_xy: ::core::ffi::c_int = 0 as ::core::ffi::c_int;
            let mut pel_offset_y: ::core::ffi::c_int = 0 as ::core::ffi::c_int;
            while y < i_lines {
                let mut x: ::core::ffi::c_int = 0 as ::core::ffi::c_int;
                let mut pel_offset_x: ::core::ffi::c_int = 0 as ::core::ffi::c_int;
                while x < i_width {
                    let mut pix: *mut pixel = dst
                        .offset(pel_offset_y as isize)
                        .offset(pel_offset_x as isize);
                    let mut src: *mut pixel = (*ref_0).plane[p as usize]
                        .offset(pel_offset_y as isize)
                        .offset(pel_offset_x as isize);
                    let mut mvx: ::core::ffi::c_int = (*(*fenc).lowres_mvs
                        [0 as ::core::ffi::c_int as usize][ref0_distance as usize]
                        .offset(mb_xy as isize))[0 as ::core::ffi::c_int as usize]
                        as ::core::ffi::c_int
                        / 2 as ::core::ffi::c_int;
                    let mut mvy: ::core::ffi::c_int = (*(*fenc).lowres_mvs
                        [0 as ::core::ffi::c_int as usize][ref0_distance as usize]
                        .offset(mb_xy as isize))[1 as ::core::ffi::c_int as usize]
                        as ::core::ffi::c_int
                        / 2 as ::core::ffi::c_int;
                    (*h).mc
                        .copy_16x16_unaligned
                        .expect("non-null function pointer")(
                        pix,
                        i_stride as intptr_t,
                        src.offset(mvx as isize).offset((mvy * i_stride) as isize),
                        i_stride as intptr_t,
                        16 as ::core::ffi::c_int,
                    );
                    x += 16 as ::core::ffi::c_int;
                    mb_xy += 1;
                    pel_offset_x += 16 as ::core::ffi::c_int;
                }
                y += 16 as ::core::ffi::c_int;
                pel_offset_y = y * i_stride;
            }
            return dst;
        }
        return (*ref_0).plane[p as usize];
    }
    #[c2rust::src_loc = "170:1"]
    pub unsafe extern "C" fn weight_slice_header_cost(
        mut h: *mut x264_t,
        mut w: *mut x264_weight_t,
        mut b_chroma: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int {
        let mut lambda: ::core::ffi::c_int =
            x264_lambda_tab[X264_LOOKAHEAD_QP as usize] as ::core::ffi::c_int;
        if b_chroma != 0 {
            lambda *= 4 as ::core::ffi::c_int;
        }
        let mut numslices: ::core::ffi::c_int = 0;
        if (*h).param.i_slice_count != 0 {
            numslices = (*h).param.i_slice_count;
        } else if (*h).param.i_slice_max_mbs != 0 {
            numslices = ((*h).mb.i_mb_width * (*h).mb.i_mb_height + (*h).param.i_slice_max_mbs
                - 1 as ::core::ffi::c_int)
                / (*h).param.i_slice_max_mbs;
        } else {
            numslices = 1 as ::core::ffi::c_int;
        }
        let mut denom_cost: ::core::ffi::c_int = bs_size_ue(
            (*w.offset(0 as ::core::ffi::c_int as isize)).i_denom as ::core::ffi::c_uint,
        ) * (2 as ::core::ffi::c_int - b_chroma);
        return lambda
            * numslices
            * (10 as ::core::ffi::c_int
                + denom_cost
                + 2 as ::core::ffi::c_int
                    * (bs_size_se(
                        (*w.offset(0 as ::core::ffi::c_int as isize)).i_scale as ::core::ffi::c_int,
                    ) + bs_size_se(
                        (*w.offset(0 as ::core::ffi::c_int as isize)).i_offset
                            as ::core::ffi::c_int,
                    )));
    }
    #[inline(never)]
    #[c2rust::src_loc = "191:1"]
    pub unsafe extern "C" fn weight_cost_luma(
        mut h: *mut x264_t,
        mut fenc: *mut x264_frame_t,
        mut src: *mut pixel,
        mut w: *mut x264_weight_t,
    ) -> ::core::ffi::c_uint {
        let mut cost: ::core::ffi::c_uint = 0 as ::core::ffi::c_uint;
        let mut i_stride: ::core::ffi::c_int = (*fenc).i_stride_lowres;
        let mut i_lines: ::core::ffi::c_int = (*fenc).i_lines_lowres;
        let mut i_width: ::core::ffi::c_int = (*fenc).i_width_lowres;
        let mut fenc_plane: *mut pixel = (*fenc).lowres[0 as ::core::ffi::c_int as usize];
        let mut buf: [pixel; 64] = [0; 64];
        let mut pixoff: ::core::ffi::c_int = 0 as ::core::ffi::c_int;
        let mut i_mb: ::core::ffi::c_int = 0 as ::core::ffi::c_int;
        if !w.is_null() {
            let mut y: ::core::ffi::c_int = 0 as ::core::ffi::c_int;
            while y < i_lines {
                let mut x: ::core::ffi::c_int = 0 as ::core::ffi::c_int;
                while x < i_width {
                    (*(*w)
                        .weightfn
                        .offset((8 as ::core::ffi::c_int >> 2 as ::core::ffi::c_int) as isize))
                    .expect("non-null function pointer")(
                        buf.as_mut_ptr(),
                        8 as intptr_t,
                        &mut *src.offset(pixoff as isize),
                        i_stride as intptr_t,
                        w,
                        8 as ::core::ffi::c_int,
                    );
                    let mut cmp: ::core::ffi::c_int = (*h).pixf.mbcmp
                        [PIXEL_8x8 as ::core::ffi::c_int as usize]
                        .expect("non-null function pointer")(
                        buf.as_mut_ptr(),
                        8 as intptr_t,
                        &mut *fenc_plane.offset(pixoff as isize),
                        i_stride as intptr_t,
                    );
                    cost = cost.wrapping_add(
                        (if cmp < *(*fenc).i_intra_cost.offset(i_mb as isize) as ::core::ffi::c_int
                        {
                            cmp
                        } else {
                            *(*fenc).i_intra_cost.offset(i_mb as isize) as ::core::ffi::c_int
                        }) as ::core::ffi::c_uint,
                    );
                    x += 8 as ::core::ffi::c_int;
                    i_mb += 1;
                    pixoff += 8 as ::core::ffi::c_int;
                }
                y += 8 as ::core::ffi::c_int;
                pixoff = y * i_stride;
            }
            cost = cost.wrapping_add(
                weight_slice_header_cost(h, w, 0 as ::core::ffi::c_int) as ::core::ffi::c_uint
            );
        } else {
            let mut y_0: ::core::ffi::c_int = 0 as ::core::ffi::c_int;
            while y_0 < i_lines {
                let mut x_0: ::core::ffi::c_int = 0 as ::core::ffi::c_int;
                while x_0 < i_width {
                    let mut cmp_0: ::core::ffi::c_int = (*h).pixf.mbcmp
                        [PIXEL_8x8 as ::core::ffi::c_int as usize]
                        .expect("non-null function pointer")(
                        &mut *src.offset(pixoff as isize),
                        i_stride as intptr_t,
                        &mut *fenc_plane.offset(pixoff as isize),
                        i_stride as intptr_t,
                    );
                    cost = cost.wrapping_add(
                        (if cmp_0
                            < *(*fenc).i_intra_cost.offset(i_mb as isize) as ::core::ffi::c_int
                        {
                            cmp_0
                        } else {
                            *(*fenc).i_intra_cost.offset(i_mb as isize) as ::core::ffi::c_int
                        }) as ::core::ffi::c_uint,
                    );
                    x_0 += 8 as ::core::ffi::c_int;
                    i_mb += 1;
                    pixoff += 8 as ::core::ffi::c_int;
                }
                y_0 += 8 as ::core::ffi::c_int;
                pixoff = y_0 * i_stride;
            }
        }
        return cost;
    }
    #[inline(never)]
    #[c2rust::src_loc = "224:1"]
    pub unsafe extern "C" fn weight_cost_chroma(
        mut h: *mut x264_t,
        mut fenc: *mut x264_frame_t,
        mut ref_0: *mut pixel,
        mut w: *mut x264_weight_t,
    ) -> ::core::ffi::c_uint {
        let mut cost: ::core::ffi::c_uint = 0 as ::core::ffi::c_uint;
        let mut i_stride: ::core::ffi::c_int = (*fenc).i_stride[1 as ::core::ffi::c_int as usize];
        let mut i_lines: ::core::ffi::c_int = (*fenc).i_lines[1 as ::core::ffi::c_int as usize];
        let mut i_width: ::core::ffi::c_int = (*fenc).i_width[1 as ::core::ffi::c_int as usize];
        let mut src: *mut pixel = ref_0.offset(i_width as isize);
        let mut buf: [pixel; 128] = [0; 128];
        let mut pixoff: ::core::ffi::c_int = 0 as ::core::ffi::c_int;
        let mut height: ::core::ffi::c_int = 16 as ::core::ffi::c_int >> (*h).mb.chroma_v_shift;
        if !w.is_null() {
            let mut y: ::core::ffi::c_int = 0 as ::core::ffi::c_int;
            while y < i_lines {
                let mut x: ::core::ffi::c_int = 0 as ::core::ffi::c_int;
                while x < i_width {
                    (*(*w)
                        .weightfn
                        .offset((8 as ::core::ffi::c_int >> 2 as ::core::ffi::c_int) as isize))
                    .expect("non-null function pointer")(
                        buf.as_mut_ptr(),
                        8 as intptr_t,
                        &mut *ref_0.offset(pixoff as isize),
                        i_stride as intptr_t,
                        w,
                        height,
                    );
                    cost = cost.wrapping_add((*h).pixf.asd8.expect("non-null function pointer")(
                        buf.as_mut_ptr(),
                        8 as intptr_t,
                        &mut *src.offset(pixoff as isize),
                        i_stride as intptr_t,
                        height,
                    ) as ::core::ffi::c_uint);
                    x += 8 as ::core::ffi::c_int;
                    pixoff += 8 as ::core::ffi::c_int;
                }
                y += height;
                pixoff = y * i_stride;
            }
            cost = cost.wrapping_add(
                weight_slice_header_cost(h, w, 1 as ::core::ffi::c_int) as ::core::ffi::c_uint
            );
        } else {
            let mut y_0: ::core::ffi::c_int = 0 as ::core::ffi::c_int;
            while y_0 < i_lines {
                let mut x_0: ::core::ffi::c_int = 0 as ::core::ffi::c_int;
                while x_0 < i_width {
                    cost = cost.wrapping_add((*h).pixf.asd8.expect("non-null function pointer")(
                        &mut *ref_0.offset(pixoff as isize),
                        i_stride as intptr_t,
                        &mut *src.offset(pixoff as isize),
                        i_stride as intptr_t,
                        height,
                    ) as ::core::ffi::c_uint);
                    x_0 += 8 as ::core::ffi::c_int;
                    pixoff += 8 as ::core::ffi::c_int;
                }
                y_0 += height;
                pixoff = y_0 * i_stride;
            }
        }
        return cost;
    }
    #[inline(never)]
    #[c2rust::src_loc = "257:1"]
    pub unsafe extern "C" fn weight_cost_chroma444(
        mut h: *mut x264_t,
        mut fenc: *mut x264_frame_t,
        mut ref_0: *mut pixel,
        mut w: *mut x264_weight_t,
        mut p: ::core::ffi::c_int,
    ) -> ::core::ffi::c_uint {
        let mut cost: ::core::ffi::c_uint = 0 as ::core::ffi::c_uint;
        let mut i_stride: ::core::ffi::c_int = (*fenc).i_stride[p as usize];
        let mut i_lines: ::core::ffi::c_int = (*fenc).i_lines[p as usize];
        let mut i_width: ::core::ffi::c_int = (*fenc).i_width[p as usize];
        let mut src: *mut pixel = (*fenc).plane[p as usize];
        let mut buf: [pixel; 256] = [0; 256];
        let mut pixoff: ::core::ffi::c_int = 0 as ::core::ffi::c_int;
        if !w.is_null() {
            let mut y: ::core::ffi::c_int = 0 as ::core::ffi::c_int;
            while y < i_lines {
                let mut x: ::core::ffi::c_int = 0 as ::core::ffi::c_int;
                while x < i_width {
                    (*(*w)
                        .weightfn
                        .offset((16 as ::core::ffi::c_int >> 2 as ::core::ffi::c_int) as isize))
                    .expect("non-null function pointer")(
                        buf.as_mut_ptr(),
                        16 as intptr_t,
                        &mut *ref_0.offset(pixoff as isize),
                        i_stride as intptr_t,
                        w,
                        16 as ::core::ffi::c_int,
                    );
                    cost = cost.wrapping_add((*h).pixf.mbcmp
                        [PIXEL_16x16 as ::core::ffi::c_int as usize]
                        .expect("non-null function pointer")(
                        buf.as_mut_ptr(),
                        16 as intptr_t,
                        &mut *src.offset(pixoff as isize),
                        i_stride as intptr_t,
                    ) as ::core::ffi::c_uint);
                    x += 16 as ::core::ffi::c_int;
                    pixoff += 16 as ::core::ffi::c_int;
                }
                y += 16 as ::core::ffi::c_int;
                pixoff = y * i_stride;
            }
            cost = cost.wrapping_add(
                weight_slice_header_cost(h, w, 1 as ::core::ffi::c_int) as ::core::ffi::c_uint
            );
        } else {
            let mut y_0: ::core::ffi::c_int = 0 as ::core::ffi::c_int;
            while y_0 < i_lines {
                let mut x_0: ::core::ffi::c_int = 0 as ::core::ffi::c_int;
                while x_0 < i_width {
                    cost = cost.wrapping_add((*h).pixf.mbcmp
                        [PIXEL_16x16 as ::core::ffi::c_int as usize]
                        .expect("non-null function pointer")(
                        &mut *ref_0.offset(pixoff as isize),
                        i_stride as intptr_t,
                        &mut *src.offset(pixoff as isize),
                        i_stride as intptr_t,
                    ) as ::core::ffi::c_uint);
                    x_0 += 16 as ::core::ffi::c_int;
                    pixoff += 16 as ::core::ffi::c_int;
                }
                y_0 += 16 as ::core::ffi::c_int;
                pixoff = y_0 * i_stride;
            }
        }
        return cost;
    }
    #[no_mangle]
    #[c2rust::src_loc = "284:1"]
    pub unsafe extern "C" fn x264_10_weights_analyse(
        mut h: *mut x264_t,
        mut fenc: *mut x264_frame_t,
        mut ref_0: *mut x264_frame_t,
        mut b_lookahead: ::core::ffi::c_int,
    ) {
        let mut i_delta_index: ::core::ffi::c_int =
            (*fenc).i_frame - (*ref_0).i_frame - 1 as ::core::ffi::c_int;
        let epsilon: ::core::ffi::c_float = 1.0f32 / 128.0f32;
        let mut weights: *mut x264_weight_t = (*(*fenc)
            .weight
            .as_mut_ptr()
            .offset(0 as ::core::ffi::c_int as isize))
        .as_mut_ptr();
        (*weights.offset(0 as ::core::ffi::c_int as isize)).i_scale =
            1 as ::core::ffi::c_int as int32_t;
        (*weights.offset(0 as ::core::ffi::c_int as isize)).i_denom =
            0 as ::core::ffi::c_int as int32_t;
        (*weights.offset(0 as ::core::ffi::c_int as isize)).i_offset =
            0 as ::core::ffi::c_int as int32_t;
        let ref mut fresh8 = (*weights.offset(0 as ::core::ffi::c_int as isize)).weightfn;
        *fresh8 = 0 as *mut weight_fn_t;
        (*weights.offset(1 as ::core::ffi::c_int as isize)).i_scale =
            1 as ::core::ffi::c_int as int32_t;
        (*weights.offset(1 as ::core::ffi::c_int as isize)).i_denom =
            0 as ::core::ffi::c_int as int32_t;
        (*weights.offset(1 as ::core::ffi::c_int as isize)).i_offset =
            0 as ::core::ffi::c_int as int32_t;
        let ref mut fresh9 = (*weights.offset(1 as ::core::ffi::c_int as isize)).weightfn;
        *fresh9 = 0 as *mut weight_fn_t;
        (*weights.offset(2 as ::core::ffi::c_int as isize)).i_scale =
            1 as ::core::ffi::c_int as int32_t;
        (*weights.offset(2 as ::core::ffi::c_int as isize)).i_denom =
            0 as ::core::ffi::c_int as int32_t;
        (*weights.offset(2 as ::core::ffi::c_int as isize)).i_offset =
            0 as ::core::ffi::c_int as int32_t;
        let ref mut fresh10 = (*weights.offset(2 as ::core::ffi::c_int as isize)).weightfn;
        *fresh10 = 0 as *mut weight_fn_t;
        let mut chroma_initted: ::core::ffi::c_int = 0 as ::core::ffi::c_int;
        let mut guess_scale: [::core::ffi::c_float; 3] = [0.; 3];
        let mut fenc_mean: [::core::ffi::c_float; 3] = [0.; 3];
        let mut ref_mean: [::core::ffi::c_float; 3] = [0.; 3];
        let mut plane: ::core::ffi::c_int = 0 as ::core::ffi::c_int;
        while plane <= 2 as ::core::ffi::c_int * (b_lookahead == 0) as ::core::ffi::c_int {
            if plane == 0 || (*(*h).sps.as_mut_ptr()).i_chroma_format_idc != 0 {
                let mut zero_bias: ::core::ffi::c_int =
                    ((*ref_0).i_pixel_ssd[plane as usize] == 0) as ::core::ffi::c_int;
                let mut fenc_var: ::core::ffi::c_float = (*fenc).i_pixel_ssd[plane as usize]
                    .wrapping_add(zero_bias as uint64_t)
                    as ::core::ffi::c_float;
                let mut ref_var: ::core::ffi::c_float = (*ref_0).i_pixel_ssd[plane as usize]
                    .wrapping_add(zero_bias as uint64_t)
                    as ::core::ffi::c_float;
                guess_scale[plane as usize] = sqrtf(fenc_var / ref_var);
                fenc_mean[plane as usize] = (*fenc).i_pixel_sum[plane as usize]
                    .wrapping_add(zero_bias as uint32_t)
                    as ::core::ffi::c_float
                    / ((*fenc).i_lines[(plane != 0) as ::core::ffi::c_int as usize]
                        * (*fenc).i_width[(plane != 0) as ::core::ffi::c_int as usize])
                        as ::core::ffi::c_float
                    / ((1 as ::core::ffi::c_int) << BIT_DEPTH - 8 as ::core::ffi::c_int)
                        as ::core::ffi::c_float;
                ref_mean[plane as usize] = (*ref_0).i_pixel_sum[plane as usize]
                    .wrapping_add(zero_bias as uint32_t)
                    as ::core::ffi::c_float
                    / ((*fenc).i_lines[(plane != 0) as ::core::ffi::c_int as usize]
                        * (*fenc).i_width[(plane != 0) as ::core::ffi::c_int as usize])
                        as ::core::ffi::c_float
                    / ((1 as ::core::ffi::c_int) << BIT_DEPTH - 8 as ::core::ffi::c_int)
                        as ::core::ffi::c_float;
            } else {
                guess_scale[plane as usize] = 1 as ::core::ffi::c_int as ::core::ffi::c_float;
                fenc_mean[plane as usize] = 0 as ::core::ffi::c_int as ::core::ffi::c_float;
                ref_mean[plane as usize] = 0 as ::core::ffi::c_int as ::core::ffi::c_float;
            }
            plane += 1;
        }
        let mut chroma_denom: ::core::ffi::c_int = 7 as ::core::ffi::c_int;
        if b_lookahead == 0 {
            while chroma_denom > 0 as ::core::ffi::c_int {
                let mut thresh: ::core::ffi::c_float =
                    127.0f32 / ((1 as ::core::ffi::c_int) << chroma_denom) as ::core::ffi::c_float;
                if guess_scale[1 as ::core::ffi::c_int as usize] < thresh
                    && guess_scale[2 as ::core::ffi::c_int as usize] < thresh
                {
                    break;
                }
                chroma_denom -= 1;
            }
        }
        let mut plane_0: ::core::ffi::c_int = 0 as ::core::ffi::c_int;
        while plane_0
            < (if (*(*h).sps.as_mut_ptr()).i_chroma_format_idc != 0 {
                3 as ::core::ffi::c_int
            } else {
                1 as ::core::ffi::c_int
            })
            && !(plane_0 != 0
                && ((*weights.offset(0 as ::core::ffi::c_int as isize))
                    .weightfn
                    .is_null()
                    || b_lookahead != 0))
        {
            let mut minoff: ::core::ffi::c_int = 0;
            let mut minscale: ::core::ffi::c_int = 0;
            let mut mindenom: ::core::ffi::c_int = 0;
            let mut minscore: ::core::ffi::c_uint = 0;
            let mut origscore: ::core::ffi::c_uint = 0;
            let mut found: ::core::ffi::c_int = 0;
            if fabsf(ref_mean[plane_0 as usize] - fenc_mean[plane_0 as usize]) < 0.5f32
                && fabsf(1.0f32 - guess_scale[plane_0 as usize]) < epsilon
            {
                (*weights.offset(plane_0 as isize)).i_scale = 1 as ::core::ffi::c_int as int32_t;
                (*weights.offset(plane_0 as isize)).i_denom = 0 as ::core::ffi::c_int as int32_t;
                (*weights.offset(plane_0 as isize)).i_offset = 0 as ::core::ffi::c_int as int32_t;
                let ref mut fresh11 = (*weights.offset(plane_0 as isize)).weightfn;
                *fresh11 = 0 as *mut weight_fn_t;
            } else {
                if plane_0 != 0 {
                    (*weights.offset(plane_0 as isize)).i_denom = chroma_denom as int32_t;
                    (*weights.offset(plane_0 as isize)).i_scale = x264_clip3(
                        round(
                            (guess_scale[plane_0 as usize]
                                * ((1 as ::core::ffi::c_int) << chroma_denom)
                                    as ::core::ffi::c_float)
                                as ::core::ffi::c_double,
                        ) as ::core::ffi::c_int,
                        0 as ::core::ffi::c_int,
                        255 as ::core::ffi::c_int,
                    ) as int32_t;
                    if (*weights.offset(plane_0 as isize)).i_scale > 127 as int32_t {
                        let ref mut fresh12 =
                            (*weights.offset(2 as ::core::ffi::c_int as isize)).weightfn;
                        *fresh12 = 0 as *mut weight_fn_t;
                        let ref mut fresh13 =
                            (*weights.offset(1 as ::core::ffi::c_int as isize)).weightfn;
                        *fresh13 = *fresh12;
                        break;
                    }
                } else {
                    weight_get_h264(
                        round(
                            (guess_scale[plane_0 as usize]
                                * 128 as ::core::ffi::c_int as ::core::ffi::c_float)
                                as ::core::ffi::c_double,
                        ) as ::core::ffi::c_int,
                        0 as ::core::ffi::c_int,
                        &mut *weights.offset(plane_0 as isize),
                    );
                }
                found = 0 as ::core::ffi::c_int;
                mindenom = (*weights.offset(plane_0 as isize)).i_denom as ::core::ffi::c_int;
                minscale = (*weights.offset(plane_0 as isize)).i_scale as ::core::ffi::c_int;
                minoff = 0 as ::core::ffi::c_int;
                let mut mcbuf: *mut pixel = 0 as *mut pixel;
                if plane_0 == 0 {
                    if (*fenc).b_intra_calculated == 0 {
                        let mut a: x264_mb_analysis_t = x264_mb_analysis_t {
                            i_lambda: 0,
                            i_lambda2: 0,
                            i_qp: 0,
                            p_cost_mv: 0 as *mut uint16_t,
                            p_cost_ref: [0 as *mut uint16_t; 2],
                            i_mbrd: 0,
                            b_fast_intra: 0,
                            b_force_intra: 0,
                            b_avoid_topright: 0,
                            b_try_skip: 0,
                            i_satd_i16x16: 0,
                            i_satd_i16x16_dir: [0; 7],
                            i_predict16x16: 0,
                            i_satd_i8x8: 0,
                            i_cbp_i8x8_luma: 0,
                            i_satd_i8x8_dir: [[0; 16]; 4],
                            i_predict8x8: [0; 4],
                            i_satd_i4x4: 0,
                            i_predict4x4: [0; 16],
                            i_satd_pcm: 0,
                            i_satd_chroma: 0,
                            i_satd_chroma_dir: [0; 7],
                            i_predict8x8chroma: 0,
                            l0: x264_mb_analysis_list_t {
                                me16x16: x264_me_t {
                                    i_pixel: 0,
                                    p_cost_mv: 0 as *mut uint16_t,
                                    i_ref_cost: 0,
                                    i_ref: 0,
                                    weight: 0 as *const x264_weight_t,
                                    p_fref: [0 as *mut pixel; 12],
                                    p_fref_w: 0 as *mut pixel,
                                    p_fenc: [0 as *mut pixel; 3],
                                    integral: 0 as *mut uint16_t,
                                    i_stride: [0; 3],
                                    mvp: [0; 2],
                                    cost_mv: 0,
                                    cost: 0,
                                    mv: [0; 2],
                                },
                                bi16x16: x264_me_t {
                                    i_pixel: 0,
                                    p_cost_mv: 0 as *mut uint16_t,
                                    i_ref_cost: 0,
                                    i_ref: 0,
                                    weight: 0 as *const x264_weight_t,
                                    p_fref: [0 as *mut pixel; 12],
                                    p_fref_w: 0 as *mut pixel,
                                    p_fenc: [0 as *mut pixel; 3],
                                    integral: 0 as *mut uint16_t,
                                    i_stride: [0; 3],
                                    mvp: [0; 2],
                                    cost_mv: 0,
                                    cost: 0,
                                    mv: [0; 2],
                                },
                                me8x8: [x264_me_t {
                                    i_pixel: 0,
                                    p_cost_mv: 0 as *mut uint16_t,
                                    i_ref_cost: 0,
                                    i_ref: 0,
                                    weight: 0 as *const x264_weight_t,
                                    p_fref: [0 as *mut pixel; 12],
                                    p_fref_w: 0 as *mut pixel,
                                    p_fenc: [0 as *mut pixel; 3],
                                    integral: 0 as *mut uint16_t,
                                    i_stride: [0; 3],
                                    mvp: [0; 2],
                                    cost_mv: 0,
                                    cost: 0,
                                    mv: [0; 2],
                                }; 4],
                                me4x4: [[x264_me_t {
                                    i_pixel: 0,
                                    p_cost_mv: 0 as *mut uint16_t,
                                    i_ref_cost: 0,
                                    i_ref: 0,
                                    weight: 0 as *const x264_weight_t,
                                    p_fref: [0 as *mut pixel; 12],
                                    p_fref_w: 0 as *mut pixel,
                                    p_fenc: [0 as *mut pixel; 3],
                                    integral: 0 as *mut uint16_t,
                                    i_stride: [0; 3],
                                    mvp: [0; 2],
                                    cost_mv: 0,
                                    cost: 0,
                                    mv: [0; 2],
                                }; 4]; 4],
                                me8x4: [[x264_me_t {
                                    i_pixel: 0,
                                    p_cost_mv: 0 as *mut uint16_t,
                                    i_ref_cost: 0,
                                    i_ref: 0,
                                    weight: 0 as *const x264_weight_t,
                                    p_fref: [0 as *mut pixel; 12],
                                    p_fref_w: 0 as *mut pixel,
                                    p_fenc: [0 as *mut pixel; 3],
                                    integral: 0 as *mut uint16_t,
                                    i_stride: [0; 3],
                                    mvp: [0; 2],
                                    cost_mv: 0,
                                    cost: 0,
                                    mv: [0; 2],
                                }; 2]; 4],
                                me4x8: [[x264_me_t {
                                    i_pixel: 0,
                                    p_cost_mv: 0 as *mut uint16_t,
                                    i_ref_cost: 0,
                                    i_ref: 0,
                                    weight: 0 as *const x264_weight_t,
                                    p_fref: [0 as *mut pixel; 12],
                                    p_fref_w: 0 as *mut pixel,
                                    p_fenc: [0 as *mut pixel; 3],
                                    integral: 0 as *mut uint16_t,
                                    i_stride: [0; 3],
                                    mvp: [0; 2],
                                    cost_mv: 0,
                                    cost: 0,
                                    mv: [0; 2],
                                }; 2]; 4],
                                me16x8: [x264_me_t {
                                    i_pixel: 0,
                                    p_cost_mv: 0 as *mut uint16_t,
                                    i_ref_cost: 0,
                                    i_ref: 0,
                                    weight: 0 as *const x264_weight_t,
                                    p_fref: [0 as *mut pixel; 12],
                                    p_fref_w: 0 as *mut pixel,
                                    p_fenc: [0 as *mut pixel; 3],
                                    integral: 0 as *mut uint16_t,
                                    i_stride: [0; 3],
                                    mvp: [0; 2],
                                    cost_mv: 0,
                                    cost: 0,
                                    mv: [0; 2],
                                }; 2],
                                me8x16: [x264_me_t {
                                    i_pixel: 0,
                                    p_cost_mv: 0 as *mut uint16_t,
                                    i_ref_cost: 0,
                                    i_ref: 0,
                                    weight: 0 as *const x264_weight_t,
                                    p_fref: [0 as *mut pixel; 12],
                                    p_fref_w: 0 as *mut pixel,
                                    p_fenc: [0 as *mut pixel; 3],
                                    integral: 0 as *mut uint16_t,
                                    i_stride: [0; 3],
                                    mvp: [0; 2],
                                    cost_mv: 0,
                                    cost: 0,
                                    mv: [0; 2],
                                }; 2],
                                i_rd16x16: 0,
                                i_cost8x8: 0,
                                i_cost4x4: [0; 4],
                                i_cost8x4: [0; 4],
                                i_cost4x8: [0; 4],
                                i_cost16x8: 0,
                                i_cost8x16: 0,
                                mvc: [[[0; 2]; 6]; 32],
                            },
                            l1: x264_mb_analysis_list_t {
                                me16x16: x264_me_t {
                                    i_pixel: 0,
                                    p_cost_mv: 0 as *mut uint16_t,
                                    i_ref_cost: 0,
                                    i_ref: 0,
                                    weight: 0 as *const x264_weight_t,
                                    p_fref: [0 as *mut pixel; 12],
                                    p_fref_w: 0 as *mut pixel,
                                    p_fenc: [0 as *mut pixel; 3],
                                    integral: 0 as *mut uint16_t,
                                    i_stride: [0; 3],
                                    mvp: [0; 2],
                                    cost_mv: 0,
                                    cost: 0,
                                    mv: [0; 2],
                                },
                                bi16x16: x264_me_t {
                                    i_pixel: 0,
                                    p_cost_mv: 0 as *mut uint16_t,
                                    i_ref_cost: 0,
                                    i_ref: 0,
                                    weight: 0 as *const x264_weight_t,
                                    p_fref: [0 as *mut pixel; 12],
                                    p_fref_w: 0 as *mut pixel,
                                    p_fenc: [0 as *mut pixel; 3],
                                    integral: 0 as *mut uint16_t,
                                    i_stride: [0; 3],
                                    mvp: [0; 2],
                                    cost_mv: 0,
                                    cost: 0,
                                    mv: [0; 2],
                                },
                                me8x8: [x264_me_t {
                                    i_pixel: 0,
                                    p_cost_mv: 0 as *mut uint16_t,
                                    i_ref_cost: 0,
                                    i_ref: 0,
                                    weight: 0 as *const x264_weight_t,
                                    p_fref: [0 as *mut pixel; 12],
                                    p_fref_w: 0 as *mut pixel,
                                    p_fenc: [0 as *mut pixel; 3],
                                    integral: 0 as *mut uint16_t,
                                    i_stride: [0; 3],
                                    mvp: [0; 2],
                                    cost_mv: 0,
                                    cost: 0,
                                    mv: [0; 2],
                                }; 4],
                                me4x4: [[x264_me_t {
                                    i_pixel: 0,
                                    p_cost_mv: 0 as *mut uint16_t,
                                    i_ref_cost: 0,
                                    i_ref: 0,
                                    weight: 0 as *const x264_weight_t,
                                    p_fref: [0 as *mut pixel; 12],
                                    p_fref_w: 0 as *mut pixel,
                                    p_fenc: [0 as *mut pixel; 3],
                                    integral: 0 as *mut uint16_t,
                                    i_stride: [0; 3],
                                    mvp: [0; 2],
                                    cost_mv: 0,
                                    cost: 0,
                                    mv: [0; 2],
                                }; 4]; 4],
                                me8x4: [[x264_me_t {
                                    i_pixel: 0,
                                    p_cost_mv: 0 as *mut uint16_t,
                                    i_ref_cost: 0,
                                    i_ref: 0,
                                    weight: 0 as *const x264_weight_t,
                                    p_fref: [0 as *mut pixel; 12],
                                    p_fref_w: 0 as *mut pixel,
                                    p_fenc: [0 as *mut pixel; 3],
                                    integral: 0 as *mut uint16_t,
                                    i_stride: [0; 3],
                                    mvp: [0; 2],
                                    cost_mv: 0,
                                    cost: 0,
                                    mv: [0; 2],
                                }; 2]; 4],
                                me4x8: [[x264_me_t {
                                    i_pixel: 0,
                                    p_cost_mv: 0 as *mut uint16_t,
                                    i_ref_cost: 0,
                                    i_ref: 0,
                                    weight: 0 as *const x264_weight_t,
                                    p_fref: [0 as *mut pixel; 12],
                                    p_fref_w: 0 as *mut pixel,
                                    p_fenc: [0 as *mut pixel; 3],
                                    integral: 0 as *mut uint16_t,
                                    i_stride: [0; 3],
                                    mvp: [0; 2],
                                    cost_mv: 0,
                                    cost: 0,
                                    mv: [0; 2],
                                }; 2]; 4],
                                me16x8: [x264_me_t {
                                    i_pixel: 0,
                                    p_cost_mv: 0 as *mut uint16_t,
                                    i_ref_cost: 0,
                                    i_ref: 0,
                                    weight: 0 as *const x264_weight_t,
                                    p_fref: [0 as *mut pixel; 12],
                                    p_fref_w: 0 as *mut pixel,
                                    p_fenc: [0 as *mut pixel; 3],
                                    integral: 0 as *mut uint16_t,
                                    i_stride: [0; 3],
                                    mvp: [0; 2],
                                    cost_mv: 0,
                                    cost: 0,
                                    mv: [0; 2],
                                }; 2],
                                me8x16: [x264_me_t {
                                    i_pixel: 0,
                                    p_cost_mv: 0 as *mut uint16_t,
                                    i_ref_cost: 0,
                                    i_ref: 0,
                                    weight: 0 as *const x264_weight_t,
                                    p_fref: [0 as *mut pixel; 12],
                                    p_fref_w: 0 as *mut pixel,
                                    p_fenc: [0 as *mut pixel; 3],
                                    integral: 0 as *mut uint16_t,
                                    i_stride: [0; 3],
                                    mvp: [0; 2],
                                    cost_mv: 0,
                                    cost: 0,
                                    mv: [0; 2],
                                }; 2],
                                i_rd16x16: 0,
                                i_cost8x8: 0,
                                i_cost4x4: [0; 4],
                                i_cost8x4: [0; 4],
                                i_cost4x8: [0; 4],
                                i_cost16x8: 0,
                                i_cost8x16: 0,
                                mvc: [[[0; 2]; 6]; 32],
                            },
                            i_cost16x16bi: 0,
                            i_cost16x16direct: 0,
                            i_cost8x8bi: 0,
                            i_cost8x8direct: [0; 4],
                            i_satd8x8: [[0; 4]; 3],
                            i_cost_est16x8: [0; 2],
                            i_cost_est8x16: [0; 2],
                            i_cost16x8bi: 0,
                            i_cost8x16bi: 0,
                            i_rd16x16bi: 0,
                            i_rd16x16direct: 0,
                            i_rd16x8bi: 0,
                            i_rd8x16bi: 0,
                            i_rd8x8bi: 0,
                            i_mb_partition16x8: [0; 2],
                            i_mb_partition8x16: [0; 2],
                            i_mb_type16x8: 0,
                            i_mb_type8x16: 0,
                            b_direct_available: 0,
                            b_early_terminate: 0,
                        };
                        lowres_context_init(h, &mut a);
                        slicetype_frame_cost(
                            h,
                            &mut a,
                            &mut fenc,
                            0 as ::core::ffi::c_int,
                            0 as ::core::ffi::c_int,
                            0 as ::core::ffi::c_int,
                        );
                    }
                    mcbuf = weight_cost_init_luma(
                        h,
                        fenc,
                        ref_0,
                        (*h).mb.p_weight_buf[0 as ::core::ffi::c_int as usize],
                    );
                    minscore = weight_cost_luma(h, fenc, mcbuf, 0 as *mut x264_weight_t);
                    origscore = minscore;
                } else if (*(*h).sps.as_mut_ptr()).i_chroma_format_idc
                    == CHROMA_444 as ::core::ffi::c_int
                {
                    mcbuf = weight_cost_init_chroma444(
                        h,
                        fenc,
                        ref_0,
                        (*h).mb.p_weight_buf[0 as ::core::ffi::c_int as usize],
                        plane_0,
                    );
                    minscore =
                        weight_cost_chroma444(h, fenc, mcbuf, 0 as *mut x264_weight_t, plane_0);
                    origscore = minscore;
                } else {
                    let mut dstu: *mut pixel =
                        (*h).mb.p_weight_buf[0 as ::core::ffi::c_int as usize];
                    let mut dstv: *mut pixel =
                        (*h).mb.p_weight_buf[0 as ::core::ffi::c_int as usize].offset(
                            ((*fenc).i_stride[1 as ::core::ffi::c_int as usize]
                                * (*fenc).i_lines[1 as ::core::ffi::c_int as usize])
                                as isize,
                        );
                    let fresh14 = chroma_initted;
                    chroma_initted = chroma_initted + 1;
                    if fresh14 == 0 {
                        weight_cost_init_chroma(h, fenc, ref_0, dstu, dstv);
                    }
                    mcbuf = if plane_0 == 1 as ::core::ffi::c_int {
                        dstu
                    } else {
                        dstv
                    };
                    minscore = weight_cost_chroma(h, fenc, mcbuf, 0 as *mut x264_weight_t);
                    origscore = minscore;
                }
                if !(minscore == 0) {
                    pub static mut weight_check_distance: [[uint8_t; 2]; 12] = [
                        [
                            0 as ::core::ffi::c_int as uint8_t,
                            0 as ::core::ffi::c_int as uint8_t,
                        ],
                        [
                            0 as ::core::ffi::c_int as uint8_t,
                            0 as ::core::ffi::c_int as uint8_t,
                        ],
                        [
                            0 as ::core::ffi::c_int as uint8_t,
                            1 as ::core::ffi::c_int as uint8_t,
                        ],
                        [
                            0 as ::core::ffi::c_int as uint8_t,
                            1 as ::core::ffi::c_int as uint8_t,
                        ],
                        [
                            0 as ::core::ffi::c_int as uint8_t,
                            1 as ::core::ffi::c_int as uint8_t,
                        ],
                        [
                            0 as ::core::ffi::c_int as uint8_t,
                            1 as ::core::ffi::c_int as uint8_t,
                        ],
                        [
                            0 as ::core::ffi::c_int as uint8_t,
                            1 as ::core::ffi::c_int as uint8_t,
                        ],
                        [
                            1 as ::core::ffi::c_int as uint8_t,
                            1 as ::core::ffi::c_int as uint8_t,
                        ],
                        [
                            1 as ::core::ffi::c_int as uint8_t,
                            1 as ::core::ffi::c_int as uint8_t,
                        ],
                        [
                            2 as ::core::ffi::c_int as uint8_t,
                            1 as ::core::ffi::c_int as uint8_t,
                        ],
                        [
                            2 as ::core::ffi::c_int as uint8_t,
                            1 as ::core::ffi::c_int as uint8_t,
                        ],
                        [
                            4 as ::core::ffi::c_int as uint8_t,
                            2 as ::core::ffi::c_int as uint8_t,
                        ],
                    ];
                    let mut scale_dist: ::core::ffi::c_int = if b_lookahead != 0 {
                        0 as ::core::ffi::c_int
                    } else {
                        weight_check_distance[(*h).param.analyse.i_subpel_refine as usize]
                            [0 as ::core::ffi::c_int as usize]
                            as ::core::ffi::c_int
                    };
                    let mut offset_dist: ::core::ffi::c_int = if b_lookahead != 0 {
                        0 as ::core::ffi::c_int
                    } else {
                        weight_check_distance[(*h).param.analyse.i_subpel_refine as usize]
                            [1 as ::core::ffi::c_int as usize]
                            as ::core::ffi::c_int
                    };
                    let mut start_scale: ::core::ffi::c_int = x264_clip3(
                        minscale - scale_dist,
                        0 as ::core::ffi::c_int,
                        127 as ::core::ffi::c_int,
                    );
                    let mut end_scale: ::core::ffi::c_int = x264_clip3(
                        minscale + scale_dist,
                        0 as ::core::ffi::c_int,
                        127 as ::core::ffi::c_int,
                    );
                    let mut i_scale: ::core::ffi::c_int = start_scale;
                    while i_scale <= end_scale {
                        let mut cur_scale: ::core::ffi::c_int = i_scale;
                        let mut cur_offset: ::core::ffi::c_int = (fenc_mean[plane_0 as usize]
                            - ref_mean[plane_0 as usize] * cur_scale as ::core::ffi::c_float
                                / ((1 as ::core::ffi::c_int) << mindenom) as ::core::ffi::c_float
                            + 0.5f32 * b_lookahead as ::core::ffi::c_float)
                            as ::core::ffi::c_int;
                        if cur_offset < -(128 as ::core::ffi::c_int)
                            || cur_offset > 127 as ::core::ffi::c_int
                        {
                            cur_offset = x264_clip3(
                                cur_offset,
                                -(128 as ::core::ffi::c_int),
                                127 as ::core::ffi::c_int,
                            );
                            cur_scale = x264_clip3f(
                                (((1 as ::core::ffi::c_int) << mindenom) as ::core::ffi::c_float
                                    * (fenc_mean[plane_0 as usize]
                                        - cur_offset as ::core::ffi::c_float)
                                    / ref_mean[plane_0 as usize]
                                    + 0.5f32)
                                    as ::core::ffi::c_double,
                                0 as ::core::ffi::c_int as ::core::ffi::c_double,
                                127 as ::core::ffi::c_int as ::core::ffi::c_double,
                            ) as ::core::ffi::c_int;
                        }
                        let mut start_offset: ::core::ffi::c_int = x264_clip3(
                            cur_offset - offset_dist,
                            -(128 as ::core::ffi::c_int),
                            127 as ::core::ffi::c_int,
                        );
                        let mut end_offset: ::core::ffi::c_int = x264_clip3(
                            cur_offset + offset_dist,
                            -(128 as ::core::ffi::c_int),
                            127 as ::core::ffi::c_int,
                        );
                        let mut i_off: ::core::ffi::c_int = start_offset;
                        while i_off <= end_offset {
                            (*weights.offset(plane_0 as isize)).i_scale = cur_scale as int32_t;
                            (*weights.offset(plane_0 as isize)).i_denom = mindenom as int32_t;
                            (*weights.offset(plane_0 as isize)).i_offset = i_off as int32_t;
                            (*h).mc.weight_cache.expect("non-null function pointer")(
                                h,
                                &mut *weights.offset(plane_0 as isize),
                            );
                            let mut s: ::core::ffi::c_uint = 0;
                            if plane_0 != 0 {
                                if (*(*h).sps.as_mut_ptr()).i_chroma_format_idc
                                    == CHROMA_444 as ::core::ffi::c_int
                                {
                                    s = weight_cost_chroma444(
                                        h,
                                        fenc,
                                        mcbuf,
                                        &mut *weights.offset(plane_0 as isize),
                                        plane_0,
                                    );
                                } else {
                                    s = weight_cost_chroma(
                                        h,
                                        fenc,
                                        mcbuf,
                                        &mut *weights.offset(plane_0 as isize),
                                    );
                                }
                            } else {
                                s = weight_cost_luma(
                                    h,
                                    fenc,
                                    mcbuf,
                                    &mut *weights.offset(plane_0 as isize),
                                );
                            }
                            if s < minscore {
                                minscore = s;
                                minscale = cur_scale;
                                minoff = i_off;
                                found = 1 as ::core::ffi::c_int;
                            }
                            if minoff == start_offset && i_off != start_offset {
                                break;
                            }
                            i_off += 1;
                        }
                        i_scale += 1;
                    }
                    if plane_0 == 0 {
                        while mindenom > 0 as ::core::ffi::c_int
                            && minscale & 1 as ::core::ffi::c_int == 0
                        {
                            mindenom -= 1;
                            minscale >>= 1 as ::core::ffi::c_int;
                        }
                    }
                    if found == 0
                        || minscale == (1 as ::core::ffi::c_int) << mindenom
                            && minoff == 0 as ::core::ffi::c_int
                        || minscore as ::core::ffi::c_float / origscore as ::core::ffi::c_float
                            > 0.998f32
                    {
                        (*weights.offset(plane_0 as isize)).i_scale =
                            1 as ::core::ffi::c_int as int32_t;
                        (*weights.offset(plane_0 as isize)).i_denom =
                            0 as ::core::ffi::c_int as int32_t;
                        (*weights.offset(plane_0 as isize)).i_offset =
                            0 as ::core::ffi::c_int as int32_t;
                        let ref mut fresh16 = (*weights.offset(plane_0 as isize)).weightfn;
                        *fresh16 = 0 as *mut weight_fn_t;
                    } else {
                        (*weights.offset(plane_0 as isize)).i_scale = minscale as int32_t;
                        (*weights.offset(plane_0 as isize)).i_denom = mindenom as int32_t;
                        (*weights.offset(plane_0 as isize)).i_offset = minoff as int32_t;
                        (*h).mc.weight_cache.expect("non-null function pointer")(
                            h,
                            &mut *weights.offset(plane_0 as isize),
                        );
                        if (*h).param.analyse.i_weighted_pred == X264_WEIGHTP_FAKE
                            && !(*weights.offset(0 as ::core::ffi::c_int as isize))
                                .weightfn
                                .is_null()
                            && plane_0 == 0
                        {
                            (*fenc).f_weighted_cost_delta[i_delta_index as usize] = minscore
                                as ::core::ffi::c_float
                                / origscore as ::core::ffi::c_float;
                        }
                    }
                }
            }
            plane_0 += 1;
        }
        if !(*weights.offset(1 as ::core::ffi::c_int as isize))
            .weightfn
            .is_null()
            || !(*weights.offset(2 as ::core::ffi::c_int as isize))
                .weightfn
                .is_null()
        {
            let mut denom: ::core::ffi::c_int = if !(*weights
                .offset(1 as ::core::ffi::c_int as isize))
            .weightfn
            .is_null()
            {
                (*weights.offset(1 as ::core::ffi::c_int as isize)).i_denom as ::core::ffi::c_int
            } else {
                (*weights.offset(2 as ::core::ffi::c_int as isize)).i_denom as ::core::ffi::c_int
            };
            let mut both_weighted: ::core::ffi::c_int =
                (!(*weights.offset(1 as ::core::ffi::c_int as isize))
                    .weightfn
                    .is_null()
                    && !(*weights.offset(2 as ::core::ffi::c_int as isize))
                        .weightfn
                        .is_null()) as ::core::ffi::c_int;
            while both_weighted == 0 && denom == 7 as ::core::ffi::c_int
                || denom > 0 as ::core::ffi::c_int
                    && !(!(*weights.offset(1 as ::core::ffi::c_int as isize))
                        .weightfn
                        .is_null()
                        && (*weights.offset(1 as ::core::ffi::c_int as isize)).i_scale
                            & 1 as int32_t
                            != 0)
                    && !(!(*weights.offset(2 as ::core::ffi::c_int as isize))
                        .weightfn
                        .is_null()
                        && (*weights.offset(2 as ::core::ffi::c_int as isize)).i_scale
                            & 1 as int32_t
                            != 0)
            {
                denom -= 1;
                let mut i: ::core::ffi::c_int = 1 as ::core::ffi::c_int;
                while i <= 2 as ::core::ffi::c_int {
                    if !(*weights.offset(i as isize)).weightfn.is_null() {
                        (*weights.offset(i as isize)).i_scale >>= 1 as ::core::ffi::c_int;
                        (*weights.offset(i as isize)).i_denom = denom as int32_t;
                    }
                    i += 1;
                }
            }
        }
        let mut i_0: ::core::ffi::c_int = 1 as ::core::ffi::c_int;
        while i_0 <= 2 as ::core::ffi::c_int {
            if !(*weights.offset(i_0 as isize)).weightfn.is_null() {
                (*h).mc.weight_cache.expect("non-null function pointer")(
                    h,
                    &mut *weights.offset(i_0 as isize),
                );
            }
            i_0 += 1;
        }
        if !(*weights.offset(0 as ::core::ffi::c_int as isize))
            .weightfn
            .is_null()
            && b_lookahead != 0
        {
            let mut src: *mut pixel = (*ref_0).buffer_lowres;
            let mut dst: *mut pixel = (*h).mb.p_weight_buf[0 as ::core::ffi::c_int as usize];
            let mut width: ::core::ffi::c_int = (*ref_0).i_width_lowres
                + ((if 32 as ::core::ffi::c_int
                    > 64 as ::core::ffi::c_int
                        / ::core::mem::size_of::<pixel>() as ::core::ffi::c_int
                {
                    32 as ::core::ffi::c_int
                } else {
                    64 as ::core::ffi::c_int / ::core::mem::size_of::<pixel>() as ::core::ffi::c_int
                }) + PADH);
            let mut height: ::core::ffi::c_int =
                (*ref_0).i_lines_lowres + PADV * 2 as ::core::ffi::c_int;
            x264_10_weight_scale_plane(
                h,
                dst,
                (*ref_0).i_stride_lowres as intptr_t,
                src,
                (*ref_0).i_stride_lowres as intptr_t,
                width,
                height,
                &mut *weights.offset(0 as ::core::ffi::c_int as isize),
            );
            (*fenc).weighted[0 as ::core::ffi::c_int as usize] = (*h).mb.p_weight_buf
                [0 as ::core::ffi::c_int as usize]
                .offset(
                    (if 32 as ::core::ffi::c_int
                        > 64 as ::core::ffi::c_int
                            / ::core::mem::size_of::<pixel>() as ::core::ffi::c_int
                    {
                        32 as ::core::ffi::c_int
                    } else {
                        64 as ::core::ffi::c_int
                            / ::core::mem::size_of::<pixel>() as ::core::ffi::c_int
                    }) as isize,
                )
                .offset(((*ref_0).i_stride_lowres * PADV) as isize);
        }
    }
    #[c2rust::src_loc = "505:9"]
    pub const PAD_SIZE: ::core::ffi::c_int = 32 as ::core::ffi::c_int;
    #[c2rust::src_loc = "507:9"]
    pub const NUM_INTS: ::core::ffi::c_int = 4 as ::core::ffi::c_int;
    #[c2rust::src_loc = "508:9"]
    pub const COST_EST: ::core::ffi::c_int = 0 as ::core::ffi::c_int;
    #[c2rust::src_loc = "509:9"]
    pub const COST_EST_AQ: ::core::ffi::c_int = 1 as ::core::ffi::c_int;
    #[c2rust::src_loc = "510:9"]
    pub const INTRA_MBS: ::core::ffi::c_int = 2 as ::core::ffi::c_int;
    #[c2rust::src_loc = "511:9"]
    pub const NUM_ROWS: ::core::ffi::c_int = 3 as ::core::ffi::c_int;
    #[c2rust::src_loc = "514:1"]
    pub unsafe extern "C" fn slicetype_mb_cost(
        mut h: *mut x264_t,
        mut a: *mut x264_mb_analysis_t,
        mut frames: *mut *mut x264_frame_t,
        mut p0: ::core::ffi::c_int,
        mut p1: ::core::ffi::c_int,
        mut b: ::core::ffi::c_int,
        mut dist_scale_factor: ::core::ffi::c_int,
        mut do_search: *mut ::core::ffi::c_int,
        mut w: *const x264_weight_t,
        mut output_inter: *mut ::core::ffi::c_int,
        mut output_intra: *mut ::core::ffi::c_int,
    ) {
        let mut mv_range: ::core::ffi::c_int = 0;
        let mut fref0: *mut x264_frame_t = *frames.offset(p0 as isize);
        let mut fref1: *mut x264_frame_t = *frames.offset(p1 as isize);
        let mut fenc: *mut x264_frame_t = *frames.offset(b as isize);
        let b_bidir: ::core::ffi::c_int = (b < p1) as ::core::ffi::c_int;
        let i_mb_x: ::core::ffi::c_int = (*h).mb.i_mb_x;
        let i_mb_y: ::core::ffi::c_int = (*h).mb.i_mb_y;
        let i_mb_stride: ::core::ffi::c_int = (*h).mb.i_mb_width;
        let i_mb_xy: ::core::ffi::c_int = i_mb_x + i_mb_y * i_mb_stride;
        let i_stride: ::core::ffi::c_int = (*fenc).i_stride_lowres;
        let i_pel_offset: ::core::ffi::c_int =
            8 as ::core::ffi::c_int * (i_mb_x + i_mb_y * i_stride);
        let i_bipred_weight: ::core::ffi::c_int = if (*h).param.analyse.b_weighted_bipred != 0 {
            64 as ::core::ffi::c_int - (dist_scale_factor >> 2 as ::core::ffi::c_int)
        } else {
            32 as ::core::ffi::c_int
        };
        let mut fenc_mvs: [*mut [int16_t; 2]; 2] = [
            if b != p0 {
                &mut *(*(*(*fenc)
                    .lowres_mvs
                    .as_mut_ptr()
                    .offset(0 as ::core::ffi::c_int as isize))
                .as_mut_ptr()
                .offset((b - p0 - 1 as ::core::ffi::c_int) as isize))
                .offset(i_mb_xy as isize) as *mut [int16_t; 2]
            } else {
                0 as *mut [int16_t; 2]
            },
            if b != p1 {
                &mut *(*(*(*fenc)
                    .lowres_mvs
                    .as_mut_ptr()
                    .offset(1 as ::core::ffi::c_int as isize))
                .as_mut_ptr()
                .offset((p1 - b - 1 as ::core::ffi::c_int) as isize))
                .offset(i_mb_xy as isize) as *mut [int16_t; 2]
            } else {
                0 as *mut [int16_t; 2]
            },
        ];
        let mut fenc_costs: [*mut ::core::ffi::c_int; 2] = [
            if b != p0 {
                &mut *(*(*(*fenc)
                    .lowres_mv_costs
                    .as_mut_ptr()
                    .offset(0 as ::core::ffi::c_int as isize))
                .as_mut_ptr()
                .offset((b - p0 - 1 as ::core::ffi::c_int) as isize))
                .offset(i_mb_xy as isize) as *mut ::core::ffi::c_int
            } else {
                0 as *mut ::core::ffi::c_int
            },
            if b != p1 {
                &mut *(*(*(*fenc)
                    .lowres_mv_costs
                    .as_mut_ptr()
                    .offset(1 as ::core::ffi::c_int as isize))
                .as_mut_ptr()
                .offset((p1 - b - 1 as ::core::ffi::c_int) as isize))
                .offset(i_mb_xy as isize) as *mut ::core::ffi::c_int
            } else {
                0 as *mut ::core::ffi::c_int
            },
        ];
        let mut b_frame_score_mb: ::core::ffi::c_int = (i_mb_x > 0 as ::core::ffi::c_int
            && i_mb_x < (*h).mb.i_mb_width - 1 as ::core::ffi::c_int
            && i_mb_y > 0 as ::core::ffi::c_int
            && i_mb_y < (*h).mb.i_mb_height - 1 as ::core::ffi::c_int
            || (*h).mb.i_mb_width <= 2 as ::core::ffi::c_int
            || (*h).mb.i_mb_height <= 2 as ::core::ffi::c_int)
            as ::core::ffi::c_int;
        let mut pix1: [pixel; 288] = [0; 288];
        let mut pix2: *mut pixel = pix1.as_mut_ptr().offset(8 as ::core::ffi::c_int as isize);
        let mut m: [x264_me_t; 2] = [x264_me_t {
            i_pixel: 0,
            p_cost_mv: 0 as *mut uint16_t,
            i_ref_cost: 0,
            i_ref: 0,
            weight: 0 as *const x264_weight_t,
            p_fref: [0 as *mut pixel; 12],
            p_fref_w: 0 as *mut pixel,
            p_fenc: [0 as *mut pixel; 3],
            integral: 0 as *mut uint16_t,
            i_stride: [0; 3],
            mvp: [0; 2],
            cost_mv: 0,
            cost: 0,
            mv: [0; 2],
        }; 2];
        let mut i_bcost: ::core::ffi::c_int = COST_MAX;
        let mut list_used: ::core::ffi::c_int = 0 as ::core::ffi::c_int;
        let mut lowres_penalty: ::core::ffi::c_int = 4 as ::core::ffi::c_int;
        (*h).mb.pic.p_fenc[0 as ::core::ffi::c_int as usize] = (*h).mb.pic.fenc_buf.as_mut_ptr();
        (*h).mc.copy[PIXEL_8x8 as ::core::ffi::c_int as usize].expect("non-null function pointer")(
            (*h).mb.pic.p_fenc[0 as ::core::ffi::c_int as usize],
            FENC_STRIDE as intptr_t,
            &mut *(*(*fenc)
                .lowres
                .as_mut_ptr()
                .offset(0 as ::core::ffi::c_int as isize))
            .offset(i_pel_offset as isize),
            i_stride as intptr_t,
            8 as ::core::ffi::c_int,
        );
        if !(p0 == p1) {
            mv_range = 2 as ::core::ffi::c_int * (*h).param.analyse.i_mv_range;
            (*h).mb.mv_min_spel[0 as ::core::ffi::c_int as usize] = if 4 as ::core::ffi::c_int
                * (-(8 as ::core::ffi::c_int) * (*h).mb.i_mb_x - 12 as ::core::ffi::c_int)
                > -mv_range
            {
                4 as ::core::ffi::c_int
                    * (-(8 as ::core::ffi::c_int) * (*h).mb.i_mb_x - 12 as ::core::ffi::c_int)
            } else {
                -mv_range
            };
            (*h).mb.mv_max_spel[0 as ::core::ffi::c_int as usize] = if 4 as ::core::ffi::c_int
                * (8 as ::core::ffi::c_int
                    * ((*h).mb.i_mb_width - (*h).mb.i_mb_x - 1 as ::core::ffi::c_int)
                    + 12 as ::core::ffi::c_int)
                < mv_range - 1 as ::core::ffi::c_int
            {
                4 as ::core::ffi::c_int
                    * (8 as ::core::ffi::c_int
                        * ((*h).mb.i_mb_width - (*h).mb.i_mb_x - 1 as ::core::ffi::c_int)
                        + 12 as ::core::ffi::c_int)
            } else {
                mv_range - 1 as ::core::ffi::c_int
            };
            (*h).mb.mv_limit_fpel[0 as ::core::ffi::c_int as usize]
                [0 as ::core::ffi::c_int as usize] =
                ((*h).mb.mv_min_spel[0 as ::core::ffi::c_int as usize] >> 2 as ::core::ffi::c_int)
                    as int16_t;
            (*h).mb.mv_limit_fpel[1 as ::core::ffi::c_int as usize]
                [0 as ::core::ffi::c_int as usize] =
                ((*h).mb.mv_max_spel[0 as ::core::ffi::c_int as usize] >> 2 as ::core::ffi::c_int)
                    as int16_t;
            if (*h).mb.i_mb_x >= (*h).mb.i_mb_width - 2 as ::core::ffi::c_int {
                (*h).mb.mv_min_spel[1 as ::core::ffi::c_int as usize] = if 4 as ::core::ffi::c_int
                    * (-(8 as ::core::ffi::c_int) * (*h).mb.i_mb_y - 12 as ::core::ffi::c_int)
                    > -mv_range
                {
                    4 as ::core::ffi::c_int
                        * (-(8 as ::core::ffi::c_int) * (*h).mb.i_mb_y - 12 as ::core::ffi::c_int)
                } else {
                    -mv_range
                };
                (*h).mb.mv_max_spel[1 as ::core::ffi::c_int as usize] = if 4 as ::core::ffi::c_int
                    * (8 as ::core::ffi::c_int
                        * ((*h).mb.i_mb_height - (*h).mb.i_mb_y - 1 as ::core::ffi::c_int)
                        + 12 as ::core::ffi::c_int)
                    < mv_range - 1 as ::core::ffi::c_int
                {
                    4 as ::core::ffi::c_int
                        * (8 as ::core::ffi::c_int
                            * ((*h).mb.i_mb_height - (*h).mb.i_mb_y - 1 as ::core::ffi::c_int)
                            + 12 as ::core::ffi::c_int)
                } else {
                    mv_range - 1 as ::core::ffi::c_int
                };
                (*h).mb.mv_limit_fpel[0 as ::core::ffi::c_int as usize]
                    [1 as ::core::ffi::c_int as usize] =
                    ((*h).mb.mv_min_spel[1 as ::core::ffi::c_int as usize]
                        >> 2 as ::core::ffi::c_int) as int16_t;
                (*h).mb.mv_limit_fpel[1 as ::core::ffi::c_int as usize]
                    [1 as ::core::ffi::c_int as usize] =
                    ((*h).mb.mv_max_spel[1 as ::core::ffi::c_int as usize]
                        >> 2 as ::core::ffi::c_int) as int16_t;
            }
            m[0 as ::core::ffi::c_int as usize].i_pixel = PIXEL_8x8 as ::core::ffi::c_int;
            m[0 as ::core::ffi::c_int as usize].p_cost_mv = (*a).p_cost_mv;
            m[0 as ::core::ffi::c_int as usize].i_stride[0 as ::core::ffi::c_int as usize] =
                i_stride;
            m[0 as ::core::ffi::c_int as usize].p_fenc[0 as ::core::ffi::c_int as usize] =
                (*h).mb.pic.p_fenc[0 as ::core::ffi::c_int as usize];
            m[0 as ::core::ffi::c_int as usize].weight = w;
            m[0 as ::core::ffi::c_int as usize].i_ref = 0 as ::core::ffi::c_int;
            m[0 as ::core::ffi::c_int as usize].p_fref[0 as ::core::ffi::c_int as usize] =
                &mut *(*(*fref0)
                    .lowres
                    .as_mut_ptr()
                    .offset(0 as ::core::ffi::c_int as isize))
                .offset(i_pel_offset as isize) as *mut pixel;
            m[0 as ::core::ffi::c_int as usize].p_fref[1 as ::core::ffi::c_int as usize] =
                &mut *(*(*fref0)
                    .lowres
                    .as_mut_ptr()
                    .offset(1 as ::core::ffi::c_int as isize))
                .offset(i_pel_offset as isize) as *mut pixel;
            m[0 as ::core::ffi::c_int as usize].p_fref[2 as ::core::ffi::c_int as usize] =
                &mut *(*(*fref0)
                    .lowres
                    .as_mut_ptr()
                    .offset(2 as ::core::ffi::c_int as isize))
                .offset(i_pel_offset as isize) as *mut pixel;
            m[0 as ::core::ffi::c_int as usize].p_fref[3 as ::core::ffi::c_int as usize] =
                &mut *(*(*fref0)
                    .lowres
                    .as_mut_ptr()
                    .offset(3 as ::core::ffi::c_int as isize))
                .offset(i_pel_offset as isize) as *mut pixel;
            m[0 as ::core::ffi::c_int as usize].p_fref_w =
                m[0 as ::core::ffi::c_int as usize].p_fref[0 as ::core::ffi::c_int as usize];
            if !(*w.offset(0 as ::core::ffi::c_int as isize))
                .weightfn
                .is_null()
            {
                m[0 as ::core::ffi::c_int as usize].p_fref_w = &mut *(*(*fenc)
                    .weighted
                    .as_mut_ptr()
                    .offset(0 as ::core::ffi::c_int as isize))
                .offset(i_pel_offset as isize)
                    as *mut pixel;
            }
            if b_bidir != 0 {
                let mut dmv: [[int16_t; 2]; 2] = [[0; 2]; 2];
                m[1 as ::core::ffi::c_int as usize].i_pixel = PIXEL_8x8 as ::core::ffi::c_int;
                m[1 as ::core::ffi::c_int as usize].p_cost_mv = (*a).p_cost_mv;
                m[1 as ::core::ffi::c_int as usize].i_stride[0 as ::core::ffi::c_int as usize] =
                    i_stride;
                m[1 as ::core::ffi::c_int as usize].p_fenc[0 as ::core::ffi::c_int as usize] =
                    (*h).mb.pic.p_fenc[0 as ::core::ffi::c_int as usize];
                m[1 as ::core::ffi::c_int as usize].i_ref = 0 as ::core::ffi::c_int;
                m[1 as ::core::ffi::c_int as usize].weight =
                    x264_zero.as_mut_ptr() as *const x264_weight_t;
                m[1 as ::core::ffi::c_int as usize].p_fref[0 as ::core::ffi::c_int as usize] =
                    &mut *(*(*fref1)
                        .lowres
                        .as_mut_ptr()
                        .offset(0 as ::core::ffi::c_int as isize))
                    .offset(i_pel_offset as isize) as *mut pixel;
                m[1 as ::core::ffi::c_int as usize].p_fref[1 as ::core::ffi::c_int as usize] =
                    &mut *(*(*fref1)
                        .lowres
                        .as_mut_ptr()
                        .offset(1 as ::core::ffi::c_int as isize))
                    .offset(i_pel_offset as isize) as *mut pixel;
                m[1 as ::core::ffi::c_int as usize].p_fref[2 as ::core::ffi::c_int as usize] =
                    &mut *(*(*fref1)
                        .lowres
                        .as_mut_ptr()
                        .offset(2 as ::core::ffi::c_int as isize))
                    .offset(i_pel_offset as isize) as *mut pixel;
                m[1 as ::core::ffi::c_int as usize].p_fref[3 as ::core::ffi::c_int as usize] =
                    &mut *(*(*fref1)
                        .lowres
                        .as_mut_ptr()
                        .offset(3 as ::core::ffi::c_int as isize))
                    .offset(i_pel_offset as isize) as *mut pixel;
                m[1 as ::core::ffi::c_int as usize].p_fref_w =
                    m[1 as ::core::ffi::c_int as usize].p_fref[0 as ::core::ffi::c_int as usize];
                if (*(*fref1).lowres_mvs[0 as ::core::ffi::c_int as usize]
                    [(p1 - p0 - 1 as ::core::ffi::c_int) as usize]
                    .offset(0 as ::core::ffi::c_int as isize))
                    [0 as ::core::ffi::c_int as usize] as ::core::ffi::c_int
                    != 0x7fff as ::core::ffi::c_int
                {
                    let mut mvr: *mut int16_t = (*(*(*(*fref1)
                        .lowres_mvs
                        .as_mut_ptr()
                        .offset(0 as ::core::ffi::c_int as isize))
                    .as_mut_ptr()
                    .offset((p1 - p0 - 1 as ::core::ffi::c_int) as isize))
                    .offset(i_mb_xy as isize))
                    .as_mut_ptr();
                    dmv[0 as ::core::ffi::c_int as usize][0 as ::core::ffi::c_int as usize] =
                        (*mvr.offset(0 as ::core::ffi::c_int as isize) as ::core::ffi::c_int
                            * dist_scale_factor
                            + 128 as ::core::ffi::c_int
                            >> 8 as ::core::ffi::c_int) as int16_t;
                    dmv[0 as ::core::ffi::c_int as usize][1 as ::core::ffi::c_int as usize] =
                        (*mvr.offset(1 as ::core::ffi::c_int as isize) as ::core::ffi::c_int
                            * dist_scale_factor
                            + 128 as ::core::ffi::c_int
                            >> 8 as ::core::ffi::c_int) as int16_t;
                    dmv[1 as ::core::ffi::c_int as usize][0 as ::core::ffi::c_int as usize] =
                        (dmv[0 as ::core::ffi::c_int as usize][0 as ::core::ffi::c_int as usize]
                            as ::core::ffi::c_int
                            - *mvr.offset(0 as ::core::ffi::c_int as isize) as ::core::ffi::c_int)
                            as int16_t;
                    dmv[1 as ::core::ffi::c_int as usize][1 as ::core::ffi::c_int as usize] =
                        (dmv[0 as ::core::ffi::c_int as usize][1 as ::core::ffi::c_int as usize]
                            as ::core::ffi::c_int
                            - *mvr.offset(1 as ::core::ffi::c_int as isize) as ::core::ffi::c_int)
                            as int16_t;
                    dmv[0 as ::core::ffi::c_int as usize][0 as ::core::ffi::c_int as usize] =
                        x264_clip3(
                            dmv[0 as ::core::ffi::c_int as usize][0 as ::core::ffi::c_int as usize]
                                as ::core::ffi::c_int,
                            (*h).mb.mv_min_spel[0 as ::core::ffi::c_int as usize],
                            (*h).mb.mv_max_spel[0 as ::core::ffi::c_int as usize],
                        ) as int16_t;
                    dmv[0 as ::core::ffi::c_int as usize][1 as ::core::ffi::c_int as usize] =
                        x264_clip3(
                            dmv[0 as ::core::ffi::c_int as usize][1 as ::core::ffi::c_int as usize]
                                as ::core::ffi::c_int,
                            (*h).mb.mv_min_spel[1 as ::core::ffi::c_int as usize],
                            (*h).mb.mv_max_spel[1 as ::core::ffi::c_int as usize],
                        ) as int16_t;
                    dmv[1 as ::core::ffi::c_int as usize][0 as ::core::ffi::c_int as usize] =
                        x264_clip3(
                            dmv[1 as ::core::ffi::c_int as usize][0 as ::core::ffi::c_int as usize]
                                as ::core::ffi::c_int,
                            (*h).mb.mv_min_spel[0 as ::core::ffi::c_int as usize],
                            (*h).mb.mv_max_spel[0 as ::core::ffi::c_int as usize],
                        ) as int16_t;
                    dmv[1 as ::core::ffi::c_int as usize][1 as ::core::ffi::c_int as usize] =
                        x264_clip3(
                            dmv[1 as ::core::ffi::c_int as usize][1 as ::core::ffi::c_int as usize]
                                as ::core::ffi::c_int,
                            (*h).mb.mv_min_spel[1 as ::core::ffi::c_int as usize],
                            (*h).mb.mv_max_spel[1 as ::core::ffi::c_int as usize],
                        ) as int16_t;
                    if (*h).param.analyse.i_subpel_refine <= 1 as ::core::ffi::c_int {
                        let ref mut fresh20 = (*(dmv.as_mut_ptr() as *mut x264_union64_t)).i;
                        *fresh20 = (*fresh20 as ::core::ffi::c_ulonglong
                            & !(0x1000100010001 as ::core::ffi::c_ulonglong))
                            as uint64_t;
                    }
                } else {
                    (*(dmv.as_mut_ptr() as *mut x264_union64_t)).i = 0 as uint64_t;
                }
                let mut i_cost: ::core::ffi::c_int = 0;
                if (*h).param.analyse.i_subpel_refine <= 1 as ::core::ffi::c_int {
                    let mut hpel_idx1: ::core::ffi::c_int = ((dmv[0 as ::core::ffi::c_int as usize]
                        [0 as ::core::ffi::c_int as usize]
                        as ::core::ffi::c_int
                        & 2 as ::core::ffi::c_int)
                        >> 1 as ::core::ffi::c_int)
                        + (dmv[0 as ::core::ffi::c_int as usize][1 as ::core::ffi::c_int as usize]
                            as ::core::ffi::c_int
                            & 2 as ::core::ffi::c_int);
                    let mut hpel_idx2: ::core::ffi::c_int = ((dmv[1 as ::core::ffi::c_int as usize]
                        [0 as ::core::ffi::c_int as usize]
                        as ::core::ffi::c_int
                        & 2 as ::core::ffi::c_int)
                        >> 1 as ::core::ffi::c_int)
                        + (dmv[1 as ::core::ffi::c_int as usize][1 as ::core::ffi::c_int as usize]
                            as ::core::ffi::c_int
                            & 2 as ::core::ffi::c_int);
                    let mut src1: *mut pixel = m[0 as ::core::ffi::c_int as usize].p_fref
                        [hpel_idx1 as usize]
                        .offset(
                            (dmv[0 as ::core::ffi::c_int as usize][0 as ::core::ffi::c_int as usize]
                                as ::core::ffi::c_int
                                >> 2 as ::core::ffi::c_int) as isize,
                        )
                        .offset(
                            ((dmv[0 as ::core::ffi::c_int as usize]
                                [1 as ::core::ffi::c_int as usize]
                                as ::core::ffi::c_int
                                >> 2 as ::core::ffi::c_int)
                                * m[0 as ::core::ffi::c_int as usize].i_stride
                                    [0 as ::core::ffi::c_int as usize])
                                as isize,
                        );
                    let mut src2: *mut pixel = m[1 as ::core::ffi::c_int as usize].p_fref
                        [hpel_idx2 as usize]
                        .offset(
                            (dmv[1 as ::core::ffi::c_int as usize][0 as ::core::ffi::c_int as usize]
                                as ::core::ffi::c_int
                                >> 2 as ::core::ffi::c_int) as isize,
                        )
                        .offset(
                            ((dmv[1 as ::core::ffi::c_int as usize]
                                [1 as ::core::ffi::c_int as usize]
                                as ::core::ffi::c_int
                                >> 2 as ::core::ffi::c_int)
                                * m[1 as ::core::ffi::c_int as usize].i_stride
                                    [0 as ::core::ffi::c_int as usize])
                                as isize,
                        );
                    (*h).mc.avg[PIXEL_8x8 as ::core::ffi::c_int as usize]
                        .expect("non-null function pointer")(
                        pix1.as_mut_ptr(),
                        16 as intptr_t,
                        src1,
                        m[0 as ::core::ffi::c_int as usize].i_stride
                            [0 as ::core::ffi::c_int as usize] as intptr_t,
                        src2,
                        m[1 as ::core::ffi::c_int as usize].i_stride
                            [0 as ::core::ffi::c_int as usize] as intptr_t,
                        i_bipred_weight,
                    );
                } else {
                    let mut stride1: intptr_t = 16 as intptr_t;
                    let mut stride2: intptr_t = 16 as intptr_t;
                    let mut src1_0: *mut pixel = 0 as *mut pixel;
                    let mut src2_0: *mut pixel = 0 as *mut pixel;
                    src1_0 = (*h).mc.get_ref.expect("non-null function pointer")(
                        pix1.as_mut_ptr(),
                        &mut stride1,
                        (*m.as_mut_ptr().offset(0 as ::core::ffi::c_int as isize))
                            .p_fref
                            .as_mut_ptr(),
                        m[0 as ::core::ffi::c_int as usize].i_stride
                            [0 as ::core::ffi::c_int as usize] as intptr_t,
                        dmv[0 as ::core::ffi::c_int as usize][0 as ::core::ffi::c_int as usize]
                            as ::core::ffi::c_int,
                        dmv[0 as ::core::ffi::c_int as usize][1 as ::core::ffi::c_int as usize]
                            as ::core::ffi::c_int,
                        8 as ::core::ffi::c_int,
                        8 as ::core::ffi::c_int,
                        w,
                    );
                    src2_0 = (*h).mc.get_ref.expect("non-null function pointer")(
                        pix2,
                        &mut stride2,
                        (*m.as_mut_ptr().offset(1 as ::core::ffi::c_int as isize))
                            .p_fref
                            .as_mut_ptr(),
                        m[1 as ::core::ffi::c_int as usize].i_stride
                            [0 as ::core::ffi::c_int as usize] as intptr_t,
                        dmv[1 as ::core::ffi::c_int as usize][0 as ::core::ffi::c_int as usize]
                            as ::core::ffi::c_int,
                        dmv[1 as ::core::ffi::c_int as usize][1 as ::core::ffi::c_int as usize]
                            as ::core::ffi::c_int,
                        8 as ::core::ffi::c_int,
                        8 as ::core::ffi::c_int,
                        w,
                    );
                    (*h).mc.avg[PIXEL_8x8 as ::core::ffi::c_int as usize]
                        .expect("non-null function pointer")(
                        pix1.as_mut_ptr(),
                        16 as intptr_t,
                        src1_0,
                        stride1,
                        src2_0,
                        stride2,
                        i_bipred_weight,
                    );
                }
                i_cost = 0 as ::core::ffi::c_int * (*a).i_lambda
                    + (*h).pixf.mbcmp[PIXEL_8x8 as ::core::ffi::c_int as usize]
                        .expect("non-null function pointer")(
                        m[0 as ::core::ffi::c_int as usize].p_fenc
                            [0 as ::core::ffi::c_int as usize],
                        FENC_STRIDE as intptr_t,
                        pix1.as_mut_ptr(),
                        16 as intptr_t,
                    );
                if i_cost < i_bcost {
                    i_bcost = i_cost;
                    list_used = 3 as ::core::ffi::c_int;
                }
                if (*(dmv.as_mut_ptr() as *mut x264_union64_t)).i != 0 {
                    let mut i_cost_0: ::core::ffi::c_int = 0;
                    (*h).mc.avg[PIXEL_8x8 as ::core::ffi::c_int as usize]
                        .expect("non-null function pointer")(
                        pix1.as_mut_ptr(),
                        16 as intptr_t,
                        m[0 as ::core::ffi::c_int as usize].p_fref
                            [0 as ::core::ffi::c_int as usize],
                        m[0 as ::core::ffi::c_int as usize].i_stride
                            [0 as ::core::ffi::c_int as usize] as intptr_t,
                        m[1 as ::core::ffi::c_int as usize].p_fref
                            [0 as ::core::ffi::c_int as usize],
                        m[1 as ::core::ffi::c_int as usize].i_stride
                            [0 as ::core::ffi::c_int as usize] as intptr_t,
                        i_bipred_weight,
                    );
                    i_cost_0 = (*h).pixf.mbcmp[PIXEL_8x8 as ::core::ffi::c_int as usize]
                        .expect("non-null function pointer")(
                        m[0 as ::core::ffi::c_int as usize].p_fenc
                            [0 as ::core::ffi::c_int as usize],
                        FENC_STRIDE as intptr_t,
                        pix1.as_mut_ptr(),
                        16 as intptr_t,
                    );
                    if i_cost_0 < i_bcost {
                        i_bcost = i_cost_0;
                        list_used = 3 as ::core::ffi::c_int;
                    }
                }
            }
            let mut l: ::core::ffi::c_int = 0 as ::core::ffi::c_int;
            while l < 1 as ::core::ffi::c_int + b_bidir {
                if *do_search.offset(l as isize) != 0 {
                    let mut current_block_117: u64;
                    let mut i_mvc: ::core::ffi::c_int = 0 as ::core::ffi::c_int;
                    let mut fenc_mv: *mut [int16_t; 2] = fenc_mvs[l as usize];
                    let mut mvc: [[int16_t; 2]; 4] = [[0; 2]; 4];
                    (*((*mvc.as_mut_ptr().offset(0 as ::core::ffi::c_int as isize)).as_mut_ptr()
                        as *mut x264_union32_t))
                        .i = 0 as uint32_t;
                    (*((*mvc.as_mut_ptr().offset(2 as ::core::ffi::c_int as isize)).as_mut_ptr()
                        as *mut x264_union32_t))
                        .i = 0 as uint32_t;
                    if i_mb_x < (*h).mb.i_mb_width - 1 as ::core::ffi::c_int {
                        (*((*mvc.as_mut_ptr().offset(i_mvc as isize)).as_mut_ptr()
                            as *mut x264_union32_t))
                            .i =
                            (*((*fenc_mv.offset(1 as ::core::ffi::c_int as isize)).as_mut_ptr()
                                as *mut x264_union32_t))
                                .i;
                        i_mvc += 1;
                    }
                    if i_mb_y < (*h).i_threadslice_end - 1 as ::core::ffi::c_int {
                        (*((*mvc.as_mut_ptr().offset(i_mvc as isize)).as_mut_ptr()
                            as *mut x264_union32_t))
                            .i = (*((*fenc_mv.offset(i_mb_stride as isize)).as_mut_ptr()
                            as *mut x264_union32_t))
                            .i;
                        i_mvc += 1;
                        if i_mb_x > 0 as ::core::ffi::c_int {
                            (*((*mvc.as_mut_ptr().offset(i_mvc as isize)).as_mut_ptr()
                                as *mut x264_union32_t))
                                .i = (*((*fenc_mv
                                .offset((i_mb_stride - 1 as ::core::ffi::c_int) as isize))
                            .as_mut_ptr()
                                as *mut x264_union32_t))
                                .i;
                            i_mvc += 1;
                        }
                        if i_mb_x < (*h).mb.i_mb_width - 1 as ::core::ffi::c_int {
                            (*((*mvc.as_mut_ptr().offset(i_mvc as isize)).as_mut_ptr()
                                as *mut x264_union32_t))
                                .i = (*((*fenc_mv
                                .offset((i_mb_stride + 1 as ::core::ffi::c_int) as isize))
                            .as_mut_ptr()
                                as *mut x264_union32_t))
                                .i;
                            i_mvc += 1;
                        }
                    }
                    if i_mvc <= 1 as ::core::ffi::c_int {
                        (*((*m.as_mut_ptr().offset(l as isize)).mvp.as_mut_ptr()
                            as *mut x264_union32_t))
                            .i = (*((*mvc.as_mut_ptr().offset(0 as ::core::ffi::c_int as isize))
                            .as_mut_ptr()
                            as *mut x264_union32_t))
                            .i;
                    } else {
                        x264_median_mv(
                            (*m.as_mut_ptr().offset(l as isize)).mvp.as_mut_ptr(),
                            (*mvc.as_mut_ptr().offset(0 as ::core::ffi::c_int as isize))
                                .as_mut_ptr(),
                            (*mvc.as_mut_ptr().offset(1 as ::core::ffi::c_int as isize))
                                .as_mut_ptr(),
                            (*mvc.as_mut_ptr().offset(2 as ::core::ffi::c_int as isize))
                                .as_mut_ptr(),
                        );
                    }
                    if (*((*m.as_mut_ptr().offset(l as isize)).mvp.as_mut_ptr()
                        as *mut x264_union32_t))
                        .i
                        == 0
                    {
                        m[l as usize].cost = (*h).pixf.mbcmp
                            [PIXEL_8x8 as ::core::ffi::c_int as usize]
                            .expect("non-null function pointer")(
                            m[l as usize].p_fenc[0 as ::core::ffi::c_int as usize],
                            FENC_STRIDE as intptr_t,
                            m[l as usize].p_fref[0 as ::core::ffi::c_int as usize],
                            m[l as usize].i_stride[0 as ::core::ffi::c_int as usize] as intptr_t,
                        );
                        if m[l as usize].cost < 64 as ::core::ffi::c_int {
                            (*((*m.as_mut_ptr().offset(l as isize)).mv.as_mut_ptr()
                                as *mut x264_union32_t))
                                .i = 0 as uint32_t;
                            current_block_117 = 8572148166097892831;
                        } else {
                            current_block_117 = 17958840340921835115;
                        }
                    } else {
                        current_block_117 = 17958840340921835115;
                    }
                    match current_block_117 {
                        17958840340921835115 => {
                            x264_10_me_search_ref(
                                h,
                                &mut *m.as_mut_ptr().offset(l as isize),
                                mvc.as_mut_ptr() as *mut [int16_t; 2],
                                i_mvc,
                                0 as *mut ::core::ffi::c_int,
                            );
                            m[l as usize].cost -=
                                *(*a).p_cost_mv.offset(0 as ::core::ffi::c_int as isize)
                                    as ::core::ffi::c_int;
                            if (*((*m.as_mut_ptr().offset(l as isize)).mv.as_mut_ptr()
                                as *mut x264_union32_t))
                                .i
                                != 0
                            {
                                m[l as usize].cost += 5 as ::core::ffi::c_int * (*a).i_lambda;
                            }
                        }
                        _ => {}
                    }
                    (*(fenc_mvs[l as usize] as *mut x264_union32_t)).i =
                        (*((*m.as_mut_ptr().offset(l as isize)).mv.as_mut_ptr()
                            as *mut x264_union32_t))
                            .i;
                    *fenc_costs[l as usize] = m[l as usize].cost as ::core::ffi::c_int;
                } else {
                    (*((*m.as_mut_ptr().offset(l as isize)).mv.as_mut_ptr()
                        as *mut x264_union32_t))
                        .i = (*(fenc_mvs[l as usize] as *mut x264_union32_t)).i;
                    m[l as usize].cost = *fenc_costs[l as usize] as ::core::ffi::c_int;
                }
                if m[l as usize].cost < i_bcost {
                    i_bcost = m[l as usize].cost;
                    list_used = l + 1 as ::core::ffi::c_int;
                }
                l += 1;
            }
            if b_bidir != 0
                && ((*((*m.as_mut_ptr().offset(0 as ::core::ffi::c_int as isize))
                    .mv
                    .as_mut_ptr() as *mut x264_union32_t))
                    .i
                    != 0
                    || (*((*m.as_mut_ptr().offset(1 as ::core::ffi::c_int as isize))
                        .mv
                        .as_mut_ptr() as *mut x264_union32_t))
                        .i
                        != 0)
            {
                let mut i_cost_1: ::core::ffi::c_int = 0;
                if (*h).param.analyse.i_subpel_refine <= 1 as ::core::ffi::c_int {
                    let mut hpel_idx1_0: ::core::ffi::c_int = ((m[0 as ::core::ffi::c_int as usize]
                        .mv[0 as ::core::ffi::c_int as usize]
                        as ::core::ffi::c_int
                        & 2 as ::core::ffi::c_int)
                        >> 1 as ::core::ffi::c_int)
                        + (m[0 as ::core::ffi::c_int as usize].mv[1 as ::core::ffi::c_int as usize]
                            as ::core::ffi::c_int
                            & 2 as ::core::ffi::c_int);
                    let mut hpel_idx2_0: ::core::ffi::c_int = ((m[1 as ::core::ffi::c_int as usize]
                        .mv[0 as ::core::ffi::c_int as usize]
                        as ::core::ffi::c_int
                        & 2 as ::core::ffi::c_int)
                        >> 1 as ::core::ffi::c_int)
                        + (m[1 as ::core::ffi::c_int as usize].mv[1 as ::core::ffi::c_int as usize]
                            as ::core::ffi::c_int
                            & 2 as ::core::ffi::c_int);
                    let mut src1_1: *mut pixel = m[0 as ::core::ffi::c_int as usize].p_fref
                        [hpel_idx1_0 as usize]
                        .offset(
                            (m[0 as ::core::ffi::c_int as usize].mv
                                [0 as ::core::ffi::c_int as usize]
                                as ::core::ffi::c_int
                                >> 2 as ::core::ffi::c_int) as isize,
                        )
                        .offset(
                            ((m[0 as ::core::ffi::c_int as usize].mv
                                [1 as ::core::ffi::c_int as usize]
                                as ::core::ffi::c_int
                                >> 2 as ::core::ffi::c_int)
                                * m[0 as ::core::ffi::c_int as usize].i_stride
                                    [0 as ::core::ffi::c_int as usize])
                                as isize,
                        );
                    let mut src2_1: *mut pixel = m[1 as ::core::ffi::c_int as usize].p_fref
                        [hpel_idx2_0 as usize]
                        .offset(
                            (m[1 as ::core::ffi::c_int as usize].mv
                                [0 as ::core::ffi::c_int as usize]
                                as ::core::ffi::c_int
                                >> 2 as ::core::ffi::c_int) as isize,
                        )
                        .offset(
                            ((m[1 as ::core::ffi::c_int as usize].mv
                                [1 as ::core::ffi::c_int as usize]
                                as ::core::ffi::c_int
                                >> 2 as ::core::ffi::c_int)
                                * m[1 as ::core::ffi::c_int as usize].i_stride
                                    [0 as ::core::ffi::c_int as usize])
                                as isize,
                        );
                    (*h).mc.avg[PIXEL_8x8 as ::core::ffi::c_int as usize]
                        .expect("non-null function pointer")(
                        pix1.as_mut_ptr(),
                        16 as intptr_t,
                        src1_1,
                        m[0 as ::core::ffi::c_int as usize].i_stride
                            [0 as ::core::ffi::c_int as usize] as intptr_t,
                        src2_1,
                        m[1 as ::core::ffi::c_int as usize].i_stride
                            [0 as ::core::ffi::c_int as usize] as intptr_t,
                        i_bipred_weight,
                    );
                } else {
                    let mut stride1_0: intptr_t = 16 as intptr_t;
                    let mut stride2_0: intptr_t = 16 as intptr_t;
                    let mut src1_2: *mut pixel = 0 as *mut pixel;
                    let mut src2_2: *mut pixel = 0 as *mut pixel;
                    src1_2 = (*h).mc.get_ref.expect("non-null function pointer")(
                        pix1.as_mut_ptr(),
                        &mut stride1_0,
                        (*m.as_mut_ptr().offset(0 as ::core::ffi::c_int as isize))
                            .p_fref
                            .as_mut_ptr(),
                        m[0 as ::core::ffi::c_int as usize].i_stride
                            [0 as ::core::ffi::c_int as usize] as intptr_t,
                        m[0 as ::core::ffi::c_int as usize].mv[0 as ::core::ffi::c_int as usize]
                            as ::core::ffi::c_int,
                        m[0 as ::core::ffi::c_int as usize].mv[1 as ::core::ffi::c_int as usize]
                            as ::core::ffi::c_int,
                        8 as ::core::ffi::c_int,
                        8 as ::core::ffi::c_int,
                        w,
                    );
                    src2_2 = (*h).mc.get_ref.expect("non-null function pointer")(
                        pix2,
                        &mut stride2_0,
                        (*m.as_mut_ptr().offset(1 as ::core::ffi::c_int as isize))
                            .p_fref
                            .as_mut_ptr(),
                        m[1 as ::core::ffi::c_int as usize].i_stride
                            [0 as ::core::ffi::c_int as usize] as intptr_t,
                        m[1 as ::core::ffi::c_int as usize].mv[0 as ::core::ffi::c_int as usize]
                            as ::core::ffi::c_int,
                        m[1 as ::core::ffi::c_int as usize].mv[1 as ::core::ffi::c_int as usize]
                            as ::core::ffi::c_int,
                        8 as ::core::ffi::c_int,
                        8 as ::core::ffi::c_int,
                        w,
                    );
                    (*h).mc.avg[PIXEL_8x8 as ::core::ffi::c_int as usize]
                        .expect("non-null function pointer")(
                        pix1.as_mut_ptr(),
                        16 as intptr_t,
                        src1_2,
                        stride1_0,
                        src2_2,
                        stride2_0,
                        i_bipred_weight,
                    );
                }
                i_cost_1 = 5 as ::core::ffi::c_int * (*a).i_lambda
                    + (*h).pixf.mbcmp[PIXEL_8x8 as ::core::ffi::c_int as usize]
                        .expect("non-null function pointer")(
                        m[0 as ::core::ffi::c_int as usize].p_fenc
                            [0 as ::core::ffi::c_int as usize],
                        FENC_STRIDE as intptr_t,
                        pix1.as_mut_ptr(),
                        16 as intptr_t,
                    );
                if i_cost_1 < i_bcost {
                    i_bcost = i_cost_1;
                    list_used = 3 as ::core::ffi::c_int;
                }
            }
        }
        if (*fenc).b_intra_calculated == 0 {
            let mut edge: [pixel; 36] = [0; 36];
            let mut pix: *mut pixel = &mut *pix1
                .as_mut_ptr()
                .offset((8 as ::core::ffi::c_int + FDEC_STRIDE) as isize)
                as *mut pixel;
            let mut src: *mut pixel = &mut *(*(*fenc)
                .lowres
                .as_mut_ptr()
                .offset(0 as ::core::ffi::c_int as isize))
            .offset(i_pel_offset as isize) as *mut pixel;
            let intra_penalty: ::core::ffi::c_int = 5 as ::core::ffi::c_int * (*a).i_lambda;
            let mut satds: [::core::ffi::c_int; 3] = [0; 3];
            let mut pixoff: ::core::ffi::c_int = 4 as ::core::ffi::c_int / SIZEOF_PIXEL;
            memcpy(
                pix.offset(-(FDEC_STRIDE as isize)) as *mut ::core::ffi::c_void,
                src.offset(-(i_stride as isize)) as *const ::core::ffi::c_void,
                (16 as ::core::ffi::c_int * SIZEOF_PIXEL) as size_t,
            );
            let mut i: ::core::ffi::c_int = -(1 as ::core::ffi::c_int);
            while i < 8 as ::core::ffi::c_int {
                (*(&mut *pix.offset((i * 32 as ::core::ffi::c_int - pixoff) as isize)
                    as *mut pixel as *mut x264_union32_t))
                    .i = (*(&mut *src.offset((i * i_stride - pixoff) as isize)
                    as *mut pixel as *mut x264_union32_t))
                    .i;
                i += 1;
            }
            (*h).pixf
                .intra_mbcmp_x3_8x8c
                .expect("non-null function pointer")(
                (*h).mb.pic.p_fenc[0 as ::core::ffi::c_int as usize],
                pix,
                satds.as_mut_ptr(),
            );
            let mut i_icost: ::core::ffi::c_int = if satds[0 as ::core::ffi::c_int as usize]
                < (if satds[1 as ::core::ffi::c_int as usize]
                    < satds[2 as ::core::ffi::c_int as usize]
                {
                    satds[1 as ::core::ffi::c_int as usize]
                } else {
                    satds[2 as ::core::ffi::c_int as usize]
                }) {
                satds[0 as ::core::ffi::c_int as usize]
            } else if satds[1 as ::core::ffi::c_int as usize]
                < satds[2 as ::core::ffi::c_int as usize]
            {
                satds[1 as ::core::ffi::c_int as usize]
            } else {
                satds[2 as ::core::ffi::c_int as usize]
            };
            if (*h).param.analyse.i_subpel_refine > 1 as ::core::ffi::c_int {
                (*h).predict_8x8c[I_PRED_CHROMA_P as ::core::ffi::c_int as usize]
                    .expect("non-null function pointer")(pix);
                let mut satd: ::core::ffi::c_int = (*h).pixf.mbcmp
                    [PIXEL_8x8 as ::core::ffi::c_int as usize]
                    .expect("non-null function pointer")(
                    (*h).mb.pic.p_fenc[0 as ::core::ffi::c_int as usize],
                    FENC_STRIDE as intptr_t,
                    pix,
                    FDEC_STRIDE as intptr_t,
                );
                i_icost = if i_icost < satd { i_icost } else { satd };
                (*h).predict_8x8_filter.expect("non-null function pointer")(
                    pix,
                    edge.as_mut_ptr(),
                    ALL_NEIGHBORS as ::core::ffi::c_int,
                    ALL_NEIGHBORS as ::core::ffi::c_int,
                );
                let mut i_0: ::core::ffi::c_int = 3 as ::core::ffi::c_int;
                while i_0 < 9 as ::core::ffi::c_int {
                    (*h).predict_8x8[i_0 as usize].expect("non-null function pointer")(
                        pix,
                        edge.as_mut_ptr(),
                    );
                    satd = (*h).pixf.mbcmp[PIXEL_8x8 as ::core::ffi::c_int as usize]
                        .expect("non-null function pointer")(
                        (*h).mb.pic.p_fenc[0 as ::core::ffi::c_int as usize],
                        FENC_STRIDE as intptr_t,
                        pix,
                        FDEC_STRIDE as intptr_t,
                    );
                    i_icost = if i_icost < satd { i_icost } else { satd };
                    i_0 += 1;
                }
            }
            i_icost =
                (i_icost + intra_penalty >> BIT_DEPTH - 8 as ::core::ffi::c_int) + lowres_penalty;
            *(*fenc).i_intra_cost.offset(i_mb_xy as isize) = i_icost as uint16_t;
            let mut i_icost_aq: ::core::ffi::c_int = i_icost;
            if (*h).param.rc.i_aq_mode != 0 {
                i_icost_aq = i_icost_aq
                    * *(*fenc).i_inv_qscale_factor.offset(i_mb_xy as isize) as ::core::ffi::c_int
                    + 128 as ::core::ffi::c_int
                    >> 8 as ::core::ffi::c_int;
            }
            *output_intra
                .offset((NUM_INTS + ((*h).mb.i_mb_y - (*h).i_threadslice_start)) as isize) +=
                i_icost_aq;
            if b_frame_score_mb != 0 {
                *output_intra.offset(COST_EST as isize) += i_icost;
                *output_intra.offset(COST_EST_AQ as isize) += i_icost_aq;
            }
        }
        i_bcost = (i_bcost >> BIT_DEPTH - 8 as ::core::ffi::c_int) + lowres_penalty;
        if b_bidir == 0 {
            let mut i_icost_0: ::core::ffi::c_int =
                *(*fenc).i_intra_cost.offset(i_mb_xy as isize) as ::core::ffi::c_int;
            let mut b_intra: ::core::ffi::c_int = (i_icost_0 < i_bcost) as ::core::ffi::c_int;
            if b_intra != 0 {
                i_bcost = i_icost_0;
                list_used = 0 as ::core::ffi::c_int;
            }
            if b_frame_score_mb != 0 {
                *output_inter.offset(INTRA_MBS as isize) += b_intra;
            }
        }
        if p0 != p1 {
            let mut i_bcost_aq: ::core::ffi::c_int = i_bcost;
            if (*h).param.rc.i_aq_mode != 0 {
                i_bcost_aq = i_bcost_aq
                    * *(*fenc).i_inv_qscale_factor.offset(i_mb_xy as isize) as ::core::ffi::c_int
                    + 128 as ::core::ffi::c_int
                    >> 8 as ::core::ffi::c_int;
            }
            *output_inter
                .offset((NUM_INTS + ((*h).mb.i_mb_y - (*h).i_threadslice_start)) as isize) +=
                i_bcost_aq;
            if b_frame_score_mb != 0 {
                *output_inter.offset(COST_EST as isize) += i_bcost;
                *output_inter.offset(COST_EST_AQ as isize) += i_bcost_aq;
            }
        }
        *(*fenc).lowres_costs[(b - p0) as usize][(p1 - b) as usize].offset(i_mb_xy as isize) =
            ((if i_bcost
                < ((1 as ::core::ffi::c_int) << 14 as ::core::ffi::c_int) - 1 as ::core::ffi::c_int
            {
                i_bcost
            } else {
                ((1 as ::core::ffi::c_int) << 14 as ::core::ffi::c_int) - 1 as ::core::ffi::c_int
            }) + (list_used << LOWRES_COST_SHIFT)) as uint16_t;
    }
    #[c2rust::src_loc = "814:1"]
    pub unsafe extern "C" fn slicetype_slice_cost(mut s: *mut x264_slicetype_slice_t) {
        let mut h: *mut x264_t = (*s).h;
        let mut do_edges: ::core::ffi::c_int = ((*h).param.rc.b_mb_tree != 0
            || (*h).param.rc.i_vbv_buffer_size != 0
            || (*h).mb.i_mb_width <= 2 as ::core::ffi::c_int
            || (*h).mb.i_mb_height <= 2 as ::core::ffi::c_int)
            as ::core::ffi::c_int;
        let mut start_y: ::core::ffi::c_int = if ((*h).i_threadslice_end - 1 as ::core::ffi::c_int)
            < (*h).mb.i_mb_height - 2 as ::core::ffi::c_int + do_edges
        {
            (*h).i_threadslice_end - 1 as ::core::ffi::c_int
        } else {
            (*h).mb.i_mb_height - 2 as ::core::ffi::c_int + do_edges
        };
        let mut end_y: ::core::ffi::c_int =
            if (*h).i_threadslice_start > 1 as ::core::ffi::c_int - do_edges {
                (*h).i_threadslice_start
            } else {
                1 as ::core::ffi::c_int - do_edges
            };
        let mut start_x: ::core::ffi::c_int =
            (*h).mb.i_mb_width - 2 as ::core::ffi::c_int + do_edges;
        let mut end_x: ::core::ffi::c_int = 1 as ::core::ffi::c_int - do_edges;
        (*h).mb.i_mb_y = start_y;
        while (*h).mb.i_mb_y >= end_y {
            (*h).mb.i_mb_x = start_x;
            while (*h).mb.i_mb_x >= end_x {
                slicetype_mb_cost(
                    h,
                    (*s).a,
                    (*s).frames,
                    (*s).p0,
                    (*s).p1,
                    (*s).b,
                    (*s).dist_scale_factor,
                    (*s).do_search as *mut ::core::ffi::c_int,
                    (*s).w,
                    (*s).output_inter,
                    (*s).output_intra,
                );
                (*h).mb.i_mb_x -= 1;
            }
            (*h).mb.i_mb_y -= 1;
        }
    }
    #[c2rust::src_loc = "836:1"]
    pub unsafe extern "C" fn slicetype_frame_cost(
        mut h: *mut x264_t,
        mut a: *mut x264_mb_analysis_t,
        mut frames: *mut *mut x264_frame_t,
        mut p0: ::core::ffi::c_int,
        mut p1: ::core::ffi::c_int,
        mut b: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int {
        let mut i_score: ::core::ffi::c_int = 0 as ::core::ffi::c_int;
        let mut do_search: [::core::ffi::c_int; 2] = [0; 2];
        let mut w: *const x264_weight_t = x264_zero.as_mut_ptr() as *const x264_weight_t;
        let mut fenc: *mut x264_frame_t = *frames.offset(b as isize);
        if (*fenc).i_cost_est[(b - p0) as usize][(p1 - b) as usize] >= 0 as ::core::ffi::c_int
            && ((*h).param.rc.i_vbv_buffer_size == 0
                || *(*fenc).i_row_satds[(b - p0) as usize][(p1 - b) as usize]
                    .offset(0 as ::core::ffi::c_int as isize)
                    != -(1 as ::core::ffi::c_int))
        {
            i_score = (*fenc).i_cost_est[(b - p0) as usize][(p1 - b) as usize];
        } else {
            let mut dist_scale_factor: ::core::ffi::c_int = 128 as ::core::ffi::c_int;
            do_search[0 as ::core::ffi::c_int as usize] = (b != p0
                && (*(*fenc).lowres_mvs[0 as ::core::ffi::c_int as usize]
                    [(b - p0 - 1 as ::core::ffi::c_int) as usize]
                    .offset(0 as ::core::ffi::c_int as isize))
                    [0 as ::core::ffi::c_int as usize] as ::core::ffi::c_int
                    == 0x7fff as ::core::ffi::c_int)
                as ::core::ffi::c_int;
            do_search[1 as ::core::ffi::c_int as usize] = (b != p1
                && (*(*fenc).lowres_mvs[1 as ::core::ffi::c_int as usize]
                    [(p1 - b - 1 as ::core::ffi::c_int) as usize]
                    .offset(0 as ::core::ffi::c_int as isize))
                    [0 as ::core::ffi::c_int as usize] as ::core::ffi::c_int
                    == 0x7fff as ::core::ffi::c_int)
                as ::core::ffi::c_int;
            if do_search[0 as ::core::ffi::c_int as usize] != 0 {
                if (*h).param.analyse.i_weighted_pred != 0 && b == p1 {
                    x264_10_weights_analyse(
                        h,
                        fenc,
                        *frames.offset(p0 as isize),
                        1 as ::core::ffi::c_int,
                    );
                    w = (*(*fenc)
                        .weight
                        .as_mut_ptr()
                        .offset(0 as ::core::ffi::c_int as isize))
                    .as_mut_ptr();
                }
                (*(*fenc).lowres_mvs[0 as ::core::ffi::c_int as usize]
                    [(b - p0 - 1 as ::core::ffi::c_int) as usize]
                    .offset(0 as ::core::ffi::c_int as isize))
                    [0 as ::core::ffi::c_int as usize] = 0 as int16_t;
            }
            if do_search[1 as ::core::ffi::c_int as usize] != 0 {
                (*(*fenc).lowres_mvs[1 as ::core::ffi::c_int as usize]
                    [(p1 - b - 1 as ::core::ffi::c_int) as usize]
                    .offset(0 as ::core::ffi::c_int as isize))
                    [0 as ::core::ffi::c_int as usize] = 0 as int16_t;
            }
            if p1 != p0 {
                dist_scale_factor = ((b - p0 << 8 as ::core::ffi::c_int)
                    + (p1 - p0 >> 1 as ::core::ffi::c_int))
                    / (p1 - p0);
            }
            let mut output_buf_size: ::core::ffi::c_int =
                (*h).mb.i_mb_height + (NUM_INTS + PAD_SIZE) * (*h).param.i_lookahead_threads;
            let mut output_inter: [*mut ::core::ffi::c_int; 17] =
                [0 as *mut ::core::ffi::c_int; 17];
            let mut output_intra: [*mut ::core::ffi::c_int; 17] =
                [0 as *mut ::core::ffi::c_int; 17];
            output_inter[0 as ::core::ffi::c_int as usize] =
                (*h).scratch_buffer2 as *mut ::core::ffi::c_int;
            output_intra[0 as ::core::ffi::c_int as usize] =
                output_inter[0 as ::core::ffi::c_int as usize].offset(output_buf_size as isize);
            if (*h).param.i_lookahead_threads > 1 as ::core::ffi::c_int {
                let mut s: [x264_slicetype_slice_t; 16] = [x264_slicetype_slice_t {
                    h: 0 as *mut x264_t,
                    a: 0 as *mut x264_mb_analysis_t,
                    frames: 0 as *mut *mut x264_frame_t,
                    p0: 0,
                    p1: 0,
                    b: 0,
                    dist_scale_factor: 0,
                    do_search: 0 as *mut ::core::ffi::c_int,
                    w: 0 as *const x264_weight_t,
                    output_inter: 0 as *mut ::core::ffi::c_int,
                    output_intra: 0 as *mut ::core::ffi::c_int,
                }; 16];
                let mut i: ::core::ffi::c_int = 0 as ::core::ffi::c_int;
                while i < (*h).param.i_lookahead_threads {
                    let mut t: *mut x264_t = (*h).lookahead_thread[i as usize];
                    (*t).mb.i_me_method = (*h).mb.i_me_method;
                    (*t).mb.i_subpel_refine = (*h).mb.i_subpel_refine;
                    (*t).mb.b_chroma_me = (*h).mb.b_chroma_me;
                    s[i as usize] = {
                        let mut init = x264_slicetype_slice_t {
                            h: t,
                            a: a,
                            frames: frames,
                            p0: p0,
                            p1: p1,
                            b: b,
                            dist_scale_factor: dist_scale_factor,
                            do_search: do_search.as_mut_ptr(),
                            w: w,
                            output_inter: output_inter[i as usize],
                            output_intra: output_intra[i as usize],
                        };
                        init
                    };
                    (*t).i_threadslice_start = ((*h).mb.i_mb_height * i
                        + (*h).param.i_lookahead_threads / 2 as ::core::ffi::c_int)
                        / (*h).param.i_lookahead_threads;
                    (*t).i_threadslice_end = ((*h).mb.i_mb_height * (i + 1 as ::core::ffi::c_int)
                        + (*h).param.i_lookahead_threads / 2 as ::core::ffi::c_int)
                        / (*h).param.i_lookahead_threads;
                    let mut thread_height: ::core::ffi::c_int =
                        (*t).i_threadslice_end - (*t).i_threadslice_start;
                    let mut thread_output_size: ::core::ffi::c_int = thread_height + NUM_INTS;
                    memset(
                        output_inter[i as usize] as *mut ::core::ffi::c_void,
                        0 as ::core::ffi::c_int,
                        (thread_output_size as size_t)
                            .wrapping_mul(::core::mem::size_of::<::core::ffi::c_int>() as size_t),
                    );
                    memset(
                        output_intra[i as usize] as *mut ::core::ffi::c_void,
                        0 as ::core::ffi::c_int,
                        (thread_output_size as size_t)
                            .wrapping_mul(::core::mem::size_of::<::core::ffi::c_int>() as size_t),
                    );
                    let ref mut fresh18 = *output_intra[i as usize].offset(NUM_ROWS as isize);
                    *fresh18 = thread_height;
                    *output_inter[i as usize].offset(NUM_ROWS as isize) = *fresh18;
                    output_inter[(i + 1 as ::core::ffi::c_int) as usize] = output_inter[i as usize]
                        .offset(thread_output_size as isize)
                        .offset(PAD_SIZE as isize);
                    output_intra[(i + 1 as ::core::ffi::c_int) as usize] = output_intra[i as usize]
                        .offset(thread_output_size as isize)
                        .offset(PAD_SIZE as isize);
                    x264_10_threadpool_run(
                        (*h).lookaheadpool,
                        ::core::mem::transmute::<
                            *mut ::core::ffi::c_void,
                            Option<
                                unsafe extern "C" fn(
                                    *mut ::core::ffi::c_void,
                                )
                                    -> *mut ::core::ffi::c_void,
                            >,
                        >(::core::mem::transmute::<
                            Option<unsafe extern "C" fn(*mut x264_slicetype_slice_t) -> ()>,
                            *mut ::core::ffi::c_void,
                        >(Some(
                            slicetype_slice_cost
                                as unsafe extern "C" fn(*mut x264_slicetype_slice_t) -> (),
                        ))),
                        &mut *s.as_mut_ptr().offset(i as isize) as *mut x264_slicetype_slice_t
                            as *mut ::core::ffi::c_void,
                    );
                    i += 1;
                }
                let mut i_0: ::core::ffi::c_int = 0 as ::core::ffi::c_int;
                while i_0 < (*h).param.i_lookahead_threads {
                    x264_10_threadpool_wait(
                        (*h).lookaheadpool,
                        &mut *s.as_mut_ptr().offset(i_0 as isize) as *mut x264_slicetype_slice_t
                            as *mut ::core::ffi::c_void,
                    );
                    i_0 += 1;
                }
            } else {
                (*h).i_threadslice_start = 0 as ::core::ffi::c_int;
                (*h).i_threadslice_end = (*h).mb.i_mb_height;
                memset(
                    output_inter[0 as ::core::ffi::c_int as usize] as *mut ::core::ffi::c_void,
                    0 as ::core::ffi::c_int,
                    ((output_buf_size - PAD_SIZE) as size_t)
                        .wrapping_mul(::core::mem::size_of::<::core::ffi::c_int>() as size_t),
                );
                memset(
                    output_intra[0 as ::core::ffi::c_int as usize] as *mut ::core::ffi::c_void,
                    0 as ::core::ffi::c_int,
                    ((output_buf_size - PAD_SIZE) as size_t)
                        .wrapping_mul(::core::mem::size_of::<::core::ffi::c_int>() as size_t),
                );
                let ref mut fresh19 =
                    *output_intra[0 as ::core::ffi::c_int as usize].offset(NUM_ROWS as isize);
                *fresh19 = (*h).mb.i_mb_height;
                *output_inter[0 as ::core::ffi::c_int as usize].offset(NUM_ROWS as isize) =
                    *fresh19;
                let mut s_0: x264_slicetype_slice_t = {
                    let mut init = x264_slicetype_slice_t {
                        h: h,
                        a: a,
                        frames: frames,
                        p0: p0,
                        p1: p1,
                        b: b,
                        dist_scale_factor: dist_scale_factor,
                        do_search: do_search.as_mut_ptr(),
                        w: w,
                        output_inter: output_inter[0 as ::core::ffi::c_int as usize],
                        output_intra: output_intra[0 as ::core::ffi::c_int as usize],
                    };
                    init
                };
                slicetype_slice_cost(&mut s_0);
            }
            if b == p1 {
                (*fenc).i_intra_mbs[(b - p0) as usize] = 0 as ::core::ffi::c_int;
            }
            if (*fenc).b_intra_calculated == 0 {
                (*fenc).i_cost_est[0 as ::core::ffi::c_int as usize]
                    [0 as ::core::ffi::c_int as usize] = 0 as ::core::ffi::c_int;
                (*fenc).i_cost_est_aq[0 as ::core::ffi::c_int as usize]
                    [0 as ::core::ffi::c_int as usize] = 0 as ::core::ffi::c_int;
            }
            (*fenc).i_cost_est[(b - p0) as usize][(p1 - b) as usize] = 0 as ::core::ffi::c_int;
            (*fenc).i_cost_est_aq[(b - p0) as usize][(p1 - b) as usize] = 0 as ::core::ffi::c_int;
            let mut row_satd_inter: *mut ::core::ffi::c_int =
                (*fenc).i_row_satds[(b - p0) as usize][(p1 - b) as usize];
            let mut row_satd_intra: *mut ::core::ffi::c_int = (*fenc).i_row_satds
                [0 as ::core::ffi::c_int as usize][0 as ::core::ffi::c_int as usize];
            let mut i_1: ::core::ffi::c_int = 0 as ::core::ffi::c_int;
            while i_1 < (*h).param.i_lookahead_threads {
                if b == p1 {
                    (*fenc).i_intra_mbs[(b - p0) as usize] +=
                        *output_inter[i_1 as usize].offset(INTRA_MBS as isize);
                }
                if (*fenc).b_intra_calculated == 0 {
                    (*fenc).i_cost_est[0 as ::core::ffi::c_int as usize]
                        [0 as ::core::ffi::c_int as usize] +=
                        *output_intra[i_1 as usize].offset(COST_EST as isize);
                    (*fenc).i_cost_est_aq[0 as ::core::ffi::c_int as usize]
                        [0 as ::core::ffi::c_int as usize] +=
                        *output_intra[i_1 as usize].offset(COST_EST_AQ as isize);
                }
                (*fenc).i_cost_est[(b - p0) as usize][(p1 - b) as usize] +=
                    *output_inter[i_1 as usize].offset(COST_EST as isize);
                (*fenc).i_cost_est_aq[(b - p0) as usize][(p1 - b) as usize] +=
                    *output_inter[i_1 as usize].offset(COST_EST_AQ as isize);
                if (*h).param.rc.i_vbv_buffer_size != 0 {
                    let mut row_count: ::core::ffi::c_int =
                        *output_inter[i_1 as usize].offset(NUM_ROWS as isize);
                    memcpy(
                        row_satd_inter as *mut ::core::ffi::c_void,
                        output_inter[i_1 as usize].offset(NUM_INTS as isize)
                            as *const ::core::ffi::c_void,
                        (row_count as size_t)
                            .wrapping_mul(::core::mem::size_of::<::core::ffi::c_int>() as size_t),
                    );
                    if (*fenc).b_intra_calculated == 0 {
                        memcpy(
                            row_satd_intra as *mut ::core::ffi::c_void,
                            output_intra[i_1 as usize].offset(NUM_INTS as isize)
                                as *const ::core::ffi::c_void,
                            (row_count as size_t)
                                .wrapping_mul(
                                    ::core::mem::size_of::<::core::ffi::c_int>() as size_t
                                ),
                        );
                    }
                    row_satd_inter = row_satd_inter.offset(row_count as isize);
                    row_satd_intra = row_satd_intra.offset(row_count as isize);
                }
                i_1 += 1;
            }
            i_score = (*fenc).i_cost_est[(b - p0) as usize][(p1 - b) as usize];
            if b != p1 {
                i_score = (i_score as uint64_t)
                    .wrapping_mul(100 as uint64_t)
                    .wrapping_div(
                        (120 as ::core::ffi::c_int + (*h).param.i_bframe_bias) as uint64_t,
                    ) as ::core::ffi::c_int;
            } else {
                (*fenc).b_intra_calculated = 1 as ::core::ffi::c_int;
            }
            (*fenc).i_cost_est[(b - p0) as usize][(p1 - b) as usize] = i_score;
        }
        return i_score;
    }
    #[c2rust::src_loc = "999:1"]
    pub unsafe extern "C" fn slicetype_frame_cost_recalculate(
        mut h: *mut x264_t,
        mut frames: *mut *mut x264_frame_t,
        mut p0: ::core::ffi::c_int,
        mut p1: ::core::ffi::c_int,
        mut b: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int {
        let mut i_score: ::core::ffi::c_int = 0 as ::core::ffi::c_int;
        let mut row_satd: *mut ::core::ffi::c_int =
            (**frames.offset(b as isize)).i_row_satds[(b - p0) as usize][(p1 - b) as usize];
        let mut qp_offset: *mut ::core::ffi::c_float = if (**frames.offset(b as isize)).i_type
            == X264_TYPE_B
            || (**frames.offset(b as isize)).i_type == X264_TYPE_BREF
        {
            (**frames.offset(b as isize)).f_qp_offset_aq
        } else {
            (**frames.offset(b as isize)).f_qp_offset
        };
        (*h).mb.i_mb_y = (*h).mb.i_mb_height - 1 as ::core::ffi::c_int;
        while (*h).mb.i_mb_y >= 0 as ::core::ffi::c_int {
            *row_satd.offset((*h).mb.i_mb_y as isize) = 0 as ::core::ffi::c_int;
            (*h).mb.i_mb_x = (*h).mb.i_mb_width - 1 as ::core::ffi::c_int;
            while (*h).mb.i_mb_x >= 0 as ::core::ffi::c_int {
                let mut i_mb_xy: ::core::ffi::c_int =
                    (*h).mb.i_mb_x + (*h).mb.i_mb_y * (*h).mb.i_mb_stride;
                let mut i_mb_cost: ::core::ffi::c_int = *(**frames.offset(b as isize)).lowres_costs
                    [(b - p0) as usize][(p1 - b) as usize]
                    .offset(i_mb_xy as isize)
                    as ::core::ffi::c_int
                    & LOWRES_COST_MASK;
                let mut qp_adj: ::core::ffi::c_float = *qp_offset.offset(i_mb_xy as isize);
                i_mb_cost = i_mb_cost * x264_exp2fix8(qp_adj) + 128 as ::core::ffi::c_int
                    >> 8 as ::core::ffi::c_int;
                *row_satd.offset((*h).mb.i_mb_y as isize) += i_mb_cost;
                if (*h).mb.i_mb_y > 0 as ::core::ffi::c_int
                    && (*h).mb.i_mb_y < (*h).mb.i_mb_height - 1 as ::core::ffi::c_int
                    && (*h).mb.i_mb_x > 0 as ::core::ffi::c_int
                    && (*h).mb.i_mb_x < (*h).mb.i_mb_width - 1 as ::core::ffi::c_int
                    || (*h).mb.i_mb_width <= 2 as ::core::ffi::c_int
                    || (*h).mb.i_mb_height <= 2 as ::core::ffi::c_int
                {
                    i_score += i_mb_cost;
                }
                (*h).mb.i_mb_x -= 1;
            }
            (*h).mb.i_mb_y -= 1;
        }
        return i_score;
    }
    #[c2rust::src_loc = "1027:9"]
    pub const MBTREE_PRECISION: ::core::ffi::c_float = 0.5f32;
    #[c2rust::src_loc = "1029:1"]
    pub unsafe extern "C" fn macroblock_tree_finish(
        mut h: *mut x264_t,
        mut frame: *mut x264_frame_t,
        mut average_duration: ::core::ffi::c_float,
        mut ref0_distance: ::core::ffi::c_int,
    ) {
        let mut fps_factor: ::core::ffi::c_int = round(
            x264_clip3f(
                average_duration as ::core::ffi::c_double,
                (0.01f32
                    / (((*h).param.i_frame_packing == 5 as ::core::ffi::c_int)
                        as ::core::ffi::c_int
                        + 1 as ::core::ffi::c_int) as ::core::ffi::c_float)
                    as ::core::ffi::c_double,
                (1.00f32
                    / (((*h).param.i_frame_packing == 5 as ::core::ffi::c_int)
                        as ::core::ffi::c_int
                        + 1 as ::core::ffi::c_int) as ::core::ffi::c_float)
                    as ::core::ffi::c_double,
            ) / x264_clip3f(
                (*frame).f_duration as ::core::ffi::c_double,
                (0.01f32
                    / (((*h).param.i_frame_packing == 5 as ::core::ffi::c_int)
                        as ::core::ffi::c_int
                        + 1 as ::core::ffi::c_int) as ::core::ffi::c_float)
                    as ::core::ffi::c_double,
                (1.00f32
                    / (((*h).param.i_frame_packing == 5 as ::core::ffi::c_int)
                        as ::core::ffi::c_int
                        + 1 as ::core::ffi::c_int) as ::core::ffi::c_float)
                    as ::core::ffi::c_double,
            ) * 256 as ::core::ffi::c_int as ::core::ffi::c_double
                / MBTREE_PRECISION as ::core::ffi::c_double,
        ) as ::core::ffi::c_int;
        let mut weightdelta: ::core::ffi::c_float = 0.0f32;
        if ref0_distance != 0
            && (*frame).f_weighted_cost_delta[(ref0_distance - 1 as ::core::ffi::c_int) as usize]
                > 0 as ::core::ffi::c_int as ::core::ffi::c_float
        {
            weightdelta = (1.0f64
                - (*frame).f_weighted_cost_delta[(ref0_distance - 1 as ::core::ffi::c_int) as usize]
                    as ::core::ffi::c_double) as ::core::ffi::c_float;
        }
        let mut strength: ::core::ffi::c_float = 5.0f32 * (1.0f32 - (*h).param.rc.f_qcompress);
        let mut mb_index: ::core::ffi::c_int = 0 as ::core::ffi::c_int;
        while mb_index < (*h).mb.i_mb_count {
            let mut intra_cost: ::core::ffi::c_int =
                *(*frame).i_intra_cost.offset(mb_index as isize) as ::core::ffi::c_int
                    * *(*frame).i_inv_qscale_factor.offset(mb_index as isize) as ::core::ffi::c_int
                    + 128 as ::core::ffi::c_int
                    >> 8 as ::core::ffi::c_int;
            if intra_cost != 0 {
                let mut propagate_cost: ::core::ffi::c_int =
                    *(*frame).i_propagate_cost.offset(mb_index as isize) as ::core::ffi::c_int
                        * fps_factor
                        + 128 as ::core::ffi::c_int
                        >> 8 as ::core::ffi::c_int;
                let mut log2_ratio: ::core::ffi::c_float =
                    x264_log2((intra_cost + propagate_cost) as uint32_t)
                        - x264_log2(intra_cost as uint32_t)
                        + weightdelta;
                *(*frame).f_qp_offset.offset(mb_index as isize) =
                    *(*frame).f_qp_offset_aq.offset(mb_index as isize) - strength * log2_ratio;
            }
            mb_index += 1;
        }
    }
    #[c2rust::src_loc = "1051:1"]
    pub unsafe extern "C" fn macroblock_tree_propagate(
        mut h: *mut x264_t,
        mut frames: *mut *mut x264_frame_t,
        mut average_duration: ::core::ffi::c_float,
        mut p0: ::core::ffi::c_int,
        mut p1: ::core::ffi::c_int,
        mut b: ::core::ffi::c_int,
        mut referenced: ::core::ffi::c_int,
    ) {
        let mut ref_costs: [*mut uint16_t; 2] = [
            (**frames.offset(p0 as isize)).i_propagate_cost,
            (**frames.offset(p1 as isize)).i_propagate_cost,
        ];
        let mut dist_scale_factor: ::core::ffi::c_int = ((b - p0 << 8 as ::core::ffi::c_int)
            + (p1 - p0 >> 1 as ::core::ffi::c_int))
            / (p1 - p0);
        let mut i_bipred_weight: ::core::ffi::c_int = if (*h).param.analyse.b_weighted_bipred != 0 {
            64 as ::core::ffi::c_int - (dist_scale_factor >> 2 as ::core::ffi::c_int)
        } else {
            32 as ::core::ffi::c_int
        };
        let mut mvs: [*mut [int16_t; 2]; 2] = [
            if b != p0 {
                (**frames.offset(b as isize)).lowres_mvs[0 as ::core::ffi::c_int as usize]
                    [(b - p0 - 1 as ::core::ffi::c_int) as usize]
            } else {
                0 as *mut [int16_t; 2]
            },
            if b != p1 {
                (**frames.offset(b as isize)).lowres_mvs[1 as ::core::ffi::c_int as usize]
                    [(p1 - b - 1 as ::core::ffi::c_int) as usize]
            } else {
                0 as *mut [int16_t; 2]
            },
        ];
        let mut bipred_weights: [::core::ffi::c_int; 2] =
            [i_bipred_weight, 64 as ::core::ffi::c_int - i_bipred_weight];
        let mut buf: *mut int16_t = (*h).scratch_buffer as *mut int16_t;
        let mut propagate_cost: *mut uint16_t = (**frames.offset(b as isize)).i_propagate_cost;
        let mut lowres_costs: *mut uint16_t =
            (**frames.offset(b as isize)).lowres_costs[(b - p0) as usize][(p1 - b) as usize];
        let mut fps_factor: ::core::ffi::c_float = (x264_clip3f(
            (**frames.offset(b as isize)).f_duration as ::core::ffi::c_double,
            (0.01f32
                / (((*h).param.i_frame_packing == 5 as ::core::ffi::c_int) as ::core::ffi::c_int
                    + 1 as ::core::ffi::c_int) as ::core::ffi::c_float)
                as ::core::ffi::c_double,
            (1.00f32
                / (((*h).param.i_frame_packing == 5 as ::core::ffi::c_int) as ::core::ffi::c_int
                    + 1 as ::core::ffi::c_int) as ::core::ffi::c_float)
                as ::core::ffi::c_double,
        ) / (x264_clip3f(
            average_duration as ::core::ffi::c_double,
            (0.01f32
                / (((*h).param.i_frame_packing == 5 as ::core::ffi::c_int) as ::core::ffi::c_int
                    + 1 as ::core::ffi::c_int) as ::core::ffi::c_float)
                as ::core::ffi::c_double,
            (1.00f32
                / (((*h).param.i_frame_packing == 5 as ::core::ffi::c_int) as ::core::ffi::c_int
                    + 1 as ::core::ffi::c_int) as ::core::ffi::c_float)
                as ::core::ffi::c_double,
        ) * 256.0f64)
            * MBTREE_PRECISION as ::core::ffi::c_double)
            as ::core::ffi::c_float;
        if referenced == 0 {
            memset(
                (**frames.offset(b as isize)).i_propagate_cost as *mut ::core::ffi::c_void,
                0 as ::core::ffi::c_int,
                ((*h).mb.i_mb_width as size_t)
                    .wrapping_mul(::core::mem::size_of::<uint16_t>() as size_t),
            );
        }
        (*h).mb.i_mb_y = 0 as ::core::ffi::c_int;
        while (*h).mb.i_mb_y < (*h).mb.i_mb_height {
            let mut mb_index: ::core::ffi::c_int = (*h).mb.i_mb_y * (*h).mb.i_mb_stride;
            (*h).mc
                .mbtree_propagate_cost
                .expect("non-null function pointer")(
                buf,
                propagate_cost,
                (**frames.offset(b as isize))
                    .i_intra_cost
                    .offset(mb_index as isize),
                lowres_costs.offset(mb_index as isize),
                (**frames.offset(b as isize))
                    .i_inv_qscale_factor
                    .offset(mb_index as isize),
                &mut fps_factor,
                (*h).mb.i_mb_width,
            );
            if referenced != 0 {
                propagate_cost = propagate_cost.offset((*h).mb.i_mb_width as isize);
            }
            (*h).mc
                .mbtree_propagate_list
                .expect("non-null function pointer")(
                h,
                ref_costs[0 as ::core::ffi::c_int as usize],
                &mut *(*mvs.as_mut_ptr().offset(0 as ::core::ffi::c_int as isize))
                    .offset(mb_index as isize),
                buf,
                &mut *lowres_costs.offset(mb_index as isize),
                bipred_weights[0 as ::core::ffi::c_int as usize],
                (*h).mb.i_mb_y,
                (*h).mb.i_mb_width,
                0 as ::core::ffi::c_int,
            );
            if b != p1 {
                (*h).mc
                    .mbtree_propagate_list
                    .expect("non-null function pointer")(
                    h,
                    ref_costs[1 as ::core::ffi::c_int as usize],
                    &mut *(*mvs.as_mut_ptr().offset(1 as ::core::ffi::c_int as isize))
                        .offset(mb_index as isize),
                    buf,
                    &mut *lowres_costs.offset(mb_index as isize),
                    bipred_weights[1 as ::core::ffi::c_int as usize],
                    (*h).mb.i_mb_y,
                    (*h).mb.i_mb_width,
                    1 as ::core::ffi::c_int,
                );
            }
            (*h).mb.i_mb_y += 1;
        }
        if (*h).param.rc.i_vbv_buffer_size != 0 && (*h).param.rc.i_lookahead != 0 && referenced != 0
        {
            macroblock_tree_finish(
                h,
                *frames.offset(b as isize),
                average_duration,
                if b == p1 {
                    b - p0
                } else {
                    0 as ::core::ffi::c_int
                },
            );
        }
    }
    #[c2rust::src_loc = "1091:1"]
    pub unsafe extern "C" fn macroblock_tree(
        mut h: *mut x264_t,
        mut a: *mut x264_mb_analysis_t,
        mut frames: *mut *mut x264_frame_t,
        mut num_frames: ::core::ffi::c_int,
        mut b_intra: ::core::ffi::c_int,
    ) {
        let mut idx: ::core::ffi::c_int = (b_intra == 0) as ::core::ffi::c_int;
        let mut last_nonb: ::core::ffi::c_int = 0;
        let mut cur_nonb: ::core::ffi::c_int = 1 as ::core::ffi::c_int;
        let mut bframes: ::core::ffi::c_int = 0 as ::core::ffi::c_int;
        let mut total_duration: ::core::ffi::c_float = 0.0f32;
        let mut j: ::core::ffi::c_int = 0 as ::core::ffi::c_int;
        while j <= num_frames {
            total_duration += (**frames.offset(j as isize)).f_duration;
            j += 1;
        }
        let mut average_duration: ::core::ffi::c_float =
            total_duration / (num_frames + 1 as ::core::ffi::c_int) as ::core::ffi::c_float;
        let mut i: ::core::ffi::c_int = num_frames;
        if b_intra != 0 {
            slicetype_frame_cost(
                h,
                a,
                frames,
                0 as ::core::ffi::c_int,
                0 as ::core::ffi::c_int,
                0 as ::core::ffi::c_int,
            );
        }
        while i > 0 as ::core::ffi::c_int
            && ((**frames.offset(i as isize)).i_type == X264_TYPE_B
                || (**frames.offset(i as isize)).i_type == X264_TYPE_BREF)
        {
            i -= 1;
        }
        last_nonb = i;
        if (*h).param.rc.i_lookahead == 0 {
            if b_intra != 0 {
                memset(
                    (**frames.offset(0 as ::core::ffi::c_int as isize)).i_propagate_cost
                        as *mut ::core::ffi::c_void,
                    0 as ::core::ffi::c_int,
                    ((*h).mb.i_mb_count as size_t)
                        .wrapping_mul(::core::mem::size_of::<uint16_t>() as size_t),
                );
                memcpy(
                    (**frames.offset(0 as ::core::ffi::c_int as isize)).f_qp_offset
                        as *mut ::core::ffi::c_void,
                    (**frames.offset(0 as ::core::ffi::c_int as isize)).f_qp_offset_aq
                        as *const ::core::ffi::c_void,
                    ((*h).mb.i_mb_count as size_t)
                        .wrapping_mul(::core::mem::size_of::<::core::ffi::c_float>() as size_t),
                );
                return;
            }
            let mut t: *mut uint16_t = (**frames.offset(last_nonb as isize)).i_propagate_cost;
            let ref mut fresh21 = (**frames.offset(last_nonb as isize)).i_propagate_cost;
            *fresh21 = (**frames.offset(0 as ::core::ffi::c_int as isize)).i_propagate_cost;
            let ref mut fresh22 =
                (**frames.offset(0 as ::core::ffi::c_int as isize)).i_propagate_cost;
            *fresh22 = t;
            memset(
                (**frames.offset(0 as ::core::ffi::c_int as isize)).i_propagate_cost
                    as *mut ::core::ffi::c_void,
                0 as ::core::ffi::c_int,
                ((*h).mb.i_mb_count as size_t)
                    .wrapping_mul(::core::mem::size_of::<uint16_t>() as size_t),
            );
        } else {
            if last_nonb < idx {
                return;
            }
            memset(
                (**frames.offset(last_nonb as isize)).i_propagate_cost as *mut ::core::ffi::c_void,
                0 as ::core::ffi::c_int,
                ((*h).mb.i_mb_count as size_t)
                    .wrapping_mul(::core::mem::size_of::<uint16_t>() as size_t),
            );
        }
        loop {
            let fresh23 = i;
            i = i - 1;
            if !(fresh23 > idx) {
                break;
            }
            cur_nonb = i;
            while ((**frames.offset(cur_nonb as isize)).i_type == X264_TYPE_B
                || (**frames.offset(cur_nonb as isize)).i_type == X264_TYPE_BREF)
                && cur_nonb > 0 as ::core::ffi::c_int
            {
                cur_nonb -= 1;
            }
            if cur_nonb < idx {
                break;
            }
            slicetype_frame_cost(h, a, frames, cur_nonb, last_nonb, last_nonb);
            memset(
                (**frames.offset(cur_nonb as isize)).i_propagate_cost as *mut ::core::ffi::c_void,
                0 as ::core::ffi::c_int,
                ((*h).mb.i_mb_count as size_t)
                    .wrapping_mul(::core::mem::size_of::<uint16_t>() as size_t),
            );
            bframes = last_nonb - cur_nonb - 1 as ::core::ffi::c_int;
            if (*h).param.i_bframe_pyramid != 0 && bframes > 1 as ::core::ffi::c_int {
                let mut middle: ::core::ffi::c_int =
                    (bframes + 1 as ::core::ffi::c_int) / 2 as ::core::ffi::c_int + cur_nonb;
                slicetype_frame_cost(h, a, frames, cur_nonb, last_nonb, middle);
                memset(
                    (**frames.offset(middle as isize)).i_propagate_cost as *mut ::core::ffi::c_void,
                    0 as ::core::ffi::c_int,
                    ((*h).mb.i_mb_count as size_t)
                        .wrapping_mul(::core::mem::size_of::<uint16_t>() as size_t),
                );
                while i > cur_nonb {
                    let mut p0: ::core::ffi::c_int = if i > middle { middle } else { cur_nonb };
                    let mut p1: ::core::ffi::c_int = if i < middle { middle } else { last_nonb };
                    if i != middle {
                        slicetype_frame_cost(h, a, frames, p0, p1, i);
                        macroblock_tree_propagate(
                            h,
                            frames,
                            average_duration,
                            p0,
                            p1,
                            i,
                            0 as ::core::ffi::c_int,
                        );
                    }
                    i -= 1;
                }
                macroblock_tree_propagate(
                    h,
                    frames,
                    average_duration,
                    cur_nonb,
                    last_nonb,
                    middle,
                    1 as ::core::ffi::c_int,
                );
            } else {
                while i > cur_nonb {
                    slicetype_frame_cost(h, a, frames, cur_nonb, last_nonb, i);
                    macroblock_tree_propagate(
                        h,
                        frames,
                        average_duration,
                        cur_nonb,
                        last_nonb,
                        i,
                        0 as ::core::ffi::c_int,
                    );
                    i -= 1;
                }
            }
            macroblock_tree_propagate(
                h,
                frames,
                average_duration,
                cur_nonb,
                last_nonb,
                last_nonb,
                1 as ::core::ffi::c_int,
            );
            last_nonb = cur_nonb;
        }
        if (*h).param.rc.i_lookahead == 0 {
            slicetype_frame_cost(h, a, frames, 0 as ::core::ffi::c_int, last_nonb, last_nonb);
            macroblock_tree_propagate(
                h,
                frames,
                average_duration,
                0 as ::core::ffi::c_int,
                last_nonb,
                last_nonb,
                1 as ::core::ffi::c_int,
            );
            let mut t_0: *mut uint16_t = (**frames.offset(last_nonb as isize)).i_propagate_cost;
            let ref mut fresh24 = (**frames.offset(last_nonb as isize)).i_propagate_cost;
            *fresh24 = (**frames.offset(0 as ::core::ffi::c_int as isize)).i_propagate_cost;
            let ref mut fresh25 =
                (**frames.offset(0 as ::core::ffi::c_int as isize)).i_propagate_cost;
            *fresh25 = t_0;
        }
        macroblock_tree_finish(
            h,
            *frames.offset(last_nonb as isize),
            average_duration,
            last_nonb,
        );
        if (*h).param.i_bframe_pyramid != 0
            && bframes > 1 as ::core::ffi::c_int
            && (*h).param.rc.i_vbv_buffer_size == 0
        {
            macroblock_tree_finish(
                h,
                *frames.offset(
                    (last_nonb + (bframes + 1 as ::core::ffi::c_int) / 2 as ::core::ffi::c_int)
                        as isize,
                ),
                average_duration,
                0 as ::core::ffi::c_int,
            );
        }
    }
    #[c2rust::src_loc = "1186:1"]
    pub unsafe extern "C" fn vbv_frame_cost(
        mut h: *mut x264_t,
        mut a: *mut x264_mb_analysis_t,
        mut frames: *mut *mut x264_frame_t,
        mut p0: ::core::ffi::c_int,
        mut p1: ::core::ffi::c_int,
        mut b: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int {
        let mut cost: ::core::ffi::c_int = slicetype_frame_cost(h, a, frames, p0, p1, b);
        if (*h).param.rc.i_aq_mode != 0 {
            if (*h).param.rc.b_mb_tree != 0 {
                return slicetype_frame_cost_recalculate(h, frames, p0, p1, b);
            } else {
                return (**frames.offset(b as isize)).i_cost_est_aq[(b - p0) as usize]
                    [(p1 - b) as usize];
            }
        }
        return cost;
    }
    #[c2rust::src_loc = "1199:1"]
    pub unsafe extern "C" fn calculate_durations(
        mut h: *mut x264_t,
        mut cur_frame: *mut x264_frame_t,
        mut prev_frame: *mut x264_frame_t,
        mut i_cpb_delay: *mut int64_t,
        mut i_coded_fields: *mut int64_t,
    ) {
        (*cur_frame).i_cpb_delay = *i_cpb_delay;
        (*cur_frame).i_dpb_output_delay = (*cur_frame).i_field_cnt - *i_coded_fields;
        (*cur_frame).i_dpb_output_delay += ((*(*h).sps.as_mut_ptr()).vui.i_num_reorder_frames
            * 2 as ::core::ffi::c_int) as int64_t;
        if (*cur_frame).i_dpb_output_delay < 0 as int64_t {
            (*cur_frame).i_cpb_delay += (*cur_frame).i_dpb_output_delay;
            (*cur_frame).i_dpb_output_delay = 0 as int64_t;
            if !prev_frame.is_null() {
                (*prev_frame).i_cpb_duration += (*cur_frame).i_dpb_output_delay;
            }
        }
        if (*cur_frame).b_keyframe != 0 && (*h).param.b_intra_refresh == 0 {
            *i_cpb_delay = 0 as int64_t;
        }
        *i_cpb_delay += (*cur_frame).i_duration;
        *i_coded_fields += (*cur_frame).i_duration;
        (*cur_frame).i_cpb_duration = (*cur_frame).i_duration;
    }
    #[c2rust::src_loc = "1225:1"]
    pub unsafe extern "C" fn vbv_lookahead(
        mut h: *mut x264_t,
        mut a: *mut x264_mb_analysis_t,
        mut frames: *mut *mut x264_frame_t,
        mut num_frames: ::core::ffi::c_int,
        mut keyframe: ::core::ffi::c_int,
    ) {
        let mut last_nonb: ::core::ffi::c_int = 0 as ::core::ffi::c_int;
        let mut cur_nonb: ::core::ffi::c_int = 1 as ::core::ffi::c_int;
        let mut idx: ::core::ffi::c_int = 0 as ::core::ffi::c_int;
        let mut prev_frame: *mut x264_frame_t = 0 as *mut x264_frame_t;
        let mut prev_frame_idx: ::core::ffi::c_int = 0 as ::core::ffi::c_int;
        while cur_nonb < num_frames
            && ((**frames.offset(cur_nonb as isize)).i_type == X264_TYPE_B
                || (**frames.offset(cur_nonb as isize)).i_type == X264_TYPE_BREF)
        {
            cur_nonb += 1;
        }
        let mut next_nonb: ::core::ffi::c_int = if keyframe != 0 { last_nonb } else { cur_nonb };
        if (**frames.offset(cur_nonb as isize)).i_coded_fields_lookahead >= 0 as int64_t {
            (*h).i_coded_fields_lookahead =
                (**frames.offset(cur_nonb as isize)).i_coded_fields_lookahead;
            (*h).i_cpb_delay_lookahead = (**frames.offset(cur_nonb as isize)).i_cpb_delay_lookahead;
        }
        while cur_nonb < num_frames {
            if next_nonb != cur_nonb {
                let mut p0: ::core::ffi::c_int = if (**frames.offset(cur_nonb as isize)).i_type
                    == X264_TYPE_I
                    || (**frames.offset(cur_nonb as isize)).i_type == X264_TYPE_IDR
                    || (**frames.offset(cur_nonb as isize)).i_type == X264_TYPE_KEYFRAME
                {
                    cur_nonb
                } else {
                    last_nonb
                };
                (**frames.offset(next_nonb as isize)).i_planned_satd[idx as usize] =
                    vbv_frame_cost(h, a, frames, p0, cur_nonb, cur_nonb);
                (**frames.offset(next_nonb as isize)).i_planned_type[idx as usize] =
                    (**frames.offset(cur_nonb as isize)).i_type as uint8_t;
                (**frames.offset(cur_nonb as isize)).i_coded_fields_lookahead =
                    (*h).i_coded_fields_lookahead;
                (**frames.offset(cur_nonb as isize)).i_cpb_delay_lookahead =
                    (*h).i_cpb_delay_lookahead;
                calculate_durations(
                    h,
                    *frames.offset(cur_nonb as isize),
                    prev_frame,
                    &mut (*h).i_cpb_delay_lookahead,
                    &mut (*h).i_coded_fields_lookahead,
                );
                if !prev_frame.is_null() {
                    (**frames.offset(next_nonb as isize)).f_planned_cpb_duration
                        [prev_frame_idx as usize] = (*prev_frame).i_cpb_duration
                        as ::core::ffi::c_double
                        * (*(*h).sps.as_mut_ptr()).vui.i_num_units_in_tick as ::core::ffi::c_double
                        / (*(*h).sps.as_mut_ptr()).vui.i_time_scale as ::core::ffi::c_double;
                }
                (**frames.offset(next_nonb as isize)).f_planned_cpb_duration[idx as usize] =
                    (**frames.offset(cur_nonb as isize)).i_cpb_duration as ::core::ffi::c_double
                        * (*(*h).sps.as_mut_ptr()).vui.i_num_units_in_tick as ::core::ffi::c_double
                        / (*(*h).sps.as_mut_ptr()).vui.i_time_scale as ::core::ffi::c_double;
                prev_frame = *frames.offset(cur_nonb as isize);
                prev_frame_idx = idx;
                idx += 1;
            }
            let mut i: ::core::ffi::c_int = last_nonb + 1 as ::core::ffi::c_int;
            while i < cur_nonb {
                (**frames.offset(next_nonb as isize)).i_planned_satd[idx as usize] =
                    vbv_frame_cost(h, a, frames, last_nonb, cur_nonb, i);
                (**frames.offset(next_nonb as isize)).i_planned_type[idx as usize] =
                    X264_TYPE_B as uint8_t;
                (**frames.offset(i as isize)).i_coded_fields_lookahead =
                    (*h).i_coded_fields_lookahead;
                (**frames.offset(i as isize)).i_cpb_delay_lookahead = (*h).i_cpb_delay_lookahead;
                calculate_durations(
                    h,
                    *frames.offset(i as isize),
                    prev_frame,
                    &mut (*h).i_cpb_delay_lookahead,
                    &mut (*h).i_coded_fields_lookahead,
                );
                if !prev_frame.is_null() {
                    (**frames.offset(next_nonb as isize)).f_planned_cpb_duration
                        [prev_frame_idx as usize] = (*prev_frame).i_cpb_duration
                        as ::core::ffi::c_double
                        * (*(*h).sps.as_mut_ptr()).vui.i_num_units_in_tick as ::core::ffi::c_double
                        / (*(*h).sps.as_mut_ptr()).vui.i_time_scale as ::core::ffi::c_double;
                }
                (**frames.offset(next_nonb as isize)).f_planned_cpb_duration[idx as usize] =
                    (**frames.offset(i as isize)).i_cpb_duration as ::core::ffi::c_double
                        * (*(*h).sps.as_mut_ptr()).vui.i_num_units_in_tick as ::core::ffi::c_double
                        / (*(*h).sps.as_mut_ptr()).vui.i_time_scale as ::core::ffi::c_double;
                prev_frame = *frames.offset(i as isize);
                prev_frame_idx = idx;
                i += 1;
                idx += 1;
            }
            last_nonb = cur_nonb;
            cur_nonb += 1;
            while cur_nonb <= num_frames
                && ((**frames.offset(cur_nonb as isize)).i_type == X264_TYPE_B
                    || (**frames.offset(cur_nonb as isize)).i_type == X264_TYPE_BREF)
            {
                cur_nonb += 1;
            }
        }
        (**frames.offset(next_nonb as isize)).i_planned_type[idx as usize] =
            X264_TYPE_AUTO as uint8_t;
    }
    #[c2rust::src_loc = "1288:1"]
    pub unsafe extern "C" fn slicetype_path_cost(
        mut h: *mut x264_t,
        mut a: *mut x264_mb_analysis_t,
        mut frames: *mut *mut x264_frame_t,
        mut path: *mut ::core::ffi::c_char,
        mut threshold: uint64_t,
    ) -> uint64_t {
        let mut cost: uint64_t = 0 as uint64_t;
        let mut loc: ::core::ffi::c_int = 1 as ::core::ffi::c_int;
        let mut cur_nonb: ::core::ffi::c_int = 0 as ::core::ffi::c_int;
        path = path.offset(-1);
        while *path.offset(loc as isize) != 0 {
            let mut next_nonb: ::core::ffi::c_int = loc;
            while *path.offset(next_nonb as isize) as ::core::ffi::c_int == 'B' as i32 {
                next_nonb += 1;
            }
            if *path.offset(next_nonb as isize) as ::core::ffi::c_int == 'P' as i32 {
                cost = cost.wrapping_add(slicetype_frame_cost(
                    h, a, frames, cur_nonb, next_nonb, next_nonb,
                ) as uint64_t);
            } else {
                cost = cost.wrapping_add(slicetype_frame_cost(
                    h, a, frames, next_nonb, next_nonb, next_nonb,
                ) as uint64_t);
            }
            if cost > threshold {
                break;
            }
            if (*h).param.i_bframe_pyramid != 0 && next_nonb - cur_nonb > 2 as ::core::ffi::c_int {
                let mut middle: ::core::ffi::c_int =
                    cur_nonb + (next_nonb - cur_nonb) / 2 as ::core::ffi::c_int;
                cost = cost.wrapping_add(slicetype_frame_cost(
                    h, a, frames, cur_nonb, next_nonb, middle,
                ) as uint64_t);
                let mut next_b: ::core::ffi::c_int = loc;
                while next_b < middle && cost < threshold {
                    cost = cost
                        .wrapping_add(slicetype_frame_cost(h, a, frames, cur_nonb, middle, next_b)
                            as uint64_t);
                    next_b += 1;
                }
                let mut next_b_0: ::core::ffi::c_int = middle + 1 as ::core::ffi::c_int;
                while next_b_0 < next_nonb && cost < threshold {
                    cost = cost.wrapping_add(slicetype_frame_cost(
                        h, a, frames, middle, next_nonb, next_b_0,
                    ) as uint64_t);
                    next_b_0 += 1;
                }
            } else {
                let mut next_b_1: ::core::ffi::c_int = loc;
                while next_b_1 < next_nonb && cost < threshold {
                    cost = cost.wrapping_add(slicetype_frame_cost(
                        h, a, frames, cur_nonb, next_nonb, next_b_1,
                    ) as uint64_t);
                    next_b_1 += 1;
                }
            }
            loc = next_nonb + 1 as ::core::ffi::c_int;
            cur_nonb = next_nonb;
        }
        return cost;
    }
    #[c2rust::src_loc = "1333:1"]
    pub unsafe extern "C" fn slicetype_path(
        mut h: *mut x264_t,
        mut a: *mut x264_mb_analysis_t,
        mut frames: *mut *mut x264_frame_t,
        mut length: ::core::ffi::c_int,
        mut best_paths: *mut [::core::ffi::c_char; 251],
    ) {
        let mut paths: [[::core::ffi::c_char; 251]; 2] = [[0; 251]; 2];
        let mut num_paths: ::core::ffi::c_int =
            if ((*h).param.i_bframe + 1 as ::core::ffi::c_int) < length {
                (*h).param.i_bframe + 1 as ::core::ffi::c_int
            } else {
                length
            };
        let mut best_cost: uint64_t = COST_MAX64 as uint64_t;
        let mut best_possible: ::core::ffi::c_int = 0 as ::core::ffi::c_int;
        let mut idx: ::core::ffi::c_int = 0 as ::core::ffi::c_int;
        let mut path: ::core::ffi::c_int = 0 as ::core::ffi::c_int;
        while path < num_paths {
            let mut len: ::core::ffi::c_int = length - (path + 1 as ::core::ffi::c_int);
            memcpy(
                (*paths.as_mut_ptr().offset(idx as isize)).as_mut_ptr() as *mut ::core::ffi::c_void,
                (*best_paths.offset((len % (X264_BFRAME_MAX + 1 as ::core::ffi::c_int)) as isize))
                    .as_mut_ptr() as *const ::core::ffi::c_void,
                len as size_t,
            );
            memset(
                (*paths.as_mut_ptr().offset(idx as isize))
                    .as_mut_ptr()
                    .offset(len as isize) as *mut ::core::ffi::c_void,
                'B' as i32,
                path as size_t,
            );
            strcpy(
                (*paths.as_mut_ptr().offset(idx as isize))
                    .as_mut_ptr()
                    .offset(len as isize)
                    .offset(path as isize),
                b"P\0" as *const u8 as *const ::core::ffi::c_char,
            );
            let mut possible: ::core::ffi::c_int = 1 as ::core::ffi::c_int;
            let mut i: ::core::ffi::c_int = 1 as ::core::ffi::c_int;
            while i <= length {
                let mut i_type: ::core::ffi::c_int = (**frames.offset(i as isize)).i_type;
                if !(i_type == X264_TYPE_AUTO) {
                    if i_type == X264_TYPE_B || i_type == X264_TYPE_BREF {
                        possible = (possible != 0
                            && (i < len
                                || i == length
                                || paths[idx as usize][(i - 1 as ::core::ffi::c_int) as usize]
                                    as ::core::ffi::c_int
                                    == 'B' as i32))
                            as ::core::ffi::c_int;
                    } else {
                        possible = (possible != 0
                            && (i < len
                                || paths[idx as usize][(i - 1 as ::core::ffi::c_int) as usize]
                                    as ::core::ffi::c_int
                                    != 'B' as i32))
                            as ::core::ffi::c_int;
                        paths[idx as usize][(i - 1 as ::core::ffi::c_int) as usize] =
                            (if i_type == X264_TYPE_I
                                || i_type == X264_TYPE_IDR
                                || i_type == X264_TYPE_KEYFRAME
                            {
                                'I' as i32
                            } else {
                                'P' as i32
                            }) as ::core::ffi::c_char;
                    }
                }
                i += 1;
            }
            if possible != 0 || best_possible == 0 {
                if possible != 0 && best_possible == 0 {
                    best_cost = COST_MAX64 as uint64_t;
                }
                let mut cost: uint64_t = slicetype_path_cost(
                    h,
                    a,
                    frames,
                    (*paths.as_mut_ptr().offset(idx as isize)).as_mut_ptr(),
                    best_cost,
                );
                if cost < best_cost {
                    best_cost = cost;
                    best_possible = possible;
                    idx ^= 1 as ::core::ffi::c_int;
                }
            }
            path += 1;
        }
        memcpy(
            (*best_paths.offset((length % (X264_BFRAME_MAX + 1 as ::core::ffi::c_int)) as isize))
                .as_mut_ptr() as *mut ::core::ffi::c_void,
            (*paths
                .as_mut_ptr()
                .offset((idx ^ 1 as ::core::ffi::c_int) as isize))
            .as_mut_ptr() as *const ::core::ffi::c_void,
            length as size_t,
        );
    }
    #[c2rust::src_loc = "1384:1"]
    pub unsafe extern "C" fn scenecut_internal(
        mut h: *mut x264_t,
        mut a: *mut x264_mb_analysis_t,
        mut frames: *mut *mut x264_frame_t,
        mut p0: ::core::ffi::c_int,
        mut p1: ::core::ffi::c_int,
        mut real_scenecut: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int {
        let mut frame: *mut x264_frame_t = *frames.offset(p1 as isize);
        if real_scenecut != 0
            && (*h).param.i_frame_packing == 5 as ::core::ffi::c_int
            && (*frame).i_frame & 1 as ::core::ffi::c_int != 0
        {
            return 0 as ::core::ffi::c_int;
        }
        slicetype_frame_cost(h, a, frames, p0, p1, p1);
        let mut icost: ::core::ffi::c_int =
            (*frame).i_cost_est[0 as ::core::ffi::c_int as usize][0 as ::core::ffi::c_int as usize];
        let mut pcost: ::core::ffi::c_int =
            (*frame).i_cost_est[(p1 - p0) as usize][0 as ::core::ffi::c_int as usize];
        let mut f_bias: ::core::ffi::c_float = 0.;
        let mut i_gop_size: ::core::ffi::c_int =
            (*frame).i_frame - (*(*h).lookahead).i_last_keyframe;
        let mut f_thresh_max: ::core::ffi::c_float =
            ((*h).param.i_scenecut_threshold as ::core::ffi::c_double / 100.0f64)
                as ::core::ffi::c_float;
        let mut f_thresh_min: ::core::ffi::c_float =
            (f_thresh_max as ::core::ffi::c_double * 0.25f64) as ::core::ffi::c_float;
        let mut res: ::core::ffi::c_int = 0;
        if (*h).param.i_keyint_min == (*h).param.i_keyint_max {
            f_thresh_min = f_thresh_max;
        }
        if i_gop_size <= (*h).param.i_keyint_min / 4 as ::core::ffi::c_int
            || (*h).param.b_intra_refresh != 0
        {
            f_bias = f_thresh_min / 4 as ::core::ffi::c_int as ::core::ffi::c_float;
        } else if i_gop_size <= (*h).param.i_keyint_min {
            f_bias = f_thresh_min * i_gop_size as ::core::ffi::c_float
                / (*h).param.i_keyint_min as ::core::ffi::c_float;
        } else {
            f_bias = f_thresh_min
                + (f_thresh_max - f_thresh_min)
                    * (i_gop_size - (*h).param.i_keyint_min) as ::core::ffi::c_float
                    / ((*h).param.i_keyint_max - (*h).param.i_keyint_min) as ::core::ffi::c_float;
        }
        res = (pcost as ::core::ffi::c_double
            >= (1.0f64 - f_bias as ::core::ffi::c_double) * icost as ::core::ffi::c_double)
            as ::core::ffi::c_int;
        if res != 0 && real_scenecut != 0 {
            let mut imb: ::core::ffi::c_int = (*frame).i_intra_mbs[(p1 - p0) as usize];
            let mut pmb: ::core::ffi::c_int = (if (*h).mb.i_mb_width > 2 as ::core::ffi::c_int
                && (*h).mb.i_mb_height > 2 as ::core::ffi::c_int
            {
                ((*h).mb.i_mb_width - 2 as ::core::ffi::c_int)
                    * ((*h).mb.i_mb_height - 2 as ::core::ffi::c_int)
            } else {
                (*h).mb.i_mb_width * (*h).mb.i_mb_height
            }) - imb;
            x264_10_log(
                h,
                X264_LOG_DEBUG,
                b"scene cut at %d Icost:%d Pcost:%d ratio:%.4f bias:%.4f gop:%d (imb:%d pmb:%d)\n\0"
                    as *const u8 as *const ::core::ffi::c_char,
                (*frame).i_frame,
                icost,
                pcost,
                1.0f64 - pcost as ::core::ffi::c_double / icost as ::core::ffi::c_double,
                f_bias as ::core::ffi::c_double,
                i_gop_size,
                imb,
                pmb,
            );
        }
        return res;
    }
    #[c2rust::src_loc = "1430:1"]
    pub unsafe extern "C" fn scenecut(
        mut h: *mut x264_t,
        mut a: *mut x264_mb_analysis_t,
        mut frames: *mut *mut x264_frame_t,
        mut p0: ::core::ffi::c_int,
        mut p1: ::core::ffi::c_int,
        mut real_scenecut: ::core::ffi::c_int,
        mut num_frames: ::core::ffi::c_int,
        mut i_max_search: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int {
        if real_scenecut != 0 && (*h).param.i_bframe != 0 {
            let mut origmaxp1: ::core::ffi::c_int = p0 + 1 as ::core::ffi::c_int;
            if (*h).param.i_bframe_adaptive == X264_B_ADAPT_TRELLIS {
                origmaxp1 += (*h).param.i_bframe;
            } else {
                origmaxp1 += 1;
            }
            let mut maxp1: ::core::ffi::c_int = if origmaxp1 < num_frames {
                origmaxp1
            } else {
                num_frames
            };
            let mut curp1: ::core::ffi::c_int = p1;
            while curp1 <= maxp1 {
                if scenecut_internal(h, a, frames, p0, curp1, 0 as ::core::ffi::c_int) == 0 {
                    let mut i: ::core::ffi::c_int = curp1;
                    while i > p0 {
                        (**frames.offset(i as isize)).b_scenecut = 0 as ::core::ffi::c_int;
                        i -= 1;
                    }
                }
                curp1 += 1;
            }
            let mut curp0: ::core::ffi::c_int = p0;
            while curp0 <= maxp1 {
                if origmaxp1 > i_max_search
                    || curp0 < maxp1
                        && scenecut_internal(h, a, frames, curp0, maxp1, 0 as ::core::ffi::c_int)
                            != 0
                {
                    (**frames.offset(curp0 as isize)).b_scenecut = 0 as ::core::ffi::c_int;
                }
                curp0 += 1;
            }
        }
        if (**frames.offset(p1 as isize)).b_scenecut == 0 {
            return 0 as ::core::ffi::c_int;
        }
        return scenecut_internal(h, a, frames, p0, p1, real_scenecut);
    }
    #[no_mangle]
    #[c2rust::src_loc = "1473:1"]
    pub unsafe extern "C" fn x264_10_slicetype_analyse(
        mut h: *mut x264_t,
        mut intra_minigop: ::core::ffi::c_int,
    ) {
        let mut a: x264_mb_analysis_t = x264_mb_analysis_t {
            i_lambda: 0,
            i_lambda2: 0,
            i_qp: 0,
            p_cost_mv: 0 as *mut uint16_t,
            p_cost_ref: [0 as *mut uint16_t; 2],
            i_mbrd: 0,
            b_fast_intra: 0,
            b_force_intra: 0,
            b_avoid_topright: 0,
            b_try_skip: 0,
            i_satd_i16x16: 0,
            i_satd_i16x16_dir: [0; 7],
            i_predict16x16: 0,
            i_satd_i8x8: 0,
            i_cbp_i8x8_luma: 0,
            i_satd_i8x8_dir: [[0; 16]; 4],
            i_predict8x8: [0; 4],
            i_satd_i4x4: 0,
            i_predict4x4: [0; 16],
            i_satd_pcm: 0,
            i_satd_chroma: 0,
            i_satd_chroma_dir: [0; 7],
            i_predict8x8chroma: 0,
            l0: x264_mb_analysis_list_t {
                me16x16: x264_me_t {
                    i_pixel: 0,
                    p_cost_mv: 0 as *mut uint16_t,
                    i_ref_cost: 0,
                    i_ref: 0,
                    weight: 0 as *const x264_weight_t,
                    p_fref: [0 as *mut pixel; 12],
                    p_fref_w: 0 as *mut pixel,
                    p_fenc: [0 as *mut pixel; 3],
                    integral: 0 as *mut uint16_t,
                    i_stride: [0; 3],
                    mvp: [0; 2],
                    cost_mv: 0,
                    cost: 0,
                    mv: [0; 2],
                },
                bi16x16: x264_me_t {
                    i_pixel: 0,
                    p_cost_mv: 0 as *mut uint16_t,
                    i_ref_cost: 0,
                    i_ref: 0,
                    weight: 0 as *const x264_weight_t,
                    p_fref: [0 as *mut pixel; 12],
                    p_fref_w: 0 as *mut pixel,
                    p_fenc: [0 as *mut pixel; 3],
                    integral: 0 as *mut uint16_t,
                    i_stride: [0; 3],
                    mvp: [0; 2],
                    cost_mv: 0,
                    cost: 0,
                    mv: [0; 2],
                },
                me8x8: [x264_me_t {
                    i_pixel: 0,
                    p_cost_mv: 0 as *mut uint16_t,
                    i_ref_cost: 0,
                    i_ref: 0,
                    weight: 0 as *const x264_weight_t,
                    p_fref: [0 as *mut pixel; 12],
                    p_fref_w: 0 as *mut pixel,
                    p_fenc: [0 as *mut pixel; 3],
                    integral: 0 as *mut uint16_t,
                    i_stride: [0; 3],
                    mvp: [0; 2],
                    cost_mv: 0,
                    cost: 0,
                    mv: [0; 2],
                }; 4],
                me4x4: [[x264_me_t {
                    i_pixel: 0,
                    p_cost_mv: 0 as *mut uint16_t,
                    i_ref_cost: 0,
                    i_ref: 0,
                    weight: 0 as *const x264_weight_t,
                    p_fref: [0 as *mut pixel; 12],
                    p_fref_w: 0 as *mut pixel,
                    p_fenc: [0 as *mut pixel; 3],
                    integral: 0 as *mut uint16_t,
                    i_stride: [0; 3],
                    mvp: [0; 2],
                    cost_mv: 0,
                    cost: 0,
                    mv: [0; 2],
                }; 4]; 4],
                me8x4: [[x264_me_t {
                    i_pixel: 0,
                    p_cost_mv: 0 as *mut uint16_t,
                    i_ref_cost: 0,
                    i_ref: 0,
                    weight: 0 as *const x264_weight_t,
                    p_fref: [0 as *mut pixel; 12],
                    p_fref_w: 0 as *mut pixel,
                    p_fenc: [0 as *mut pixel; 3],
                    integral: 0 as *mut uint16_t,
                    i_stride: [0; 3],
                    mvp: [0; 2],
                    cost_mv: 0,
                    cost: 0,
                    mv: [0; 2],
                }; 2]; 4],
                me4x8: [[x264_me_t {
                    i_pixel: 0,
                    p_cost_mv: 0 as *mut uint16_t,
                    i_ref_cost: 0,
                    i_ref: 0,
                    weight: 0 as *const x264_weight_t,
                    p_fref: [0 as *mut pixel; 12],
                    p_fref_w: 0 as *mut pixel,
                    p_fenc: [0 as *mut pixel; 3],
                    integral: 0 as *mut uint16_t,
                    i_stride: [0; 3],
                    mvp: [0; 2],
                    cost_mv: 0,
                    cost: 0,
                    mv: [0; 2],
                }; 2]; 4],
                me16x8: [x264_me_t {
                    i_pixel: 0,
                    p_cost_mv: 0 as *mut uint16_t,
                    i_ref_cost: 0,
                    i_ref: 0,
                    weight: 0 as *const x264_weight_t,
                    p_fref: [0 as *mut pixel; 12],
                    p_fref_w: 0 as *mut pixel,
                    p_fenc: [0 as *mut pixel; 3],
                    integral: 0 as *mut uint16_t,
                    i_stride: [0; 3],
                    mvp: [0; 2],
                    cost_mv: 0,
                    cost: 0,
                    mv: [0; 2],
                }; 2],
                me8x16: [x264_me_t {
                    i_pixel: 0,
                    p_cost_mv: 0 as *mut uint16_t,
                    i_ref_cost: 0,
                    i_ref: 0,
                    weight: 0 as *const x264_weight_t,
                    p_fref: [0 as *mut pixel; 12],
                    p_fref_w: 0 as *mut pixel,
                    p_fenc: [0 as *mut pixel; 3],
                    integral: 0 as *mut uint16_t,
                    i_stride: [0; 3],
                    mvp: [0; 2],
                    cost_mv: 0,
                    cost: 0,
                    mv: [0; 2],
                }; 2],
                i_rd16x16: 0,
                i_cost8x8: 0,
                i_cost4x4: [0; 4],
                i_cost8x4: [0; 4],
                i_cost4x8: [0; 4],
                i_cost16x8: 0,
                i_cost8x16: 0,
                mvc: [[[0; 2]; 6]; 32],
            },
            l1: x264_mb_analysis_list_t {
                me16x16: x264_me_t {
                    i_pixel: 0,
                    p_cost_mv: 0 as *mut uint16_t,
                    i_ref_cost: 0,
                    i_ref: 0,
                    weight: 0 as *const x264_weight_t,
                    p_fref: [0 as *mut pixel; 12],
                    p_fref_w: 0 as *mut pixel,
                    p_fenc: [0 as *mut pixel; 3],
                    integral: 0 as *mut uint16_t,
                    i_stride: [0; 3],
                    mvp: [0; 2],
                    cost_mv: 0,
                    cost: 0,
                    mv: [0; 2],
                },
                bi16x16: x264_me_t {
                    i_pixel: 0,
                    p_cost_mv: 0 as *mut uint16_t,
                    i_ref_cost: 0,
                    i_ref: 0,
                    weight: 0 as *const x264_weight_t,
                    p_fref: [0 as *mut pixel; 12],
                    p_fref_w: 0 as *mut pixel,
                    p_fenc: [0 as *mut pixel; 3],
                    integral: 0 as *mut uint16_t,
                    i_stride: [0; 3],
                    mvp: [0; 2],
                    cost_mv: 0,
                    cost: 0,
                    mv: [0; 2],
                },
                me8x8: [x264_me_t {
                    i_pixel: 0,
                    p_cost_mv: 0 as *mut uint16_t,
                    i_ref_cost: 0,
                    i_ref: 0,
                    weight: 0 as *const x264_weight_t,
                    p_fref: [0 as *mut pixel; 12],
                    p_fref_w: 0 as *mut pixel,
                    p_fenc: [0 as *mut pixel; 3],
                    integral: 0 as *mut uint16_t,
                    i_stride: [0; 3],
                    mvp: [0; 2],
                    cost_mv: 0,
                    cost: 0,
                    mv: [0; 2],
                }; 4],
                me4x4: [[x264_me_t {
                    i_pixel: 0,
                    p_cost_mv: 0 as *mut uint16_t,
                    i_ref_cost: 0,
                    i_ref: 0,
                    weight: 0 as *const x264_weight_t,
                    p_fref: [0 as *mut pixel; 12],
                    p_fref_w: 0 as *mut pixel,
                    p_fenc: [0 as *mut pixel; 3],
                    integral: 0 as *mut uint16_t,
                    i_stride: [0; 3],
                    mvp: [0; 2],
                    cost_mv: 0,
                    cost: 0,
                    mv: [0; 2],
                }; 4]; 4],
                me8x4: [[x264_me_t {
                    i_pixel: 0,
                    p_cost_mv: 0 as *mut uint16_t,
                    i_ref_cost: 0,
                    i_ref: 0,
                    weight: 0 as *const x264_weight_t,
                    p_fref: [0 as *mut pixel; 12],
                    p_fref_w: 0 as *mut pixel,
                    p_fenc: [0 as *mut pixel; 3],
                    integral: 0 as *mut uint16_t,
                    i_stride: [0; 3],
                    mvp: [0; 2],
                    cost_mv: 0,
                    cost: 0,
                    mv: [0; 2],
                }; 2]; 4],
                me4x8: [[x264_me_t {
                    i_pixel: 0,
                    p_cost_mv: 0 as *mut uint16_t,
                    i_ref_cost: 0,
                    i_ref: 0,
                    weight: 0 as *const x264_weight_t,
                    p_fref: [0 as *mut pixel; 12],
                    p_fref_w: 0 as *mut pixel,
                    p_fenc: [0 as *mut pixel; 3],
                    integral: 0 as *mut uint16_t,
                    i_stride: [0; 3],
                    mvp: [0; 2],
                    cost_mv: 0,
                    cost: 0,
                    mv: [0; 2],
                }; 2]; 4],
                me16x8: [x264_me_t {
                    i_pixel: 0,
                    p_cost_mv: 0 as *mut uint16_t,
                    i_ref_cost: 0,
                    i_ref: 0,
                    weight: 0 as *const x264_weight_t,
                    p_fref: [0 as *mut pixel; 12],
                    p_fref_w: 0 as *mut pixel,
                    p_fenc: [0 as *mut pixel; 3],
                    integral: 0 as *mut uint16_t,
                    i_stride: [0; 3],
                    mvp: [0; 2],
                    cost_mv: 0,
                    cost: 0,
                    mv: [0; 2],
                }; 2],
                me8x16: [x264_me_t {
                    i_pixel: 0,
                    p_cost_mv: 0 as *mut uint16_t,
                    i_ref_cost: 0,
                    i_ref: 0,
                    weight: 0 as *const x264_weight_t,
                    p_fref: [0 as *mut pixel; 12],
                    p_fref_w: 0 as *mut pixel,
                    p_fenc: [0 as *mut pixel; 3],
                    integral: 0 as *mut uint16_t,
                    i_stride: [0; 3],
                    mvp: [0; 2],
                    cost_mv: 0,
                    cost: 0,
                    mv: [0; 2],
                }; 2],
                i_rd16x16: 0,
                i_cost8x8: 0,
                i_cost4x4: [0; 4],
                i_cost8x4: [0; 4],
                i_cost4x8: [0; 4],
                i_cost16x8: 0,
                i_cost8x16: 0,
                mvc: [[[0; 2]; 6]; 32],
            },
            i_cost16x16bi: 0,
            i_cost16x16direct: 0,
            i_cost8x8bi: 0,
            i_cost8x8direct: [0; 4],
            i_satd8x8: [[0; 4]; 3],
            i_cost_est16x8: [0; 2],
            i_cost_est8x16: [0; 2],
            i_cost16x8bi: 0,
            i_cost8x16bi: 0,
            i_rd16x16bi: 0,
            i_rd16x16direct: 0,
            i_rd16x8bi: 0,
            i_rd8x16bi: 0,
            i_rd8x8bi: 0,
            i_mb_partition16x8: [0; 2],
            i_mb_partition8x16: [0; 2],
            i_mb_type16x8: 0,
            i_mb_type8x16: 0,
            b_direct_available: 0,
            b_early_terminate: 0,
        };
        let mut frames: [*mut x264_frame_t; 253] = [
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
            0 as *mut x264_frame_t,
        ];
        let mut num_frames: ::core::ffi::c_int = 0;
        let mut orig_num_frames: ::core::ffi::c_int = 0;
        let mut keyint_limit: ::core::ffi::c_int = 0;
        let mut framecnt: ::core::ffi::c_int = 0;
        let mut i_max_search: ::core::ffi::c_int =
            if (*(*h).lookahead).next.i_size < 250 as ::core::ffi::c_int {
                (*(*h).lookahead).next.i_size
            } else {
                250 as ::core::ffi::c_int
            };
        let mut b_vbv_lookahead: ::core::ffi::c_int = ((*h).param.rc.i_vbv_buffer_size != 0
            && (*h).param.rc.i_lookahead != 0)
            as ::core::ffi::c_int;
        if (*h).param.b_deterministic != 0 {
            i_max_search = if i_max_search
                < (*(*h).lookahead).i_slicetype_length + 1 as ::core::ffi::c_int - intra_minigop
            {
                i_max_search
            } else {
                (*(*h).lookahead).i_slicetype_length + 1 as ::core::ffi::c_int - intra_minigop
            };
        }
        let mut keyframe: ::core::ffi::c_int = (intra_minigop != 0) as ::core::ffi::c_int;
        if (*h).frames.b_have_lowres != 0 {
        } else {
            __assert_fail(
                b"h->frames.b_have_lowres\0" as *const u8 as *const ::core::ffi::c_char,
                b"encoder/slicetype.c\0" as *const u8 as *const ::core::ffi::c_char,
                1488 as ::core::ffi::c_uint,
                ::core::mem::transmute::<[u8; 46], [::core::ffi::c_char; 46]>(
                    *b"void x264_10_slicetype_analyse(x264_t *, int)\0",
                )
                .as_ptr(),
            );
        }
        'c_125261: {
            if (*h).frames.b_have_lowres != 0 {
            } else {
                __assert_fail(
                    b"h->frames.b_have_lowres\0" as *const u8 as *const ::core::ffi::c_char,
                    b"encoder/slicetype.c\0" as *const u8 as *const ::core::ffi::c_char,
                    1488 as ::core::ffi::c_uint,
                    ::core::mem::transmute::<[u8; 46], [::core::ffi::c_char; 46]>(
                        *b"void x264_10_slicetype_analyse(x264_t *, int)\0",
                    )
                    .as_ptr(),
                );
            }
        };
        if (*(*h).lookahead).last_nonb.is_null() {
            return;
        }
        frames[0 as ::core::ffi::c_int as usize] = (*(*h).lookahead).last_nonb;
        framecnt = 0 as ::core::ffi::c_int;
        while framecnt < i_max_search {
            frames[(framecnt + 1 as ::core::ffi::c_int) as usize] =
                *(*(*h).lookahead).next.list.offset(framecnt as isize);
            framecnt += 1;
        }
        lowres_context_init(h, &mut a);
        if framecnt == 0 {
            if (*h).param.rc.b_mb_tree != 0 {
                macroblock_tree(
                    h,
                    &mut a,
                    frames.as_mut_ptr(),
                    0 as ::core::ffi::c_int,
                    keyframe,
                );
            }
            return;
        }
        keyint_limit = (*h).param.i_keyint_max
            - (*frames[0 as ::core::ffi::c_int as usize]).i_frame
            + (*(*h).lookahead).i_last_keyframe
            - 1 as ::core::ffi::c_int;
        num_frames = if (*h).param.b_intra_refresh != 0 {
            framecnt
        } else if framecnt < keyint_limit {
            framecnt
        } else {
            keyint_limit
        };
        orig_num_frames = num_frames;
        if (*h).param.analyse.b_psy != 0 && (*h).param.rc.b_mb_tree != 0 || b_vbv_lookahead != 0 {
            num_frames = framecnt;
        } else if (*h).param.b_open_gop != 0 && num_frames < framecnt {
            num_frames += 1;
        } else if num_frames == 0 as ::core::ffi::c_int {
            (*frames[1 as ::core::ffi::c_int as usize]).i_type = X264_TYPE_I;
            return;
        }
        if ((*frames[1 as ::core::ffi::c_int as usize]).i_type == X264_TYPE_AUTO
            || ((*frames[1 as ::core::ffi::c_int as usize]).i_type == X264_TYPE_I
                || (*frames[1 as ::core::ffi::c_int as usize]).i_type == X264_TYPE_IDR
                || (*frames[1 as ::core::ffi::c_int as usize]).i_type == X264_TYPE_KEYFRAME))
            && (*h).param.i_scenecut_threshold != 0
            && scenecut(
                h,
                &mut a,
                frames.as_mut_ptr(),
                0 as ::core::ffi::c_int,
                1 as ::core::ffi::c_int,
                1 as ::core::ffi::c_int,
                orig_num_frames,
                i_max_search,
            ) != 0
        {
            if (*frames[1 as ::core::ffi::c_int as usize]).i_type == X264_TYPE_AUTO {
                (*frames[1 as ::core::ffi::c_int as usize]).i_type = X264_TYPE_I;
            }
            return;
        }
        let mut j: ::core::ffi::c_int = 1 as ::core::ffi::c_int;
        while j <= num_frames {
            if (*frames[j as usize]).i_type == X264_TYPE_KEYFRAME {
                (*frames[j as usize]).i_type = if (*h).param.b_open_gop != 0 {
                    X264_TYPE_I
                } else {
                    X264_TYPE_IDR
                };
            }
            j += 1;
        }
        let mut j_0: ::core::ffi::c_int = 2 as ::core::ffi::c_int;
        while j_0 <= num_frames {
            if (*frames[j_0 as usize]).i_type == X264_TYPE_IDR
                && ((*frames[(j_0 - 1 as ::core::ffi::c_int) as usize]).i_type == X264_TYPE_AUTO
                    || ((*frames[(j_0 - 1 as ::core::ffi::c_int) as usize]).i_type == X264_TYPE_B
                        || (*frames[(j_0 - 1 as ::core::ffi::c_int) as usize]).i_type
                            == X264_TYPE_BREF))
            {
                (*frames[(j_0 - 1 as ::core::ffi::c_int) as usize]).i_type = X264_TYPE_P;
            }
            j_0 += 1;
        }
        let mut num_analysed_frames: ::core::ffi::c_int = num_frames;
        let mut reset_start: ::core::ffi::c_int = 0;
        if (*h).param.i_bframe != 0 {
            if (*h).param.i_bframe_adaptive == X264_B_ADAPT_TRELLIS {
                if num_frames > 1 as ::core::ffi::c_int {
                    let mut best_paths: [[::core::ffi::c_char; 251]; 17] = [
                        ::core::mem::transmute::<
                            [u8; 251],
                            [::core::ffi::c_char; 251],
                        >(
                            *b"\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0",
                        ),
                        ::core::mem::transmute::<
                            [u8; 251],
                            [::core::ffi::c_char; 251],
                        >(
                            *b"P\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0",
                        ),
                        [0; 251],
                        [0; 251],
                        [0; 251],
                        [0; 251],
                        [0; 251],
                        [0; 251],
                        [0; 251],
                        [0; 251],
                        [0; 251],
                        [0; 251],
                        [0; 251],
                        [0; 251],
                        [0; 251],
                        [0; 251],
                        [0; 251],
                    ];
                    let mut best_path_index: ::core::ffi::c_int =
                        num_frames % (X264_BFRAME_MAX + 1 as ::core::ffi::c_int);
                    let mut j_1: ::core::ffi::c_int = 2 as ::core::ffi::c_int;
                    while j_1 <= num_frames {
                        slicetype_path(
                            h,
                            &mut a,
                            frames.as_mut_ptr(),
                            j_1,
                            best_paths.as_mut_ptr() as *mut [::core::ffi::c_char; 251],
                        );
                        j_1 += 1;
                    }
                    let mut j_2: ::core::ffi::c_int = 1 as ::core::ffi::c_int;
                    while j_2 < num_frames {
                        if best_paths[best_path_index as usize]
                            [(j_2 - 1 as ::core::ffi::c_int) as usize]
                            as ::core::ffi::c_int
                            != 'B' as i32
                        {
                            if (*frames[j_2 as usize]).i_type == X264_TYPE_AUTO
                                || ((*frames[j_2 as usize]).i_type == X264_TYPE_B
                                    || (*frames[j_2 as usize]).i_type == X264_TYPE_BREF)
                            {
                                (*frames[j_2 as usize]).i_type = X264_TYPE_P;
                            }
                        } else if (*frames[j_2 as usize]).i_type == X264_TYPE_AUTO {
                            (*frames[j_2 as usize]).i_type = X264_TYPE_B;
                        }
                        j_2 += 1;
                    }
                }
            } else if (*h).param.i_bframe_adaptive == X264_B_ADAPT_FAST {
                let mut last_nonb: ::core::ffi::c_int = 0 as ::core::ffi::c_int;
                let mut num_bframes: ::core::ffi::c_int = (*h).param.i_bframe;
                let mut path: [::core::ffi::c_char; 251] = [0; 251];
                let mut j_3: ::core::ffi::c_int = 1 as ::core::ffi::c_int;
                while j_3 < num_frames {
                    if j_3 - 1 as ::core::ffi::c_int > 0 as ::core::ffi::c_int
                        && ((*frames[(j_3 - 1 as ::core::ffi::c_int) as usize]).i_type
                            == X264_TYPE_B
                            || (*frames[(j_3 - 1 as ::core::ffi::c_int) as usize]).i_type
                                == X264_TYPE_BREF)
                    {
                        num_bframes -= 1;
                    } else {
                        last_nonb = j_3 - 1 as ::core::ffi::c_int;
                        num_bframes = (*h).param.i_bframe;
                    }
                    if num_bframes == 0 {
                        if (*frames[j_3 as usize]).i_type == X264_TYPE_AUTO
                            || ((*frames[j_3 as usize]).i_type == X264_TYPE_B
                                || (*frames[j_3 as usize]).i_type == X264_TYPE_BREF)
                        {
                            (*frames[j_3 as usize]).i_type = X264_TYPE_P;
                        }
                    } else if !((*frames[j_3 as usize]).i_type != X264_TYPE_AUTO) {
                        if (*frames[(j_3 + 1 as ::core::ffi::c_int) as usize]).i_type == X264_TYPE_B
                            || (*frames[(j_3 + 1 as ::core::ffi::c_int) as usize]).i_type
                                == X264_TYPE_BREF
                        {
                            (*frames[j_3 as usize]).i_type = X264_TYPE_P;
                        } else {
                            let mut bframes: ::core::ffi::c_int =
                                j_3 - last_nonb - 1 as ::core::ffi::c_int;
                            memset(
                                path.as_mut_ptr() as *mut ::core::ffi::c_void,
                                'B' as i32,
                                bframes as size_t,
                            );
                            strcpy(
                                path.as_mut_ptr().offset(bframes as isize),
                                b"PP\0" as *const u8 as *const ::core::ffi::c_char,
                            );
                            let mut cost_p: uint64_t = slicetype_path_cost(
                                h,
                                &mut a,
                                frames.as_mut_ptr().offset(last_nonb as isize),
                                path.as_mut_ptr(),
                                COST_MAX64 as uint64_t,
                            );
                            strcpy(
                                path.as_mut_ptr().offset(bframes as isize),
                                b"BP\0" as *const u8 as *const ::core::ffi::c_char,
                            );
                            let mut cost_b: uint64_t = slicetype_path_cost(
                                h,
                                &mut a,
                                frames.as_mut_ptr().offset(last_nonb as isize),
                                path.as_mut_ptr(),
                                cost_p,
                            );
                            if cost_b < cost_p {
                                (*frames[j_3 as usize]).i_type = X264_TYPE_B;
                            } else {
                                (*frames[j_3 as usize]).i_type = X264_TYPE_P;
                            }
                        }
                    }
                    j_3 += 1;
                }
            } else {
                let mut num_bframes_0: ::core::ffi::c_int = (*h).param.i_bframe;
                let mut j_4: ::core::ffi::c_int = 1 as ::core::ffi::c_int;
                while j_4 < num_frames {
                    if num_bframes_0 == 0 {
                        if (*frames[j_4 as usize]).i_type == X264_TYPE_AUTO
                            || ((*frames[j_4 as usize]).i_type == X264_TYPE_B
                                || (*frames[j_4 as usize]).i_type == X264_TYPE_BREF)
                        {
                            (*frames[j_4 as usize]).i_type = X264_TYPE_P;
                        }
                    } else if (*frames[j_4 as usize]).i_type == X264_TYPE_AUTO {
                        if (*frames[(j_4 + 1 as ::core::ffi::c_int) as usize]).i_type == X264_TYPE_B
                            || (*frames[(j_4 + 1 as ::core::ffi::c_int) as usize]).i_type
                                == X264_TYPE_BREF
                        {
                            (*frames[j_4 as usize]).i_type = X264_TYPE_P;
                        } else {
                            (*frames[j_4 as usize]).i_type = X264_TYPE_B;
                        }
                    }
                    if (*frames[j_4 as usize]).i_type == X264_TYPE_B
                        || (*frames[j_4 as usize]).i_type == X264_TYPE_BREF
                    {
                        num_bframes_0 -= 1;
                    } else {
                        num_bframes_0 = (*h).param.i_bframe;
                    }
                    j_4 += 1;
                }
            }
            if (*frames[num_frames as usize]).i_type == X264_TYPE_AUTO
                || ((*frames[num_frames as usize]).i_type == X264_TYPE_B
                    || (*frames[num_frames as usize]).i_type == X264_TYPE_BREF)
            {
                (*frames[num_frames as usize]).i_type = X264_TYPE_P;
            }
            let mut num_bframes_1: ::core::ffi::c_int = 0 as ::core::ffi::c_int;
            while num_bframes_1 < num_frames
                && ((*frames[(num_bframes_1 + 1 as ::core::ffi::c_int) as usize]).i_type
                    == X264_TYPE_B
                    || (*frames[(num_bframes_1 + 1 as ::core::ffi::c_int) as usize]).i_type
                        == X264_TYPE_BREF)
            {
                num_bframes_1 += 1;
            }
            let mut j_5: ::core::ffi::c_int = 1 as ::core::ffi::c_int;
            while j_5 < num_bframes_1 + 1 as ::core::ffi::c_int {
                if (*frames[j_5 as usize]).i_forced_type == X264_TYPE_AUTO
                    && ((*frames[(j_5 + 1 as ::core::ffi::c_int) as usize]).i_forced_type
                        == X264_TYPE_AUTO
                        || ((*frames[(j_5 + 1 as ::core::ffi::c_int) as usize]).i_forced_type
                            == X264_TYPE_I
                            || (*frames[(j_5 + 1 as ::core::ffi::c_int) as usize]).i_forced_type
                                == X264_TYPE_IDR
                            || (*frames[(j_5 + 1 as ::core::ffi::c_int) as usize]).i_forced_type
                                == X264_TYPE_KEYFRAME))
                    && (*h).param.i_scenecut_threshold != 0
                    && scenecut(
                        h,
                        &mut a,
                        frames.as_mut_ptr(),
                        j_5,
                        j_5 + 1 as ::core::ffi::c_int,
                        0 as ::core::ffi::c_int,
                        orig_num_frames,
                        i_max_search,
                    ) != 0
                {
                    (*frames[j_5 as usize]).i_type = X264_TYPE_P;
                    num_analysed_frames = j_5;
                    break;
                } else {
                    j_5 += 1;
                }
            }
            reset_start = if keyframe != 0 {
                1 as ::core::ffi::c_int
            } else if (num_bframes_1 + 2 as ::core::ffi::c_int)
                < num_analysed_frames + 1 as ::core::ffi::c_int
            {
                num_bframes_1 + 2 as ::core::ffi::c_int
            } else {
                num_analysed_frames + 1 as ::core::ffi::c_int
            };
        } else {
            let mut j_6: ::core::ffi::c_int = 1 as ::core::ffi::c_int;
            while j_6 <= num_frames {
                if (*frames[j_6 as usize]).i_type == X264_TYPE_AUTO
                    || ((*frames[j_6 as usize]).i_type == X264_TYPE_B
                        || (*frames[j_6 as usize]).i_type == X264_TYPE_BREF)
                {
                    (*frames[j_6 as usize]).i_type = X264_TYPE_P;
                }
                j_6 += 1;
            }
            reset_start = (keyframe == 0) as ::core::ffi::c_int + 1 as ::core::ffi::c_int;
        }
        if (*h).param.rc.b_mb_tree != 0 {
            macroblock_tree(
                h,
                &mut a,
                frames.as_mut_ptr(),
                if num_frames < (*h).param.i_keyint_max {
                    num_frames
                } else {
                    (*h).param.i_keyint_max
                },
                keyframe,
            );
        }
        if (*h).param.b_intra_refresh == 0 {
            let mut last_keyframe: ::core::ffi::c_int = (*(*h).lookahead).i_last_keyframe;
            let mut last_possible: ::core::ffi::c_int = 0 as ::core::ffi::c_int;
            let mut j_7: ::core::ffi::c_int = 1 as ::core::ffi::c_int;
            while j_7 <= num_frames {
                let mut frm: *mut x264_frame_t = frames[j_7 as usize];
                let mut keyframe_dist: ::core::ffi::c_int = (*frm).i_frame - last_keyframe;
                if (*frm).i_forced_type == X264_TYPE_AUTO
                    || ((*frm).i_forced_type == X264_TYPE_I
                        || (*frm).i_forced_type == X264_TYPE_IDR
                        || (*frm).i_forced_type == X264_TYPE_KEYFRAME)
                {
                    if (*h).param.b_open_gop != 0
                        || !((*frames[(j_7 - 1 as ::core::ffi::c_int) as usize]).i_forced_type
                            == X264_TYPE_B
                            || (*frames[(j_7 - 1 as ::core::ffi::c_int) as usize]).i_forced_type
                                == X264_TYPE_BREF)
                    {
                        last_possible = j_7;
                    }
                }
                if keyframe_dist >= (*h).param.i_keyint_max {
                    if last_possible != 0 as ::core::ffi::c_int && last_possible != j_7 {
                        j_7 = last_possible;
                        frm = frames[j_7 as usize];
                        keyframe_dist = (*frm).i_frame - last_keyframe;
                    }
                    last_possible = 0 as ::core::ffi::c_int;
                    if (*frm).i_type != X264_TYPE_IDR {
                        (*frm).i_type = if (*h).param.b_open_gop != 0 {
                            X264_TYPE_I
                        } else {
                            X264_TYPE_IDR
                        };
                    }
                }
                if (*frm).i_type == X264_TYPE_I && keyframe_dist >= (*h).param.i_keyint_min {
                    if (*h).param.b_open_gop != 0 {
                        last_keyframe = (*frm).i_frame;
                        if (*h).param.b_bluray_compat != 0 {
                            let mut bframes_0: ::core::ffi::c_int = 0 as ::core::ffi::c_int;
                            while bframes_0 < j_7 - 1 as ::core::ffi::c_int
                                && ((*frames[(j_7 - 1 as ::core::ffi::c_int - bframes_0) as usize])
                                    .i_type
                                    == X264_TYPE_B
                                    || (*frames
                                        [(j_7 - 1 as ::core::ffi::c_int - bframes_0) as usize])
                                        .i_type
                                        == X264_TYPE_BREF)
                            {
                                bframes_0 += 1;
                            }
                            last_keyframe -= bframes_0;
                        }
                    } else if (*frm).i_forced_type != X264_TYPE_I {
                        (*frm).i_type = X264_TYPE_IDR;
                    }
                }
                if (*frm).i_type == X264_TYPE_IDR {
                    last_keyframe = (*frm).i_frame;
                    if j_7 > 1 as ::core::ffi::c_int
                        && ((*frames[(j_7 - 1 as ::core::ffi::c_int) as usize]).i_type
                            == X264_TYPE_B
                            || (*frames[(j_7 - 1 as ::core::ffi::c_int) as usize]).i_type
                                == X264_TYPE_BREF)
                    {
                        (*frames[(j_7 - 1 as ::core::ffi::c_int) as usize]).i_type = X264_TYPE_P;
                    }
                }
                j_7 += 1;
            }
        }
        if b_vbv_lookahead != 0 {
            vbv_lookahead(h, &mut a, frames.as_mut_ptr(), num_frames, keyframe);
        }
        let mut j_8: ::core::ffi::c_int = reset_start;
        while j_8 <= num_frames {
            (*frames[j_8 as usize]).i_type = (*frames[j_8 as usize]).i_forced_type;
            j_8 += 1;
        }
    }
    use crate::src::encoder::analyse::x264_mb_analysis_list_t;
    #[no_mangle]
    #[c2rust::src_loc = "1745:1"]
    pub unsafe extern "C" fn x264_10_slicetype_decide(mut h: *mut x264_t) {
        let mut frames: [*mut x264_frame_t; 18] = [0 as *mut x264_frame_t; 18];
        let mut frm: *mut x264_frame_t = 0 as *mut x264_frame_t;
        let mut bframes: ::core::ffi::c_int = 0;
        let mut brefs: ::core::ffi::c_int = 0;
        if (*(*h).lookahead).next.i_size == 0 {
            return;
        }
        let mut lookahead_size: ::core::ffi::c_int = (*(*h).lookahead).next.i_size;
        let mut i: ::core::ffi::c_int = 0 as ::core::ffi::c_int;
        while i < (*(*h).lookahead).next.i_size {
            if (*h).param.b_vfr_input != 0 {
                let fresh5 = lookahead_size;
                lookahead_size = lookahead_size - 1;
                if fresh5 > 1 as ::core::ffi::c_int {
                    (**(*(*h).lookahead).next.list.offset(i as isize)).i_duration = 2 as int64_t
                        * ((**(*(*h).lookahead)
                            .next
                            .list
                            .offset((i + 1 as ::core::ffi::c_int) as isize))
                        .i_pts
                            - (**(*(*h).lookahead).next.list.offset(i as isize)).i_pts);
                } else {
                    (**(*(*h).lookahead).next.list.offset(i as isize)).i_duration =
                        (*h).i_prev_duration;
                }
            } else {
                (**(*(*h).lookahead).next.list.offset(i as isize)).i_duration = delta_tfi_divisor
                    [(**(*(*h).lookahead).next.list.offset(i as isize)).i_pic_struct as usize]
                    as int64_t;
            }
            (*h).i_prev_duration = (**(*(*h).lookahead).next.list.offset(i as isize)).i_duration;
            (**(*(*h).lookahead).next.list.offset(i as isize)).f_duration =
                ((**(*(*h).lookahead).next.list.offset(i as isize)).i_duration
                    as ::core::ffi::c_double
                    * (*(*h).sps.as_mut_ptr()).vui.i_num_units_in_tick as ::core::ffi::c_double
                    / (*(*h).sps.as_mut_ptr()).vui.i_time_scale as ::core::ffi::c_double)
                    as ::core::ffi::c_float;
            if (**(*(*h).lookahead).next.list.offset(i as isize)).i_frame
                > (*h).i_disp_fields_last_frame
                && lookahead_size > 0 as ::core::ffi::c_int
            {
                (**(*(*h).lookahead).next.list.offset(i as isize)).i_field_cnt = (*h).i_disp_fields;
                (*h).i_disp_fields += (**(*(*h).lookahead).next.list.offset(i as isize)).i_duration;
                (*h).i_disp_fields_last_frame =
                    (**(*(*h).lookahead).next.list.offset(i as isize)).i_frame;
            } else if lookahead_size == 0 as ::core::ffi::c_int {
                (**(*(*h).lookahead).next.list.offset(i as isize)).i_field_cnt = (*h).i_disp_fields;
                (**(*(*h).lookahead).next.list.offset(i as isize)).i_duration =
                    (*h).i_prev_duration;
            }
            i += 1;
        }
        if (*h).param.rc.b_stat_read != 0 {
            let mut i_0: ::core::ffi::c_int = 0 as ::core::ffi::c_int;
            while i_0 < (*(*h).lookahead).next.i_size {
                (**(*(*h).lookahead).next.list.offset(i_0 as isize)).i_type =
                    x264_10_ratecontrol_slice_type(
                        h,
                        (**(*(*h).lookahead).next.list.offset(i_0 as isize)).i_frame,
                    );
                i_0 += 1;
            }
        } else if (*h).param.i_bframe != 0 && (*h).param.i_bframe_adaptive != 0
            || (*h).param.i_scenecut_threshold != 0
            || (*h).param.rc.b_mb_tree != 0
            || (*h).param.rc.i_vbv_buffer_size != 0 && (*h).param.rc.i_lookahead != 0
        {
            x264_10_slicetype_analyse(h, 0 as ::core::ffi::c_int);
        }
        bframes = 0 as ::core::ffi::c_int;
        brefs = 0 as ::core::ffi::c_int;
        loop {
            frm = *(*(*h).lookahead).next.list.offset(bframes as isize);
            if (*frm).i_forced_type != X264_TYPE_AUTO
                && (*frm).i_type != (*frm).i_forced_type
                && !((*frm).i_forced_type == X264_TYPE_KEYFRAME
                    && ((*frm).i_type == X264_TYPE_I
                        || (*frm).i_type == X264_TYPE_IDR
                        || (*frm).i_type == X264_TYPE_KEYFRAME))
            {
                x264_10_log(
                    h,
                    X264_LOG_WARNING,
                    b"forced frame type (%d) at %d was changed to frame type (%d)\n\0" as *const u8
                        as *const ::core::ffi::c_char,
                    (*frm).i_forced_type,
                    (*frm).i_frame,
                    (*frm).i_type,
                );
            }
            if (*frm).i_type == X264_TYPE_BREF
                && (*h).param.i_bframe_pyramid < X264_B_PYRAMID_NORMAL
                && brefs == (*h).param.i_bframe_pyramid
            {
                (*frm).i_type = X264_TYPE_B;
                x264_10_log(
                    h,
                    X264_LOG_WARNING,
                    b"B-ref at frame %d incompatible with B-pyramid %s \n\0" as *const u8
                        as *const ::core::ffi::c_char,
                    (*frm).i_frame,
                    x264_b_pyramid_names[(*h).param.i_bframe_pyramid as usize],
                );
            } else if (*frm).i_type == X264_TYPE_BREF
                && (*h).param.i_bframe_pyramid == X264_B_PYRAMID_NORMAL
                && brefs != 0
                && (*h).param.i_frame_reference <= brefs + 3 as ::core::ffi::c_int
            {
                (*frm).i_type = X264_TYPE_B;
                x264_10_log(
                    h,
                    X264_LOG_WARNING,
                    b"B-ref at frame %d incompatible with B-pyramid %s and %d reference frames\n\0"
                        as *const u8 as *const ::core::ffi::c_char,
                    (*frm).i_frame,
                    x264_b_pyramid_names[(*h).param.i_bframe_pyramid as usize],
                    (*h).param.i_frame_reference,
                );
            }
            if (*frm).i_type == X264_TYPE_KEYFRAME {
                (*frm).i_type = if (*h).param.b_open_gop != 0 {
                    X264_TYPE_I
                } else {
                    X264_TYPE_IDR
                };
            }
            if ((*h).param.b_intra_refresh == 0 || (*frm).i_frame == 0 as ::core::ffi::c_int)
                && (*frm).i_frame - (*(*h).lookahead).i_last_keyframe >= (*h).param.i_keyint_max
            {
                if (*frm).i_type == X264_TYPE_AUTO || (*frm).i_type == X264_TYPE_I {
                    (*frm).i_type = if (*h).param.b_open_gop != 0
                        && (*(*h).lookahead).i_last_keyframe >= 0 as ::core::ffi::c_int
                    {
                        X264_TYPE_I
                    } else {
                        X264_TYPE_IDR
                    };
                }
                let mut warn: ::core::ffi::c_int =
                    ((*frm).i_type != X264_TYPE_IDR) as ::core::ffi::c_int;
                if warn != 0 && (*h).param.b_open_gop != 0 {
                    warn &= ((*frm).i_type != X264_TYPE_I) as ::core::ffi::c_int;
                }
                if warn != 0 {
                    x264_10_log(
                        h,
                        X264_LOG_WARNING,
                        b"specified frame type (%d) at %d is not compatible with keyframe interval\n\0"
                            as *const u8 as *const ::core::ffi::c_char,
                        (*frm).i_type,
                        (*frm).i_frame,
                    );
                    (*frm).i_type = if (*h).param.b_open_gop != 0
                        && (*(*h).lookahead).i_last_keyframe >= 0 as ::core::ffi::c_int
                    {
                        X264_TYPE_I
                    } else {
                        X264_TYPE_IDR
                    };
                }
            }
            if (*frm).i_type == X264_TYPE_I
                && (*frm).i_frame - (*(*h).lookahead).i_last_keyframe >= (*h).param.i_keyint_min
            {
                if (*h).param.b_open_gop != 0 {
                    (*(*h).lookahead).i_last_keyframe = (*frm).i_frame;
                    if (*h).param.b_bluray_compat != 0 {
                        (*(*h).lookahead).i_last_keyframe -= bframes;
                    }
                    (*frm).b_keyframe = 1 as ::core::ffi::c_int;
                } else {
                    (*frm).i_type = X264_TYPE_IDR;
                }
            }
            if (*frm).i_type == X264_TYPE_IDR {
                (*(*h).lookahead).i_last_keyframe = (*frm).i_frame;
                (*frm).b_keyframe = 1 as ::core::ffi::c_int;
                if bframes > 0 as ::core::ffi::c_int {
                    bframes -= 1;
                    (**(*(*h).lookahead).next.list.offset(bframes as isize)).i_type = X264_TYPE_P;
                }
            }
            if bframes == (*h).param.i_bframe
                || (*(*(*h).lookahead)
                    .next
                    .list
                    .offset((bframes + 1 as ::core::ffi::c_int) as isize))
                .is_null()
            {
                if (*frm).i_type == X264_TYPE_B || (*frm).i_type == X264_TYPE_BREF {
                    x264_10_log(
                        h,
                        X264_LOG_WARNING,
                        b"specified frame type is not compatible with max B-frames\n\0" as *const u8
                            as *const ::core::ffi::c_char,
                    );
                }
                if (*frm).i_type == X264_TYPE_AUTO
                    || ((*frm).i_type == X264_TYPE_B || (*frm).i_type == X264_TYPE_BREF)
                {
                    (*frm).i_type = X264_TYPE_P;
                }
            }
            if (*frm).i_type == X264_TYPE_BREF {
                brefs += 1;
            }
            if (*frm).i_type == X264_TYPE_AUTO {
                (*frm).i_type = X264_TYPE_B;
            } else if !((*frm).i_type == X264_TYPE_B || (*frm).i_type == X264_TYPE_BREF) {
                break;
            }
            bframes += 1;
        }
        if bframes != 0 {
            (**(*(*h).lookahead)
                .next
                .list
                .offset((bframes - 1 as ::core::ffi::c_int) as isize))
            .b_last_minigop_bframe = 1 as uint8_t;
        }
        (**(*(*h).lookahead).next.list.offset(bframes as isize)).i_bframes = bframes as uint8_t;
        if (*h).param.i_bframe_pyramid != 0 && bframes > 1 as ::core::ffi::c_int && brefs == 0 {
            (**(*(*h).lookahead).next.list.offset(
                ((bframes - 1 as ::core::ffi::c_int) / 2 as ::core::ffi::c_int) as isize,
            ))
            .i_type = X264_TYPE_BREF;
            brefs += 1;
        }
        if (*h).param.rc.i_rc_method != X264_RC_CQP {
            let mut a: x264_mb_analysis_t = x264_mb_analysis_t {
                i_lambda: 0,
                i_lambda2: 0,
                i_qp: 0,
                p_cost_mv: 0 as *mut uint16_t,
                p_cost_ref: [0 as *mut uint16_t; 2],
                i_mbrd: 0,
                b_fast_intra: 0,
                b_force_intra: 0,
                b_avoid_topright: 0,
                b_try_skip: 0,
                i_satd_i16x16: 0,
                i_satd_i16x16_dir: [0; 7],
                i_predict16x16: 0,
                i_satd_i8x8: 0,
                i_cbp_i8x8_luma: 0,
                i_satd_i8x8_dir: [[0; 16]; 4],
                i_predict8x8: [0; 4],
                i_satd_i4x4: 0,
                i_predict4x4: [0; 16],
                i_satd_pcm: 0,
                i_satd_chroma: 0,
                i_satd_chroma_dir: [0; 7],
                i_predict8x8chroma: 0,
                l0: x264_mb_analysis_list_t {
                    me16x16: x264_me_t {
                        i_pixel: 0,
                        p_cost_mv: 0 as *mut uint16_t,
                        i_ref_cost: 0,
                        i_ref: 0,
                        weight: 0 as *const x264_weight_t,
                        p_fref: [0 as *mut pixel; 12],
                        p_fref_w: 0 as *mut pixel,
                        p_fenc: [0 as *mut pixel; 3],
                        integral: 0 as *mut uint16_t,
                        i_stride: [0; 3],
                        mvp: [0; 2],
                        cost_mv: 0,
                        cost: 0,
                        mv: [0; 2],
                    },
                    bi16x16: x264_me_t {
                        i_pixel: 0,
                        p_cost_mv: 0 as *mut uint16_t,
                        i_ref_cost: 0,
                        i_ref: 0,
                        weight: 0 as *const x264_weight_t,
                        p_fref: [0 as *mut pixel; 12],
                        p_fref_w: 0 as *mut pixel,
                        p_fenc: [0 as *mut pixel; 3],
                        integral: 0 as *mut uint16_t,
                        i_stride: [0; 3],
                        mvp: [0; 2],
                        cost_mv: 0,
                        cost: 0,
                        mv: [0; 2],
                    },
                    me8x8: [x264_me_t {
                        i_pixel: 0,
                        p_cost_mv: 0 as *mut uint16_t,
                        i_ref_cost: 0,
                        i_ref: 0,
                        weight: 0 as *const x264_weight_t,
                        p_fref: [0 as *mut pixel; 12],
                        p_fref_w: 0 as *mut pixel,
                        p_fenc: [0 as *mut pixel; 3],
                        integral: 0 as *mut uint16_t,
                        i_stride: [0; 3],
                        mvp: [0; 2],
                        cost_mv: 0,
                        cost: 0,
                        mv: [0; 2],
                    }; 4],
                    me4x4: [[x264_me_t {
                        i_pixel: 0,
                        p_cost_mv: 0 as *mut uint16_t,
                        i_ref_cost: 0,
                        i_ref: 0,
                        weight: 0 as *const x264_weight_t,
                        p_fref: [0 as *mut pixel; 12],
                        p_fref_w: 0 as *mut pixel,
                        p_fenc: [0 as *mut pixel; 3],
                        integral: 0 as *mut uint16_t,
                        i_stride: [0; 3],
                        mvp: [0; 2],
                        cost_mv: 0,
                        cost: 0,
                        mv: [0; 2],
                    }; 4]; 4],
                    me8x4: [[x264_me_t {
                        i_pixel: 0,
                        p_cost_mv: 0 as *mut uint16_t,
                        i_ref_cost: 0,
                        i_ref: 0,
                        weight: 0 as *const x264_weight_t,
                        p_fref: [0 as *mut pixel; 12],
                        p_fref_w: 0 as *mut pixel,
                        p_fenc: [0 as *mut pixel; 3],
                        integral: 0 as *mut uint16_t,
                        i_stride: [0; 3],
                        mvp: [0; 2],
                        cost_mv: 0,
                        cost: 0,
                        mv: [0; 2],
                    }; 2]; 4],
                    me4x8: [[x264_me_t {
                        i_pixel: 0,
                        p_cost_mv: 0 as *mut uint16_t,
                        i_ref_cost: 0,
                        i_ref: 0,
                        weight: 0 as *const x264_weight_t,
                        p_fref: [0 as *mut pixel; 12],
                        p_fref_w: 0 as *mut pixel,
                        p_fenc: [0 as *mut pixel; 3],
                        integral: 0 as *mut uint16_t,
                        i_stride: [0; 3],
                        mvp: [0; 2],
                        cost_mv: 0,
                        cost: 0,
                        mv: [0; 2],
                    }; 2]; 4],
                    me16x8: [x264_me_t {
                        i_pixel: 0,
                        p_cost_mv: 0 as *mut uint16_t,
                        i_ref_cost: 0,
                        i_ref: 0,
                        weight: 0 as *const x264_weight_t,
                        p_fref: [0 as *mut pixel; 12],
                        p_fref_w: 0 as *mut pixel,
                        p_fenc: [0 as *mut pixel; 3],
                        integral: 0 as *mut uint16_t,
                        i_stride: [0; 3],
                        mvp: [0; 2],
                        cost_mv: 0,
                        cost: 0,
                        mv: [0; 2],
                    }; 2],
                    me8x16: [x264_me_t {
                        i_pixel: 0,
                        p_cost_mv: 0 as *mut uint16_t,
                        i_ref_cost: 0,
                        i_ref: 0,
                        weight: 0 as *const x264_weight_t,
                        p_fref: [0 as *mut pixel; 12],
                        p_fref_w: 0 as *mut pixel,
                        p_fenc: [0 as *mut pixel; 3],
                        integral: 0 as *mut uint16_t,
                        i_stride: [0; 3],
                        mvp: [0; 2],
                        cost_mv: 0,
                        cost: 0,
                        mv: [0; 2],
                    }; 2],
                    i_rd16x16: 0,
                    i_cost8x8: 0,
                    i_cost4x4: [0; 4],
                    i_cost8x4: [0; 4],
                    i_cost4x8: [0; 4],
                    i_cost16x8: 0,
                    i_cost8x16: 0,
                    mvc: [[[0; 2]; 6]; 32],
                },
                l1: x264_mb_analysis_list_t {
                    me16x16: x264_me_t {
                        i_pixel: 0,
                        p_cost_mv: 0 as *mut uint16_t,
                        i_ref_cost: 0,
                        i_ref: 0,
                        weight: 0 as *const x264_weight_t,
                        p_fref: [0 as *mut pixel; 12],
                        p_fref_w: 0 as *mut pixel,
                        p_fenc: [0 as *mut pixel; 3],
                        integral: 0 as *mut uint16_t,
                        i_stride: [0; 3],
                        mvp: [0; 2],
                        cost_mv: 0,
                        cost: 0,
                        mv: [0; 2],
                    },
                    bi16x16: x264_me_t {
                        i_pixel: 0,
                        p_cost_mv: 0 as *mut uint16_t,
                        i_ref_cost: 0,
                        i_ref: 0,
                        weight: 0 as *const x264_weight_t,
                        p_fref: [0 as *mut pixel; 12],
                        p_fref_w: 0 as *mut pixel,
                        p_fenc: [0 as *mut pixel; 3],
                        integral: 0 as *mut uint16_t,
                        i_stride: [0; 3],
                        mvp: [0; 2],
                        cost_mv: 0,
                        cost: 0,
                        mv: [0; 2],
                    },
                    me8x8: [x264_me_t {
                        i_pixel: 0,
                        p_cost_mv: 0 as *mut uint16_t,
                        i_ref_cost: 0,
                        i_ref: 0,
                        weight: 0 as *const x264_weight_t,
                        p_fref: [0 as *mut pixel; 12],
                        p_fref_w: 0 as *mut pixel,
                        p_fenc: [0 as *mut pixel; 3],
                        integral: 0 as *mut uint16_t,
                        i_stride: [0; 3],
                        mvp: [0; 2],
                        cost_mv: 0,
                        cost: 0,
                        mv: [0; 2],
                    }; 4],
                    me4x4: [[x264_me_t {
                        i_pixel: 0,
                        p_cost_mv: 0 as *mut uint16_t,
                        i_ref_cost: 0,
                        i_ref: 0,
                        weight: 0 as *const x264_weight_t,
                        p_fref: [0 as *mut pixel; 12],
                        p_fref_w: 0 as *mut pixel,
                        p_fenc: [0 as *mut pixel; 3],
                        integral: 0 as *mut uint16_t,
                        i_stride: [0; 3],
                        mvp: [0; 2],
                        cost_mv: 0,
                        cost: 0,
                        mv: [0; 2],
                    }; 4]; 4],
                    me8x4: [[x264_me_t {
                        i_pixel: 0,
                        p_cost_mv: 0 as *mut uint16_t,
                        i_ref_cost: 0,
                        i_ref: 0,
                        weight: 0 as *const x264_weight_t,
                        p_fref: [0 as *mut pixel; 12],
                        p_fref_w: 0 as *mut pixel,
                        p_fenc: [0 as *mut pixel; 3],
                        integral: 0 as *mut uint16_t,
                        i_stride: [0; 3],
                        mvp: [0; 2],
                        cost_mv: 0,
                        cost: 0,
                        mv: [0; 2],
                    }; 2]; 4],
                    me4x8: [[x264_me_t {
                        i_pixel: 0,
                        p_cost_mv: 0 as *mut uint16_t,
                        i_ref_cost: 0,
                        i_ref: 0,
                        weight: 0 as *const x264_weight_t,
                        p_fref: [0 as *mut pixel; 12],
                        p_fref_w: 0 as *mut pixel,
                        p_fenc: [0 as *mut pixel; 3],
                        integral: 0 as *mut uint16_t,
                        i_stride: [0; 3],
                        mvp: [0; 2],
                        cost_mv: 0,
                        cost: 0,
                        mv: [0; 2],
                    }; 2]; 4],
                    me16x8: [x264_me_t {
                        i_pixel: 0,
                        p_cost_mv: 0 as *mut uint16_t,
                        i_ref_cost: 0,
                        i_ref: 0,
                        weight: 0 as *const x264_weight_t,
                        p_fref: [0 as *mut pixel; 12],
                        p_fref_w: 0 as *mut pixel,
                        p_fenc: [0 as *mut pixel; 3],
                        integral: 0 as *mut uint16_t,
                        i_stride: [0; 3],
                        mvp: [0; 2],
                        cost_mv: 0,
                        cost: 0,
                        mv: [0; 2],
                    }; 2],
                    me8x16: [x264_me_t {
                        i_pixel: 0,
                        p_cost_mv: 0 as *mut uint16_t,
                        i_ref_cost: 0,
                        i_ref: 0,
                        weight: 0 as *const x264_weight_t,
                        p_fref: [0 as *mut pixel; 12],
                        p_fref_w: 0 as *mut pixel,
                        p_fenc: [0 as *mut pixel; 3],
                        integral: 0 as *mut uint16_t,
                        i_stride: [0; 3],
                        mvp: [0; 2],
                        cost_mv: 0,
                        cost: 0,
                        mv: [0; 2],
                    }; 2],
                    i_rd16x16: 0,
                    i_cost8x8: 0,
                    i_cost4x4: [0; 4],
                    i_cost8x4: [0; 4],
                    i_cost4x8: [0; 4],
                    i_cost16x8: 0,
                    i_cost8x16: 0,
                    mvc: [[[0; 2]; 6]; 32],
                },
                i_cost16x16bi: 0,
                i_cost16x16direct: 0,
                i_cost8x8bi: 0,
                i_cost8x8direct: [0; 4],
                i_satd8x8: [[0; 4]; 3],
                i_cost_est16x8: [0; 2],
                i_cost_est8x16: [0; 2],
                i_cost16x8bi: 0,
                i_cost8x16bi: 0,
                i_rd16x16bi: 0,
                i_rd16x16direct: 0,
                i_rd16x8bi: 0,
                i_rd8x16bi: 0,
                i_rd8x8bi: 0,
                i_mb_partition16x8: [0; 2],
                i_mb_partition8x16: [0; 2],
                i_mb_type16x8: 0,
                i_mb_type8x16: 0,
                b_direct_available: 0,
                b_early_terminate: 0,
            };
            let mut p0: ::core::ffi::c_int = 0;
            let mut p1: ::core::ffi::c_int = 0;
            let mut b: ::core::ffi::c_int = 0;
            b = bframes + 1 as ::core::ffi::c_int;
            p1 = b;
            lowres_context_init(h, &mut a);
            frames[0 as ::core::ffi::c_int as usize] = (*(*h).lookahead).last_nonb;
            memcpy(
                &mut *frames.as_mut_ptr().offset(1 as ::core::ffi::c_int as isize)
                    as *mut *mut x264_frame_t as *mut ::core::ffi::c_void,
                (*(*h).lookahead).next.list as *const ::core::ffi::c_void,
                ((bframes + 1 as ::core::ffi::c_int) as size_t)
                    .wrapping_mul(::core::mem::size_of::<*mut x264_frame_t>() as size_t),
            );
            if (**(*(*h).lookahead).next.list.offset(bframes as isize)).i_type == X264_TYPE_I
                || (**(*(*h).lookahead).next.list.offset(bframes as isize)).i_type == X264_TYPE_IDR
                || (**(*(*h).lookahead).next.list.offset(bframes as isize)).i_type
                    == X264_TYPE_KEYFRAME
            {
                p0 = bframes + 1 as ::core::ffi::c_int;
            } else {
                p0 = 0 as ::core::ffi::c_int;
            }
            slicetype_frame_cost(h, &mut a, frames.as_mut_ptr(), p0, p1, b);
            if (p0 != p1 || bframes != 0) && (*h).param.rc.i_vbv_buffer_size != 0 {
                slicetype_frame_cost(h, &mut a, frames.as_mut_ptr(), b, b, b);
                p0 = 0 as ::core::ffi::c_int;
                b = 1 as ::core::ffi::c_int;
                while b <= bframes {
                    if (*frames[b as usize]).i_type == X264_TYPE_B {
                        p1 = b;
                        while (*frames[p1 as usize]).i_type == X264_TYPE_B {
                            p1 += 1;
                        }
                    } else {
                        p1 = bframes + 1 as ::core::ffi::c_int;
                    }
                    slicetype_frame_cost(h, &mut a, frames.as_mut_ptr(), p0, p1, b);
                    if (*frames[b as usize]).i_type == X264_TYPE_BREF {
                        p0 = b;
                    }
                    b += 1;
                }
            }
        }
        if (*h).param.rc.b_stat_read == 0
            && (**(*(*h).lookahead).next.list.offset(bframes as isize)).i_type == X264_TYPE_P
            && (*h).param.analyse.i_weighted_pred >= X264_WEIGHTP_SIMPLE
        {
            x264_10_weights_analyse(
                h,
                *(*(*h).lookahead).next.list.offset(bframes as isize),
                (*(*h).lookahead).last_nonb,
                0 as ::core::ffi::c_int,
            );
        }
        let mut i_coded: ::core::ffi::c_int = (**(*(*h).lookahead)
            .next
            .list
            .offset(0 as ::core::ffi::c_int as isize))
        .i_frame;
        if bframes != 0 {
            let mut idx_list: [::core::ffi::c_int; 2] =
                [brefs + 1 as ::core::ffi::c_int, 1 as ::core::ffi::c_int];
            let mut i_1: ::core::ffi::c_int = 0 as ::core::ffi::c_int;
            while i_1 < bframes {
                let fresh6 = idx_list[((**(*(*h).lookahead).next.list.offset(i_1 as isize)).i_type
                    == X264_TYPE_BREF) as ::core::ffi::c_int
                    as usize];
                idx_list[((**(*(*h).lookahead).next.list.offset(i_1 as isize)).i_type
                    == X264_TYPE_BREF) as ::core::ffi::c_int as usize] =
                    idx_list[((**(*(*h).lookahead).next.list.offset(i_1 as isize)).i_type
                        == X264_TYPE_BREF) as ::core::ffi::c_int
                        as usize]
                        + 1;
                let mut idx: ::core::ffi::c_int = fresh6;
                frames[idx as usize] = *(*(*h).lookahead).next.list.offset(i_1 as isize);
                (*frames[idx as usize]).i_reordered_pts =
                    (**(*(*h).lookahead).next.list.offset(idx as isize)).i_pts;
                i_1 += 1;
            }
            frames[0 as ::core::ffi::c_int as usize] =
                *(*(*h).lookahead).next.list.offset(bframes as isize);
            (*frames[0 as ::core::ffi::c_int as usize]).i_reordered_pts = (**(*(*h).lookahead)
                .next
                .list
                .offset(0 as ::core::ffi::c_int as isize))
            .i_pts;
            memcpy(
                (*(*h).lookahead).next.list as *mut ::core::ffi::c_void,
                frames.as_mut_ptr() as *const ::core::ffi::c_void,
                ((bframes + 1 as ::core::ffi::c_int) as size_t)
                    .wrapping_mul(::core::mem::size_of::<*mut x264_frame_t>() as size_t),
            );
        }
        let mut i_2: ::core::ffi::c_int = 0 as ::core::ffi::c_int;
        while i_2 <= bframes {
            let fresh7 = i_coded;
            i_coded = i_coded + 1;
            (**(*(*h).lookahead).next.list.offset(i_2 as isize)).i_coded = fresh7;
            if i_2 != 0 {
                calculate_durations(
                    h,
                    *(*(*h).lookahead).next.list.offset(i_2 as isize),
                    *(*(*h).lookahead)
                        .next
                        .list
                        .offset((i_2 - 1 as ::core::ffi::c_int) as isize),
                    &mut (*h).i_cpb_delay,
                    &mut (*h).i_coded_fields,
                );
                (**(*(*h).lookahead)
                    .next
                    .list
                    .offset(0 as ::core::ffi::c_int as isize))
                .f_planned_cpb_duration[(i_2 - 1 as ::core::ffi::c_int) as usize] =
                    (**(*(*h).lookahead).next.list.offset(i_2 as isize)).i_cpb_duration
                        as ::core::ffi::c_double
                        * (*(*h).sps.as_mut_ptr()).vui.i_num_units_in_tick as ::core::ffi::c_double
                        / (*(*h).sps.as_mut_ptr()).vui.i_time_scale as ::core::ffi::c_double;
            } else {
                calculate_durations(
                    h,
                    *(*(*h).lookahead).next.list.offset(i_2 as isize),
                    0 as *mut x264_frame_t,
                    &mut (*h).i_cpb_delay,
                    &mut (*h).i_coded_fields,
                );
            }
            i_2 += 1;
        }
    }
    #[no_mangle]
    #[c2rust::src_loc = "1976:1"]
    pub unsafe extern "C" fn x264_10_rc_analyse_slice(mut h: *mut x264_t) -> ::core::ffi::c_int {
        let mut p0: ::core::ffi::c_int = 0 as ::core::ffi::c_int;
        let mut p1: ::core::ffi::c_int = 0;
        let mut b: ::core::ffi::c_int = 0;
        let mut cost: ::core::ffi::c_int = 0;
        if (*(*h).fenc).i_type == X264_TYPE_I
            || (*(*h).fenc).i_type == X264_TYPE_IDR
            || (*(*h).fenc).i_type == X264_TYPE_KEYFRAME
        {
            b = 0 as ::core::ffi::c_int;
            p1 = b;
        } else if (*(*h).fenc).i_type == X264_TYPE_P {
            b = (*(*h).fenc).i_bframes as ::core::ffi::c_int + 1 as ::core::ffi::c_int;
            p1 = b;
        } else {
            p1 = ((*(*h).fref_nearest[1 as ::core::ffi::c_int as usize]).i_poc
                - (*(*h).fref_nearest[0 as ::core::ffi::c_int as usize]).i_poc)
                / 2 as ::core::ffi::c_int;
            b = ((*(*h).fenc).i_poc - (*(*h).fref_nearest[0 as ::core::ffi::c_int as usize]).i_poc)
                / 2 as ::core::ffi::c_int;
        }
        let mut frames: *mut *mut x264_frame_t =
            (&mut (*h).fenc as *mut *mut x264_frame_t).offset(-(b as isize));
        cost = (**frames.offset(b as isize)).i_cost_est[(b - p0) as usize][(p1 - b) as usize];
        if cost >= 0 as ::core::ffi::c_int {
        } else {
            __assert_fail(
                b"cost >= 0\0" as *const u8 as *const ::core::ffi::c_char,
                b"encoder/slicetype.c\0" as *const u8 as *const ::core::ffi::c_char,
                1996 as ::core::ffi::c_uint,
                ::core::mem::transmute::<[u8; 39], [::core::ffi::c_char; 39]>(
                    *b"int x264_10_rc_analyse_slice(x264_t *)\0",
                )
                .as_ptr(),
            );
        }
        'c_55672: {
            if cost >= 0 as ::core::ffi::c_int {
            } else {
                __assert_fail(
                    b"cost >= 0\0" as *const u8 as *const ::core::ffi::c_char,
                    b"encoder/slicetype.c\0" as *const u8 as *const ::core::ffi::c_char,
                    1996 as ::core::ffi::c_uint,
                    ::core::mem::transmute::<[u8; 39], [::core::ffi::c_char; 39]>(
                        *b"int x264_10_rc_analyse_slice(x264_t *)\0",
                    )
                    .as_ptr(),
                );
            }
        };
        if (*h).param.rc.b_mb_tree != 0 && (*h).param.rc.b_stat_read == 0 {
            cost = slicetype_frame_cost_recalculate(h, frames, p0, p1, b);
            if b != 0 && (*h).param.rc.i_vbv_buffer_size != 0 {
                slicetype_frame_cost_recalculate(h, frames, b, b, b);
            }
        } else if (*h).param.rc.i_aq_mode != 0 {
            cost =
                (**frames.offset(b as isize)).i_cost_est_aq[(b - p0) as usize][(p1 - b) as usize];
        }
        (*(*h).fenc).i_row_satd = (*(*h).fenc).i_row_satds[(b - p0) as usize][(p1 - b) as usize];
        (*(*h).fdec).i_row_satd = (*(*h).fdec).i_row_satds[(b - p0) as usize][(p1 - b) as usize];
        (*(*h).fdec).i_satd = cost;
        memcpy(
            (*(*h).fdec).i_row_satd as *mut ::core::ffi::c_void,
            (*(*h).fenc).i_row_satd as *const ::core::ffi::c_void,
            ((*h).mb.i_mb_height as size_t)
                .wrapping_mul(::core::mem::size_of::<::core::ffi::c_int>() as size_t),
        );
        if !((*(*h).fenc).i_type == X264_TYPE_I
            || (*(*h).fenc).i_type == X264_TYPE_IDR
            || (*(*h).fenc).i_type == X264_TYPE_KEYFRAME)
        {
            memcpy(
                (*(*h).fdec).i_row_satds[0 as ::core::ffi::c_int as usize]
                    [0 as ::core::ffi::c_int as usize] as *mut ::core::ffi::c_void,
                (*(*h).fenc).i_row_satds[0 as ::core::ffi::c_int as usize]
                    [0 as ::core::ffi::c_int as usize]
                    as *const ::core::ffi::c_void,
                ((*h).mb.i_mb_height as size_t)
                    .wrapping_mul(::core::mem::size_of::<::core::ffi::c_int>() as size_t),
            );
        }
        if (*h).param.b_intra_refresh != 0
            && (*h).param.rc.i_vbv_buffer_size != 0
            && (*(*h).fenc).i_type == X264_TYPE_P
        {
            let mut ip_factor: ::core::ffi::c_int =
                (256 as ::core::ffi::c_int as ::core::ffi::c_float * (*h).param.rc.f_ip_factor)
                    as ::core::ffi::c_int;
            let mut y: ::core::ffi::c_int = 0 as ::core::ffi::c_int;
            while y < (*h).mb.i_mb_height {
                let mut mb_xy: ::core::ffi::c_int =
                    y * (*h).mb.i_mb_stride + (*(*h).fdec).i_pir_start_col;
                let mut x: ::core::ffi::c_int = (*(*h).fdec).i_pir_start_col;
                while x <= (*(*h).fdec).i_pir_end_col {
                    let mut intra_cost: ::core::ffi::c_int =
                        *(*(*h).fenc).i_intra_cost.offset(mb_xy as isize) as ::core::ffi::c_int
                            * ip_factor
                            + 128 as ::core::ffi::c_int
                            >> 8 as ::core::ffi::c_int;
                    let mut inter_cost: ::core::ffi::c_int =
                        *(*(*h).fenc).lowres_costs[(b - p0) as usize][(p1 - b) as usize]
                            .offset(mb_xy as isize) as ::core::ffi::c_int
                            & LOWRES_COST_MASK;
                    let mut diff: ::core::ffi::c_int = intra_cost - inter_cost;
                    if (*h).param.rc.i_aq_mode != 0 {
                        *(*(*h).fdec).i_row_satd.offset(y as isize) += diff
                            * *(**frames.offset(b as isize))
                                .i_inv_qscale_factor
                                .offset(mb_xy as isize)
                                as ::core::ffi::c_int
                            + 128 as ::core::ffi::c_int
                            >> 8 as ::core::ffi::c_int;
                    } else {
                        *(*(*h).fdec).i_row_satd.offset(y as isize) += diff;
                    }
                    cost += diff;
                    x += 1;
                    mb_xy += 1;
                }
                y += 1;
            }
        }
        return cost;
    }
    use super::__stddef_null_h::NULL;
    use super::__stddef_size_t_h::size_t;
    use super::assert_h::__assert_fail;
    use super::base_h::{
        x264_clip3, x264_clip3f, x264_exp2fix8, x264_log2, x264_median_mv, x264_union32_t,
        x264_union64_t, CHROMA_444, X264_BFRAME_MAX, X264_WEIGHTP_FAKE,
    };
    use super::bitstream_h::{bs_size_se, bs_size_ue};
    use super::common_h::{
        pixel, x264_10_log, x264_t, FDEC_STRIDE, FENC_STRIDE, SIZEOF_PIXEL, X264_LOOKAHEAD_QP,
    };
    use super::frame_h::{
        x264_10_frame_expand_border_chroma, x264_10_weight_scale_plane, x264_frame_t,
        LOWRES_COST_MASK, LOWRES_COST_SHIFT, PADH, PADV,
    };
    use super::internal::BIT_DEPTH;
    use super::macroblock_h::ALL_NEIGHBORS;
    use super::mathcalls_h::{fabsf, round, sqrtf};
    use super::mc_h::{weight_fn_t, x264_weight_t};
    use super::me_h::{x264_10_me_search_ref, x264_me_t, COST_MAX, COST_MAX64};
    use super::pixel_h::{PIXEL_16x16, PIXEL_8x8};
    use super::predict_h::I_PRED_CHROMA_P;
    use super::ratecontrol_h::x264_10_ratecontrol_slice_type;
    use super::stdint_h::intptr_t;
    use super::stdint_intn_h::{int16_t, int32_t, int64_t};
    use super::stdint_uintn_h::{uint16_t, uint32_t, uint64_t, uint8_t};
    use super::string_h::{memcpy, memset, strcpy};
    use super::tables_h::{x264_lambda_tab, x264_zero};
    use super::threadpool_h::{x264_10_threadpool_run, x264_10_threadpool_wait};
    use super::x264_h::{
        x264_b_pyramid_names, X264_B_ADAPT_FAST, X264_B_ADAPT_TRELLIS, X264_B_PYRAMID_NORMAL,
        X264_LOG_DEBUG, X264_LOG_WARNING, X264_ME_DIA, X264_RC_CQP, X264_TYPE_AUTO, X264_TYPE_B,
        X264_TYPE_BREF, X264_TYPE_I, X264_TYPE_IDR, X264_TYPE_KEYFRAME, X264_TYPE_P,
        X264_WEIGHTP_SIMPLE,
    };
    use crate::src::encoder::analyse::{mb_analyse_load_costs, x264_mb_analysis_t};
}
#[c2rust::header_src = "/home/nwplayer123/Hacks/hex264/x264/common/rectangle.h:28"]
pub mod rectangle_h {
    #[inline(always)]
    #[c2rust::src_loc = "28:1"]
    pub unsafe extern "C" fn x264_macroblock_cache_rect(
        mut dst: *mut ::core::ffi::c_void,
        mut w: ::core::ffi::c_int,
        mut h: ::core::ffi::c_int,
        mut s: ::core::ffi::c_int,
        mut v: uint32_t,
    ) {
        let mut d: *mut uint8_t = dst as *mut uint8_t;
        let mut v2: uint16_t = (if s >= 2 as ::core::ffi::c_int {
            v
        } else {
            v.wrapping_mul(0x101 as uint32_t)
        }) as uint16_t;
        let mut v4: uint32_t = if s >= 4 as ::core::ffi::c_int {
            v
        } else if s >= 2 as ::core::ffi::c_int {
            v.wrapping_mul(0x10001 as uint32_t)
        } else {
            v.wrapping_mul(0x1010101 as uint32_t)
        };
        let mut v8: uint64_t =
            (v4 as uint64_t).wrapping_add((v4 as uint64_t) << 32 as ::core::ffi::c_int);
        s *= 8 as ::core::ffi::c_int;
        if w == 2 as ::core::ffi::c_int {
            (*(d.offset((s * 0 as ::core::ffi::c_int) as isize) as *mut x264_union16_t)).i = v2;
            if h == 1 as ::core::ffi::c_int {
                return;
            }
            (*(d.offset((s * 1 as ::core::ffi::c_int) as isize) as *mut x264_union16_t)).i = v2;
            if h == 2 as ::core::ffi::c_int {
                return;
            }
            (*(d.offset((s * 2 as ::core::ffi::c_int) as isize) as *mut x264_union16_t)).i = v2;
            (*(d.offset((s * 3 as ::core::ffi::c_int) as isize) as *mut x264_union16_t)).i = v2;
        } else if w == 4 as ::core::ffi::c_int {
            (*(d.offset((s * 0 as ::core::ffi::c_int) as isize) as *mut x264_union32_t)).i = v4;
            if h == 1 as ::core::ffi::c_int {
                return;
            }
            (*(d.offset((s * 1 as ::core::ffi::c_int) as isize) as *mut x264_union32_t)).i = v4;
            if h == 2 as ::core::ffi::c_int {
                return;
            }
            (*(d.offset((s * 2 as ::core::ffi::c_int) as isize) as *mut x264_union32_t)).i = v4;
            (*(d.offset((s * 3 as ::core::ffi::c_int) as isize) as *mut x264_union32_t)).i = v4;
        } else if w == 8 as ::core::ffi::c_int {
            if WORD_SIZE == 8 as uint64_t {
                (*(d.offset((s * 0 as ::core::ffi::c_int) as isize) as *mut x264_union64_t)).i = v8;
                if h == 1 as ::core::ffi::c_int {
                    return;
                }
                (*(d.offset((s * 1 as ::core::ffi::c_int) as isize) as *mut x264_union64_t)).i = v8;
                if h == 2 as ::core::ffi::c_int {
                    return;
                }
                (*(d.offset((s * 2 as ::core::ffi::c_int) as isize) as *mut x264_union64_t)).i = v8;
                (*(d.offset((s * 3 as ::core::ffi::c_int) as isize) as *mut x264_union64_t)).i = v8;
            } else {
                (*(d.offset((s * 0 as ::core::ffi::c_int) as isize)
                    .offset(0 as ::core::ffi::c_int as isize)
                    as *mut x264_union32_t))
                    .i = v4;
                (*(d.offset((s * 0 as ::core::ffi::c_int) as isize)
                    .offset(4 as ::core::ffi::c_int as isize)
                    as *mut x264_union32_t))
                    .i = v4;
                if h == 1 as ::core::ffi::c_int {
                    return;
                }
                (*(d.offset((s * 1 as ::core::ffi::c_int) as isize)
                    .offset(0 as ::core::ffi::c_int as isize)
                    as *mut x264_union32_t))
                    .i = v4;
                (*(d.offset((s * 1 as ::core::ffi::c_int) as isize)
                    .offset(4 as ::core::ffi::c_int as isize)
                    as *mut x264_union32_t))
                    .i = v4;
                if h == 2 as ::core::ffi::c_int {
                    return;
                }
                (*(d.offset((s * 2 as ::core::ffi::c_int) as isize)
                    .offset(0 as ::core::ffi::c_int as isize)
                    as *mut x264_union32_t))
                    .i = v4;
                (*(d.offset((s * 2 as ::core::ffi::c_int) as isize)
                    .offset(4 as ::core::ffi::c_int as isize)
                    as *mut x264_union32_t))
                    .i = v4;
                (*(d.offset((s * 3 as ::core::ffi::c_int) as isize)
                    .offset(0 as ::core::ffi::c_int as isize)
                    as *mut x264_union32_t))
                    .i = v4;
                (*(d.offset((s * 3 as ::core::ffi::c_int) as isize)
                    .offset(4 as ::core::ffi::c_int as isize)
                    as *mut x264_union32_t))
                    .i = v4;
            }
        } else if w == 16 as ::core::ffi::c_int {
            if h != 1 as ::core::ffi::c_int {
            } else {
                __assert_fail(
                    b"h != 1\0" as *const u8 as *const ::core::ffi::c_char,
                    b"./common/rectangle.h\0" as *const u8 as *const ::core::ffi::c_char,
                    82 as ::core::ffi::c_uint,
                    ::core::mem::transmute::<[u8; 65], [::core::ffi::c_char; 65]>(
                        *b"void x264_macroblock_cache_rect(void *, int, int, int, uint32_t)\0",
                    )
                    .as_ptr(),
                );
            }
            'c_27249: {
                if h != 1 as ::core::ffi::c_int {
                } else {
                    __assert_fail(
                        b"h != 1\0" as *const u8 as *const ::core::ffi::c_char,
                        b"./common/rectangle.h\0" as *const u8 as *const ::core::ffi::c_char,
                        82 as ::core::ffi::c_uint,
                        ::core::mem::transmute::<[u8; 65], [::core::ffi::c_char; 65]>(
                            *b"void x264_macroblock_cache_rect(void *, int, int, int, uint32_t)\0",
                        )
                        .as_ptr(),
                    );
                }
            };
            if WORD_SIZE == 8 as uint64_t {
                loop {
                    (*(d.offset((s * 0 as ::core::ffi::c_int) as isize)
                        .offset(0 as ::core::ffi::c_int as isize)
                        as *mut x264_union64_t))
                        .i = v8;
                    (*(d.offset((s * 0 as ::core::ffi::c_int) as isize)
                        .offset(8 as ::core::ffi::c_int as isize)
                        as *mut x264_union64_t))
                        .i = v8;
                    (*(d.offset((s * 1 as ::core::ffi::c_int) as isize)
                        .offset(0 as ::core::ffi::c_int as isize)
                        as *mut x264_union64_t))
                        .i = v8;
                    (*(d.offset((s * 1 as ::core::ffi::c_int) as isize)
                        .offset(8 as ::core::ffi::c_int as isize)
                        as *mut x264_union64_t))
                        .i = v8;
                    h -= 2 as ::core::ffi::c_int;
                    d = d.offset((s * 2 as ::core::ffi::c_int) as isize);
                    if !(h != 0) {
                        break;
                    }
                }
            } else {
                loop {
                    (*(d.offset(0 as ::core::ffi::c_int as isize) as *mut x264_union32_t)).i = v4;
                    (*(d.offset(4 as ::core::ffi::c_int as isize) as *mut x264_union32_t)).i = v4;
                    (*(d.offset(8 as ::core::ffi::c_int as isize) as *mut x264_union32_t)).i = v4;
                    (*(d.offset(12 as ::core::ffi::c_int as isize) as *mut x264_union32_t)).i = v4;
                    d = d.offset(s as isize);
                    h -= 1;
                    if !(h != 0) {
                        break;
                    }
                }
            }
        } else {
            __assert_fail(
                b"0\0" as *const u8 as *const ::core::ffi::c_char,
                b"./common/rectangle.h\0" as *const u8 as *const ::core::ffi::c_char,
                108 as ::core::ffi::c_uint,
                ::core::mem::transmute::<[u8; 65], [::core::ffi::c_char; 65]>(
                    *b"void x264_macroblock_cache_rect(void *, int, int, int, uint32_t)\0",
                )
                .as_ptr(),
            );
            'c_27015: {
                __assert_fail(
                    b"0\0" as *const u8 as *const ::core::ffi::c_char,
                    b"./common/rectangle.h\0" as *const u8 as *const ::core::ffi::c_char,
                    108 as ::core::ffi::c_uint,
                    ::core::mem::transmute::<[u8; 65], [::core::ffi::c_char; 65]>(
                        *b"void x264_macroblock_cache_rect(void *, int, int, int, uint32_t)\0",
                    )
                    .as_ptr(),
                );
            };
        };
    }
    #[inline(always)]
    #[c2rust::src_loc = "119:1"]
    pub unsafe extern "C" fn x264_macroblock_cache_mv(
        mut h: *mut x264_t,
        mut x: ::core::ffi::c_int,
        mut y: ::core::ffi::c_int,
        mut width: ::core::ffi::c_int,
        mut height: ::core::ffi::c_int,
        mut i_list: ::core::ffi::c_int,
        mut mv: uint32_t,
    ) {
        let mut mv_cache: *mut ::core::ffi::c_void =
            &mut *(*(*h).mb.cache.mv.as_mut_ptr().offset(i_list as isize))
                .as_mut_ptr()
                .offset((X264_SCAN8_0 + x + 8 as ::core::ffi::c_int * y) as isize)
                as *mut [int16_t; 2] as *mut ::core::ffi::c_void;
        if 0 == 0 || 0 == 0 {
            x264_10_cache_mv_func_table
                [(width + (height << 1 as ::core::ffi::c_int) - 3 as ::core::ffi::c_int) as usize]
                .expect("non-null function pointer")(mv_cache, mv);
        } else {
            x264_macroblock_cache_rect(
                mv_cache,
                width * 4 as ::core::ffi::c_int,
                height,
                4 as ::core::ffi::c_int,
                mv,
            );
        };
    }
    #[inline(always)]
    #[c2rust::src_loc = "127:1"]
    pub unsafe extern "C" fn x264_macroblock_cache_mvd(
        mut h: *mut x264_t,
        mut x: ::core::ffi::c_int,
        mut y: ::core::ffi::c_int,
        mut width: ::core::ffi::c_int,
        mut height: ::core::ffi::c_int,
        mut i_list: ::core::ffi::c_int,
        mut mvd: uint16_t,
    ) {
        let mut mvd_cache: *mut ::core::ffi::c_void =
            &mut *(*(*h).mb.cache.mvd.as_mut_ptr().offset(i_list as isize))
                .as_mut_ptr()
                .offset((X264_SCAN8_0 + x + 8 as ::core::ffi::c_int * y) as isize)
                as *mut [uint8_t; 2] as *mut ::core::ffi::c_void;
        if 0 == 0 || 0 == 0 {
            x264_10_cache_mvd_func_table
                [(width + (height << 1 as ::core::ffi::c_int) - 3 as ::core::ffi::c_int) as usize]
                .expect("non-null function pointer")(mvd_cache, mvd as uint32_t);
        } else {
            x264_macroblock_cache_rect(
                mvd_cache,
                width * 2 as ::core::ffi::c_int,
                height,
                2 as ::core::ffi::c_int,
                mvd as uint32_t,
            );
        };
    }
    #[inline(always)]
    #[c2rust::src_loc = "135:1"]
    pub unsafe extern "C" fn x264_macroblock_cache_ref(
        mut h: *mut x264_t,
        mut x: ::core::ffi::c_int,
        mut y: ::core::ffi::c_int,
        mut width: ::core::ffi::c_int,
        mut height: ::core::ffi::c_int,
        mut i_list: ::core::ffi::c_int,
        mut ref_0: int8_t,
    ) {
        let mut ref_cache: *mut ::core::ffi::c_void =
            &mut *(*(*h).mb.cache.ref_0.as_mut_ptr().offset(i_list as isize))
                .as_mut_ptr()
                .offset((X264_SCAN8_0 + x + 8 as ::core::ffi::c_int * y) as isize)
                as *mut int8_t as *mut ::core::ffi::c_void;
        if 0 == 0 || 0 == 0 {
            x264_10_cache_ref_func_table
                [(width + (height << 1 as ::core::ffi::c_int) - 3 as ::core::ffi::c_int) as usize]
                .expect("non-null function pointer")(
                ref_cache, ref_0 as uint8_t as uint32_t
            );
        } else {
            x264_macroblock_cache_rect(
                ref_cache,
                width,
                height,
                1 as ::core::ffi::c_int,
                ref_0 as uint8_t as uint32_t,
            );
        };
    }
    #[inline(always)]
    #[c2rust::src_loc = "143:1"]
    pub unsafe extern "C" fn x264_macroblock_cache_skip(
        mut h: *mut x264_t,
        mut x: ::core::ffi::c_int,
        mut y: ::core::ffi::c_int,
        mut width: ::core::ffi::c_int,
        mut height: ::core::ffi::c_int,
        mut b_skip: ::core::ffi::c_int,
    ) {
        x264_macroblock_cache_rect(
            &mut *(*h)
                .mb
                .cache
                .skip
                .as_mut_ptr()
                .offset((X264_SCAN8_0 + x + 8 as ::core::ffi::c_int * y) as isize)
                as *mut int8_t as *mut ::core::ffi::c_void,
            width,
            height,
            1 as ::core::ffi::c_int,
            b_skip as uint32_t,
        );
    }
    #[inline(always)]
    #[c2rust::src_loc = "147:1"]
    pub unsafe extern "C" fn x264_macroblock_cache_intra8x8_pred(
        mut h: *mut x264_t,
        mut x: ::core::ffi::c_int,
        mut y: ::core::ffi::c_int,
        mut i_mode: ::core::ffi::c_int,
    ) {
        x264_macroblock_cache_rect(
            &mut *(*h)
                .mb
                .cache
                .intra4x4_pred_mode
                .as_mut_ptr()
                .offset((X264_SCAN8_0 + x + 8 as ::core::ffi::c_int * y) as isize)
                as *mut int8_t as *mut ::core::ffi::c_void,
            2 as ::core::ffi::c_int,
            2 as ::core::ffi::c_int,
            1 as ::core::ffi::c_int,
            i_mode as uint32_t,
        );
    }
    use super::assert_h::__assert_fail;
    use super::base_h::{x264_union16_t, x264_union32_t, x264_union64_t, X264_SCAN8_0};
    use super::common_h::x264_t;
    use super::osdep_h::WORD_SIZE;
    use super::stdint_intn_h::{int16_t, int8_t};
    use super::stdint_uintn_h::{uint16_t, uint32_t, uint64_t, uint8_t};
    extern "C" {
        #[c2rust::src_loc = "112:15"]
        pub static mut x264_10_cache_mv_func_table:
            [Option<unsafe extern "C" fn(*mut ::core::ffi::c_void, uint32_t) -> ()>; 10];
        #[c2rust::src_loc = "114:15"]
        pub static mut x264_10_cache_mvd_func_table:
            [Option<unsafe extern "C" fn(*mut ::core::ffi::c_void, uint32_t) -> ()>; 10];
        #[c2rust::src_loc = "116:15"]
        pub static mut x264_10_cache_ref_func_table:
            [Option<unsafe extern "C" fn(*mut ::core::ffi::c_void, uint32_t) -> ()>; 10];
    }
}
#[c2rust::header_src = "/home/nwplayer123/Hacks/hex264/x264/encoder/macroblock.h:28"]
pub mod encoder_macroblock_h {
    #[inline(always)]
    #[c2rust::src_loc = "90:1"]
    pub unsafe extern "C" fn x264_quant_4x4(
        mut h: *mut x264_t,
        mut dct: *mut dctcoef,
        mut i_qp: ::core::ffi::c_int,
        mut ctx_block_cat: ::core::ffi::c_int,
        mut b_intra: ::core::ffi::c_int,
        mut p: ::core::ffi::c_int,
        mut idx: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int {
        let mut i_quant_cat: ::core::ffi::c_int = if b_intra != 0 {
            if p != 0 {
                CQM_4IC as ::core::ffi::c_int
            } else {
                CQM_4IY as ::core::ffi::c_int
            }
        } else if p != 0 {
            CQM_4PC as ::core::ffi::c_int
        } else {
            CQM_4PY as ::core::ffi::c_int
        };
        if (*h).mb.b_noise_reduction != 0 {
            (*h).quantf.denoise_dct.expect("non-null function pointer")(
                dct as *mut dctcoef,
                (*(*h).nr_residual_sum.offset(
                    (0 as ::core::ffi::c_int
                        + (p != 0) as ::core::ffi::c_int * 2 as ::core::ffi::c_int)
                        as isize,
                ))
                .as_mut_ptr(),
                (*(*h).nr_offset.offset(
                    (0 as ::core::ffi::c_int
                        + (p != 0) as ::core::ffi::c_int * 2 as ::core::ffi::c_int)
                        as isize,
                ))
                .as_mut_ptr(),
                16 as ::core::ffi::c_int,
            );
        }
        if (*h).mb.b_trellis != 0 {
            return x264_10_quant_4x4_trellis(
                h,
                dct as *mut dctcoef,
                i_quant_cat,
                i_qp,
                ctx_block_cat,
                b_intra,
                (p != 0) as ::core::ffi::c_int,
                idx + p * 16 as ::core::ffi::c_int,
            );
        } else {
            return (*h).quantf.quant_4x4.expect("non-null function pointer")(
                dct,
                (*(*(*h).quant4_mf.as_mut_ptr().offset(i_quant_cat as isize))
                    .offset(i_qp as isize))
                .as_mut_ptr(),
                (*(*(*h).quant4_bias.as_mut_ptr().offset(i_quant_cat as isize))
                    .offset(i_qp as isize))
                .as_mut_ptr(),
            );
        };
    }
    #[inline(always)]
    #[c2rust::src_loc = "101:1"]
    pub unsafe extern "C" fn x264_quant_8x8(
        mut h: *mut x264_t,
        mut dct: *mut dctcoef,
        mut i_qp: ::core::ffi::c_int,
        mut ctx_block_cat: ::core::ffi::c_int,
        mut b_intra: ::core::ffi::c_int,
        mut p: ::core::ffi::c_int,
        mut idx: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int {
        let mut i_quant_cat: ::core::ffi::c_int = if b_intra != 0 {
            if p != 0 {
                CQM_8IC as ::core::ffi::c_int
            } else {
                CQM_8IY as ::core::ffi::c_int
            }
        } else if p != 0 {
            CQM_8PC as ::core::ffi::c_int
        } else {
            CQM_8PY as ::core::ffi::c_int
        };
        if (*h).mb.b_noise_reduction != 0 {
            (*h).quantf.denoise_dct.expect("non-null function pointer")(
                dct as *mut dctcoef,
                (*(*h).nr_residual_sum.offset(
                    (1 as ::core::ffi::c_int
                        + (p != 0) as ::core::ffi::c_int * 2 as ::core::ffi::c_int)
                        as isize,
                ))
                .as_mut_ptr(),
                (*(*h).nr_offset.offset(
                    (1 as ::core::ffi::c_int
                        + (p != 0) as ::core::ffi::c_int * 2 as ::core::ffi::c_int)
                        as isize,
                ))
                .as_mut_ptr(),
                64 as ::core::ffi::c_int,
            );
        }
        if (*h).mb.b_trellis != 0 {
            return x264_10_quant_8x8_trellis(
                h,
                dct as *mut dctcoef,
                i_quant_cat,
                i_qp,
                ctx_block_cat,
                b_intra,
                (p != 0) as ::core::ffi::c_int,
                idx + p * 4 as ::core::ffi::c_int,
            );
        } else {
            return (*h).quantf.quant_8x8.expect("non-null function pointer")(
                dct,
                (*(*(*h).quant8_mf.as_mut_ptr().offset(i_quant_cat as isize))
                    .offset(i_qp as isize))
                .as_mut_ptr(),
                (*(*(*h).quant8_bias.as_mut_ptr().offset(i_quant_cat as isize))
                    .offset(i_qp as isize))
                .as_mut_ptr(),
            );
        };
    }
    #[inline(always)]
    #[c2rust::src_loc = "132:1"]
    pub unsafe extern "C" fn x264_mb_encode_i4x4(
        mut h: *mut x264_t,
        mut p: ::core::ffi::c_int,
        mut idx: ::core::ffi::c_int,
        mut i_qp: ::core::ffi::c_int,
        mut i_mode: ::core::ffi::c_int,
        mut b_predict: ::core::ffi::c_int,
    ) {
        let mut nz: ::core::ffi::c_int = 0;
        let mut p_src: *mut pixel = &mut *(*(*h).mb.pic.p_fenc.as_mut_ptr().offset(p as isize))
            .offset(*block_idx_xy_fenc.as_ptr().offset(idx as isize) as isize)
            as *mut pixel;
        let mut p_dst: *mut pixel = &mut *(*(*h).mb.pic.p_fdec.as_mut_ptr().offset(p as isize))
            .offset(*block_idx_xy_fdec.as_ptr().offset(idx as isize) as isize)
            as *mut pixel;
        let mut dct4x4: [dctcoef; 16] = [0; 16];
        if b_predict != 0 {
            if (*h).mb.b_lossless != 0 {
                x264_10_predict_lossless_4x4(h, p_dst, p, idx, i_mode);
            } else {
                (*h).predict_4x4[i_mode as usize].expect("non-null function pointer")(p_dst);
            }
        }
        if (*h).mb.b_lossless != 0 {
            nz = (*h).zigzagf.sub_4x4.expect("non-null function pointer")(
                (*(*h)
                    .dct
                    .luma4x4
                    .as_mut_ptr()
                    .offset((p * 16 as ::core::ffi::c_int + idx) as isize))
                .as_mut_ptr(),
                p_src,
                p_dst,
            );
            (*h).mb.cache.non_zero_count
                [x264_scan8[(p * 16 as ::core::ffi::c_int + idx) as usize] as usize] =
                nz as uint8_t;
            (*h).mb.i_cbp_luma |= nz << (idx >> 2 as ::core::ffi::c_int);
            return;
        }
        (*h).dctf.sub4x4_dct.expect("non-null function pointer")(dct4x4.as_mut_ptr(), p_src, p_dst);
        nz = x264_quant_4x4(
            h,
            dct4x4.as_mut_ptr(),
            i_qp,
            ctx_cat_plane[DCT_LUMA_4x4 as ::core::ffi::c_int as usize][p as usize]
                as ::core::ffi::c_int,
            1 as ::core::ffi::c_int,
            p,
            idx,
        );
        (*h).mb.cache.non_zero_count
            [x264_scan8[(p * 16 as ::core::ffi::c_int + idx) as usize] as usize] = nz as uint8_t;
        if nz != 0 {
            (*h).mb.i_cbp_luma |= (1 as ::core::ffi::c_int) << (idx >> 2 as ::core::ffi::c_int);
            (*h).zigzagf.scan_4x4.expect("non-null function pointer")(
                (*(*h)
                    .dct
                    .luma4x4
                    .as_mut_ptr()
                    .offset((p * 16 as ::core::ffi::c_int + idx) as isize))
                .as_mut_ptr(),
                dct4x4.as_mut_ptr(),
            );
            (*h).quantf.dequant_4x4.expect("non-null function pointer")(
                dct4x4.as_mut_ptr(),
                (*h).dequant4_mf[(if p != 0 {
                    CQM_4IC as ::core::ffi::c_int
                } else {
                    CQM_4IY as ::core::ffi::c_int
                }) as usize],
                i_qp,
            );
            (*h).dctf.add4x4_idct.expect("non-null function pointer")(p_dst, dct4x4.as_mut_ptr());
        }
    }
    #[inline(always)]
    #[c2rust::src_loc = "168:1"]
    pub unsafe extern "C" fn x264_mb_encode_i8x8(
        mut h: *mut x264_t,
        mut p: ::core::ffi::c_int,
        mut idx: ::core::ffi::c_int,
        mut i_qp: ::core::ffi::c_int,
        mut i_mode: ::core::ffi::c_int,
        mut edge: *mut pixel,
        mut b_predict: ::core::ffi::c_int,
    ) {
        let mut x: ::core::ffi::c_int = idx & 1 as ::core::ffi::c_int;
        let mut y: ::core::ffi::c_int = idx >> 1 as ::core::ffi::c_int;
        let mut nz: ::core::ffi::c_int = 0;
        let mut p_src: *mut pixel = &mut *(*(*h).mb.pic.p_fenc.as_mut_ptr().offset(p as isize))
            .offset(
                (8 as ::core::ffi::c_int * x + 8 as ::core::ffi::c_int * y * FENC_STRIDE) as isize,
            ) as *mut pixel;
        let mut p_dst: *mut pixel = &mut *(*(*h).mb.pic.p_fdec.as_mut_ptr().offset(p as isize))
            .offset(
                (8 as ::core::ffi::c_int * x + 8 as ::core::ffi::c_int * y * FDEC_STRIDE) as isize,
            ) as *mut pixel;
        let mut dct8x8: [dctcoef; 64] = [0; 64];
        let mut edge_buf: [pixel; 36] = [0; 36];
        if b_predict != 0 {
            if edge.is_null() {
                (*h).predict_8x8_filter.expect("non-null function pointer")(
                    p_dst,
                    edge_buf.as_mut_ptr(),
                    (*h).mb.i_neighbour8[idx as usize] as ::core::ffi::c_int,
                    x264_pred_i4x4_neighbors[i_mode as usize] as ::core::ffi::c_int,
                );
                edge = edge_buf.as_mut_ptr();
            }
            if (*h).mb.b_lossless != 0 {
                x264_10_predict_lossless_8x8(h, p_dst, p, idx, i_mode, edge as *mut pixel);
            } else {
                (*h).predict_8x8[i_mode as usize].expect("non-null function pointer")(
                    p_dst,
                    edge as *mut pixel,
                );
            }
        }
        if (*h).mb.b_lossless != 0 {
            nz = (*h).zigzagf.sub_8x8.expect("non-null function pointer")(
                (*(*h)
                    .dct
                    .luma8x8
                    .as_mut_ptr()
                    .offset((p * 4 as ::core::ffi::c_int + idx) as isize))
                .as_mut_ptr(),
                p_src,
                p_dst,
            );
            (*(&mut *(*h).mb.cache.non_zero_count.as_mut_ptr().offset(
                (*x264_scan8
                    .as_ptr()
                    .offset((p * 16 as ::core::ffi::c_int + idx * 4 as ::core::ffi::c_int) as isize)
                    as ::core::ffi::c_int
                    + 0 as ::core::ffi::c_int) as isize,
            ) as *mut uint8_t as *mut x264_union16_t))
                .i = (nz * 0x101 as ::core::ffi::c_int) as uint16_t;
            (*(&mut *(*h).mb.cache.non_zero_count.as_mut_ptr().offset(
                (*x264_scan8
                    .as_ptr()
                    .offset((p * 16 as ::core::ffi::c_int + idx * 4 as ::core::ffi::c_int) as isize)
                    as ::core::ffi::c_int
                    + 8 as ::core::ffi::c_int) as isize,
            ) as *mut uint8_t as *mut x264_union16_t))
                .i = (nz * 0x101 as ::core::ffi::c_int) as uint16_t;
            (*h).mb.i_cbp_luma |= nz << idx;
            return;
        }
        (*h).dctf.sub8x8_dct8.expect("non-null function pointer")(
            dct8x8.as_mut_ptr(),
            p_src,
            p_dst,
        );
        nz = x264_quant_8x8(
            h,
            dct8x8.as_mut_ptr(),
            i_qp,
            ctx_cat_plane[DCT_LUMA_8x8 as ::core::ffi::c_int as usize][p as usize]
                as ::core::ffi::c_int,
            1 as ::core::ffi::c_int,
            p,
            idx,
        );
        if nz != 0 {
            (*h).mb.i_cbp_luma |= (1 as ::core::ffi::c_int) << idx;
            (*h).zigzagf.scan_8x8.expect("non-null function pointer")(
                (*(*h)
                    .dct
                    .luma8x8
                    .as_mut_ptr()
                    .offset((p * 4 as ::core::ffi::c_int + idx) as isize))
                .as_mut_ptr(),
                dct8x8.as_mut_ptr(),
            );
            (*h).quantf.dequant_8x8.expect("non-null function pointer")(
                dct8x8.as_mut_ptr(),
                (*h).dequant8_mf[(if p != 0 {
                    CQM_8IC as ::core::ffi::c_int
                } else {
                    CQM_8IY as ::core::ffi::c_int
                }) as usize],
                i_qp,
            );
            (*h).dctf.add8x8_idct8.expect("non-null function pointer")(p_dst, dct8x8.as_mut_ptr());
            (*(&mut *(*h).mb.cache.non_zero_count.as_mut_ptr().offset(
                (*x264_scan8
                    .as_ptr()
                    .offset((p * 16 as ::core::ffi::c_int + idx * 4 as ::core::ffi::c_int) as isize)
                    as ::core::ffi::c_int
                    + 0 as ::core::ffi::c_int) as isize,
            ) as *mut uint8_t as *mut x264_union16_t))
                .i = (1 as ::core::ffi::c_int * 0x101 as ::core::ffi::c_int) as uint16_t;
            (*(&mut *(*h).mb.cache.non_zero_count.as_mut_ptr().offset(
                (*x264_scan8
                    .as_ptr()
                    .offset((p * 16 as ::core::ffi::c_int + idx * 4 as ::core::ffi::c_int) as isize)
                    as ::core::ffi::c_int
                    + 8 as ::core::ffi::c_int) as isize,
            ) as *mut uint8_t as *mut x264_union16_t))
                .i = (1 as ::core::ffi::c_int * 0x101 as ::core::ffi::c_int) as uint16_t;
        } else {
            (*(&mut *(*h).mb.cache.non_zero_count.as_mut_ptr().offset(
                (*x264_scan8
                    .as_ptr()
                    .offset((p * 16 as ::core::ffi::c_int + idx * 4 as ::core::ffi::c_int) as isize)
                    as ::core::ffi::c_int
                    + 0 as ::core::ffi::c_int) as isize,
            ) as *mut uint8_t as *mut x264_union16_t))
                .i = (0 as ::core::ffi::c_int * 0x101 as ::core::ffi::c_int) as uint16_t;
            (*(&mut *(*h).mb.cache.non_zero_count.as_mut_ptr().offset(
                (*x264_scan8
                    .as_ptr()
                    .offset((p * 16 as ::core::ffi::c_int + idx * 4 as ::core::ffi::c_int) as isize)
                    as ::core::ffi::c_int
                    + 8 as ::core::ffi::c_int) as isize,
            ) as *mut uint8_t as *mut x264_union16_t))
                .i = (0 as ::core::ffi::c_int * 0x101 as ::core::ffi::c_int) as uint16_t;
        };
    }
    use super::base_h::{x264_scan8, x264_union16_t};
    use super::common_h::{dctcoef, pixel, x264_t, FDEC_STRIDE, FENC_STRIDE};
    use super::macroblock_h::{
        block_idx_xy_fdec, block_idx_xy_fenc, ctx_cat_plane, x264_pred_i4x4_neighbors,
        DCT_LUMA_4x4, DCT_LUMA_8x8,
    };
    use super::rdo_c::{x264_10_quant_4x4_trellis, x264_10_quant_8x8_trellis};
    use super::set_h::{CQM_4IC, CQM_4IY, CQM_4PC, CQM_4PY, CQM_8IC, CQM_8IY, CQM_8PC, CQM_8PY};
    use super::stdint_uintn_h::{uint16_t, uint8_t};
    extern "C" {
        #[c2rust::src_loc = "36:1"]
        pub fn x264_10_macroblock_probe_skip(
            h: *mut x264_t,
            b_bidir: ::core::ffi::c_int,
        ) -> ::core::ffi::c_int;
        #[c2rust::src_loc = "44:1"]
        pub fn x264_10_predict_lossless_4x4(
            h: *mut x264_t,
            p_dst: *mut pixel,
            p: ::core::ffi::c_int,
            idx: ::core::ffi::c_int,
            i_mode: ::core::ffi::c_int,
        );
        #[c2rust::src_loc = "46:1"]
        pub fn x264_10_predict_lossless_8x8(
            h: *mut x264_t,
            p_dst: *mut pixel,
            p: ::core::ffi::c_int,
            idx: ::core::ffi::c_int,
            i_mode: ::core::ffi::c_int,
            edge: *mut pixel,
        );
        #[c2rust::src_loc = "48:1"]
        pub fn x264_10_predict_lossless_16x16(
            h: *mut x264_t,
            p: ::core::ffi::c_int,
            i_mode: ::core::ffi::c_int,
        );
        #[c2rust::src_loc = "50:1"]
        pub fn x264_10_predict_lossless_chroma(h: *mut x264_t, i_mode: ::core::ffi::c_int);
        #[c2rust::src_loc = "53:1"]
        pub fn x264_10_macroblock_encode(h: *mut x264_t);
        #[c2rust::src_loc = "60:1"]
        pub fn x264_10_macroblock_encode_p8x8(h: *mut x264_t, i8: ::core::ffi::c_int);
        #[c2rust::src_loc = "62:1"]
        pub fn x264_10_macroblock_encode_p4x4(h: *mut x264_t, i4: ::core::ffi::c_int);
        #[c2rust::src_loc = "64:1"]
        pub fn x264_10_mb_encode_chroma(
            h: *mut x264_t,
            b_inter: ::core::ffi::c_int,
            i_qp: ::core::ffi::c_int,
        );
    }
    use super::cabac_h::x264_cabac_t;
    extern "C" {
        #[c2rust::src_loc = "33:1"]
        pub fn x264_10_rdo_init();
        #[c2rust::src_loc = "55:1"]
        pub fn x264_10_macroblock_write_cabac(h: *mut x264_t, cb: *mut x264_cabac_t);
        #[c2rust::src_loc = "57:1"]
        pub fn x264_10_macroblock_write_cavlc(h: *mut x264_t);
        #[c2rust::src_loc = "67:1"]
        pub fn x264_10_cabac_mb_skip(h: *mut x264_t, b_skip: ::core::ffi::c_int);
        #[c2rust::src_loc = "88:1"]
        pub fn x264_10_noise_reduction_update(h: *mut x264_t);
    }
}
#[c2rust::header_src = "/home/nwplayer123/Hacks/hex264/x264/encoder/cabac.c:28"]
pub mod cabac_c {
    #[inline]
    #[c2rust::src_loc = "35:1"]
    pub unsafe extern "C" fn cabac_mb_type_intra(
        mut h: *mut x264_t,
        mut cb: *mut x264_cabac_t,
        mut i_mb_type: ::core::ffi::c_int,
        mut ctx0: ::core::ffi::c_int,
        mut ctx1: ::core::ffi::c_int,
        mut ctx2: ::core::ffi::c_int,
        mut ctx3: ::core::ffi::c_int,
        mut ctx4: ::core::ffi::c_int,
        mut ctx5: ::core::ffi::c_int,
    ) {
        if i_mb_type == I_4x4 as ::core::ffi::c_int || i_mb_type == I_8x8 as ::core::ffi::c_int {
            x264_cabac_size_decision_noup(
                cb,
                ctx0 as ::core::ffi::c_long,
                0 as ::core::ffi::c_long,
            );
        } else {
            let mut i_pred: ::core::ffi::c_int = x264_mb_pred_mode16x16_fix
                [(*h).mb.i_intra16x16_pred_mode as usize]
                as ::core::ffi::c_int;
            x264_cabac_size_decision_noup(
                cb,
                ctx0 as ::core::ffi::c_long,
                1 as ::core::ffi::c_long,
            );
            (*cb).f8_bits_encoded += 7 as ::core::ffi::c_int;
            x264_cabac_size_decision_noup(
                cb,
                ctx1 as ::core::ffi::c_long,
                ((*h).mb.i_cbp_luma != 0) as ::core::ffi::c_int as ::core::ffi::c_long,
            );
            if (*h).mb.i_cbp_chroma == 0 as ::core::ffi::c_int {
                x264_cabac_size_decision_noup(
                    cb,
                    ctx2 as ::core::ffi::c_long,
                    0 as ::core::ffi::c_long,
                );
            } else {
                x264_cabac_size_decision(cb, ctx2 as ::core::ffi::c_long, 1 as ::core::ffi::c_long);
                x264_cabac_size_decision_noup(
                    cb,
                    ctx3 as ::core::ffi::c_long,
                    ((*h).mb.i_cbp_chroma >> 1 as ::core::ffi::c_int) as ::core::ffi::c_long,
                );
            }
            x264_cabac_size_decision(
                cb,
                ctx4 as ::core::ffi::c_long,
                (i_pred >> 1 as ::core::ffi::c_int) as ::core::ffi::c_long,
            );
            x264_cabac_size_decision_noup(
                cb,
                ctx5 as ::core::ffi::c_long,
                (i_pred & 1 as ::core::ffi::c_int) as ::core::ffi::c_long,
            );
        };
    }
    #[c2rust::src_loc = "83:1"]
    pub unsafe extern "C" fn cabac_intra4x4_pred_mode(
        mut cb: *mut x264_cabac_t,
        mut i_pred: ::core::ffi::c_int,
        mut i_mode: ::core::ffi::c_int,
    ) {
        if i_pred == i_mode {
            x264_cabac_size_decision(cb, 68 as ::core::ffi::c_long, 1 as ::core::ffi::c_long);
        } else {
            x264_cabac_size_decision(cb, 68 as ::core::ffi::c_long, 0 as ::core::ffi::c_long);
            if i_mode > i_pred {
                i_mode -= 1;
            }
            x264_cabac_size_decision(
                cb,
                69 as ::core::ffi::c_long,
                (i_mode & 0x1 as ::core::ffi::c_int) as ::core::ffi::c_long,
            );
            x264_cabac_size_decision(
                cb,
                69 as ::core::ffi::c_long,
                (i_mode >> 1 as ::core::ffi::c_int & 0x1 as ::core::ffi::c_int)
                    as ::core::ffi::c_long,
            );
            x264_cabac_size_decision(
                cb,
                69 as ::core::ffi::c_long,
                (i_mode >> 2 as ::core::ffi::c_int) as ::core::ffi::c_long,
            );
        };
    }
    #[c2rust::src_loc = "98:1"]
    pub unsafe extern "C" fn cabac_intra_chroma_pred_mode(
        mut h: *mut x264_t,
        mut cb: *mut x264_cabac_t,
    ) {
        let mut i_mode: ::core::ffi::c_int =
            x264_mb_chroma_pred_mode_fix[(*h).mb.i_chroma_pred_mode as usize] as ::core::ffi::c_int;
        let mut ctx: ::core::ffi::c_int = 0 as ::core::ffi::c_int;
        if (*h).mb.i_neighbour & MB_LEFT as ::core::ffi::c_int as ::core::ffi::c_uint != 0
            && *(*h)
                .mb
                .chroma_pred_mode
                .offset((*h).mb.i_mb_left_xy[0 as ::core::ffi::c_int as usize] as isize)
                as ::core::ffi::c_int
                != 0 as ::core::ffi::c_int
        {
            ctx += 1;
        }
        if (*h).mb.i_neighbour & MB_TOP as ::core::ffi::c_int as ::core::ffi::c_uint != 0
            && *(*h)
                .mb
                .chroma_pred_mode
                .offset((*h).mb.i_mb_top_xy as isize) as ::core::ffi::c_int
                != 0 as ::core::ffi::c_int
        {
            ctx += 1;
        }
        x264_cabac_size_decision_noup(
            cb,
            (64 as ::core::ffi::c_int + ctx) as ::core::ffi::c_long,
            (i_mode > 0 as ::core::ffi::c_int) as ::core::ffi::c_int as ::core::ffi::c_long,
        );
        if i_mode > 0 as ::core::ffi::c_int {
            x264_cabac_size_decision(
                cb,
                (64 as ::core::ffi::c_int + 3 as ::core::ffi::c_int) as ::core::ffi::c_long,
                (i_mode > 1 as ::core::ffi::c_int) as ::core::ffi::c_int as ::core::ffi::c_long,
            );
            if i_mode > 1 as ::core::ffi::c_int {
                x264_cabac_size_decision_noup(
                    cb,
                    (64 as ::core::ffi::c_int + 3 as ::core::ffi::c_int) as ::core::ffi::c_long,
                    (i_mode > 2 as ::core::ffi::c_int) as ::core::ffi::c_int as ::core::ffi::c_long,
                );
            }
        }
    }
    #[c2rust::src_loc = "118:1"]
    pub unsafe extern "C" fn cabac_cbp_luma(mut h: *mut x264_t, mut cb: *mut x264_cabac_t) {
        let mut cbp: ::core::ffi::c_int = (*h).mb.i_cbp_luma;
        let mut cbp_l: ::core::ffi::c_int = (*h).mb.cache.i_cbp_left;
        let mut cbp_t: ::core::ffi::c_int = (*h).mb.cache.i_cbp_top;
        x264_cabac_size_decision(
            cb,
            (76 as ::core::ffi::c_int
                - (cbp_l >> 1 as ::core::ffi::c_int & 1 as ::core::ffi::c_int)
                - (cbp_t >> 1 as ::core::ffi::c_int & 2 as ::core::ffi::c_int))
                as ::core::ffi::c_long,
            (cbp >> 0 as ::core::ffi::c_int & 1 as ::core::ffi::c_int) as ::core::ffi::c_long,
        );
        x264_cabac_size_decision(
            cb,
            (76 as ::core::ffi::c_int
                - (cbp >> 0 as ::core::ffi::c_int & 1 as ::core::ffi::c_int)
                - (cbp_t >> 2 as ::core::ffi::c_int & 2 as ::core::ffi::c_int))
                as ::core::ffi::c_long,
            (cbp >> 1 as ::core::ffi::c_int & 1 as ::core::ffi::c_int) as ::core::ffi::c_long,
        );
        x264_cabac_size_decision(
            cb,
            (76 as ::core::ffi::c_int
                - (cbp_l >> 3 as ::core::ffi::c_int & 1 as ::core::ffi::c_int)
                - (cbp << 1 as ::core::ffi::c_int & 2 as ::core::ffi::c_int))
                as ::core::ffi::c_long,
            (cbp >> 2 as ::core::ffi::c_int & 1 as ::core::ffi::c_int) as ::core::ffi::c_long,
        );
        x264_cabac_size_decision_noup(
            cb,
            (76 as ::core::ffi::c_int
                - (cbp >> 2 as ::core::ffi::c_int & 1 as ::core::ffi::c_int)
                - (cbp >> 0 as ::core::ffi::c_int & 2 as ::core::ffi::c_int))
                as ::core::ffi::c_long,
            (cbp >> 3 as ::core::ffi::c_int & 1 as ::core::ffi::c_int) as ::core::ffi::c_long,
        );
    }
    #[c2rust::src_loc = "129:1"]
    pub unsafe extern "C" fn cabac_cbp_chroma(mut h: *mut x264_t, mut cb: *mut x264_cabac_t) {
        let mut cbp_a: ::core::ffi::c_int = (*h).mb.cache.i_cbp_left & 0x30 as ::core::ffi::c_int;
        let mut cbp_b: ::core::ffi::c_int = (*h).mb.cache.i_cbp_top & 0x30 as ::core::ffi::c_int;
        let mut ctx: ::core::ffi::c_int = 0 as ::core::ffi::c_int;
        if cbp_a != 0 && (*h).mb.cache.i_cbp_left != -(1 as ::core::ffi::c_int) {
            ctx += 1;
        }
        if cbp_b != 0 && (*h).mb.cache.i_cbp_top != -(1 as ::core::ffi::c_int) {
            ctx += 2 as ::core::ffi::c_int;
        }
        if (*h).mb.i_cbp_chroma == 0 as ::core::ffi::c_int {
            x264_cabac_size_decision_noup(
                cb,
                (77 as ::core::ffi::c_int + ctx) as ::core::ffi::c_long,
                0 as ::core::ffi::c_long,
            );
        } else {
            x264_cabac_size_decision_noup(
                cb,
                (77 as ::core::ffi::c_int + ctx) as ::core::ffi::c_long,
                1 as ::core::ffi::c_long,
            );
            ctx = 4 as ::core::ffi::c_int;
            if cbp_a == 0x20 as ::core::ffi::c_int {
                ctx += 1;
            }
            if cbp_b == 0x20 as ::core::ffi::c_int {
                ctx += 2 as ::core::ffi::c_int;
            }
            x264_cabac_size_decision_noup(
                cb,
                (77 as ::core::ffi::c_int + ctx) as ::core::ffi::c_long,
                ((*h).mb.i_cbp_chroma >> 1 as ::core::ffi::c_int) as ::core::ffi::c_long,
            );
        };
    }
    #[c2rust::src_loc = "150:1"]
    pub unsafe extern "C" fn cabac_qp_delta(mut h: *mut x264_t, mut cb: *mut x264_cabac_t) {
        let mut i_dqp: ::core::ffi::c_int = (*h).mb.i_qp - (*h).mb.i_last_qp;
        let mut ctx: ::core::ffi::c_int = 0;
        if (*h).mb.i_type == I_16x16 as ::core::ffi::c_int
            && *(*h).mb.cbp.offset((*h).mb.i_mb_xy as isize) == 0
            && (*h).mb.i_qp > (*h).mb.i_last_qp
        {
            i_dqp = 0 as ::core::ffi::c_int;
        }
        ctx = ((*h).mb.i_last_dqp != 0
            && (*(*h).mb.type_0.offset((*h).mb.i_mb_prev_xy as isize) as ::core::ffi::c_int
                == I_16x16 as ::core::ffi::c_int
                || *(*h).mb.cbp.offset((*h).mb.i_mb_prev_xy as isize) as ::core::ffi::c_int
                    & 0x3f as ::core::ffi::c_int
                    != 0)) as ::core::ffi::c_int;
        if i_dqp != 0 as ::core::ffi::c_int {
            i_dqp *= 2 as ::core::ffi::c_int;
            let mut val: ::core::ffi::c_int = 1 as ::core::ffi::c_int - i_dqp;
            if val < 0 as ::core::ffi::c_int {
                val = i_dqp;
            }
            val -= 1;
            if val >= QP_MAX_SPEC && val != QP_MAX_SPEC + 1 as ::core::ffi::c_int {
                val = 2 as ::core::ffi::c_int * QP_MAX_SPEC + 1 as ::core::ffi::c_int - val;
            }
            loop {
                x264_cabac_size_decision(
                    cb,
                    (60 as ::core::ffi::c_int + ctx) as ::core::ffi::c_long,
                    1 as ::core::ffi::c_long,
                );
                ctx = 2 as ::core::ffi::c_int + (ctx >> 1 as ::core::ffi::c_int);
                val -= 1;
                if !(val != 0) {
                    break;
                }
            }
        }
        x264_cabac_size_decision_noup(
            cb,
            (60 as ::core::ffi::c_int + ctx) as ::core::ffi::c_long,
            0 as ::core::ffi::c_long,
        );
    }
    #[inline]
    #[c2rust::src_loc = "198:1"]
    pub unsafe extern "C" fn cabac_subpartition_p(
        mut cb: *mut x264_cabac_t,
        mut i_sub: ::core::ffi::c_int,
    ) {
        if i_sub == D_L0_8x8 as ::core::ffi::c_int {
            x264_cabac_size_decision(cb, 21 as ::core::ffi::c_long, 1 as ::core::ffi::c_long);
            return;
        }
        x264_cabac_size_decision(cb, 21 as ::core::ffi::c_long, 0 as ::core::ffi::c_long);
        if i_sub == D_L0_8x4 as ::core::ffi::c_int {
            x264_cabac_size_decision(cb, 22 as ::core::ffi::c_long, 0 as ::core::ffi::c_long);
        } else {
            x264_cabac_size_decision(cb, 22 as ::core::ffi::c_long, 1 as ::core::ffi::c_long);
            x264_cabac_size_decision(
                cb,
                23 as ::core::ffi::c_long,
                (i_sub == D_L0_4x8 as ::core::ffi::c_int) as ::core::ffi::c_int
                    as ::core::ffi::c_long,
            );
        };
    }
    #[inline(always)]
    #[c2rust::src_loc = "215:1"]
    pub unsafe extern "C" fn cabac_subpartition_b(
        mut cb: *mut x264_cabac_t,
        mut i_sub: ::core::ffi::c_int,
    ) {
        if i_sub == D_DIRECT_8x8 as ::core::ffi::c_int {
            x264_cabac_size_decision(cb, 36 as ::core::ffi::c_long, 0 as ::core::ffi::c_long);
            return;
        }
        x264_cabac_size_decision(cb, 36 as ::core::ffi::c_long, 1 as ::core::ffi::c_long);
        if i_sub == D_BI_8x8 as ::core::ffi::c_int {
            x264_cabac_size_decision(cb, 37 as ::core::ffi::c_long, 1 as ::core::ffi::c_long);
            x264_cabac_size_decision(cb, 38 as ::core::ffi::c_long, 0 as ::core::ffi::c_long);
            x264_cabac_size_decision(cb, 39 as ::core::ffi::c_long, 0 as ::core::ffi::c_long);
            x264_cabac_size_decision(cb, 39 as ::core::ffi::c_long, 0 as ::core::ffi::c_long);
            return;
        }
        x264_cabac_size_decision(cb, 37 as ::core::ffi::c_long, 0 as ::core::ffi::c_long);
        x264_cabac_size_decision(
            cb,
            39 as ::core::ffi::c_long,
            (i_sub == D_L1_8x8 as ::core::ffi::c_int) as ::core::ffi::c_int as ::core::ffi::c_long,
        );
    }
    #[inline(always)]
    #[c2rust::src_loc = "235:1"]
    pub unsafe extern "C" fn cabac_transform_size(mut h: *mut x264_t, mut cb: *mut x264_cabac_t) {
        let mut ctx: ::core::ffi::c_int =
            399 as ::core::ffi::c_int + (*h).mb.cache.i_neighbour_transform_size;
        x264_cabac_size_decision_noup(
            cb,
            ctx as ::core::ffi::c_long,
            (*h).mb.b_transform_8x8 as ::core::ffi::c_long,
        );
    }
    #[inline(always)]
    #[c2rust::src_loc = "241:1"]
    pub unsafe extern "C" fn cabac_ref_internal(
        mut h: *mut x264_t,
        mut cb: *mut x264_cabac_t,
        mut i_list: ::core::ffi::c_int,
        mut idx: ::core::ffi::c_int,
        mut bframe: ::core::ffi::c_int,
    ) {
        let i8: ::core::ffi::c_int = x264_scan8[idx as usize] as ::core::ffi::c_int;
        let i_refa: ::core::ffi::c_int = (*h).mb.cache.ref_0[i_list as usize]
            [(i8 - 1 as ::core::ffi::c_int) as usize]
            as ::core::ffi::c_int;
        let i_refb: ::core::ffi::c_int = (*h).mb.cache.ref_0[i_list as usize]
            [(i8 - 8 as ::core::ffi::c_int) as usize]
            as ::core::ffi::c_int;
        let mut ctx: ::core::ffi::c_int = 0 as ::core::ffi::c_int;
        if i_refa > 0 as ::core::ffi::c_int
            && (bframe == 0 || (*h).mb.cache.skip[(i8 - 1 as ::core::ffi::c_int) as usize] == 0)
        {
            ctx += 1;
        }
        if i_refb > 0 as ::core::ffi::c_int
            && (bframe == 0 || (*h).mb.cache.skip[(i8 - 8 as ::core::ffi::c_int) as usize] == 0)
        {
            ctx += 2 as ::core::ffi::c_int;
        }
        let mut i_ref: ::core::ffi::c_int =
            (*h).mb.cache.ref_0[i_list as usize][i8 as usize] as ::core::ffi::c_int;
        while i_ref > 0 as ::core::ffi::c_int {
            x264_cabac_size_decision(
                cb,
                (54 as ::core::ffi::c_int + ctx) as ::core::ffi::c_long,
                1 as ::core::ffi::c_long,
            );
            ctx = (ctx >> 2 as ::core::ffi::c_int) + 4 as ::core::ffi::c_int;
            i_ref -= 1;
        }
        x264_cabac_size_decision(
            cb,
            (54 as ::core::ffi::c_int + ctx) as ::core::ffi::c_long,
            0 as ::core::ffi::c_long,
        );
    }
    #[inline(never)]
    #[c2rust::src_loc = "261:1"]
    pub unsafe extern "C" fn cabac_ref_p(
        mut h: *mut x264_t,
        mut cb: *mut x264_cabac_t,
        mut idx: ::core::ffi::c_int,
    ) {
        cabac_ref_internal(h, cb, 0 as ::core::ffi::c_int, idx, 0 as ::core::ffi::c_int);
    }
    #[inline(never)]
    #[c2rust::src_loc = "265:1"]
    pub unsafe extern "C" fn cabac_ref_b(
        mut h: *mut x264_t,
        mut cb: *mut x264_cabac_t,
        mut i_list: ::core::ffi::c_int,
        mut idx: ::core::ffi::c_int,
    ) {
        cabac_ref_internal(h, cb, i_list, idx, 1 as ::core::ffi::c_int);
    }
    #[inline(always)]
    #[c2rust::src_loc = "270:1"]
    pub unsafe extern "C" fn cabac_mvd_cpn(
        mut h: *mut x264_t,
        mut cb: *mut x264_cabac_t,
        mut i_list: ::core::ffi::c_int,
        mut idx: ::core::ffi::c_int,
        mut l: ::core::ffi::c_int,
        mut mvd: ::core::ffi::c_int,
        mut ctx: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int {
        let mut ctxbase: ::core::ffi::c_int = if l != 0 {
            47 as ::core::ffi::c_int
        } else {
            40 as ::core::ffi::c_int
        };
        if mvd == 0 as ::core::ffi::c_int {
            x264_cabac_size_decision(
                cb,
                (ctxbase + ctx) as ::core::ffi::c_long,
                0 as ::core::ffi::c_long,
            );
            return 0 as ::core::ffi::c_int;
        }
        let mut i_abs: ::core::ffi::c_int = abs(mvd);
        x264_cabac_size_decision(
            cb,
            (ctxbase + ctx) as ::core::ffi::c_long,
            1 as ::core::ffi::c_long,
        );
        if i_abs <= 3 as ::core::ffi::c_int {
            let mut i: ::core::ffi::c_int = 1 as ::core::ffi::c_int;
            while i < i_abs {
                x264_cabac_size_decision(
                    cb,
                    (ctxbase + i + 2 as ::core::ffi::c_int) as ::core::ffi::c_long,
                    1 as ::core::ffi::c_long,
                );
                i += 1;
            }
            x264_cabac_size_decision(
                cb,
                (ctxbase + i_abs + 2 as ::core::ffi::c_int) as ::core::ffi::c_long,
                0 as ::core::ffi::c_long,
            );
            (*cb).f8_bits_encoded += 256 as ::core::ffi::c_int;
        } else {
            x264_cabac_size_decision(
                cb,
                (ctxbase + 3 as ::core::ffi::c_int) as ::core::ffi::c_long,
                1 as ::core::ffi::c_long,
            );
            x264_cabac_size_decision(
                cb,
                (ctxbase + 4 as ::core::ffi::c_int) as ::core::ffi::c_long,
                1 as ::core::ffi::c_long,
            );
            x264_cabac_size_decision(
                cb,
                (ctxbase + 5 as ::core::ffi::c_int) as ::core::ffi::c_long,
                1 as ::core::ffi::c_long,
            );
            if i_abs < 9 as ::core::ffi::c_int {
                (*cb).f8_bits_encoded += x264_10_cabac_size_unary
                    [(i_abs - 3 as ::core::ffi::c_int) as usize]
                    [(*cb).state[(ctxbase + 6 as ::core::ffi::c_int) as usize] as usize]
                    as ::core::ffi::c_int;
                (*cb).state[(ctxbase + 6 as ::core::ffi::c_int) as usize] =
                    x264_10_cabac_transition_unary[(i_abs - 3 as ::core::ffi::c_int) as usize]
                        [(*cb).state[(ctxbase + 6 as ::core::ffi::c_int) as usize] as usize];
            } else {
                (*cb).f8_bits_encoded += cabac_size_5ones
                    [(*cb).state[(ctxbase + 6 as ::core::ffi::c_int) as usize] as usize]
                    as ::core::ffi::c_int;
                (*cb).state[(ctxbase + 6 as ::core::ffi::c_int) as usize] = cabac_transition_5ones
                    [(*cb).state[(ctxbase + 6 as ::core::ffi::c_int) as usize] as usize];
                (*cb).f8_bits_encoded += (bs_size_ue_big(
                    (i_abs - 9 as ::core::ffi::c_int
                        + ((1 as ::core::ffi::c_int) << 3 as ::core::ffi::c_int)
                        - 1 as ::core::ffi::c_int) as ::core::ffi::c_uint,
                ) - 3 as ::core::ffi::c_int)
                    << 8 as ::core::ffi::c_int;
            }
        }
        return if i_abs < 66 as ::core::ffi::c_int {
            i_abs
        } else {
            66 as ::core::ffi::c_int
        };
    }
    #[inline(never)]
    #[c2rust::src_loc = "329:1"]
    pub unsafe extern "C" fn cabac_mvd(
        mut h: *mut x264_t,
        mut cb: *mut x264_cabac_t,
        mut i_list: ::core::ffi::c_int,
        mut idx: ::core::ffi::c_int,
        mut width: ::core::ffi::c_int,
    ) -> uint16_t {
        let mut mvp: [int16_t; 2] = [0; 2];
        let mut mdx: ::core::ffi::c_int = 0;
        let mut mdy: ::core::ffi::c_int = 0;
        x264_10_mb_predict_mv(h, i_list, idx, width, mvp.as_mut_ptr());
        mdx = (*h).mb.cache.mv[i_list as usize][x264_scan8[idx as usize] as usize]
            [0 as ::core::ffi::c_int as usize] as ::core::ffi::c_int
            - mvp[0 as ::core::ffi::c_int as usize] as ::core::ffi::c_int;
        mdy = (*h).mb.cache.mv[i_list as usize][x264_scan8[idx as usize] as usize]
            [1 as ::core::ffi::c_int as usize] as ::core::ffi::c_int
            - mvp[1 as ::core::ffi::c_int as usize] as ::core::ffi::c_int;
        let mut amvd: uint16_t = x264_cabac_mvd_sum(
            (*(*(*h).mb.cache.mvd.as_mut_ptr().offset(i_list as isize))
                .as_mut_ptr()
                .offset(
                    (*x264_scan8.as_ptr().offset(idx as isize) as ::core::ffi::c_int
                        - 1 as ::core::ffi::c_int) as isize,
                ))
            .as_mut_ptr(),
            (*(*(*h).mb.cache.mvd.as_mut_ptr().offset(i_list as isize))
                .as_mut_ptr()
                .offset(
                    (*x264_scan8.as_ptr().offset(idx as isize) as ::core::ffi::c_int
                        - 8 as ::core::ffi::c_int) as isize,
                ))
            .as_mut_ptr(),
        );
        mdx = cabac_mvd_cpn(
            h,
            cb,
            i_list,
            idx,
            0 as ::core::ffi::c_int,
            mdx,
            amvd as ::core::ffi::c_int & 0xff as ::core::ffi::c_int,
        );
        mdy = cabac_mvd_cpn(
            h,
            cb,
            i_list,
            idx,
            1 as ::core::ffi::c_int,
            mdy,
            amvd as ::core::ffi::c_int >> 8 as ::core::ffi::c_int,
        );
        return pack8to16(mdx as uint32_t, mdy as uint32_t) as uint16_t;
    }
    #[inline]
    #[c2rust::src_loc = "355:1"]
    pub unsafe extern "C" fn cabac_8x8_mvd(
        mut h: *mut x264_t,
        mut cb: *mut x264_cabac_t,
        mut i: ::core::ffi::c_int,
    ) {
        match (*h).mb.i_sub_partition[i as usize] as ::core::ffi::c_int {
            3 => {
                let mut mvd: uint16_t = cabac_mvd(
                    h,
                    cb,
                    0 as ::core::ffi::c_int,
                    4 as ::core::ffi::c_int * i,
                    2 as ::core::ffi::c_int,
                );
                x264_macroblock_cache_mvd(
                    h,
                    block_idx_x[(4 as ::core::ffi::c_int * i) as usize] as ::core::ffi::c_int,
                    block_idx_y[(4 as ::core::ffi::c_int * i) as usize] as ::core::ffi::c_int,
                    2 as ::core::ffi::c_int,
                    2 as ::core::ffi::c_int,
                    0 as ::core::ffi::c_int,
                    mvd,
                );
            }
            1 => {
                let mut mvd_0: uint16_t = cabac_mvd(
                    h,
                    cb,
                    0 as ::core::ffi::c_int,
                    4 as ::core::ffi::c_int * i + 0 as ::core::ffi::c_int,
                    2 as ::core::ffi::c_int,
                );
                x264_macroblock_cache_mvd(
                    h,
                    block_idx_x[(4 as ::core::ffi::c_int * i + 0 as ::core::ffi::c_int) as usize]
                        as ::core::ffi::c_int,
                    block_idx_y[(4 as ::core::ffi::c_int * i + 0 as ::core::ffi::c_int) as usize]
                        as ::core::ffi::c_int,
                    2 as ::core::ffi::c_int,
                    1 as ::core::ffi::c_int,
                    0 as ::core::ffi::c_int,
                    mvd_0,
                );
                let mut mvd_1: uint16_t = cabac_mvd(
                    h,
                    cb,
                    0 as ::core::ffi::c_int,
                    4 as ::core::ffi::c_int * i + 2 as ::core::ffi::c_int,
                    2 as ::core::ffi::c_int,
                );
                x264_macroblock_cache_mvd(
                    h,
                    block_idx_x[(4 as ::core::ffi::c_int * i + 2 as ::core::ffi::c_int) as usize]
                        as ::core::ffi::c_int,
                    block_idx_y[(4 as ::core::ffi::c_int * i + 2 as ::core::ffi::c_int) as usize]
                        as ::core::ffi::c_int,
                    2 as ::core::ffi::c_int,
                    1 as ::core::ffi::c_int,
                    0 as ::core::ffi::c_int,
                    mvd_1,
                );
            }
            2 => {
                let mut mvd_2: uint16_t = cabac_mvd(
                    h,
                    cb,
                    0 as ::core::ffi::c_int,
                    4 as ::core::ffi::c_int * i + 0 as ::core::ffi::c_int,
                    1 as ::core::ffi::c_int,
                );
                x264_macroblock_cache_mvd(
                    h,
                    block_idx_x[(4 as ::core::ffi::c_int * i + 0 as ::core::ffi::c_int) as usize]
                        as ::core::ffi::c_int,
                    block_idx_y[(4 as ::core::ffi::c_int * i + 0 as ::core::ffi::c_int) as usize]
                        as ::core::ffi::c_int,
                    1 as ::core::ffi::c_int,
                    2 as ::core::ffi::c_int,
                    0 as ::core::ffi::c_int,
                    mvd_2,
                );
                let mut mvd_3: uint16_t = cabac_mvd(
                    h,
                    cb,
                    0 as ::core::ffi::c_int,
                    4 as ::core::ffi::c_int * i + 1 as ::core::ffi::c_int,
                    1 as ::core::ffi::c_int,
                );
                x264_macroblock_cache_mvd(
                    h,
                    block_idx_x[(4 as ::core::ffi::c_int * i + 1 as ::core::ffi::c_int) as usize]
                        as ::core::ffi::c_int,
                    block_idx_y[(4 as ::core::ffi::c_int * i + 1 as ::core::ffi::c_int) as usize]
                        as ::core::ffi::c_int,
                    1 as ::core::ffi::c_int,
                    2 as ::core::ffi::c_int,
                    0 as ::core::ffi::c_int,
                    mvd_3,
                );
            }
            0 => {
                let mut mvd_4: uint16_t = cabac_mvd(
                    h,
                    cb,
                    0 as ::core::ffi::c_int,
                    4 as ::core::ffi::c_int * i + 0 as ::core::ffi::c_int,
                    1 as ::core::ffi::c_int,
                );
                x264_macroblock_cache_mvd(
                    h,
                    block_idx_x[(4 as ::core::ffi::c_int * i + 0 as ::core::ffi::c_int) as usize]
                        as ::core::ffi::c_int,
                    block_idx_y[(4 as ::core::ffi::c_int * i + 0 as ::core::ffi::c_int) as usize]
                        as ::core::ffi::c_int,
                    1 as ::core::ffi::c_int,
                    1 as ::core::ffi::c_int,
                    0 as ::core::ffi::c_int,
                    mvd_4,
                );
                let mut mvd_5: uint16_t = cabac_mvd(
                    h,
                    cb,
                    0 as ::core::ffi::c_int,
                    4 as ::core::ffi::c_int * i + 1 as ::core::ffi::c_int,
                    1 as ::core::ffi::c_int,
                );
                x264_macroblock_cache_mvd(
                    h,
                    block_idx_x[(4 as ::core::ffi::c_int * i + 1 as ::core::ffi::c_int) as usize]
                        as ::core::ffi::c_int,
                    block_idx_y[(4 as ::core::ffi::c_int * i + 1 as ::core::ffi::c_int) as usize]
                        as ::core::ffi::c_int,
                    1 as ::core::ffi::c_int,
                    1 as ::core::ffi::c_int,
                    0 as ::core::ffi::c_int,
                    mvd_5,
                );
                let mut mvd_6: uint16_t = cabac_mvd(
                    h,
                    cb,
                    0 as ::core::ffi::c_int,
                    4 as ::core::ffi::c_int * i + 2 as ::core::ffi::c_int,
                    1 as ::core::ffi::c_int,
                );
                x264_macroblock_cache_mvd(
                    h,
                    block_idx_x[(4 as ::core::ffi::c_int * i + 2 as ::core::ffi::c_int) as usize]
                        as ::core::ffi::c_int,
                    block_idx_y[(4 as ::core::ffi::c_int * i + 2 as ::core::ffi::c_int) as usize]
                        as ::core::ffi::c_int,
                    1 as ::core::ffi::c_int,
                    1 as ::core::ffi::c_int,
                    0 as ::core::ffi::c_int,
                    mvd_6,
                );
                let mut mvd_7: uint16_t = cabac_mvd(
                    h,
                    cb,
                    0 as ::core::ffi::c_int,
                    4 as ::core::ffi::c_int * i + 3 as ::core::ffi::c_int,
                    1 as ::core::ffi::c_int,
                );
                x264_macroblock_cache_mvd(
                    h,
                    block_idx_x[(4 as ::core::ffi::c_int * i + 3 as ::core::ffi::c_int) as usize]
                        as ::core::ffi::c_int,
                    block_idx_y[(4 as ::core::ffi::c_int * i + 3 as ::core::ffi::c_int) as usize]
                        as ::core::ffi::c_int,
                    1 as ::core::ffi::c_int,
                    1 as ::core::ffi::c_int,
                    0 as ::core::ffi::c_int,
                    mvd_7,
                );
            }
            _ => {
                __assert_fail(
                    b"0\0" as *const u8 as *const ::core::ffi::c_char,
                    b"encoder/cabac.c\0" as *const u8 as *const ::core::ffi::c_char,
                    377 as ::core::ffi::c_uint,
                    ::core::mem::transmute::<[u8; 50], [::core::ffi::c_char; 50]>(
                        *b"void cabac_8x8_mvd(x264_t *, x264_cabac_t *, int)\0",
                    )
                    .as_ptr(),
                );
                'c_42519: {
                    __assert_fail(
                        b"0\0" as *const u8 as *const ::core::ffi::c_char,
                        b"encoder/cabac.c\0" as *const u8 as *const ::core::ffi::c_char,
                        377 as ::core::ffi::c_uint,
                        ::core::mem::transmute::<[u8; 50], [::core::ffi::c_char; 50]>(
                            *b"void cabac_8x8_mvd(x264_t *, x264_cabac_t *, int)\0",
                        )
                        .as_ptr(),
                    );
                };
            }
        };
    }
    #[inline(always)]
    #[c2rust::src_loc = "381:1"]
    pub unsafe extern "C" fn cabac_mb_header_i(
        mut h: *mut x264_t,
        mut cb: *mut x264_cabac_t,
        mut i_mb_type: ::core::ffi::c_int,
        mut slice_type: ::core::ffi::c_int,
        mut chroma: ::core::ffi::c_int,
    ) {
        if slice_type == SLICE_TYPE_I as ::core::ffi::c_int {
            let mut ctx: ::core::ffi::c_int = 0 as ::core::ffi::c_int;
            if (*h).mb.i_neighbour & MB_LEFT as ::core::ffi::c_int as ::core::ffi::c_uint != 0
                && (*h).mb.i_mb_type_left[0 as ::core::ffi::c_int as usize]
                    != I_4x4 as ::core::ffi::c_int
            {
                ctx += 1;
            }
            if (*h).mb.i_neighbour & MB_TOP as ::core::ffi::c_int as ::core::ffi::c_uint != 0
                && (*h).mb.i_mb_type_top != I_4x4 as ::core::ffi::c_int
            {
                ctx += 1;
            }
            cabac_mb_type_intra(
                h,
                cb,
                i_mb_type,
                3 as ::core::ffi::c_int + ctx,
                3 as ::core::ffi::c_int + 3 as ::core::ffi::c_int,
                3 as ::core::ffi::c_int + 4 as ::core::ffi::c_int,
                3 as ::core::ffi::c_int + 5 as ::core::ffi::c_int,
                3 as ::core::ffi::c_int + 6 as ::core::ffi::c_int,
                3 as ::core::ffi::c_int + 7 as ::core::ffi::c_int,
            );
        } else if slice_type == SLICE_TYPE_P as ::core::ffi::c_int {
            x264_cabac_size_decision_noup(cb, 14 as ::core::ffi::c_long, 1 as ::core::ffi::c_long);
            cabac_mb_type_intra(
                h,
                cb,
                i_mb_type,
                17 as ::core::ffi::c_int + 0 as ::core::ffi::c_int,
                17 as ::core::ffi::c_int + 1 as ::core::ffi::c_int,
                17 as ::core::ffi::c_int + 2 as ::core::ffi::c_int,
                17 as ::core::ffi::c_int + 2 as ::core::ffi::c_int,
                17 as ::core::ffi::c_int + 3 as ::core::ffi::c_int,
                17 as ::core::ffi::c_int + 3 as ::core::ffi::c_int,
            );
        } else if slice_type == SLICE_TYPE_B as ::core::ffi::c_int {
            x264_cabac_size_decision_noup(
                cb,
                (27 as ::core::ffi::c_int + 3 as ::core::ffi::c_int) as ::core::ffi::c_long,
                1 as ::core::ffi::c_long,
            );
            x264_cabac_size_decision_noup(
                cb,
                (27 as ::core::ffi::c_int + 4 as ::core::ffi::c_int) as ::core::ffi::c_long,
                1 as ::core::ffi::c_long,
            );
            x264_cabac_size_decision(
                cb,
                (27 as ::core::ffi::c_int + 5 as ::core::ffi::c_int) as ::core::ffi::c_long,
                1 as ::core::ffi::c_long,
            );
            x264_cabac_size_decision(
                cb,
                (27 as ::core::ffi::c_int + 5 as ::core::ffi::c_int) as ::core::ffi::c_long,
                0 as ::core::ffi::c_long,
            );
            x264_cabac_size_decision(
                cb,
                (27 as ::core::ffi::c_int + 5 as ::core::ffi::c_int) as ::core::ffi::c_long,
                1 as ::core::ffi::c_long,
            );
            cabac_mb_type_intra(
                h,
                cb,
                i_mb_type,
                32 as ::core::ffi::c_int + 0 as ::core::ffi::c_int,
                32 as ::core::ffi::c_int + 1 as ::core::ffi::c_int,
                32 as ::core::ffi::c_int + 2 as ::core::ffi::c_int,
                32 as ::core::ffi::c_int + 2 as ::core::ffi::c_int,
                32 as ::core::ffi::c_int + 3 as ::core::ffi::c_int,
                32 as ::core::ffi::c_int + 3 as ::core::ffi::c_int,
            );
        }
        if i_mb_type == I_PCM as ::core::ffi::c_int {
            return;
        }
        if i_mb_type != I_16x16 as ::core::ffi::c_int {
            if (*(*h).pps.as_mut_ptr()).b_transform_8x8_mode != 0 {
                cabac_transform_size(h, cb);
            }
            let mut di: ::core::ffi::c_int = if (*h).mb.b_transform_8x8 != 0 {
                4 as ::core::ffi::c_int
            } else {
                1 as ::core::ffi::c_int
            };
            let mut i: ::core::ffi::c_int = 0 as ::core::ffi::c_int;
            while i < 16 as ::core::ffi::c_int {
                let i_pred: ::core::ffi::c_int =
                    x264_mb_predict_intra4x4_mode(h, i) as ::core::ffi::c_int;
                let i_mode: ::core::ffi::c_int =
                    x264_mb_pred_mode4x4_fix[((*h).mb.cache.intra4x4_pred_mode
                        [x264_scan8[i as usize] as usize]
                        as ::core::ffi::c_int
                        + 1 as ::core::ffi::c_int)
                        as usize] as ::core::ffi::c_int;
                cabac_intra4x4_pred_mode(cb, i_pred, i_mode);
                i += di;
            }
        }
        if chroma != 0 {
            cabac_intra_chroma_pred_mode(h, cb);
        }
    }
    #[inline(always)]
    #[c2rust::src_loc = "435:1"]
    pub unsafe extern "C" fn cabac_mb_header_p(
        mut h: *mut x264_t,
        mut cb: *mut x264_cabac_t,
        mut i_mb_type: ::core::ffi::c_int,
        mut chroma: ::core::ffi::c_int,
    ) {
        if i_mb_type == P_L0 as ::core::ffi::c_int {
            x264_cabac_size_decision_noup(cb, 14 as ::core::ffi::c_long, 0 as ::core::ffi::c_long);
            if (*h).mb.i_partition == D_16x16 as ::core::ffi::c_int {
                x264_cabac_size_decision_noup(
                    cb,
                    15 as ::core::ffi::c_long,
                    0 as ::core::ffi::c_long,
                );
                x264_cabac_size_decision_noup(
                    cb,
                    16 as ::core::ffi::c_long,
                    0 as ::core::ffi::c_long,
                );
                if (*h).mb.pic.i_fref[0 as ::core::ffi::c_int as usize] > 1 as ::core::ffi::c_int {
                    cabac_ref_p(h, cb, 0 as ::core::ffi::c_int);
                }
                let mut mvd: uint16_t = cabac_mvd(
                    h,
                    cb,
                    0 as ::core::ffi::c_int,
                    0 as ::core::ffi::c_int,
                    4 as ::core::ffi::c_int,
                );
                x264_macroblock_cache_mvd(
                    h,
                    block_idx_x[0 as ::core::ffi::c_int as usize] as ::core::ffi::c_int,
                    block_idx_y[0 as ::core::ffi::c_int as usize] as ::core::ffi::c_int,
                    4 as ::core::ffi::c_int,
                    4 as ::core::ffi::c_int,
                    0 as ::core::ffi::c_int,
                    mvd,
                );
            } else if (*h).mb.i_partition == D_16x8 as ::core::ffi::c_int {
                x264_cabac_size_decision_noup(
                    cb,
                    15 as ::core::ffi::c_long,
                    1 as ::core::ffi::c_long,
                );
                x264_cabac_size_decision_noup(
                    cb,
                    17 as ::core::ffi::c_long,
                    1 as ::core::ffi::c_long,
                );
                if (*h).mb.pic.i_fref[0 as ::core::ffi::c_int as usize] > 1 as ::core::ffi::c_int {
                    cabac_ref_p(h, cb, 0 as ::core::ffi::c_int);
                    cabac_ref_p(h, cb, 8 as ::core::ffi::c_int);
                }
                let mut mvd_0: uint16_t = cabac_mvd(
                    h,
                    cb,
                    0 as ::core::ffi::c_int,
                    0 as ::core::ffi::c_int,
                    4 as ::core::ffi::c_int,
                );
                x264_macroblock_cache_mvd(
                    h,
                    block_idx_x[0 as ::core::ffi::c_int as usize] as ::core::ffi::c_int,
                    block_idx_y[0 as ::core::ffi::c_int as usize] as ::core::ffi::c_int,
                    4 as ::core::ffi::c_int,
                    2 as ::core::ffi::c_int,
                    0 as ::core::ffi::c_int,
                    mvd_0,
                );
                let mut mvd_1: uint16_t = cabac_mvd(
                    h,
                    cb,
                    0 as ::core::ffi::c_int,
                    8 as ::core::ffi::c_int,
                    4 as ::core::ffi::c_int,
                );
                x264_macroblock_cache_mvd(
                    h,
                    block_idx_x[8 as ::core::ffi::c_int as usize] as ::core::ffi::c_int,
                    block_idx_y[8 as ::core::ffi::c_int as usize] as ::core::ffi::c_int,
                    4 as ::core::ffi::c_int,
                    2 as ::core::ffi::c_int,
                    0 as ::core::ffi::c_int,
                    mvd_1,
                );
            } else {
                x264_cabac_size_decision_noup(
                    cb,
                    15 as ::core::ffi::c_long,
                    1 as ::core::ffi::c_long,
                );
                x264_cabac_size_decision_noup(
                    cb,
                    17 as ::core::ffi::c_long,
                    0 as ::core::ffi::c_long,
                );
                if (*h).mb.pic.i_fref[0 as ::core::ffi::c_int as usize] > 1 as ::core::ffi::c_int {
                    cabac_ref_p(h, cb, 0 as ::core::ffi::c_int);
                    cabac_ref_p(h, cb, 4 as ::core::ffi::c_int);
                }
                let mut mvd_2: uint16_t = cabac_mvd(
                    h,
                    cb,
                    0 as ::core::ffi::c_int,
                    0 as ::core::ffi::c_int,
                    2 as ::core::ffi::c_int,
                );
                x264_macroblock_cache_mvd(
                    h,
                    block_idx_x[0 as ::core::ffi::c_int as usize] as ::core::ffi::c_int,
                    block_idx_y[0 as ::core::ffi::c_int as usize] as ::core::ffi::c_int,
                    2 as ::core::ffi::c_int,
                    4 as ::core::ffi::c_int,
                    0 as ::core::ffi::c_int,
                    mvd_2,
                );
                let mut mvd_3: uint16_t = cabac_mvd(
                    h,
                    cb,
                    0 as ::core::ffi::c_int,
                    4 as ::core::ffi::c_int,
                    2 as ::core::ffi::c_int,
                );
                x264_macroblock_cache_mvd(
                    h,
                    block_idx_x[4 as ::core::ffi::c_int as usize] as ::core::ffi::c_int,
                    block_idx_y[4 as ::core::ffi::c_int as usize] as ::core::ffi::c_int,
                    2 as ::core::ffi::c_int,
                    4 as ::core::ffi::c_int,
                    0 as ::core::ffi::c_int,
                    mvd_3,
                );
            }
        } else if i_mb_type == P_8x8 as ::core::ffi::c_int {
            x264_cabac_size_decision_noup(cb, 14 as ::core::ffi::c_long, 0 as ::core::ffi::c_long);
            x264_cabac_size_decision_noup(cb, 15 as ::core::ffi::c_long, 0 as ::core::ffi::c_long);
            x264_cabac_size_decision_noup(cb, 16 as ::core::ffi::c_long, 1 as ::core::ffi::c_long);
            let mut i: ::core::ffi::c_int = 0 as ::core::ffi::c_int;
            while i < 4 as ::core::ffi::c_int {
                cabac_subpartition_p(
                    cb,
                    (*h).mb.i_sub_partition[i as usize] as ::core::ffi::c_int,
                );
                i += 1;
            }
            if (*h).mb.pic.i_fref[0 as ::core::ffi::c_int as usize] > 1 as ::core::ffi::c_int {
                cabac_ref_p(h, cb, 0 as ::core::ffi::c_int);
                cabac_ref_p(h, cb, 4 as ::core::ffi::c_int);
                cabac_ref_p(h, cb, 8 as ::core::ffi::c_int);
                cabac_ref_p(h, cb, 12 as ::core::ffi::c_int);
            }
            let mut i_0: ::core::ffi::c_int = 0 as ::core::ffi::c_int;
            while i_0 < 4 as ::core::ffi::c_int {
                cabac_8x8_mvd(h, cb, i_0);
                i_0 += 1;
            }
        } else {
            cabac_mb_header_i(h, cb, i_mb_type, SLICE_TYPE_P as ::core::ffi::c_int, chroma);
        };
    }
    #[inline(always)]
    #[c2rust::src_loc = "499:1"]
    pub unsafe extern "C" fn cabac_mb_header_b(
        mut h: *mut x264_t,
        mut cb: *mut x264_cabac_t,
        mut i_mb_type: ::core::ffi::c_int,
        mut chroma: ::core::ffi::c_int,
    ) {
        let mut ctx: ::core::ffi::c_int = 0 as ::core::ffi::c_int;
        if (*h).mb.i_neighbour & MB_LEFT as ::core::ffi::c_int as ::core::ffi::c_uint != 0
            && (*h).mb.i_mb_type_left[0 as ::core::ffi::c_int as usize]
                != B_SKIP as ::core::ffi::c_int
            && (*h).mb.i_mb_type_left[0 as ::core::ffi::c_int as usize]
                != B_DIRECT as ::core::ffi::c_int
        {
            ctx += 1;
        }
        if (*h).mb.i_neighbour & MB_TOP as ::core::ffi::c_int as ::core::ffi::c_uint != 0
            && (*h).mb.i_mb_type_top != B_SKIP as ::core::ffi::c_int
            && (*h).mb.i_mb_type_top != B_DIRECT as ::core::ffi::c_int
        {
            ctx += 1;
        }
        if i_mb_type == B_DIRECT as ::core::ffi::c_int {
            x264_cabac_size_decision_noup(
                cb,
                (27 as ::core::ffi::c_int + ctx) as ::core::ffi::c_long,
                0 as ::core::ffi::c_long,
            );
            return;
        }
        x264_cabac_size_decision_noup(
            cb,
            (27 as ::core::ffi::c_int + ctx) as ::core::ffi::c_long,
            1 as ::core::ffi::c_long,
        );
        if i_mb_type == B_8x8 as ::core::ffi::c_int {
            x264_cabac_size_decision_noup(
                cb,
                (27 as ::core::ffi::c_int + 3 as ::core::ffi::c_int) as ::core::ffi::c_long,
                1 as ::core::ffi::c_long,
            );
            x264_cabac_size_decision_noup(
                cb,
                (27 as ::core::ffi::c_int + 4 as ::core::ffi::c_int) as ::core::ffi::c_long,
                1 as ::core::ffi::c_long,
            );
            x264_cabac_size_decision(
                cb,
                (27 as ::core::ffi::c_int + 5 as ::core::ffi::c_int) as ::core::ffi::c_long,
                1 as ::core::ffi::c_long,
            );
            x264_cabac_size_decision(
                cb,
                (27 as ::core::ffi::c_int + 5 as ::core::ffi::c_int) as ::core::ffi::c_long,
                1 as ::core::ffi::c_long,
            );
            x264_cabac_size_decision_noup(
                cb,
                (27 as ::core::ffi::c_int + 5 as ::core::ffi::c_int) as ::core::ffi::c_long,
                1 as ::core::ffi::c_long,
            );
            let mut i: ::core::ffi::c_int = 0 as ::core::ffi::c_int;
            while i < 4 as ::core::ffi::c_int {
                cabac_subpartition_b(
                    cb,
                    (*h).mb.i_sub_partition[i as usize] as ::core::ffi::c_int,
                );
                i += 1;
            }
            if (*h).mb.pic.i_fref[0 as ::core::ffi::c_int as usize] > 1 as ::core::ffi::c_int {
                let mut i_0: ::core::ffi::c_int = 0 as ::core::ffi::c_int;
                while i_0 < 4 as ::core::ffi::c_int {
                    if x264_mb_partition_listX_table[0 as ::core::ffi::c_int as usize]
                        [(*h).mb.i_sub_partition[i_0 as usize] as usize]
                        != 0
                    {
                        cabac_ref_b(
                            h,
                            cb,
                            0 as ::core::ffi::c_int,
                            4 as ::core::ffi::c_int * i_0,
                        );
                    }
                    i_0 += 1;
                }
            }
            if (*h).mb.pic.i_fref[1 as ::core::ffi::c_int as usize] > 1 as ::core::ffi::c_int {
                let mut i_1: ::core::ffi::c_int = 0 as ::core::ffi::c_int;
                while i_1 < 4 as ::core::ffi::c_int {
                    if x264_mb_partition_listX_table[1 as ::core::ffi::c_int as usize]
                        [(*h).mb.i_sub_partition[i_1 as usize] as usize]
                        != 0
                    {
                        cabac_ref_b(
                            h,
                            cb,
                            1 as ::core::ffi::c_int,
                            4 as ::core::ffi::c_int * i_1,
                        );
                    }
                    i_1 += 1;
                }
            }
            let mut i_2: ::core::ffi::c_int = 0 as ::core::ffi::c_int;
            while i_2 < 4 as ::core::ffi::c_int {
                if x264_mb_partition_listX_table[0 as ::core::ffi::c_int as usize]
                    [(*h).mb.i_sub_partition[i_2 as usize] as usize]
                    != 0
                {
                    let mut mvd: uint16_t = cabac_mvd(
                        h,
                        cb,
                        0 as ::core::ffi::c_int,
                        4 as ::core::ffi::c_int * i_2,
                        2 as ::core::ffi::c_int,
                    );
                    x264_macroblock_cache_mvd(
                        h,
                        block_idx_x[(4 as ::core::ffi::c_int * i_2) as usize] as ::core::ffi::c_int,
                        block_idx_y[(4 as ::core::ffi::c_int * i_2) as usize] as ::core::ffi::c_int,
                        2 as ::core::ffi::c_int,
                        2 as ::core::ffi::c_int,
                        0 as ::core::ffi::c_int,
                        mvd,
                    );
                }
                i_2 += 1;
            }
            let mut i_3: ::core::ffi::c_int = 0 as ::core::ffi::c_int;
            while i_3 < 4 as ::core::ffi::c_int {
                if x264_mb_partition_listX_table[1 as ::core::ffi::c_int as usize]
                    [(*h).mb.i_sub_partition[i_3 as usize] as usize]
                    != 0
                {
                    let mut mvd_0: uint16_t = cabac_mvd(
                        h,
                        cb,
                        1 as ::core::ffi::c_int,
                        4 as ::core::ffi::c_int * i_3,
                        2 as ::core::ffi::c_int,
                    );
                    x264_macroblock_cache_mvd(
                        h,
                        block_idx_x[(4 as ::core::ffi::c_int * i_3) as usize] as ::core::ffi::c_int,
                        block_idx_y[(4 as ::core::ffi::c_int * i_3) as usize] as ::core::ffi::c_int,
                        2 as ::core::ffi::c_int,
                        2 as ::core::ffi::c_int,
                        1 as ::core::ffi::c_int,
                        mvd_0,
                    );
                }
                i_3 += 1;
            }
        } else if i_mb_type >= B_L0_L0 as ::core::ffi::c_int
            && i_mb_type <= B_BI_BI as ::core::ffi::c_int
        {
            pub static mut i_mb_bits: [uint8_t; 27] = [
                0x31 as ::core::ffi::c_int as uint8_t,
                0x29 as ::core::ffi::c_int as uint8_t,
                0x4 as ::core::ffi::c_int as uint8_t,
                0x35 as ::core::ffi::c_int as uint8_t,
                0x2d as ::core::ffi::c_int as uint8_t,
                0 as ::core::ffi::c_int as uint8_t,
                0x43 as ::core::ffi::c_int as uint8_t,
                0x63 as ::core::ffi::c_int as uint8_t,
                0 as ::core::ffi::c_int as uint8_t,
                0x3d as ::core::ffi::c_int as uint8_t,
                0x2f as ::core::ffi::c_int as uint8_t,
                0 as ::core::ffi::c_int as uint8_t,
                0x39 as ::core::ffi::c_int as uint8_t,
                0x25 as ::core::ffi::c_int as uint8_t,
                0x6 as ::core::ffi::c_int as uint8_t,
                0x53 as ::core::ffi::c_int as uint8_t,
                0x73 as ::core::ffi::c_int as uint8_t,
                0 as ::core::ffi::c_int as uint8_t,
                0x4b as ::core::ffi::c_int as uint8_t,
                0x6b as ::core::ffi::c_int as uint8_t,
                0 as ::core::ffi::c_int as uint8_t,
                0x5b as ::core::ffi::c_int as uint8_t,
                0x7b as ::core::ffi::c_int as uint8_t,
                0 as ::core::ffi::c_int as uint8_t,
                0x47 as ::core::ffi::c_int as uint8_t,
                0x67 as ::core::ffi::c_int as uint8_t,
                0x21 as ::core::ffi::c_int as uint8_t,
            ];
            let idx: ::core::ffi::c_int = (i_mb_type
                - B_L0_L0 as ::core::ffi::c_int as ::core::ffi::c_int)
                * 3 as ::core::ffi::c_int
                + ((*h).mb.i_partition - D_16x8 as ::core::ffi::c_int as ::core::ffi::c_int);
            let mut bits: ::core::ffi::c_int = i_mb_bits[idx as usize] as ::core::ffi::c_int;
            x264_cabac_size_decision_noup(
                cb,
                (27 as ::core::ffi::c_int + 3 as ::core::ffi::c_int) as ::core::ffi::c_long,
                (bits & 1 as ::core::ffi::c_int) as ::core::ffi::c_long,
            );
            x264_cabac_size_decision(
                cb,
                (27 as ::core::ffi::c_int + 5 as ::core::ffi::c_int
                    - (bits & 1 as ::core::ffi::c_int)) as ::core::ffi::c_long,
                (bits >> 1 as ::core::ffi::c_int & 1 as ::core::ffi::c_int) as ::core::ffi::c_long,
            );
            bits >>= 2 as ::core::ffi::c_int;
            if bits != 1 as ::core::ffi::c_int {
                x264_cabac_size_decision(
                    cb,
                    (27 as ::core::ffi::c_int + 5 as ::core::ffi::c_int) as ::core::ffi::c_long,
                    (bits & 1 as ::core::ffi::c_int) as ::core::ffi::c_long,
                );
                bits >>= 1 as ::core::ffi::c_int;
                x264_cabac_size_decision(
                    cb,
                    (27 as ::core::ffi::c_int + 5 as ::core::ffi::c_int) as ::core::ffi::c_long,
                    (bits & 1 as ::core::ffi::c_int) as ::core::ffi::c_long,
                );
                bits >>= 1 as ::core::ffi::c_int;
                x264_cabac_size_decision(
                    cb,
                    (27 as ::core::ffi::c_int + 5 as ::core::ffi::c_int) as ::core::ffi::c_long,
                    (bits & 1 as ::core::ffi::c_int) as ::core::ffi::c_long,
                );
                bits >>= 1 as ::core::ffi::c_int;
                if bits != 1 as ::core::ffi::c_int {
                    x264_cabac_size_decision_noup(
                        cb,
                        (27 as ::core::ffi::c_int + 5 as ::core::ffi::c_int) as ::core::ffi::c_long,
                        (bits & 1 as ::core::ffi::c_int) as ::core::ffi::c_long,
                    );
                }
            }
            let mut b_list: *const [uint8_t; 2] =
                (*x264_mb_type_list_table.as_ptr().offset(i_mb_type as isize)).as_ptr()
                    as *const [uint8_t; 2];
            if (*h).mb.pic.i_fref[0 as ::core::ffi::c_int as usize] > 1 as ::core::ffi::c_int {
                if (*b_list.offset(0 as ::core::ffi::c_int as isize))
                    [0 as ::core::ffi::c_int as usize]
                    != 0
                {
                    cabac_ref_b(h, cb, 0 as ::core::ffi::c_int, 0 as ::core::ffi::c_int);
                }
                if (*b_list.offset(0 as ::core::ffi::c_int as isize))
                    [1 as ::core::ffi::c_int as usize] as ::core::ffi::c_int
                    != 0
                    && (*h).mb.i_partition != D_16x16 as ::core::ffi::c_int
                {
                    cabac_ref_b(
                        h,
                        cb,
                        0 as ::core::ffi::c_int,
                        8 as ::core::ffi::c_int
                            >> ((*h).mb.i_partition == D_8x16 as ::core::ffi::c_int)
                                as ::core::ffi::c_int,
                    );
                }
            }
            if (*h).mb.pic.i_fref[1 as ::core::ffi::c_int as usize] > 1 as ::core::ffi::c_int {
                if (*b_list.offset(1 as ::core::ffi::c_int as isize))
                    [0 as ::core::ffi::c_int as usize]
                    != 0
                {
                    cabac_ref_b(h, cb, 1 as ::core::ffi::c_int, 0 as ::core::ffi::c_int);
                }
                if (*b_list.offset(1 as ::core::ffi::c_int as isize))
                    [1 as ::core::ffi::c_int as usize] as ::core::ffi::c_int
                    != 0
                    && (*h).mb.i_partition != D_16x16 as ::core::ffi::c_int
                {
                    cabac_ref_b(
                        h,
                        cb,
                        1 as ::core::ffi::c_int,
                        8 as ::core::ffi::c_int
                            >> ((*h).mb.i_partition == D_8x16 as ::core::ffi::c_int)
                                as ::core::ffi::c_int,
                    );
                }
            }
            let mut i_list: ::core::ffi::c_int = 0 as ::core::ffi::c_int;
            while i_list < 2 as ::core::ffi::c_int {
                if (*h).mb.i_partition == D_16x16 as ::core::ffi::c_int {
                    if (*b_list.offset(i_list as isize))[0 as ::core::ffi::c_int as usize] != 0 {
                        let mut mvd_1: uint16_t = cabac_mvd(
                            h,
                            cb,
                            i_list,
                            0 as ::core::ffi::c_int,
                            4 as ::core::ffi::c_int,
                        );
                        x264_macroblock_cache_mvd(
                            h,
                            block_idx_x[0 as ::core::ffi::c_int as usize] as ::core::ffi::c_int,
                            block_idx_y[0 as ::core::ffi::c_int as usize] as ::core::ffi::c_int,
                            4 as ::core::ffi::c_int,
                            4 as ::core::ffi::c_int,
                            i_list,
                            mvd_1,
                        );
                    }
                } else if (*h).mb.i_partition == D_16x8 as ::core::ffi::c_int {
                    if (*b_list.offset(i_list as isize))[0 as ::core::ffi::c_int as usize] != 0 {
                        let mut mvd_2: uint16_t = cabac_mvd(
                            h,
                            cb,
                            i_list,
                            0 as ::core::ffi::c_int,
                            4 as ::core::ffi::c_int,
                        );
                        x264_macroblock_cache_mvd(
                            h,
                            block_idx_x[0 as ::core::ffi::c_int as usize] as ::core::ffi::c_int,
                            block_idx_y[0 as ::core::ffi::c_int as usize] as ::core::ffi::c_int,
                            4 as ::core::ffi::c_int,
                            2 as ::core::ffi::c_int,
                            i_list,
                            mvd_2,
                        );
                    }
                    if (*b_list.offset(i_list as isize))[1 as ::core::ffi::c_int as usize] != 0 {
                        let mut mvd_3: uint16_t = cabac_mvd(
                            h,
                            cb,
                            i_list,
                            8 as ::core::ffi::c_int,
                            4 as ::core::ffi::c_int,
                        );
                        x264_macroblock_cache_mvd(
                            h,
                            block_idx_x[8 as ::core::ffi::c_int as usize] as ::core::ffi::c_int,
                            block_idx_y[8 as ::core::ffi::c_int as usize] as ::core::ffi::c_int,
                            4 as ::core::ffi::c_int,
                            2 as ::core::ffi::c_int,
                            i_list,
                            mvd_3,
                        );
                    }
                } else {
                    if (*b_list.offset(i_list as isize))[0 as ::core::ffi::c_int as usize] != 0 {
                        let mut mvd_4: uint16_t = cabac_mvd(
                            h,
                            cb,
                            i_list,
                            0 as ::core::ffi::c_int,
                            2 as ::core::ffi::c_int,
                        );
                        x264_macroblock_cache_mvd(
                            h,
                            block_idx_x[0 as ::core::ffi::c_int as usize] as ::core::ffi::c_int,
                            block_idx_y[0 as ::core::ffi::c_int as usize] as ::core::ffi::c_int,
                            2 as ::core::ffi::c_int,
                            4 as ::core::ffi::c_int,
                            i_list,
                            mvd_4,
                        );
                    }
                    if (*b_list.offset(i_list as isize))[1 as ::core::ffi::c_int as usize] != 0 {
                        let mut mvd_5: uint16_t = cabac_mvd(
                            h,
                            cb,
                            i_list,
                            4 as ::core::ffi::c_int,
                            2 as ::core::ffi::c_int,
                        );
                        x264_macroblock_cache_mvd(
                            h,
                            block_idx_x[4 as ::core::ffi::c_int as usize] as ::core::ffi::c_int,
                            block_idx_y[4 as ::core::ffi::c_int as usize] as ::core::ffi::c_int,
                            2 as ::core::ffi::c_int,
                            4 as ::core::ffi::c_int,
                            i_list,
                            mvd_5,
                        );
                    }
                }
                i_list += 1;
            }
        } else {
            cabac_mb_header_i(h, cb, i_mb_type, SLICE_TYPE_B as ::core::ffi::c_int, chroma);
        };
    }
    #[inline(always)]
    #[c2rust::src_loc = "612:1"]
    pub unsafe extern "C" fn cabac_cbf_ctxidxinc(
        mut h: *mut x264_t,
        mut i_cat: ::core::ffi::c_int,
        mut i_idx: ::core::ffi::c_int,
        mut b_intra: ::core::ffi::c_int,
        mut b_dc: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int {
        pub static mut base_ctx: [uint16_t; 14] = [
            85 as ::core::ffi::c_int as uint16_t,
            89 as ::core::ffi::c_int as uint16_t,
            93 as ::core::ffi::c_int as uint16_t,
            97 as ::core::ffi::c_int as uint16_t,
            101 as ::core::ffi::c_int as uint16_t,
            1012 as ::core::ffi::c_int as uint16_t,
            460 as ::core::ffi::c_int as uint16_t,
            464 as ::core::ffi::c_int as uint16_t,
            468 as ::core::ffi::c_int as uint16_t,
            1016 as ::core::ffi::c_int as uint16_t,
            472 as ::core::ffi::c_int as uint16_t,
            476 as ::core::ffi::c_int as uint16_t,
            480 as ::core::ffi::c_int as uint16_t,
            1020 as ::core::ffi::c_int as uint16_t,
        ];
        if b_dc != 0 {
            i_idx -= LUMA_DC;
            if i_cat == DCT_CHROMA_DC as ::core::ffi::c_int {
                let mut i_nza: ::core::ffi::c_int =
                    if (*h).mb.cache.i_cbp_left != -(1 as ::core::ffi::c_int) {
                        (*h).mb.cache.i_cbp_left >> 8 as ::core::ffi::c_int + i_idx
                            & 1 as ::core::ffi::c_int
                    } else {
                        b_intra
                    };
                let mut i_nzb: ::core::ffi::c_int =
                    if (*h).mb.cache.i_cbp_top != -(1 as ::core::ffi::c_int) {
                        (*h).mb.cache.i_cbp_top >> 8 as ::core::ffi::c_int + i_idx
                            & 1 as ::core::ffi::c_int
                    } else {
                        b_intra
                    };
                return base_ctx[i_cat as usize] as ::core::ffi::c_int
                    + 2 as ::core::ffi::c_int * i_nzb
                    + i_nza;
            } else {
                let mut i_nza_0: ::core::ffi::c_int = (*h).mb.cache.i_cbp_left
                    >> 8 as ::core::ffi::c_int + i_idx
                    & 1 as ::core::ffi::c_int;
                let mut i_nzb_0: ::core::ffi::c_int = (*h).mb.cache.i_cbp_top
                    >> 8 as ::core::ffi::c_int + i_idx
                    & 1 as ::core::ffi::c_int;
                return base_ctx[i_cat as usize] as ::core::ffi::c_int
                    + 2 as ::core::ffi::c_int * i_nzb_0
                    + i_nza_0;
            }
        } else {
            let mut i_nza_1: ::core::ffi::c_int =
                (*h).mb.cache.non_zero_count[(x264_scan8[i_idx as usize] as ::core::ffi::c_int
                    - 1 as ::core::ffi::c_int)
                    as usize] as ::core::ffi::c_int;
            let mut i_nzb_1: ::core::ffi::c_int =
                (*h).mb.cache.non_zero_count[(x264_scan8[i_idx as usize] as ::core::ffi::c_int
                    - 8 as ::core::ffi::c_int)
                    as usize] as ::core::ffi::c_int;
            if 0 != 0 && b_intra == 0 {
                return base_ctx[i_cat as usize] as ::core::ffi::c_int
                    + (2 as ::core::ffi::c_int * i_nzb_1 + i_nza_1 & 0x7f as ::core::ffi::c_int);
            } else {
                i_nza_1 &= 0x7f as ::core::ffi::c_int + (b_intra << 7 as ::core::ffi::c_int);
                i_nzb_1 &= 0x7f as ::core::ffi::c_int + (b_intra << 7 as ::core::ffi::c_int);
                return base_ctx[i_cat as usize] as ::core::ffi::c_int
                    + 2 as ::core::ffi::c_int * (i_nzb_1 != 0) as ::core::ffi::c_int
                    + (i_nza_1 != 0) as ::core::ffi::c_int;
            }
        };
    }
    #[c2rust::src_loc = "650:22"]
    pub static mut coeff_abs_level1_ctx: [uint8_t; 8] = [
        1 as ::core::ffi::c_int as uint8_t,
        2 as ::core::ffi::c_int as uint8_t,
        3 as ::core::ffi::c_int as uint8_t,
        4 as ::core::ffi::c_int as uint8_t,
        0 as ::core::ffi::c_int as uint8_t,
        0 as ::core::ffi::c_int as uint8_t,
        0 as ::core::ffi::c_int as uint8_t,
        0 as ::core::ffi::c_int as uint8_t,
    ];
    #[c2rust::src_loc = "652:22"]
    pub static mut coeff_abs_levelgt1_ctx: [uint8_t; 8] = [
        5 as ::core::ffi::c_int as uint8_t,
        5 as ::core::ffi::c_int as uint8_t,
        5 as ::core::ffi::c_int as uint8_t,
        5 as ::core::ffi::c_int as uint8_t,
        6 as ::core::ffi::c_int as uint8_t,
        7 as ::core::ffi::c_int as uint8_t,
        8 as ::core::ffi::c_int as uint8_t,
        9 as ::core::ffi::c_int as uint8_t,
    ];
    #[c2rust::src_loc = "655:22"]
    pub static mut coeff_abs_levelgt1_ctx_chroma_dc: [uint8_t; 8] = [
        5 as ::core::ffi::c_int as uint8_t,
        5 as ::core::ffi::c_int as uint8_t,
        5 as ::core::ffi::c_int as uint8_t,
        5 as ::core::ffi::c_int as uint8_t,
        6 as ::core::ffi::c_int as uint8_t,
        7 as ::core::ffi::c_int as uint8_t,
        8 as ::core::ffi::c_int as uint8_t,
        8 as ::core::ffi::c_int as uint8_t,
    ];
    #[c2rust::src_loc = "657:22"]
    pub static mut coeff_abs_level_transition: [[uint8_t; 8]; 2] = [
        [
            1 as ::core::ffi::c_int as uint8_t,
            2 as ::core::ffi::c_int as uint8_t,
            3 as ::core::ffi::c_int as uint8_t,
            3 as ::core::ffi::c_int as uint8_t,
            4 as ::core::ffi::c_int as uint8_t,
            5 as ::core::ffi::c_int as uint8_t,
            6 as ::core::ffi::c_int as uint8_t,
            7 as ::core::ffi::c_int as uint8_t,
        ],
        [
            4 as ::core::ffi::c_int as uint8_t,
            4 as ::core::ffi::c_int as uint8_t,
            4 as ::core::ffi::c_int as uint8_t,
            4 as ::core::ffi::c_int as uint8_t,
            5 as ::core::ffi::c_int as uint8_t,
            6 as ::core::ffi::c_int as uint8_t,
            7 as ::core::ffi::c_int as uint8_t,
            7 as ::core::ffi::c_int as uint8_t,
        ],
    ];
    #[inline(always)]
    #[c2rust::src_loc = "775:1"]
    pub unsafe extern "C" fn cabac_block_residual_internal(
        mut h: *mut x264_t,
        mut cb: *mut x264_cabac_t,
        mut ctx_block_cat: ::core::ffi::c_int,
        mut l: *mut dctcoef,
        mut b_8x8: ::core::ffi::c_int,
        mut chroma422dc: ::core::ffi::c_int,
    ) {
        let mut sig_offset: *const uint8_t = (*x264_significant_coeff_flag_offset_8x8
            .as_ptr()
            .offset((*h).mb.b_interlaced as isize))
        .as_ptr();
        let mut ctx_sig: ::core::ffi::c_int = x264_significant_coeff_flag_offset
            [(*h).mb.b_interlaced as usize][ctx_block_cat as usize]
            as ::core::ffi::c_int;
        let mut ctx_last: ::core::ffi::c_int = x264_last_coeff_flag_offset
            [(*h).mb.b_interlaced as usize][ctx_block_cat as usize]
            as ::core::ffi::c_int;
        let mut ctx_level: ::core::ffi::c_int =
            x264_coeff_abs_level_m1_offset[ctx_block_cat as usize] as ::core::ffi::c_int;
        let mut last: ::core::ffi::c_int =
            (*h).quantf.coeff_last[ctx_block_cat as usize].expect("non-null function pointer")(l);
        let mut coeff_abs: ::core::ffi::c_int = abs(*l.offset(last as isize));
        let mut ctx: ::core::ffi::c_int = coeff_abs_level1_ctx[0 as ::core::ffi::c_int as usize]
            as ::core::ffi::c_int
            + ctx_level;
        let mut node_ctx: ::core::ffi::c_int = 0;
        let mut levelgt1_ctx: *const uint8_t = if chroma422dc != 0 {
            coeff_abs_levelgt1_ctx_chroma_dc.as_ptr()
        } else {
            coeff_abs_levelgt1_ctx.as_ptr()
        };
        if last
            != (if b_8x8 != 0 {
                63 as ::core::ffi::c_int
            } else {
                (if chroma422dc != 0 {
                    7 as ::core::ffi::c_int
                } else {
                    x264_count_cat_m1[ctx_block_cat as usize] as ::core::ffi::c_int
                })
            })
        {
            x264_cabac_size_decision(
                cb,
                (ctx_sig
                    + (if b_8x8 != 0 {
                        *sig_offset.offset(last as isize) as ::core::ffi::c_int
                    } else {
                        (if chroma422dc != 0 {
                            x264_coeff_flag_offset_chroma_422_dc[last as usize]
                                as ::core::ffi::c_int
                        } else {
                            last
                        })
                    })) as ::core::ffi::c_long,
                1 as ::core::ffi::c_long,
            );
            x264_cabac_size_decision(
                cb,
                (ctx_last
                    + (if b_8x8 != 0 {
                        x264_last_coeff_flag_offset_8x8[last as usize] as ::core::ffi::c_int
                    } else {
                        (if chroma422dc != 0 {
                            x264_coeff_flag_offset_chroma_422_dc[last as usize]
                                as ::core::ffi::c_int
                        } else {
                            last
                        })
                    })) as ::core::ffi::c_long,
                1 as ::core::ffi::c_long,
            );
        }
        if coeff_abs > 1 as ::core::ffi::c_int {
            x264_cabac_size_decision(cb, ctx as ::core::ffi::c_long, 1 as ::core::ffi::c_long);
            ctx = *levelgt1_ctx.offset(0 as ::core::ffi::c_int as isize) as ::core::ffi::c_int
                + ctx_level;
            if coeff_abs < 15 as ::core::ffi::c_int {
                (*cb).f8_bits_encoded += x264_10_cabac_size_unary
                    [(coeff_abs - 1 as ::core::ffi::c_int) as usize]
                    [(*cb).state[ctx as usize] as usize]
                    as ::core::ffi::c_int;
                (*cb).state[ctx as usize] = x264_10_cabac_transition_unary
                    [(coeff_abs - 1 as ::core::ffi::c_int) as usize]
                    [(*cb).state[ctx as usize] as usize];
            } else {
                (*cb).f8_bits_encoded += x264_10_cabac_size_unary[14 as ::core::ffi::c_int as usize]
                    [(*cb).state[ctx as usize] as usize]
                    as ::core::ffi::c_int;
                (*cb).state[ctx as usize] = x264_10_cabac_transition_unary
                    [14 as ::core::ffi::c_int as usize][(*cb).state[ctx as usize] as usize];
                (*cb).f8_bits_encoded += (bs_size_ue_big(
                    (coeff_abs - 15 as ::core::ffi::c_int
                        + ((1 as ::core::ffi::c_int) << 0 as ::core::ffi::c_int)
                        - 1 as ::core::ffi::c_int) as ::core::ffi::c_uint,
                ) - 0 as ::core::ffi::c_int)
                    << 8 as ::core::ffi::c_int;
            }
            node_ctx = coeff_abs_level_transition[1 as ::core::ffi::c_int as usize]
                [0 as ::core::ffi::c_int as usize] as ::core::ffi::c_int;
        } else {
            x264_cabac_size_decision(cb, ctx as ::core::ffi::c_long, 0 as ::core::ffi::c_long);
            node_ctx = coeff_abs_level_transition[0 as ::core::ffi::c_int as usize]
                [0 as ::core::ffi::c_int as usize] as ::core::ffi::c_int;
            (*cb).f8_bits_encoded += 256 as ::core::ffi::c_int;
        }
        let mut i: ::core::ffi::c_int = last - 1 as ::core::ffi::c_int;
        while i >= 0 as ::core::ffi::c_int {
            if *l.offset(i as isize) != 0 {
                coeff_abs = abs(*l.offset(i as isize));
                x264_cabac_size_decision(
                    cb,
                    (ctx_sig
                        + (if b_8x8 != 0 {
                            *sig_offset.offset(i as isize) as ::core::ffi::c_int
                        } else {
                            (if chroma422dc != 0 {
                                x264_coeff_flag_offset_chroma_422_dc[i as usize]
                                    as ::core::ffi::c_int
                            } else {
                                i
                            })
                        })) as ::core::ffi::c_long,
                    1 as ::core::ffi::c_long,
                );
                x264_cabac_size_decision(
                    cb,
                    (ctx_last
                        + (if b_8x8 != 0 {
                            x264_last_coeff_flag_offset_8x8[i as usize] as ::core::ffi::c_int
                        } else {
                            (if chroma422dc != 0 {
                                x264_coeff_flag_offset_chroma_422_dc[i as usize]
                                    as ::core::ffi::c_int
                            } else {
                                i
                            })
                        })) as ::core::ffi::c_long,
                    0 as ::core::ffi::c_long,
                );
                ctx = coeff_abs_level1_ctx[node_ctx as usize] as ::core::ffi::c_int + ctx_level;
                if coeff_abs > 1 as ::core::ffi::c_int {
                    x264_cabac_size_decision(
                        cb,
                        ctx as ::core::ffi::c_long,
                        1 as ::core::ffi::c_long,
                    );
                    ctx = *levelgt1_ctx.offset(node_ctx as isize) as ::core::ffi::c_int + ctx_level;
                    if coeff_abs < 15 as ::core::ffi::c_int {
                        (*cb).f8_bits_encoded += x264_10_cabac_size_unary
                            [(coeff_abs - 1 as ::core::ffi::c_int) as usize]
                            [(*cb).state[ctx as usize] as usize]
                            as ::core::ffi::c_int;
                        (*cb).state[ctx as usize] = x264_10_cabac_transition_unary
                            [(coeff_abs - 1 as ::core::ffi::c_int) as usize]
                            [(*cb).state[ctx as usize] as usize];
                    } else {
                        (*cb).f8_bits_encoded += x264_10_cabac_size_unary
                            [14 as ::core::ffi::c_int as usize]
                            [(*cb).state[ctx as usize] as usize]
                            as ::core::ffi::c_int;
                        (*cb).state[ctx as usize] = x264_10_cabac_transition_unary
                            [14 as ::core::ffi::c_int as usize]
                            [(*cb).state[ctx as usize] as usize];
                        (*cb).f8_bits_encoded += (bs_size_ue_big(
                            (coeff_abs - 15 as ::core::ffi::c_int
                                + ((1 as ::core::ffi::c_int) << 0 as ::core::ffi::c_int)
                                - 1 as ::core::ffi::c_int)
                                as ::core::ffi::c_uint,
                        ) - 0 as ::core::ffi::c_int)
                            << 8 as ::core::ffi::c_int;
                    }
                    node_ctx = coeff_abs_level_transition[1 as ::core::ffi::c_int as usize]
                        [node_ctx as usize] as ::core::ffi::c_int;
                } else {
                    x264_cabac_size_decision(
                        cb,
                        ctx as ::core::ffi::c_long,
                        0 as ::core::ffi::c_long,
                    );
                    node_ctx = coeff_abs_level_transition[0 as ::core::ffi::c_int as usize]
                        [node_ctx as usize] as ::core::ffi::c_int;
                    (*cb).f8_bits_encoded += 256 as ::core::ffi::c_int;
                }
            } else {
                x264_cabac_size_decision(
                    cb,
                    (ctx_sig
                        + (if b_8x8 != 0 {
                            *sig_offset.offset(i as isize) as ::core::ffi::c_int
                        } else {
                            (if chroma422dc != 0 {
                                x264_coeff_flag_offset_chroma_422_dc[i as usize]
                                    as ::core::ffi::c_int
                            } else {
                                i
                            })
                        })) as ::core::ffi::c_long,
                    0 as ::core::ffi::c_long,
                );
            }
            i -= 1;
        }
    }
    #[no_mangle]
    #[c2rust::src_loc = "860:1"]
    pub unsafe extern "C" fn x264_10_cabac_block_residual_8x8_rd_c(
        mut h: *mut x264_t,
        mut cb: *mut x264_cabac_t,
        mut ctx_block_cat: ::core::ffi::c_int,
        mut l: *mut dctcoef,
    ) {
        cabac_block_residual_internal(
            h,
            cb,
            ctx_block_cat,
            l,
            1 as ::core::ffi::c_int,
            0 as ::core::ffi::c_int,
        );
    }
    #[no_mangle]
    #[c2rust::src_loc = "864:1"]
    pub unsafe extern "C" fn x264_10_cabac_block_residual_rd_c(
        mut h: *mut x264_t,
        mut cb: *mut x264_cabac_t,
        mut ctx_block_cat: ::core::ffi::c_int,
        mut l: *mut dctcoef,
    ) {
        cabac_block_residual_internal(
            h,
            cb,
            ctx_block_cat,
            l,
            0 as ::core::ffi::c_int,
            0 as ::core::ffi::c_int,
        );
    }
    #[inline(always)]
    #[c2rust::src_loc = "869:1"]
    pub unsafe extern "C" fn cabac_block_residual_8x8(
        mut h: *mut x264_t,
        mut cb: *mut x264_cabac_t,
        mut ctx_block_cat: ::core::ffi::c_int,
        mut l: *mut dctcoef,
    ) {
        x264_10_cabac_block_residual_8x8_rd_c(h, cb, ctx_block_cat, l);
    }
    #[inline(always)]
    #[c2rust::src_loc = "877:1"]
    pub unsafe extern "C" fn cabac_block_residual(
        mut h: *mut x264_t,
        mut cb: *mut x264_cabac_t,
        mut ctx_block_cat: ::core::ffi::c_int,
        mut l: *mut dctcoef,
    ) {
        x264_10_cabac_block_residual_rd_c(h, cb, ctx_block_cat, l);
    }
    #[c2rust::src_loc = "886:1"]
    pub unsafe extern "C" fn cabac_block_residual_422_dc(
        mut h: *mut x264_t,
        mut cb: *mut x264_cabac_t,
        mut ctx_block_cat: ::core::ffi::c_int,
        mut l: *mut dctcoef,
    ) {
        cabac_block_residual_internal(
            h,
            cb,
            DCT_CHROMA_DC as ::core::ffi::c_int,
            l,
            0 as ::core::ffi::c_int,
            1 as ::core::ffi::c_int,
        );
    }
    #[inline(always)]
    #[c2rust::src_loc = "917:1"]
    pub unsafe extern "C" fn macroblock_write_cabac_internal(
        mut h: *mut x264_t,
        mut cb: *mut x264_cabac_t,
        mut plane_count: ::core::ffi::c_int,
        mut chroma: ::core::ffi::c_int,
    ) {
        let i_mb_type: ::core::ffi::c_int = (*h).mb.i_type;
        if (*h).sh.i_type == SLICE_TYPE_P as ::core::ffi::c_int {
            cabac_mb_header_p(h, cb, i_mb_type, chroma);
        } else if (*h).sh.i_type == SLICE_TYPE_B as ::core::ffi::c_int {
            cabac_mb_header_b(h, cb, i_mb_type, chroma);
        } else {
            cabac_mb_header_i(h, cb, i_mb_type, SLICE_TYPE_I as ::core::ffi::c_int, chroma);
        }
        if i_mb_type != I_16x16 as ::core::ffi::c_int {
            cabac_cbp_luma(h, cb);
            if chroma != 0 {
                cabac_cbp_chroma(h, cb);
            }
        }
        if x264_mb_transform_8x8_allowed(h) != 0 && (*h).mb.i_cbp_luma != 0 {
            cabac_transform_size(h, cb);
        }
        if (*h).mb.i_cbp_luma != 0
            || chroma != 0 && (*h).mb.i_cbp_chroma != 0
            || i_mb_type == I_16x16 as ::core::ffi::c_int
        {
            let b_intra: ::core::ffi::c_int = (i_mb_type == I_4x4 as ::core::ffi::c_int
                || i_mb_type == I_8x8 as ::core::ffi::c_int
                || i_mb_type == I_16x16 as ::core::ffi::c_int
                || i_mb_type == I_PCM as ::core::ffi::c_int)
                as ::core::ffi::c_int;
            cabac_qp_delta(h, cb);
            if i_mb_type == I_16x16 as ::core::ffi::c_int {
                let mut p: ::core::ffi::c_int = 0 as ::core::ffi::c_int;
                while p < plane_count {
                    let mut ctxidxinc: ::core::ffi::c_int = cabac_cbf_ctxidxinc(
                        h,
                        ctx_cat_plane[DCT_LUMA_DC as ::core::ffi::c_int as usize][p as usize]
                            as ::core::ffi::c_int,
                        48 as ::core::ffi::c_int + p,
                        1 as ::core::ffi::c_int,
                        1 as ::core::ffi::c_int,
                    );
                    if (*h).mb.cache.non_zero_count
                        [x264_scan8[(48 as ::core::ffi::c_int + p) as usize] as usize]
                        != 0
                    {
                        x264_cabac_size_decision(
                            cb,
                            ctxidxinc as ::core::ffi::c_long,
                            1 as ::core::ffi::c_long,
                        );
                        cabac_block_residual(
                            h,
                            cb,
                            ctx_cat_plane[DCT_LUMA_DC as ::core::ffi::c_int as usize][p as usize]
                                as ::core::ffi::c_int,
                            (*(*h).dct.luma16x16_dc.as_mut_ptr().offset(p as isize)).as_mut_ptr(),
                        );
                    } else {
                        x264_cabac_size_decision(
                            cb,
                            ctxidxinc as ::core::ffi::c_long,
                            0 as ::core::ffi::c_long,
                        );
                    }
                    if (*h).mb.i_cbp_luma != 0 {
                        let mut i: ::core::ffi::c_int = p * 16 as ::core::ffi::c_int;
                        while i < p * 16 as ::core::ffi::c_int + 16 as ::core::ffi::c_int {
                            let mut ctxidxinc_0: ::core::ffi::c_int = cabac_cbf_ctxidxinc(
                                h,
                                ctx_cat_plane[DCT_LUMA_AC as ::core::ffi::c_int as usize]
                                    [p as usize]
                                    as ::core::ffi::c_int,
                                i,
                                1 as ::core::ffi::c_int,
                                0 as ::core::ffi::c_int,
                            );
                            if (*h).mb.cache.non_zero_count[x264_scan8[i as usize] as usize] != 0 {
                                x264_cabac_size_decision(
                                    cb,
                                    ctxidxinc_0 as ::core::ffi::c_long,
                                    1 as ::core::ffi::c_long,
                                );
                                cabac_block_residual(
                                    h,
                                    cb,
                                    ctx_cat_plane[DCT_LUMA_AC as ::core::ffi::c_int as usize]
                                        [p as usize]
                                        as ::core::ffi::c_int,
                                    (*(*h).dct.luma4x4.as_mut_ptr().offset(i as isize))
                                        .as_mut_ptr()
                                        .offset(1 as ::core::ffi::c_int as isize),
                                );
                            } else {
                                x264_cabac_size_decision(
                                    cb,
                                    ctxidxinc_0 as ::core::ffi::c_long,
                                    0 as ::core::ffi::c_long,
                                );
                            }
                            i += 1;
                        }
                    }
                    p += 1;
                }
            } else if (*h).mb.b_transform_8x8 != 0 {
                if plane_count == 3 as ::core::ffi::c_int {
                    let mut nnzbak: [[uint8_t; 8]; 3] = [[0; 8]; 3];
                    if (*h).mb.i_neighbour & MB_LEFT as ::core::ffi::c_int as ::core::ffi::c_uint
                        != 0
                        && *(*h)
                            .mb
                            .mb_transform_size
                            .offset((*h).mb.i_mb_left_xy[0 as ::core::ffi::c_int as usize] as isize)
                            == 0
                        && *(*h)
                            .mb
                            .cbp
                            .offset((*h).mb.i_mb_left_xy[0 as ::core::ffi::c_int as usize] as isize)
                            as ::core::ffi::c_int
                            & 0x1000 as ::core::ffi::c_int
                            == 0
                    {
                        nnzbak[0 as ::core::ffi::c_int as usize]
                            [0 as ::core::ffi::c_int as usize] = (*h).mb.cache.non_zero_count
                            [(x264_scan8[(16 as ::core::ffi::c_int * 0 as ::core::ffi::c_int
                                + 0 as ::core::ffi::c_int)
                                as usize] as ::core::ffi::c_int
                                - 1 as ::core::ffi::c_int) as usize];
                        (*h).mb.cache.non_zero_count[(x264_scan8[(16 as ::core::ffi::c_int
                            * 0 as ::core::ffi::c_int
                            + 0 as ::core::ffi::c_int)
                            as usize]
                            as ::core::ffi::c_int
                            - 1 as ::core::ffi::c_int)
                            as usize] = 0 as uint8_t;
                        nnzbak[0 as ::core::ffi::c_int as usize]
                            [1 as ::core::ffi::c_int as usize] = (*h).mb.cache.non_zero_count
                            [(x264_scan8[(16 as ::core::ffi::c_int * 0 as ::core::ffi::c_int
                                + 2 as ::core::ffi::c_int)
                                as usize] as ::core::ffi::c_int
                                - 1 as ::core::ffi::c_int) as usize];
                        (*h).mb.cache.non_zero_count[(x264_scan8[(16 as ::core::ffi::c_int
                            * 0 as ::core::ffi::c_int
                            + 2 as ::core::ffi::c_int)
                            as usize]
                            as ::core::ffi::c_int
                            - 1 as ::core::ffi::c_int)
                            as usize] = 0 as uint8_t;
                        nnzbak[1 as ::core::ffi::c_int as usize]
                            [0 as ::core::ffi::c_int as usize] = (*h).mb.cache.non_zero_count
                            [(x264_scan8[(16 as ::core::ffi::c_int * 1 as ::core::ffi::c_int
                                + 0 as ::core::ffi::c_int)
                                as usize] as ::core::ffi::c_int
                                - 1 as ::core::ffi::c_int) as usize];
                        (*h).mb.cache.non_zero_count[(x264_scan8[(16 as ::core::ffi::c_int
                            * 1 as ::core::ffi::c_int
                            + 0 as ::core::ffi::c_int)
                            as usize]
                            as ::core::ffi::c_int
                            - 1 as ::core::ffi::c_int)
                            as usize] = 0 as uint8_t;
                        nnzbak[1 as ::core::ffi::c_int as usize]
                            [1 as ::core::ffi::c_int as usize] = (*h).mb.cache.non_zero_count
                            [(x264_scan8[(16 as ::core::ffi::c_int * 1 as ::core::ffi::c_int
                                + 2 as ::core::ffi::c_int)
                                as usize] as ::core::ffi::c_int
                                - 1 as ::core::ffi::c_int) as usize];
                        (*h).mb.cache.non_zero_count[(x264_scan8[(16 as ::core::ffi::c_int
                            * 1 as ::core::ffi::c_int
                            + 2 as ::core::ffi::c_int)
                            as usize]
                            as ::core::ffi::c_int
                            - 1 as ::core::ffi::c_int)
                            as usize] = 0 as uint8_t;
                        nnzbak[2 as ::core::ffi::c_int as usize]
                            [0 as ::core::ffi::c_int as usize] = (*h).mb.cache.non_zero_count
                            [(x264_scan8[(16 as ::core::ffi::c_int * 2 as ::core::ffi::c_int
                                + 0 as ::core::ffi::c_int)
                                as usize] as ::core::ffi::c_int
                                - 1 as ::core::ffi::c_int) as usize];
                        (*h).mb.cache.non_zero_count[(x264_scan8[(16 as ::core::ffi::c_int
                            * 2 as ::core::ffi::c_int
                            + 0 as ::core::ffi::c_int)
                            as usize]
                            as ::core::ffi::c_int
                            - 1 as ::core::ffi::c_int)
                            as usize] = 0 as uint8_t;
                        nnzbak[2 as ::core::ffi::c_int as usize]
                            [1 as ::core::ffi::c_int as usize] = (*h).mb.cache.non_zero_count
                            [(x264_scan8[(16 as ::core::ffi::c_int * 2 as ::core::ffi::c_int
                                + 2 as ::core::ffi::c_int)
                                as usize] as ::core::ffi::c_int
                                - 1 as ::core::ffi::c_int) as usize];
                        (*h).mb.cache.non_zero_count[(x264_scan8[(16 as ::core::ffi::c_int
                            * 2 as ::core::ffi::c_int
                            + 2 as ::core::ffi::c_int)
                            as usize]
                            as ::core::ffi::c_int
                            - 1 as ::core::ffi::c_int)
                            as usize] = 0 as uint8_t;
                    }
                    if (*h).mb.i_neighbour & MB_LEFT as ::core::ffi::c_int as ::core::ffi::c_uint
                        != 0
                        && *(*h)
                            .mb
                            .mb_transform_size
                            .offset((*h).mb.i_mb_left_xy[1 as ::core::ffi::c_int as usize] as isize)
                            == 0
                        && *(*h)
                            .mb
                            .cbp
                            .offset((*h).mb.i_mb_left_xy[1 as ::core::ffi::c_int as usize] as isize)
                            as ::core::ffi::c_int
                            & 0x1000 as ::core::ffi::c_int
                            == 0
                    {
                        nnzbak[0 as ::core::ffi::c_int as usize]
                            [2 as ::core::ffi::c_int as usize] = (*h).mb.cache.non_zero_count
                            [(x264_scan8[(16 as ::core::ffi::c_int * 0 as ::core::ffi::c_int
                                + 8 as ::core::ffi::c_int)
                                as usize] as ::core::ffi::c_int
                                - 1 as ::core::ffi::c_int) as usize];
                        (*h).mb.cache.non_zero_count[(x264_scan8[(16 as ::core::ffi::c_int
                            * 0 as ::core::ffi::c_int
                            + 8 as ::core::ffi::c_int)
                            as usize]
                            as ::core::ffi::c_int
                            - 1 as ::core::ffi::c_int)
                            as usize] = 0 as uint8_t;
                        nnzbak[0 as ::core::ffi::c_int as usize]
                            [3 as ::core::ffi::c_int as usize] = (*h).mb.cache.non_zero_count
                            [(x264_scan8[(16 as ::core::ffi::c_int * 0 as ::core::ffi::c_int
                                + 10 as ::core::ffi::c_int)
                                as usize] as ::core::ffi::c_int
                                - 1 as ::core::ffi::c_int) as usize];
                        (*h).mb.cache.non_zero_count[(x264_scan8[(16 as ::core::ffi::c_int
                            * 0 as ::core::ffi::c_int
                            + 10 as ::core::ffi::c_int)
                            as usize]
                            as ::core::ffi::c_int
                            - 1 as ::core::ffi::c_int)
                            as usize] = 0 as uint8_t;
                        nnzbak[1 as ::core::ffi::c_int as usize]
                            [2 as ::core::ffi::c_int as usize] = (*h).mb.cache.non_zero_count
                            [(x264_scan8[(16 as ::core::ffi::c_int * 1 as ::core::ffi::c_int
                                + 8 as ::core::ffi::c_int)
                                as usize] as ::core::ffi::c_int
                                - 1 as ::core::ffi::c_int) as usize];
                        (*h).mb.cache.non_zero_count[(x264_scan8[(16 as ::core::ffi::c_int
                            * 1 as ::core::ffi::c_int
                            + 8 as ::core::ffi::c_int)
                            as usize]
                            as ::core::ffi::c_int
                            - 1 as ::core::ffi::c_int)
                            as usize] = 0 as uint8_t;
                        nnzbak[1 as ::core::ffi::c_int as usize]
                            [3 as ::core::ffi::c_int as usize] = (*h).mb.cache.non_zero_count
                            [(x264_scan8[(16 as ::core::ffi::c_int * 1 as ::core::ffi::c_int
                                + 10 as ::core::ffi::c_int)
                                as usize] as ::core::ffi::c_int
                                - 1 as ::core::ffi::c_int) as usize];
                        (*h).mb.cache.non_zero_count[(x264_scan8[(16 as ::core::ffi::c_int
                            * 1 as ::core::ffi::c_int
                            + 10 as ::core::ffi::c_int)
                            as usize]
                            as ::core::ffi::c_int
                            - 1 as ::core::ffi::c_int)
                            as usize] = 0 as uint8_t;
                        nnzbak[2 as ::core::ffi::c_int as usize]
                            [2 as ::core::ffi::c_int as usize] = (*h).mb.cache.non_zero_count
                            [(x264_scan8[(16 as ::core::ffi::c_int * 2 as ::core::ffi::c_int
                                + 8 as ::core::ffi::c_int)
                                as usize] as ::core::ffi::c_int
                                - 1 as ::core::ffi::c_int) as usize];
                        (*h).mb.cache.non_zero_count[(x264_scan8[(16 as ::core::ffi::c_int
                            * 2 as ::core::ffi::c_int
                            + 8 as ::core::ffi::c_int)
                            as usize]
                            as ::core::ffi::c_int
                            - 1 as ::core::ffi::c_int)
                            as usize] = 0 as uint8_t;
                        nnzbak[2 as ::core::ffi::c_int as usize]
                            [3 as ::core::ffi::c_int as usize] = (*h).mb.cache.non_zero_count
                            [(x264_scan8[(16 as ::core::ffi::c_int * 2 as ::core::ffi::c_int
                                + 10 as ::core::ffi::c_int)
                                as usize] as ::core::ffi::c_int
                                - 1 as ::core::ffi::c_int) as usize];
                        (*h).mb.cache.non_zero_count[(x264_scan8[(16 as ::core::ffi::c_int
                            * 2 as ::core::ffi::c_int
                            + 10 as ::core::ffi::c_int)
                            as usize]
                            as ::core::ffi::c_int
                            - 1 as ::core::ffi::c_int)
                            as usize] = 0 as uint8_t;
                    }
                    if (*h).mb.i_neighbour & MB_TOP as ::core::ffi::c_int as ::core::ffi::c_uint
                        != 0
                        && *(*h)
                            .mb
                            .mb_transform_size
                            .offset((*h).mb.i_mb_top_xy as isize)
                            == 0
                        && *(*h).mb.cbp.offset((*h).mb.i_mb_top_xy as isize) as ::core::ffi::c_int
                            & 0x1000 as ::core::ffi::c_int
                            == 0
                    {
                        (*(&mut *(*nnzbak.as_mut_ptr().offset(0 as ::core::ffi::c_int as isize))
                            .as_mut_ptr()
                            .offset(4 as ::core::ffi::c_int as isize)
                            as *mut uint8_t as *mut x264_union32_t))
                            .i = (*(&mut *(*h).mb.cache.non_zero_count.as_mut_ptr().offset(
                            (*x264_scan8.as_ptr().offset(
                                (16 as ::core::ffi::c_int * 0 as ::core::ffi::c_int) as isize,
                            ) as ::core::ffi::c_int
                                - 8 as ::core::ffi::c_int) as isize,
                        ) as *mut uint8_t
                            as *mut x264_union32_t))
                            .i;
                        (*(&mut *(*h).mb.cache.non_zero_count.as_mut_ptr().offset(
                            (*x264_scan8.as_ptr().offset(
                                (16 as ::core::ffi::c_int * 0 as ::core::ffi::c_int) as isize,
                            ) as ::core::ffi::c_int
                                - 8 as ::core::ffi::c_int) as isize,
                        ) as *mut uint8_t as *mut x264_union32_t))
                            .i = 0 as ::core::ffi::c_uint as uint32_t;
                        (*(&mut *(*nnzbak.as_mut_ptr().offset(1 as ::core::ffi::c_int as isize))
                            .as_mut_ptr()
                            .offset(4 as ::core::ffi::c_int as isize)
                            as *mut uint8_t as *mut x264_union32_t))
                            .i = (*(&mut *(*h).mb.cache.non_zero_count.as_mut_ptr().offset(
                            (*x264_scan8.as_ptr().offset(
                                (16 as ::core::ffi::c_int * 1 as ::core::ffi::c_int) as isize,
                            ) as ::core::ffi::c_int
                                - 8 as ::core::ffi::c_int) as isize,
                        ) as *mut uint8_t
                            as *mut x264_union32_t))
                            .i;
                        (*(&mut *(*h).mb.cache.non_zero_count.as_mut_ptr().offset(
                            (*x264_scan8.as_ptr().offset(
                                (16 as ::core::ffi::c_int * 1 as ::core::ffi::c_int) as isize,
                            ) as ::core::ffi::c_int
                                - 8 as ::core::ffi::c_int) as isize,
                        ) as *mut uint8_t as *mut x264_union32_t))
                            .i = 0 as ::core::ffi::c_uint as uint32_t;
                        (*(&mut *(*nnzbak.as_mut_ptr().offset(2 as ::core::ffi::c_int as isize))
                            .as_mut_ptr()
                            .offset(4 as ::core::ffi::c_int as isize)
                            as *mut uint8_t as *mut x264_union32_t))
                            .i = (*(&mut *(*h).mb.cache.non_zero_count.as_mut_ptr().offset(
                            (*x264_scan8.as_ptr().offset(
                                (16 as ::core::ffi::c_int * 2 as ::core::ffi::c_int) as isize,
                            ) as ::core::ffi::c_int
                                - 8 as ::core::ffi::c_int) as isize,
                        ) as *mut uint8_t
                            as *mut x264_union32_t))
                            .i;
                        (*(&mut *(*h).mb.cache.non_zero_count.as_mut_ptr().offset(
                            (*x264_scan8.as_ptr().offset(
                                (16 as ::core::ffi::c_int * 2 as ::core::ffi::c_int) as isize,
                            ) as ::core::ffi::c_int
                                - 8 as ::core::ffi::c_int) as isize,
                        ) as *mut uint8_t as *mut x264_union32_t))
                            .i = 0 as ::core::ffi::c_uint as uint32_t;
                    }
                    let mut p_0: ::core::ffi::c_int = 0 as ::core::ffi::c_int;
                    while p_0 < 3 as ::core::ffi::c_int {
                        let mut i_0: ::core::ffi::c_int = 0 as ::core::ffi::c_int;
                        let mut msk: ::core::ffi::c_int = (*h).mb.i_cbp_luma;
                        let mut skip: ::core::ffi::c_int = 0;
                        while msk != 0 && {
                            skip = x264_ctz_4bit(msk as uint32_t);
                            i_0 += skip;
                            msk >>= skip + 1 as ::core::ffi::c_int;
                            1 as ::core::ffi::c_int != 0
                        } {
                            let mut ctxidxinc_1: ::core::ffi::c_int = cabac_cbf_ctxidxinc(
                                h,
                                ctx_cat_plane[DCT_LUMA_8x8 as ::core::ffi::c_int as usize]
                                    [p_0 as usize]
                                    as ::core::ffi::c_int,
                                i_0 * 4 as ::core::ffi::c_int + p_0 * 16 as ::core::ffi::c_int,
                                b_intra,
                                0 as ::core::ffi::c_int,
                            );
                            if (*h).mb.cache.non_zero_count[x264_scan8[(i_0
                                * 4 as ::core::ffi::c_int
                                + p_0 * 16 as ::core::ffi::c_int)
                                as usize]
                                as usize]
                                != 0
                            {
                                x264_cabac_size_decision(
                                    cb,
                                    ctxidxinc_1 as ::core::ffi::c_long,
                                    1 as ::core::ffi::c_long,
                                );
                                cabac_block_residual_8x8(
                                    h,
                                    cb,
                                    ctx_cat_plane[DCT_LUMA_8x8 as ::core::ffi::c_int as usize]
                                        [p_0 as usize]
                                        as ::core::ffi::c_int,
                                    (*(*h)
                                        .dct
                                        .luma8x8
                                        .as_mut_ptr()
                                        .offset((i_0 + p_0 * 4 as ::core::ffi::c_int) as isize))
                                    .as_mut_ptr(),
                                );
                            } else {
                                x264_cabac_size_decision(
                                    cb,
                                    ctxidxinc_1 as ::core::ffi::c_long,
                                    0 as ::core::ffi::c_long,
                                );
                            }
                            i_0 += 1;
                        }
                        p_0 += 1;
                    }
                    if (*h).mb.i_neighbour & MB_LEFT as ::core::ffi::c_int as ::core::ffi::c_uint
                        != 0
                        && *(*h)
                            .mb
                            .mb_transform_size
                            .offset((*h).mb.i_mb_left_xy[0 as ::core::ffi::c_int as usize] as isize)
                            == 0
                        && *(*h)
                            .mb
                            .cbp
                            .offset((*h).mb.i_mb_left_xy[0 as ::core::ffi::c_int as usize] as isize)
                            as ::core::ffi::c_int
                            & 0x1000 as ::core::ffi::c_int
                            == 0
                    {
                        (*h).mb.cache.non_zero_count[(x264_scan8[(16 as ::core::ffi::c_int
                            * 0 as ::core::ffi::c_int
                            + 0 as ::core::ffi::c_int)
                            as usize]
                            as ::core::ffi::c_int
                            - 1 as ::core::ffi::c_int)
                            as usize] = nnzbak[0 as ::core::ffi::c_int as usize]
                            [0 as ::core::ffi::c_int as usize];
                        (*h).mb.cache.non_zero_count[(x264_scan8[(16 as ::core::ffi::c_int
                            * 0 as ::core::ffi::c_int
                            + 2 as ::core::ffi::c_int)
                            as usize]
                            as ::core::ffi::c_int
                            - 1 as ::core::ffi::c_int)
                            as usize] = nnzbak[0 as ::core::ffi::c_int as usize]
                            [1 as ::core::ffi::c_int as usize];
                        (*h).mb.cache.non_zero_count[(x264_scan8[(16 as ::core::ffi::c_int
                            * 1 as ::core::ffi::c_int
                            + 0 as ::core::ffi::c_int)
                            as usize]
                            as ::core::ffi::c_int
                            - 1 as ::core::ffi::c_int)
                            as usize] = nnzbak[1 as ::core::ffi::c_int as usize]
                            [0 as ::core::ffi::c_int as usize];
                        (*h).mb.cache.non_zero_count[(x264_scan8[(16 as ::core::ffi::c_int
                            * 1 as ::core::ffi::c_int
                            + 2 as ::core::ffi::c_int)
                            as usize]
                            as ::core::ffi::c_int
                            - 1 as ::core::ffi::c_int)
                            as usize] = nnzbak[1 as ::core::ffi::c_int as usize]
                            [1 as ::core::ffi::c_int as usize];
                        (*h).mb.cache.non_zero_count[(x264_scan8[(16 as ::core::ffi::c_int
                            * 2 as ::core::ffi::c_int
                            + 0 as ::core::ffi::c_int)
                            as usize]
                            as ::core::ffi::c_int
                            - 1 as ::core::ffi::c_int)
                            as usize] = nnzbak[2 as ::core::ffi::c_int as usize]
                            [0 as ::core::ffi::c_int as usize];
                        (*h).mb.cache.non_zero_count[(x264_scan8[(16 as ::core::ffi::c_int
                            * 2 as ::core::ffi::c_int
                            + 2 as ::core::ffi::c_int)
                            as usize]
                            as ::core::ffi::c_int
                            - 1 as ::core::ffi::c_int)
                            as usize] = nnzbak[2 as ::core::ffi::c_int as usize]
                            [1 as ::core::ffi::c_int as usize];
                    }
                    if (*h).mb.i_neighbour & MB_LEFT as ::core::ffi::c_int as ::core::ffi::c_uint
                        != 0
                        && *(*h)
                            .mb
                            .mb_transform_size
                            .offset((*h).mb.i_mb_left_xy[1 as ::core::ffi::c_int as usize] as isize)
                            == 0
                        && *(*h)
                            .mb
                            .cbp
                            .offset((*h).mb.i_mb_left_xy[1 as ::core::ffi::c_int as usize] as isize)
                            as ::core::ffi::c_int
                            & 0x1000 as ::core::ffi::c_int
                            == 0
                    {
                        (*h).mb.cache.non_zero_count[(x264_scan8[(16 as ::core::ffi::c_int
                            * 0 as ::core::ffi::c_int
                            + 8 as ::core::ffi::c_int)
                            as usize]
                            as ::core::ffi::c_int
                            - 1 as ::core::ffi::c_int)
                            as usize] = nnzbak[0 as ::core::ffi::c_int as usize]
                            [2 as ::core::ffi::c_int as usize];
                        (*h).mb.cache.non_zero_count[(x264_scan8[(16 as ::core::ffi::c_int
                            * 0 as ::core::ffi::c_int
                            + 10 as ::core::ffi::c_int)
                            as usize]
                            as ::core::ffi::c_int
                            - 1 as ::core::ffi::c_int)
                            as usize] = nnzbak[0 as ::core::ffi::c_int as usize]
                            [3 as ::core::ffi::c_int as usize];
                        (*h).mb.cache.non_zero_count[(x264_scan8[(16 as ::core::ffi::c_int
                            * 1 as ::core::ffi::c_int
                            + 8 as ::core::ffi::c_int)
                            as usize]
                            as ::core::ffi::c_int
                            - 1 as ::core::ffi::c_int)
                            as usize] = nnzbak[1 as ::core::ffi::c_int as usize]
                            [2 as ::core::ffi::c_int as usize];
                        (*h).mb.cache.non_zero_count[(x264_scan8[(16 as ::core::ffi::c_int
                            * 1 as ::core::ffi::c_int
                            + 10 as ::core::ffi::c_int)
                            as usize]
                            as ::core::ffi::c_int
                            - 1 as ::core::ffi::c_int)
                            as usize] = nnzbak[1 as ::core::ffi::c_int as usize]
                            [3 as ::core::ffi::c_int as usize];
                        (*h).mb.cache.non_zero_count[(x264_scan8[(16 as ::core::ffi::c_int
                            * 2 as ::core::ffi::c_int
                            + 8 as ::core::ffi::c_int)
                            as usize]
                            as ::core::ffi::c_int
                            - 1 as ::core::ffi::c_int)
                            as usize] = nnzbak[2 as ::core::ffi::c_int as usize]
                            [2 as ::core::ffi::c_int as usize];
                        (*h).mb.cache.non_zero_count[(x264_scan8[(16 as ::core::ffi::c_int
                            * 2 as ::core::ffi::c_int
                            + 10 as ::core::ffi::c_int)
                            as usize]
                            as ::core::ffi::c_int
                            - 1 as ::core::ffi::c_int)
                            as usize] = nnzbak[2 as ::core::ffi::c_int as usize]
                            [3 as ::core::ffi::c_int as usize];
                    }
                    if (*h).mb.i_neighbour & MB_TOP as ::core::ffi::c_int as ::core::ffi::c_uint
                        != 0
                        && *(*h)
                            .mb
                            .mb_transform_size
                            .offset((*h).mb.i_mb_top_xy as isize)
                            == 0
                        && *(*h).mb.cbp.offset((*h).mb.i_mb_top_xy as isize) as ::core::ffi::c_int
                            & 0x1000 as ::core::ffi::c_int
                            == 0
                    {
                        (*(&mut *(*h).mb.cache.non_zero_count.as_mut_ptr().offset(
                            (*x264_scan8.as_ptr().offset(
                                (16 as ::core::ffi::c_int * 0 as ::core::ffi::c_int) as isize,
                            ) as ::core::ffi::c_int
                                - 8 as ::core::ffi::c_int) as isize,
                        ) as *mut uint8_t as *mut x264_union32_t))
                            .i = (*(&mut *(*nnzbak
                            .as_mut_ptr()
                            .offset(0 as ::core::ffi::c_int as isize))
                        .as_mut_ptr()
                        .offset(4 as ::core::ffi::c_int as isize)
                            as *mut uint8_t
                            as *mut x264_union32_t))
                            .i;
                        (*(&mut *(*h).mb.cache.non_zero_count.as_mut_ptr().offset(
                            (*x264_scan8.as_ptr().offset(
                                (16 as ::core::ffi::c_int * 1 as ::core::ffi::c_int) as isize,
                            ) as ::core::ffi::c_int
                                - 8 as ::core::ffi::c_int) as isize,
                        ) as *mut uint8_t as *mut x264_union32_t))
                            .i = (*(&mut *(*nnzbak
                            .as_mut_ptr()
                            .offset(1 as ::core::ffi::c_int as isize))
                        .as_mut_ptr()
                        .offset(4 as ::core::ffi::c_int as isize)
                            as *mut uint8_t
                            as *mut x264_union32_t))
                            .i;
                        (*(&mut *(*h).mb.cache.non_zero_count.as_mut_ptr().offset(
                            (*x264_scan8.as_ptr().offset(
                                (16 as ::core::ffi::c_int * 2 as ::core::ffi::c_int) as isize,
                            ) as ::core::ffi::c_int
                                - 8 as ::core::ffi::c_int) as isize,
                        ) as *mut uint8_t as *mut x264_union32_t))
                            .i = (*(&mut *(*nnzbak
                            .as_mut_ptr()
                            .offset(2 as ::core::ffi::c_int as isize))
                        .as_mut_ptr()
                        .offset(4 as ::core::ffi::c_int as isize)
                            as *mut uint8_t
                            as *mut x264_union32_t))
                            .i;
                    }
                } else {
                    let mut i_1: ::core::ffi::c_int = 0 as ::core::ffi::c_int;
                    let mut msk_0: ::core::ffi::c_int = (*h).mb.i_cbp_luma;
                    let mut skip_0: ::core::ffi::c_int = 0;
                    while msk_0 != 0 && {
                        skip_0 = x264_ctz_4bit(msk_0 as uint32_t);
                        i_1 += skip_0;
                        msk_0 >>= skip_0 + 1 as ::core::ffi::c_int;
                        1 as ::core::ffi::c_int != 0
                    } {
                        cabac_block_residual_8x8(
                            h,
                            cb,
                            DCT_LUMA_8x8 as ::core::ffi::c_int,
                            (*(*h).dct.luma8x8.as_mut_ptr().offset(i_1 as isize)).as_mut_ptr(),
                        );
                        i_1 += 1;
                    }
                }
            } else {
                let mut p_1: ::core::ffi::c_int = 0 as ::core::ffi::c_int;
                while p_1 < plane_count {
                    let mut i8x8: ::core::ffi::c_int = 0 as ::core::ffi::c_int;
                    let mut msk_1: ::core::ffi::c_int = (*h).mb.i_cbp_luma;
                    let mut skip_1: ::core::ffi::c_int = 0;
                    while msk_1 != 0 && {
                        skip_1 = x264_ctz_4bit(msk_1 as uint32_t);
                        i8x8 += skip_1;
                        msk_1 >>= skip_1 + 1 as ::core::ffi::c_int;
                        1 as ::core::ffi::c_int != 0
                    } {
                        let mut i_2: ::core::ffi::c_int = 0 as ::core::ffi::c_int;
                        while i_2 < 4 as ::core::ffi::c_int {
                            let mut ctxidxinc_2: ::core::ffi::c_int = cabac_cbf_ctxidxinc(
                                h,
                                ctx_cat_plane[DCT_LUMA_4x4 as ::core::ffi::c_int as usize]
                                    [p_1 as usize]
                                    as ::core::ffi::c_int,
                                i_2 + i8x8 * 4 as ::core::ffi::c_int
                                    + p_1 * 16 as ::core::ffi::c_int,
                                b_intra,
                                0 as ::core::ffi::c_int,
                            );
                            if (*h).mb.cache.non_zero_count[x264_scan8[(i_2
                                + i8x8 * 4 as ::core::ffi::c_int
                                + p_1 * 16 as ::core::ffi::c_int)
                                as usize]
                                as usize]
                                != 0
                            {
                                x264_cabac_size_decision(
                                    cb,
                                    ctxidxinc_2 as ::core::ffi::c_long,
                                    1 as ::core::ffi::c_long,
                                );
                                cabac_block_residual(
                                    h,
                                    cb,
                                    ctx_cat_plane[DCT_LUMA_4x4 as ::core::ffi::c_int as usize]
                                        [p_1 as usize]
                                        as ::core::ffi::c_int,
                                    (*(*h).dct.luma4x4.as_mut_ptr().offset(
                                        (i_2 + i8x8 * 4 as ::core::ffi::c_int
                                            + p_1 * 16 as ::core::ffi::c_int)
                                            as isize,
                                    ))
                                    .as_mut_ptr(),
                                );
                            } else {
                                x264_cabac_size_decision(
                                    cb,
                                    ctxidxinc_2 as ::core::ffi::c_long,
                                    0 as ::core::ffi::c_long,
                                );
                            }
                            i_2 += 1;
                        }
                        i8x8 += 1;
                    }
                    p_1 += 1;
                }
            }
            if chroma != 0 && (*h).mb.i_cbp_chroma != 0 {
                if (*(*h).sps.as_mut_ptr()).i_chroma_format_idc == CHROMA_422 as ::core::ffi::c_int
                {
                    let mut ctxidxinc_3: ::core::ffi::c_int = cabac_cbf_ctxidxinc(
                        h,
                        DCT_CHROMA_DC as ::core::ffi::c_int,
                        49 as ::core::ffi::c_int + 0 as ::core::ffi::c_int,
                        b_intra,
                        1 as ::core::ffi::c_int,
                    );
                    if (*h).mb.cache.non_zero_count[x264_scan8
                        [(49 as ::core::ffi::c_int + 0 as ::core::ffi::c_int) as usize]
                        as usize]
                        != 0
                    {
                        x264_cabac_size_decision(
                            cb,
                            ctxidxinc_3 as ::core::ffi::c_long,
                            1 as ::core::ffi::c_long,
                        );
                        cabac_block_residual_422_dc(
                            h,
                            cb,
                            DCT_CHROMA_DC as ::core::ffi::c_int,
                            (*(*h)
                                .dct
                                .chroma_dc
                                .as_mut_ptr()
                                .offset(0 as ::core::ffi::c_int as isize))
                            .as_mut_ptr(),
                        );
                    } else {
                        x264_cabac_size_decision(
                            cb,
                            ctxidxinc_3 as ::core::ffi::c_long,
                            0 as ::core::ffi::c_long,
                        );
                    }
                    let mut ctxidxinc_4: ::core::ffi::c_int = cabac_cbf_ctxidxinc(
                        h,
                        DCT_CHROMA_DC as ::core::ffi::c_int,
                        49 as ::core::ffi::c_int + 1 as ::core::ffi::c_int,
                        b_intra,
                        1 as ::core::ffi::c_int,
                    );
                    if (*h).mb.cache.non_zero_count[x264_scan8
                        [(49 as ::core::ffi::c_int + 1 as ::core::ffi::c_int) as usize]
                        as usize]
                        != 0
                    {
                        x264_cabac_size_decision(
                            cb,
                            ctxidxinc_4 as ::core::ffi::c_long,
                            1 as ::core::ffi::c_long,
                        );
                        cabac_block_residual_422_dc(
                            h,
                            cb,
                            DCT_CHROMA_DC as ::core::ffi::c_int,
                            (*(*h)
                                .dct
                                .chroma_dc
                                .as_mut_ptr()
                                .offset(1 as ::core::ffi::c_int as isize))
                            .as_mut_ptr(),
                        );
                    } else {
                        x264_cabac_size_decision(
                            cb,
                            ctxidxinc_4 as ::core::ffi::c_long,
                            0 as ::core::ffi::c_long,
                        );
                    }
                } else {
                    let mut ctxidxinc_5: ::core::ffi::c_int = cabac_cbf_ctxidxinc(
                        h,
                        DCT_CHROMA_DC as ::core::ffi::c_int,
                        49 as ::core::ffi::c_int + 0 as ::core::ffi::c_int,
                        b_intra,
                        1 as ::core::ffi::c_int,
                    );
                    if (*h).mb.cache.non_zero_count[x264_scan8
                        [(49 as ::core::ffi::c_int + 0 as ::core::ffi::c_int) as usize]
                        as usize]
                        != 0
                    {
                        x264_cabac_size_decision(
                            cb,
                            ctxidxinc_5 as ::core::ffi::c_long,
                            1 as ::core::ffi::c_long,
                        );
                        cabac_block_residual(
                            h,
                            cb,
                            DCT_CHROMA_DC as ::core::ffi::c_int,
                            (*(*h)
                                .dct
                                .chroma_dc
                                .as_mut_ptr()
                                .offset(0 as ::core::ffi::c_int as isize))
                            .as_mut_ptr(),
                        );
                    } else {
                        x264_cabac_size_decision(
                            cb,
                            ctxidxinc_5 as ::core::ffi::c_long,
                            0 as ::core::ffi::c_long,
                        );
                    }
                    let mut ctxidxinc_6: ::core::ffi::c_int = cabac_cbf_ctxidxinc(
                        h,
                        DCT_CHROMA_DC as ::core::ffi::c_int,
                        49 as ::core::ffi::c_int + 1 as ::core::ffi::c_int,
                        b_intra,
                        1 as ::core::ffi::c_int,
                    );
                    if (*h).mb.cache.non_zero_count[x264_scan8
                        [(49 as ::core::ffi::c_int + 1 as ::core::ffi::c_int) as usize]
                        as usize]
                        != 0
                    {
                        x264_cabac_size_decision(
                            cb,
                            ctxidxinc_6 as ::core::ffi::c_long,
                            1 as ::core::ffi::c_long,
                        );
                        cabac_block_residual(
                            h,
                            cb,
                            DCT_CHROMA_DC as ::core::ffi::c_int,
                            (*(*h)
                                .dct
                                .chroma_dc
                                .as_mut_ptr()
                                .offset(1 as ::core::ffi::c_int as isize))
                            .as_mut_ptr(),
                        );
                    } else {
                        x264_cabac_size_decision(
                            cb,
                            ctxidxinc_6 as ::core::ffi::c_long,
                            0 as ::core::ffi::c_long,
                        );
                    }
                }
                if (*h).mb.i_cbp_chroma == 2 as ::core::ffi::c_int {
                    let mut step: ::core::ffi::c_int =
                        (8 as ::core::ffi::c_int) << (*h).mb.chroma_v_shift;
                    let mut i_3: ::core::ffi::c_int = 16 as ::core::ffi::c_int;
                    while i_3 < 3 as ::core::ffi::c_int * 16 as ::core::ffi::c_int {
                        let mut j: ::core::ffi::c_int = i_3;
                        while j < i_3 + 4 as ::core::ffi::c_int {
                            let mut ctxidxinc_7: ::core::ffi::c_int = cabac_cbf_ctxidxinc(
                                h,
                                DCT_CHROMA_AC as ::core::ffi::c_int,
                                j,
                                b_intra,
                                0 as ::core::ffi::c_int,
                            );
                            if (*h).mb.cache.non_zero_count[x264_scan8[j as usize] as usize] != 0 {
                                x264_cabac_size_decision(
                                    cb,
                                    ctxidxinc_7 as ::core::ffi::c_long,
                                    1 as ::core::ffi::c_long,
                                );
                                cabac_block_residual(
                                    h,
                                    cb,
                                    DCT_CHROMA_AC as ::core::ffi::c_int,
                                    (*(*h).dct.luma4x4.as_mut_ptr().offset(j as isize))
                                        .as_mut_ptr()
                                        .offset(1 as ::core::ffi::c_int as isize),
                                );
                            } else {
                                x264_cabac_size_decision(
                                    cb,
                                    ctxidxinc_7 as ::core::ffi::c_long,
                                    0 as ::core::ffi::c_long,
                                );
                            }
                            j += 1;
                        }
                        i_3 += step;
                    }
                }
            }
        }
    }
    #[c2rust::src_loc = "1088:1"]
    pub unsafe extern "C" fn macroblock_size_cabac(mut h: *mut x264_t, mut cb: *mut x264_cabac_t) {
        if (*(*h).sps.as_mut_ptr()).i_chroma_format_idc == CHROMA_444 as ::core::ffi::c_int {
            macroblock_write_cabac_internal(
                h,
                cb,
                3 as ::core::ffi::c_int,
                0 as ::core::ffi::c_int,
            );
        } else if (*(*h).sps.as_mut_ptr()).i_chroma_format_idc != 0 {
            macroblock_write_cabac_internal(
                h,
                cb,
                1 as ::core::ffi::c_int,
                1 as ::core::ffi::c_int,
            );
        } else {
            macroblock_write_cabac_internal(
                h,
                cb,
                1 as ::core::ffi::c_int,
                0 as ::core::ffi::c_int,
            );
        };
    }
    #[c2rust::src_loc = "1106:1"]
    pub unsafe extern "C" fn partition_size_cabac(
        mut h: *mut x264_t,
        mut cb: *mut x264_cabac_t,
        mut i8: ::core::ffi::c_int,
        mut i_pixel: ::core::ffi::c_int,
    ) {
        let i_mb_type: ::core::ffi::c_int = (*h).mb.i_type;
        let mut b_8x16: ::core::ffi::c_int =
            ((*h).mb.i_partition == D_8x16 as ::core::ffi::c_int) as ::core::ffi::c_int;
        let mut plane_count: ::core::ffi::c_int =
            if (*(*h).sps.as_mut_ptr()).i_chroma_format_idc == CHROMA_444 as ::core::ffi::c_int {
                3 as ::core::ffi::c_int
            } else {
                1 as ::core::ffi::c_int
            };
        if i_mb_type == P_8x8 as ::core::ffi::c_int {
            cabac_8x8_mvd(h, cb, i8);
            cabac_subpartition_p(
                cb,
                (*h).mb.i_sub_partition[i8 as usize] as ::core::ffi::c_int,
            );
        } else if i_mb_type == P_L0 as ::core::ffi::c_int {
            let mut mvd: uint16_t = cabac_mvd(
                h,
                cb,
                0 as ::core::ffi::c_int,
                4 as ::core::ffi::c_int * i8,
                4 as ::core::ffi::c_int >> b_8x16,
            );
            x264_macroblock_cache_mvd(
                h,
                block_idx_x[(4 as ::core::ffi::c_int * i8) as usize] as ::core::ffi::c_int,
                block_idx_y[(4 as ::core::ffi::c_int * i8) as usize] as ::core::ffi::c_int,
                4 as ::core::ffi::c_int >> b_8x16,
                (2 as ::core::ffi::c_int) << b_8x16,
                0 as ::core::ffi::c_int,
                mvd,
            );
        } else if i_mb_type > B_DIRECT as ::core::ffi::c_int
            && i_mb_type < B_8x8 as ::core::ffi::c_int
        {
            if x264_mb_type_list_table[i_mb_type as usize][0 as ::core::ffi::c_int as usize]
                [(i8 != 0) as ::core::ffi::c_int as usize]
                != 0
            {
                let mut mvd_0: uint16_t = cabac_mvd(
                    h,
                    cb,
                    0 as ::core::ffi::c_int,
                    4 as ::core::ffi::c_int * i8,
                    4 as ::core::ffi::c_int >> b_8x16,
                );
                x264_macroblock_cache_mvd(
                    h,
                    block_idx_x[(4 as ::core::ffi::c_int * i8) as usize] as ::core::ffi::c_int,
                    block_idx_y[(4 as ::core::ffi::c_int * i8) as usize] as ::core::ffi::c_int,
                    4 as ::core::ffi::c_int >> b_8x16,
                    (2 as ::core::ffi::c_int) << b_8x16,
                    0 as ::core::ffi::c_int,
                    mvd_0,
                );
            }
            if x264_mb_type_list_table[i_mb_type as usize][1 as ::core::ffi::c_int as usize]
                [(i8 != 0) as ::core::ffi::c_int as usize]
                != 0
            {
                let mut mvd_1: uint16_t = cabac_mvd(
                    h,
                    cb,
                    1 as ::core::ffi::c_int,
                    4 as ::core::ffi::c_int * i8,
                    4 as ::core::ffi::c_int >> b_8x16,
                );
                x264_macroblock_cache_mvd(
                    h,
                    block_idx_x[(4 as ::core::ffi::c_int * i8) as usize] as ::core::ffi::c_int,
                    block_idx_y[(4 as ::core::ffi::c_int * i8) as usize] as ::core::ffi::c_int,
                    4 as ::core::ffi::c_int >> b_8x16,
                    (2 as ::core::ffi::c_int) << b_8x16,
                    1 as ::core::ffi::c_int,
                    mvd_1,
                );
            }
        } else {
            if x264_mb_partition_listX_table[0 as ::core::ffi::c_int as usize]
                [(*h).mb.i_sub_partition[i8 as usize] as usize]
                != 0
            {
                let mut mvd_2: uint16_t = cabac_mvd(
                    h,
                    cb,
                    0 as ::core::ffi::c_int,
                    4 as ::core::ffi::c_int * i8,
                    2 as ::core::ffi::c_int,
                );
                x264_macroblock_cache_mvd(
                    h,
                    block_idx_x[(4 as ::core::ffi::c_int * i8) as usize] as ::core::ffi::c_int,
                    block_idx_y[(4 as ::core::ffi::c_int * i8) as usize] as ::core::ffi::c_int,
                    2 as ::core::ffi::c_int,
                    2 as ::core::ffi::c_int,
                    0 as ::core::ffi::c_int,
                    mvd_2,
                );
            }
            if x264_mb_partition_listX_table[1 as ::core::ffi::c_int as usize]
                [(*h).mb.i_sub_partition[i8 as usize] as usize]
                != 0
            {
                let mut mvd_3: uint16_t = cabac_mvd(
                    h,
                    cb,
                    1 as ::core::ffi::c_int,
                    4 as ::core::ffi::c_int * i8,
                    2 as ::core::ffi::c_int,
                );
                x264_macroblock_cache_mvd(
                    h,
                    block_idx_x[(4 as ::core::ffi::c_int * i8) as usize] as ::core::ffi::c_int,
                    block_idx_y[(4 as ::core::ffi::c_int * i8) as usize] as ::core::ffi::c_int,
                    2 as ::core::ffi::c_int,
                    2 as ::core::ffi::c_int,
                    1 as ::core::ffi::c_int,
                    mvd_3,
                );
            }
        }
        let mut j: ::core::ffi::c_int =
            (i_pixel < PIXEL_8x8 as ::core::ffi::c_int) as ::core::ffi::c_int;
        while j >= 0 as ::core::ffi::c_int {
            if (*h).mb.i_cbp_luma & (1 as ::core::ffi::c_int) << i8 != 0 {
                if (*h).mb.b_transform_8x8 != 0 {
                    if (*(*h).sps.as_mut_ptr()).i_chroma_format_idc
                        == CHROMA_444 as ::core::ffi::c_int
                    {
                        let mut p: ::core::ffi::c_int = 0 as ::core::ffi::c_int;
                        while p < 3 as ::core::ffi::c_int {
                            let mut ctxidxinc: ::core::ffi::c_int = cabac_cbf_ctxidxinc(
                                h,
                                ctx_cat_plane[DCT_LUMA_8x8 as ::core::ffi::c_int as usize]
                                    [p as usize]
                                    as ::core::ffi::c_int,
                                i8 * 4 as ::core::ffi::c_int + p * 16 as ::core::ffi::c_int,
                                0 as ::core::ffi::c_int,
                                0 as ::core::ffi::c_int,
                            );
                            if (*h).mb.cache.non_zero_count[x264_scan8[(i8
                                * 4 as ::core::ffi::c_int
                                + p * 16 as ::core::ffi::c_int)
                                as usize]
                                as usize]
                                != 0
                            {
                                x264_cabac_size_decision(
                                    cb,
                                    ctxidxinc as ::core::ffi::c_long,
                                    1 as ::core::ffi::c_long,
                                );
                                cabac_block_residual_8x8(
                                    h,
                                    cb,
                                    ctx_cat_plane[DCT_LUMA_8x8 as ::core::ffi::c_int as usize]
                                        [p as usize]
                                        as ::core::ffi::c_int,
                                    (*(*h)
                                        .dct
                                        .luma8x8
                                        .as_mut_ptr()
                                        .offset((i8 + p * 4 as ::core::ffi::c_int) as isize))
                                    .as_mut_ptr(),
                                );
                            } else {
                                x264_cabac_size_decision(
                                    cb,
                                    ctxidxinc as ::core::ffi::c_long,
                                    0 as ::core::ffi::c_long,
                                );
                            }
                            p += 1;
                        }
                    } else {
                        cabac_block_residual_8x8(
                            h,
                            cb,
                            DCT_LUMA_8x8 as ::core::ffi::c_int,
                            (*(*h).dct.luma8x8.as_mut_ptr().offset(i8 as isize)).as_mut_ptr(),
                        );
                    }
                } else {
                    let mut p_0: ::core::ffi::c_int = 0 as ::core::ffi::c_int;
                    while p_0 < plane_count {
                        let mut i4: ::core::ffi::c_int = 0 as ::core::ffi::c_int;
                        while i4 < 4 as ::core::ffi::c_int {
                            let mut ctxidxinc_0: ::core::ffi::c_int = cabac_cbf_ctxidxinc(
                                h,
                                ctx_cat_plane[DCT_LUMA_4x4 as ::core::ffi::c_int as usize]
                                    [p_0 as usize]
                                    as ::core::ffi::c_int,
                                i4 + i8 * 4 as ::core::ffi::c_int + p_0 * 16 as ::core::ffi::c_int,
                                0 as ::core::ffi::c_int,
                                0 as ::core::ffi::c_int,
                            );
                            if (*h).mb.cache.non_zero_count[x264_scan8[(i4
                                + i8 * 4 as ::core::ffi::c_int
                                + p_0 * 16 as ::core::ffi::c_int)
                                as usize]
                                as usize]
                                != 0
                            {
                                x264_cabac_size_decision(
                                    cb,
                                    ctxidxinc_0 as ::core::ffi::c_long,
                                    1 as ::core::ffi::c_long,
                                );
                                cabac_block_residual(
                                    h,
                                    cb,
                                    ctx_cat_plane[DCT_LUMA_4x4 as ::core::ffi::c_int as usize]
                                        [p_0 as usize]
                                        as ::core::ffi::c_int,
                                    (*(*h).dct.luma4x4.as_mut_ptr().offset(
                                        (i4 + i8 * 4 as ::core::ffi::c_int
                                            + p_0 * 16 as ::core::ffi::c_int)
                                            as isize,
                                    ))
                                    .as_mut_ptr(),
                                );
                            } else {
                                x264_cabac_size_decision(
                                    cb,
                                    ctxidxinc_0 as ::core::ffi::c_long,
                                    0 as ::core::ffi::c_long,
                                );
                            }
                            i4 += 1;
                        }
                        p_0 += 1;
                    }
                }
            }
            if (*h).mb.i_cbp_chroma != 0 {
                if (*(*h).sps.as_mut_ptr()).i_chroma_format_idc == CHROMA_422 as ::core::ffi::c_int
                {
                    let mut offset: ::core::ffi::c_int =
                        5 as ::core::ffi::c_int * i8 & 0x9 as ::core::ffi::c_int;
                    let mut ctxidxinc_1: ::core::ffi::c_int = cabac_cbf_ctxidxinc(
                        h,
                        DCT_CHROMA_AC as ::core::ffi::c_int,
                        16 as ::core::ffi::c_int + offset,
                        0 as ::core::ffi::c_int,
                        0 as ::core::ffi::c_int,
                    );
                    if (*h).mb.cache.non_zero_count
                        [x264_scan8[(16 as ::core::ffi::c_int + offset) as usize] as usize]
                        != 0
                    {
                        x264_cabac_size_decision(
                            cb,
                            ctxidxinc_1 as ::core::ffi::c_long,
                            1 as ::core::ffi::c_long,
                        );
                        cabac_block_residual(
                            h,
                            cb,
                            DCT_CHROMA_AC as ::core::ffi::c_int,
                            (*(*h)
                                .dct
                                .luma4x4
                                .as_mut_ptr()
                                .offset((16 as ::core::ffi::c_int + offset) as isize))
                            .as_mut_ptr()
                            .offset(1 as ::core::ffi::c_int as isize),
                        );
                    } else {
                        x264_cabac_size_decision(
                            cb,
                            ctxidxinc_1 as ::core::ffi::c_long,
                            0 as ::core::ffi::c_long,
                        );
                    }
                    let mut ctxidxinc_2: ::core::ffi::c_int = cabac_cbf_ctxidxinc(
                        h,
                        DCT_CHROMA_AC as ::core::ffi::c_int,
                        18 as ::core::ffi::c_int + offset,
                        0 as ::core::ffi::c_int,
                        0 as ::core::ffi::c_int,
                    );
                    if (*h).mb.cache.non_zero_count
                        [x264_scan8[(18 as ::core::ffi::c_int + offset) as usize] as usize]
                        != 0
                    {
                        x264_cabac_size_decision(
                            cb,
                            ctxidxinc_2 as ::core::ffi::c_long,
                            1 as ::core::ffi::c_long,
                        );
                        cabac_block_residual(
                            h,
                            cb,
                            DCT_CHROMA_AC as ::core::ffi::c_int,
                            (*(*h)
                                .dct
                                .luma4x4
                                .as_mut_ptr()
                                .offset((18 as ::core::ffi::c_int + offset) as isize))
                            .as_mut_ptr()
                            .offset(1 as ::core::ffi::c_int as isize),
                        );
                    } else {
                        x264_cabac_size_decision(
                            cb,
                            ctxidxinc_2 as ::core::ffi::c_long,
                            0 as ::core::ffi::c_long,
                        );
                    }
                    let mut ctxidxinc_3: ::core::ffi::c_int = cabac_cbf_ctxidxinc(
                        h,
                        DCT_CHROMA_AC as ::core::ffi::c_int,
                        32 as ::core::ffi::c_int + offset,
                        0 as ::core::ffi::c_int,
                        0 as ::core::ffi::c_int,
                    );
                    if (*h).mb.cache.non_zero_count
                        [x264_scan8[(32 as ::core::ffi::c_int + offset) as usize] as usize]
                        != 0
                    {
                        x264_cabac_size_decision(
                            cb,
                            ctxidxinc_3 as ::core::ffi::c_long,
                            1 as ::core::ffi::c_long,
                        );
                        cabac_block_residual(
                            h,
                            cb,
                            DCT_CHROMA_AC as ::core::ffi::c_int,
                            (*(*h)
                                .dct
                                .luma4x4
                                .as_mut_ptr()
                                .offset((32 as ::core::ffi::c_int + offset) as isize))
                            .as_mut_ptr()
                            .offset(1 as ::core::ffi::c_int as isize),
                        );
                    } else {
                        x264_cabac_size_decision(
                            cb,
                            ctxidxinc_3 as ::core::ffi::c_long,
                            0 as ::core::ffi::c_long,
                        );
                    }
                    let mut ctxidxinc_4: ::core::ffi::c_int = cabac_cbf_ctxidxinc(
                        h,
                        DCT_CHROMA_AC as ::core::ffi::c_int,
                        34 as ::core::ffi::c_int + offset,
                        0 as ::core::ffi::c_int,
                        0 as ::core::ffi::c_int,
                    );
                    if (*h).mb.cache.non_zero_count
                        [x264_scan8[(34 as ::core::ffi::c_int + offset) as usize] as usize]
                        != 0
                    {
                        x264_cabac_size_decision(
                            cb,
                            ctxidxinc_4 as ::core::ffi::c_long,
                            1 as ::core::ffi::c_long,
                        );
                        cabac_block_residual(
                            h,
                            cb,
                            DCT_CHROMA_AC as ::core::ffi::c_int,
                            (*(*h)
                                .dct
                                .luma4x4
                                .as_mut_ptr()
                                .offset((34 as ::core::ffi::c_int + offset) as isize))
                            .as_mut_ptr()
                            .offset(1 as ::core::ffi::c_int as isize),
                        );
                    } else {
                        x264_cabac_size_decision(
                            cb,
                            ctxidxinc_4 as ::core::ffi::c_long,
                            0 as ::core::ffi::c_long,
                        );
                    }
                } else {
                    let mut ctxidxinc_5: ::core::ffi::c_int = cabac_cbf_ctxidxinc(
                        h,
                        DCT_CHROMA_AC as ::core::ffi::c_int,
                        16 as ::core::ffi::c_int + i8,
                        0 as ::core::ffi::c_int,
                        0 as ::core::ffi::c_int,
                    );
                    if (*h).mb.cache.non_zero_count
                        [x264_scan8[(16 as ::core::ffi::c_int + i8) as usize] as usize]
                        != 0
                    {
                        x264_cabac_size_decision(
                            cb,
                            ctxidxinc_5 as ::core::ffi::c_long,
                            1 as ::core::ffi::c_long,
                        );
                        cabac_block_residual(
                            h,
                            cb,
                            DCT_CHROMA_AC as ::core::ffi::c_int,
                            (*(*h)
                                .dct
                                .luma4x4
                                .as_mut_ptr()
                                .offset((16 as ::core::ffi::c_int + i8) as isize))
                            .as_mut_ptr()
                            .offset(1 as ::core::ffi::c_int as isize),
                        );
                    } else {
                        x264_cabac_size_decision(
                            cb,
                            ctxidxinc_5 as ::core::ffi::c_long,
                            0 as ::core::ffi::c_long,
                        );
                    }
                    let mut ctxidxinc_6: ::core::ffi::c_int = cabac_cbf_ctxidxinc(
                        h,
                        DCT_CHROMA_AC as ::core::ffi::c_int,
                        32 as ::core::ffi::c_int + i8,
                        0 as ::core::ffi::c_int,
                        0 as ::core::ffi::c_int,
                    );
                    if (*h).mb.cache.non_zero_count
                        [x264_scan8[(32 as ::core::ffi::c_int + i8) as usize] as usize]
                        != 0
                    {
                        x264_cabac_size_decision(
                            cb,
                            ctxidxinc_6 as ::core::ffi::c_long,
                            1 as ::core::ffi::c_long,
                        );
                        cabac_block_residual(
                            h,
                            cb,
                            DCT_CHROMA_AC as ::core::ffi::c_int,
                            (*(*h)
                                .dct
                                .luma4x4
                                .as_mut_ptr()
                                .offset((32 as ::core::ffi::c_int + i8) as isize))
                            .as_mut_ptr()
                            .offset(1 as ::core::ffi::c_int as isize),
                        );
                    } else {
                        x264_cabac_size_decision(
                            cb,
                            ctxidxinc_6 as ::core::ffi::c_long,
                            0 as ::core::ffi::c_long,
                        );
                    }
                }
            }
            i8 += x264_pixel_size[i_pixel as usize].h as ::core::ffi::c_int
                >> 3 as ::core::ffi::c_int;
            j -= 1;
        }
    }
    #[c2rust::src_loc = "1171:1"]
    pub unsafe extern "C" fn subpartition_size_cabac(
        mut h: *mut x264_t,
        mut cb: *mut x264_cabac_t,
        mut i4: ::core::ffi::c_int,
        mut i_pixel: ::core::ffi::c_int,
    ) {
        let mut b_8x4: ::core::ffi::c_int =
            (i_pixel == PIXEL_8x4 as ::core::ffi::c_int) as ::core::ffi::c_int;
        let mut plane_count: ::core::ffi::c_int =
            if (*(*h).sps.as_mut_ptr()).i_chroma_format_idc == CHROMA_444 as ::core::ffi::c_int {
                3 as ::core::ffi::c_int
            } else {
                1 as ::core::ffi::c_int
            };
        if i_pixel == PIXEL_4x4 as ::core::ffi::c_int {
            let mut mvd: uint16_t =
                cabac_mvd(h, cb, 0 as ::core::ffi::c_int, i4, 1 as ::core::ffi::c_int);
            x264_macroblock_cache_mvd(
                h,
                block_idx_x[i4 as usize] as ::core::ffi::c_int,
                block_idx_y[i4 as usize] as ::core::ffi::c_int,
                1 as ::core::ffi::c_int,
                1 as ::core::ffi::c_int,
                0 as ::core::ffi::c_int,
                mvd,
            );
        } else {
            let mut mvd_0: uint16_t = cabac_mvd(
                h,
                cb,
                0 as ::core::ffi::c_int,
                i4,
                1 as ::core::ffi::c_int + b_8x4,
            );
            x264_macroblock_cache_mvd(
                h,
                block_idx_x[i4 as usize] as ::core::ffi::c_int,
                block_idx_y[i4 as usize] as ::core::ffi::c_int,
                1 as ::core::ffi::c_int + b_8x4,
                2 as ::core::ffi::c_int - b_8x4,
                0 as ::core::ffi::c_int,
                mvd_0,
            );
        }
        let mut p: ::core::ffi::c_int = 0 as ::core::ffi::c_int;
        while p < plane_count {
            let mut ctxidxinc: ::core::ffi::c_int = cabac_cbf_ctxidxinc(
                h,
                ctx_cat_plane[DCT_LUMA_4x4 as ::core::ffi::c_int as usize][p as usize]
                    as ::core::ffi::c_int,
                p * 16 as ::core::ffi::c_int + i4,
                0 as ::core::ffi::c_int,
                0 as ::core::ffi::c_int,
            );
            if (*h).mb.cache.non_zero_count
                [x264_scan8[(p * 16 as ::core::ffi::c_int + i4) as usize] as usize]
                != 0
            {
                x264_cabac_size_decision(
                    cb,
                    ctxidxinc as ::core::ffi::c_long,
                    1 as ::core::ffi::c_long,
                );
                cabac_block_residual(
                    h,
                    cb,
                    ctx_cat_plane[DCT_LUMA_4x4 as ::core::ffi::c_int as usize][p as usize]
                        as ::core::ffi::c_int,
                    (*(*h)
                        .dct
                        .luma4x4
                        .as_mut_ptr()
                        .offset((p * 16 as ::core::ffi::c_int + i4) as isize))
                    .as_mut_ptr(),
                );
            } else {
                x264_cabac_size_decision(
                    cb,
                    ctxidxinc as ::core::ffi::c_long,
                    0 as ::core::ffi::c_long,
                );
            }
            if i_pixel != PIXEL_4x4 as ::core::ffi::c_int {
                let mut ctxidxinc_0: ::core::ffi::c_int = cabac_cbf_ctxidxinc(
                    h,
                    ctx_cat_plane[DCT_LUMA_4x4 as ::core::ffi::c_int as usize][p as usize]
                        as ::core::ffi::c_int,
                    p * 16 as ::core::ffi::c_int + i4 + 2 as ::core::ffi::c_int - b_8x4,
                    0 as ::core::ffi::c_int,
                    0 as ::core::ffi::c_int,
                );
                if (*h).mb.cache.non_zero_count[x264_scan8
                    [(p * 16 as ::core::ffi::c_int + i4 + 2 as ::core::ffi::c_int - b_8x4) as usize]
                    as usize]
                    != 0
                {
                    x264_cabac_size_decision(
                        cb,
                        ctxidxinc_0 as ::core::ffi::c_long,
                        1 as ::core::ffi::c_long,
                    );
                    cabac_block_residual(
                        h,
                        cb,
                        ctx_cat_plane[DCT_LUMA_4x4 as ::core::ffi::c_int as usize][p as usize]
                            as ::core::ffi::c_int,
                        (*(*h).dct.luma4x4.as_mut_ptr().offset(
                            (p * 16 as ::core::ffi::c_int + i4 + 2 as ::core::ffi::c_int - b_8x4)
                                as isize,
                        ))
                        .as_mut_ptr(),
                    );
                } else {
                    x264_cabac_size_decision(
                        cb,
                        ctxidxinc_0 as ::core::ffi::c_long,
                        0 as ::core::ffi::c_long,
                    );
                }
            }
            p += 1;
        }
    }
    #[c2rust::src_loc = "1187:1"]
    pub unsafe extern "C" fn partition_i8x8_size_cabac(
        mut h: *mut x264_t,
        mut cb: *mut x264_cabac_t,
        mut i8: ::core::ffi::c_int,
        mut i_mode: ::core::ffi::c_int,
    ) {
        let i_pred: ::core::ffi::c_int =
            x264_mb_predict_intra4x4_mode(h, 4 as ::core::ffi::c_int * i8) as ::core::ffi::c_int;
        i_mode = x264_mb_pred_mode4x4_fix[(i_mode + 1 as ::core::ffi::c_int) as usize]
            as ::core::ffi::c_int;
        cabac_intra4x4_pred_mode(cb, i_pred, i_mode);
        cabac_cbp_luma(h, cb);
        if (*h).mb.i_cbp_luma & (1 as ::core::ffi::c_int) << i8 != 0 {
            if (*(*h).sps.as_mut_ptr()).i_chroma_format_idc == CHROMA_444 as ::core::ffi::c_int {
                let mut p: ::core::ffi::c_int = 0 as ::core::ffi::c_int;
                while p < 3 as ::core::ffi::c_int {
                    let mut ctxidxinc: ::core::ffi::c_int = cabac_cbf_ctxidxinc(
                        h,
                        ctx_cat_plane[DCT_LUMA_8x8 as ::core::ffi::c_int as usize][p as usize]
                            as ::core::ffi::c_int,
                        i8 * 4 as ::core::ffi::c_int + p * 16 as ::core::ffi::c_int,
                        1 as ::core::ffi::c_int,
                        0 as ::core::ffi::c_int,
                    );
                    if (*h).mb.cache.non_zero_count[x264_scan8
                        [(i8 * 4 as ::core::ffi::c_int + p * 16 as ::core::ffi::c_int) as usize]
                        as usize]
                        != 0
                    {
                        x264_cabac_size_decision(
                            cb,
                            ctxidxinc as ::core::ffi::c_long,
                            1 as ::core::ffi::c_long,
                        );
                        cabac_block_residual_8x8(
                            h,
                            cb,
                            ctx_cat_plane[DCT_LUMA_8x8 as ::core::ffi::c_int as usize][p as usize]
                                as ::core::ffi::c_int,
                            (*(*h)
                                .dct
                                .luma8x8
                                .as_mut_ptr()
                                .offset((i8 + p * 4 as ::core::ffi::c_int) as isize))
                            .as_mut_ptr(),
                        );
                    } else {
                        x264_cabac_size_decision(
                            cb,
                            ctxidxinc as ::core::ffi::c_long,
                            0 as ::core::ffi::c_long,
                        );
                    }
                    p += 1;
                }
            } else {
                cabac_block_residual_8x8(
                    h,
                    cb,
                    DCT_LUMA_8x8 as ::core::ffi::c_int,
                    (*(*h).dct.luma8x8.as_mut_ptr().offset(i8 as isize)).as_mut_ptr(),
                );
            }
        }
    }
    #[c2rust::src_loc = "1203:1"]
    pub unsafe extern "C" fn partition_i4x4_size_cabac(
        mut h: *mut x264_t,
        mut cb: *mut x264_cabac_t,
        mut i4: ::core::ffi::c_int,
        mut i_mode: ::core::ffi::c_int,
    ) {
        let i_pred: ::core::ffi::c_int = x264_mb_predict_intra4x4_mode(h, i4) as ::core::ffi::c_int;
        let mut plane_count: ::core::ffi::c_int =
            if (*(*h).sps.as_mut_ptr()).i_chroma_format_idc == CHROMA_444 as ::core::ffi::c_int {
                3 as ::core::ffi::c_int
            } else {
                1 as ::core::ffi::c_int
            };
        i_mode = x264_mb_pred_mode4x4_fix[(i_mode + 1 as ::core::ffi::c_int) as usize]
            as ::core::ffi::c_int;
        cabac_intra4x4_pred_mode(cb, i_pred, i_mode);
        let mut p: ::core::ffi::c_int = 0 as ::core::ffi::c_int;
        while p < plane_count {
            let mut ctxidxinc: ::core::ffi::c_int = cabac_cbf_ctxidxinc(
                h,
                ctx_cat_plane[DCT_LUMA_4x4 as ::core::ffi::c_int as usize][p as usize]
                    as ::core::ffi::c_int,
                i4 + p * 16 as ::core::ffi::c_int,
                1 as ::core::ffi::c_int,
                0 as ::core::ffi::c_int,
            );
            if (*h).mb.cache.non_zero_count
                [x264_scan8[(i4 + p * 16 as ::core::ffi::c_int) as usize] as usize]
                != 0
            {
                x264_cabac_size_decision(
                    cb,
                    ctxidxinc as ::core::ffi::c_long,
                    1 as ::core::ffi::c_long,
                );
                cabac_block_residual(
                    h,
                    cb,
                    ctx_cat_plane[DCT_LUMA_4x4 as ::core::ffi::c_int as usize][p as usize]
                        as ::core::ffi::c_int,
                    (*(*h)
                        .dct
                        .luma4x4
                        .as_mut_ptr()
                        .offset((i4 + p * 16 as ::core::ffi::c_int) as isize))
                    .as_mut_ptr(),
                );
            } else {
                x264_cabac_size_decision(
                    cb,
                    ctxidxinc as ::core::ffi::c_long,
                    0 as ::core::ffi::c_long,
                );
            }
            p += 1;
        }
    }
    #[c2rust::src_loc = "1213:1"]
    pub unsafe extern "C" fn chroma_size_cabac(mut h: *mut x264_t, mut cb: *mut x264_cabac_t) {
        cabac_intra_chroma_pred_mode(h, cb);
        cabac_cbp_chroma(h, cb);
        if (*h).mb.i_cbp_chroma != 0 {
            if (*(*h).sps.as_mut_ptr()).i_chroma_format_idc == CHROMA_422 as ::core::ffi::c_int {
                let mut ctxidxinc: ::core::ffi::c_int = cabac_cbf_ctxidxinc(
                    h,
                    DCT_CHROMA_DC as ::core::ffi::c_int,
                    49 as ::core::ffi::c_int + 0 as ::core::ffi::c_int,
                    1 as ::core::ffi::c_int,
                    1 as ::core::ffi::c_int,
                );
                if (*h).mb.cache.non_zero_count[x264_scan8
                    [(49 as ::core::ffi::c_int + 0 as ::core::ffi::c_int) as usize]
                    as usize]
                    != 0
                {
                    x264_cabac_size_decision(
                        cb,
                        ctxidxinc as ::core::ffi::c_long,
                        1 as ::core::ffi::c_long,
                    );
                    cabac_block_residual_422_dc(
                        h,
                        cb,
                        DCT_CHROMA_DC as ::core::ffi::c_int,
                        (*(*h)
                            .dct
                            .chroma_dc
                            .as_mut_ptr()
                            .offset(0 as ::core::ffi::c_int as isize))
                        .as_mut_ptr(),
                    );
                } else {
                    x264_cabac_size_decision(
                        cb,
                        ctxidxinc as ::core::ffi::c_long,
                        0 as ::core::ffi::c_long,
                    );
                }
                let mut ctxidxinc_0: ::core::ffi::c_int = cabac_cbf_ctxidxinc(
                    h,
                    DCT_CHROMA_DC as ::core::ffi::c_int,
                    49 as ::core::ffi::c_int + 1 as ::core::ffi::c_int,
                    1 as ::core::ffi::c_int,
                    1 as ::core::ffi::c_int,
                );
                if (*h).mb.cache.non_zero_count[x264_scan8
                    [(49 as ::core::ffi::c_int + 1 as ::core::ffi::c_int) as usize]
                    as usize]
                    != 0
                {
                    x264_cabac_size_decision(
                        cb,
                        ctxidxinc_0 as ::core::ffi::c_long,
                        1 as ::core::ffi::c_long,
                    );
                    cabac_block_residual_422_dc(
                        h,
                        cb,
                        DCT_CHROMA_DC as ::core::ffi::c_int,
                        (*(*h)
                            .dct
                            .chroma_dc
                            .as_mut_ptr()
                            .offset(1 as ::core::ffi::c_int as isize))
                        .as_mut_ptr(),
                    );
                } else {
                    x264_cabac_size_decision(
                        cb,
                        ctxidxinc_0 as ::core::ffi::c_long,
                        0 as ::core::ffi::c_long,
                    );
                }
            } else {
                let mut ctxidxinc_1: ::core::ffi::c_int = cabac_cbf_ctxidxinc(
                    h,
                    DCT_CHROMA_DC as ::core::ffi::c_int,
                    49 as ::core::ffi::c_int + 0 as ::core::ffi::c_int,
                    1 as ::core::ffi::c_int,
                    1 as ::core::ffi::c_int,
                );
                if (*h).mb.cache.non_zero_count[x264_scan8
                    [(49 as ::core::ffi::c_int + 0 as ::core::ffi::c_int) as usize]
                    as usize]
                    != 0
                {
                    x264_cabac_size_decision(
                        cb,
                        ctxidxinc_1 as ::core::ffi::c_long,
                        1 as ::core::ffi::c_long,
                    );
                    cabac_block_residual(
                        h,
                        cb,
                        DCT_CHROMA_DC as ::core::ffi::c_int,
                        (*(*h)
                            .dct
                            .chroma_dc
                            .as_mut_ptr()
                            .offset(0 as ::core::ffi::c_int as isize))
                        .as_mut_ptr(),
                    );
                } else {
                    x264_cabac_size_decision(
                        cb,
                        ctxidxinc_1 as ::core::ffi::c_long,
                        0 as ::core::ffi::c_long,
                    );
                }
                let mut ctxidxinc_2: ::core::ffi::c_int = cabac_cbf_ctxidxinc(
                    h,
                    DCT_CHROMA_DC as ::core::ffi::c_int,
                    49 as ::core::ffi::c_int + 1 as ::core::ffi::c_int,
                    1 as ::core::ffi::c_int,
                    1 as ::core::ffi::c_int,
                );
                if (*h).mb.cache.non_zero_count[x264_scan8
                    [(49 as ::core::ffi::c_int + 1 as ::core::ffi::c_int) as usize]
                    as usize]
                    != 0
                {
                    x264_cabac_size_decision(
                        cb,
                        ctxidxinc_2 as ::core::ffi::c_long,
                        1 as ::core::ffi::c_long,
                    );
                    cabac_block_residual(
                        h,
                        cb,
                        DCT_CHROMA_DC as ::core::ffi::c_int,
                        (*(*h)
                            .dct
                            .chroma_dc
                            .as_mut_ptr()
                            .offset(1 as ::core::ffi::c_int as isize))
                        .as_mut_ptr(),
                    );
                } else {
                    x264_cabac_size_decision(
                        cb,
                        ctxidxinc_2 as ::core::ffi::c_long,
                        0 as ::core::ffi::c_long,
                    );
                }
            }
            if (*h).mb.i_cbp_chroma == 2 as ::core::ffi::c_int {
                let mut step: ::core::ffi::c_int =
                    (8 as ::core::ffi::c_int) << (*h).mb.chroma_v_shift;
                let mut i: ::core::ffi::c_int = 16 as ::core::ffi::c_int;
                while i < 3 as ::core::ffi::c_int * 16 as ::core::ffi::c_int {
                    let mut j: ::core::ffi::c_int = i;
                    while j < i + 4 as ::core::ffi::c_int {
                        let mut ctxidxinc_3: ::core::ffi::c_int = cabac_cbf_ctxidxinc(
                            h,
                            DCT_CHROMA_AC as ::core::ffi::c_int,
                            j,
                            1 as ::core::ffi::c_int,
                            0 as ::core::ffi::c_int,
                        );
                        if (*h).mb.cache.non_zero_count[x264_scan8[j as usize] as usize] != 0 {
                            x264_cabac_size_decision(
                                cb,
                                ctxidxinc_3 as ::core::ffi::c_long,
                                1 as ::core::ffi::c_long,
                            );
                            cabac_block_residual(
                                h,
                                cb,
                                DCT_CHROMA_AC as ::core::ffi::c_int,
                                (*(*h).dct.luma4x4.as_mut_ptr().offset(j as isize))
                                    .as_mut_ptr()
                                    .offset(1 as ::core::ffi::c_int as isize),
                            );
                        } else {
                            x264_cabac_size_decision(
                                cb,
                                ctxidxinc_3 as ::core::ffi::c_long,
                                0 as ::core::ffi::c_long,
                            );
                        }
                        j += 1;
                    }
                    i += step;
                }
            }
        }
    }
    use super::assert_h::__assert_fail;
    use super::base_h::{
        x264_cabac_mvd_sum, x264_scan8, x264_union32_t, CHROMA_422, CHROMA_444, LUMA_DC,
        SLICE_TYPE_B, SLICE_TYPE_I, SLICE_TYPE_P,
    };
    use super::bitstream_h::bs_size_ue_big;
    use super::cabac_h::{x264_cabac_size_decision, x264_cabac_size_decision_noup, x264_cabac_t};
    use super::common_h::{dctcoef, x264_t, QP_MAX_SPEC};
    use super::macroblock_h::{
        block_idx_x, block_idx_y, ctx_cat_plane, pack8to16, x264_10_mb_predict_mv,
        x264_mb_partition_listX_table, x264_mb_predict_intra4x4_mode,
        x264_mb_transform_8x8_allowed, x264_mb_type_list_table, B_8x8, DCT_LUMA_4x4, DCT_LUMA_8x8,
        D_16x16, D_16x8, D_8x16, D_BI_8x8, D_DIRECT_8x8, D_L0_4x8, D_L0_8x4, D_L0_8x8, D_L1_8x8,
        I_16x16, I_4x4, I_8x8, P_8x8, B_BI_BI, B_DIRECT, B_L0_L0, B_SKIP, DCT_CHROMA_AC,
        DCT_CHROMA_DC, DCT_LUMA_AC, DCT_LUMA_DC, I_PCM, MB_LEFT, MB_TOP, P_L0,
    };
    use super::osdep_h::x264_ctz_4bit;
    use super::pixel_h::{x264_pixel_size, PIXEL_4x4, PIXEL_8x4, PIXEL_8x8};
    use super::predict_h::{
        x264_mb_chroma_pred_mode_fix, x264_mb_pred_mode16x16_fix, x264_mb_pred_mode4x4_fix,
    };
    use super::rdo_c::{
        cabac_size_5ones, cabac_transition_5ones, x264_10_cabac_size_unary,
        x264_10_cabac_transition_unary,
    };
    use super::rectangle_h::x264_macroblock_cache_mvd;
    use super::stdint_intn_h::{int16_t, int8_t};
    use super::stdint_uintn_h::{uint16_t, uint32_t, uint8_t};
    use super::stdlib_h::abs;
    use super::tables_h::{
        x264_coeff_abs_level_m1_offset, x264_coeff_flag_offset_chroma_422_dc, x264_count_cat_m1,
        x264_last_coeff_flag_offset, x264_last_coeff_flag_offset_8x8,
        x264_significant_coeff_flag_offset, x264_significant_coeff_flag_offset_8x8,
    };
}
#[c2rust::header_src = "/home/nwplayer123/Hacks/hex264/x264/encoder/cavlc.c:28"]
pub mod cavlc_c {
    #[c2rust::src_loc = "36:22"]
    pub static mut cbp_to_golomb: [[[uint8_t; 48]; 2]; 2] = [
        [
            [
                0 as ::core::ffi::c_int as uint8_t,
                1 as ::core::ffi::c_int as uint8_t,
                2 as ::core::ffi::c_int as uint8_t,
                5 as ::core::ffi::c_int as uint8_t,
                3 as ::core::ffi::c_int as uint8_t,
                6 as ::core::ffi::c_int as uint8_t,
                14 as ::core::ffi::c_int as uint8_t,
                10 as ::core::ffi::c_int as uint8_t,
                4 as ::core::ffi::c_int as uint8_t,
                15 as ::core::ffi::c_int as uint8_t,
                7 as ::core::ffi::c_int as uint8_t,
                11 as ::core::ffi::c_int as uint8_t,
                8 as ::core::ffi::c_int as uint8_t,
                12 as ::core::ffi::c_int as uint8_t,
                13 as ::core::ffi::c_int as uint8_t,
                9 as ::core::ffi::c_int as uint8_t,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
            ],
            [
                1 as ::core::ffi::c_int as uint8_t,
                10 as ::core::ffi::c_int as uint8_t,
                11 as ::core::ffi::c_int as uint8_t,
                6 as ::core::ffi::c_int as uint8_t,
                12 as ::core::ffi::c_int as uint8_t,
                7 as ::core::ffi::c_int as uint8_t,
                14 as ::core::ffi::c_int as uint8_t,
                2 as ::core::ffi::c_int as uint8_t,
                13 as ::core::ffi::c_int as uint8_t,
                15 as ::core::ffi::c_int as uint8_t,
                8 as ::core::ffi::c_int as uint8_t,
                3 as ::core::ffi::c_int as uint8_t,
                9 as ::core::ffi::c_int as uint8_t,
                4 as ::core::ffi::c_int as uint8_t,
                5 as ::core::ffi::c_int as uint8_t,
                0 as ::core::ffi::c_int as uint8_t,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
            ],
        ],
        [
            [
                0 as ::core::ffi::c_int as uint8_t,
                2 as ::core::ffi::c_int as uint8_t,
                3 as ::core::ffi::c_int as uint8_t,
                7 as ::core::ffi::c_int as uint8_t,
                4 as ::core::ffi::c_int as uint8_t,
                8 as ::core::ffi::c_int as uint8_t,
                17 as ::core::ffi::c_int as uint8_t,
                13 as ::core::ffi::c_int as uint8_t,
                5 as ::core::ffi::c_int as uint8_t,
                18 as ::core::ffi::c_int as uint8_t,
                9 as ::core::ffi::c_int as uint8_t,
                14 as ::core::ffi::c_int as uint8_t,
                10 as ::core::ffi::c_int as uint8_t,
                15 as ::core::ffi::c_int as uint8_t,
                16 as ::core::ffi::c_int as uint8_t,
                11 as ::core::ffi::c_int as uint8_t,
                1 as ::core::ffi::c_int as uint8_t,
                32 as ::core::ffi::c_int as uint8_t,
                33 as ::core::ffi::c_int as uint8_t,
                36 as ::core::ffi::c_int as uint8_t,
                34 as ::core::ffi::c_int as uint8_t,
                37 as ::core::ffi::c_int as uint8_t,
                44 as ::core::ffi::c_int as uint8_t,
                40 as ::core::ffi::c_int as uint8_t,
                35 as ::core::ffi::c_int as uint8_t,
                45 as ::core::ffi::c_int as uint8_t,
                38 as ::core::ffi::c_int as uint8_t,
                41 as ::core::ffi::c_int as uint8_t,
                39 as ::core::ffi::c_int as uint8_t,
                42 as ::core::ffi::c_int as uint8_t,
                43 as ::core::ffi::c_int as uint8_t,
                19 as ::core::ffi::c_int as uint8_t,
                6 as ::core::ffi::c_int as uint8_t,
                24 as ::core::ffi::c_int as uint8_t,
                25 as ::core::ffi::c_int as uint8_t,
                20 as ::core::ffi::c_int as uint8_t,
                26 as ::core::ffi::c_int as uint8_t,
                21 as ::core::ffi::c_int as uint8_t,
                46 as ::core::ffi::c_int as uint8_t,
                28 as ::core::ffi::c_int as uint8_t,
                27 as ::core::ffi::c_int as uint8_t,
                47 as ::core::ffi::c_int as uint8_t,
                22 as ::core::ffi::c_int as uint8_t,
                29 as ::core::ffi::c_int as uint8_t,
                23 as ::core::ffi::c_int as uint8_t,
                30 as ::core::ffi::c_int as uint8_t,
                31 as ::core::ffi::c_int as uint8_t,
                12 as ::core::ffi::c_int as uint8_t,
            ],
            [
                3 as ::core::ffi::c_int as uint8_t,
                29 as ::core::ffi::c_int as uint8_t,
                30 as ::core::ffi::c_int as uint8_t,
                17 as ::core::ffi::c_int as uint8_t,
                31 as ::core::ffi::c_int as uint8_t,
                18 as ::core::ffi::c_int as uint8_t,
                37 as ::core::ffi::c_int as uint8_t,
                8 as ::core::ffi::c_int as uint8_t,
                32 as ::core::ffi::c_int as uint8_t,
                38 as ::core::ffi::c_int as uint8_t,
                19 as ::core::ffi::c_int as uint8_t,
                9 as ::core::ffi::c_int as uint8_t,
                20 as ::core::ffi::c_int as uint8_t,
                10 as ::core::ffi::c_int as uint8_t,
                11 as ::core::ffi::c_int as uint8_t,
                2 as ::core::ffi::c_int as uint8_t,
                16 as ::core::ffi::c_int as uint8_t,
                33 as ::core::ffi::c_int as uint8_t,
                34 as ::core::ffi::c_int as uint8_t,
                21 as ::core::ffi::c_int as uint8_t,
                35 as ::core::ffi::c_int as uint8_t,
                22 as ::core::ffi::c_int as uint8_t,
                39 as ::core::ffi::c_int as uint8_t,
                4 as ::core::ffi::c_int as uint8_t,
                36 as ::core::ffi::c_int as uint8_t,
                40 as ::core::ffi::c_int as uint8_t,
                23 as ::core::ffi::c_int as uint8_t,
                5 as ::core::ffi::c_int as uint8_t,
                24 as ::core::ffi::c_int as uint8_t,
                6 as ::core::ffi::c_int as uint8_t,
                7 as ::core::ffi::c_int as uint8_t,
                1 as ::core::ffi::c_int as uint8_t,
                41 as ::core::ffi::c_int as uint8_t,
                42 as ::core::ffi::c_int as uint8_t,
                43 as ::core::ffi::c_int as uint8_t,
                25 as ::core::ffi::c_int as uint8_t,
                44 as ::core::ffi::c_int as uint8_t,
                26 as ::core::ffi::c_int as uint8_t,
                46 as ::core::ffi::c_int as uint8_t,
                12 as ::core::ffi::c_int as uint8_t,
                45 as ::core::ffi::c_int as uint8_t,
                47 as ::core::ffi::c_int as uint8_t,
                27 as ::core::ffi::c_int as uint8_t,
                13 as ::core::ffi::c_int as uint8_t,
                28 as ::core::ffi::c_int as uint8_t,
                14 as ::core::ffi::c_int as uint8_t,
                15 as ::core::ffi::c_int as uint8_t,
                0 as ::core::ffi::c_int as uint8_t,
            ],
        ],
    ];
    #[c2rust::src_loc = "48:22"]
    pub static mut mb_type_b_to_golomb: [[uint8_t; 9]; 3] = [
        [
            4 as ::core::ffi::c_int as uint8_t,
            8 as ::core::ffi::c_int as uint8_t,
            12 as ::core::ffi::c_int as uint8_t,
            10 as ::core::ffi::c_int as uint8_t,
            6 as ::core::ffi::c_int as uint8_t,
            14 as ::core::ffi::c_int as uint8_t,
            16 as ::core::ffi::c_int as uint8_t,
            18 as ::core::ffi::c_int as uint8_t,
            20 as ::core::ffi::c_int as uint8_t,
        ],
        [
            5 as ::core::ffi::c_int as uint8_t,
            9 as ::core::ffi::c_int as uint8_t,
            13 as ::core::ffi::c_int as uint8_t,
            11 as ::core::ffi::c_int as uint8_t,
            7 as ::core::ffi::c_int as uint8_t,
            15 as ::core::ffi::c_int as uint8_t,
            17 as ::core::ffi::c_int as uint8_t,
            19 as ::core::ffi::c_int as uint8_t,
            21 as ::core::ffi::c_int as uint8_t,
        ],
        [
            1 as ::core::ffi::c_int as uint8_t,
            -(1 as ::core::ffi::c_int) as uint8_t,
            -(1 as ::core::ffi::c_int) as uint8_t,
            -(1 as ::core::ffi::c_int) as uint8_t,
            2 as ::core::ffi::c_int as uint8_t,
            -(1 as ::core::ffi::c_int) as uint8_t,
            -(1 as ::core::ffi::c_int) as uint8_t,
            -(1 as ::core::ffi::c_int) as uint8_t,
            3 as ::core::ffi::c_int as uint8_t,
        ],
    ];
    #[c2rust::src_loc = "55:22"]
    pub static mut subpartition_p_to_golomb: [uint8_t; 4] = [
        3 as ::core::ffi::c_int as uint8_t,
        1 as ::core::ffi::c_int as uint8_t,
        2 as ::core::ffi::c_int as uint8_t,
        0 as ::core::ffi::c_int as uint8_t,
    ];
    #[c2rust::src_loc = "60:22"]
    pub static mut subpartition_b_to_golomb: [uint8_t; 13] = [
        10 as ::core::ffi::c_int as uint8_t,
        4 as ::core::ffi::c_int as uint8_t,
        5 as ::core::ffi::c_int as uint8_t,
        1 as ::core::ffi::c_int as uint8_t,
        11 as ::core::ffi::c_int as uint8_t,
        6 as ::core::ffi::c_int as uint8_t,
        7 as ::core::ffi::c_int as uint8_t,
        2 as ::core::ffi::c_int as uint8_t,
        12 as ::core::ffi::c_int as uint8_t,
        8 as ::core::ffi::c_int as uint8_t,
        9 as ::core::ffi::c_int as uint8_t,
        3 as ::core::ffi::c_int as uint8_t,
        0 as ::core::ffi::c_int as uint8_t,
    ];
    #[inline]
    #[c2rust::src_loc = "70:1"]
    pub unsafe extern "C" fn cavlc_block_residual_escape(
        mut h: *mut x264_t,
        mut i_suffix_length: ::core::ffi::c_int,
        mut level: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int {
        let mut s: *mut bs_t = &mut (*h).out.bs;
        pub static mut next_suffix: [uint16_t; 7] = [
            0 as ::core::ffi::c_int as uint16_t,
            3 as ::core::ffi::c_int as uint16_t,
            6 as ::core::ffi::c_int as uint16_t,
            12 as ::core::ffi::c_int as uint16_t,
            24 as ::core::ffi::c_int as uint16_t,
            48 as ::core::ffi::c_int as uint16_t,
            0xffff as ::core::ffi::c_int as uint16_t,
        ];
        let mut i_level_prefix: ::core::ffi::c_int = 15 as ::core::ffi::c_int;
        let mut mask: ::core::ffi::c_int = level >> 31 as ::core::ffi::c_int;
        let mut abs_level: ::core::ffi::c_int = (level ^ mask) - mask;
        let mut i_level_code: ::core::ffi::c_int =
            abs_level * 2 as ::core::ffi::c_int - mask - 2 as ::core::ffi::c_int;
        if i_level_code >> i_suffix_length < 15 as ::core::ffi::c_int {
            (*s).i_bits_encoded +=
                (i_level_code >> i_suffix_length) + 1 as ::core::ffi::c_int + i_suffix_length;
        } else {
            i_level_code -= (15 as ::core::ffi::c_int) << i_suffix_length;
            if i_suffix_length == 0 as ::core::ffi::c_int {
                i_level_code -= 15 as ::core::ffi::c_int;
            }
            if i_level_code >= (1 as ::core::ffi::c_int) << 12 as ::core::ffi::c_int {
                if (*(*h).sps.as_mut_ptr()).i_profile_idc >= PROFILE_HIGH as ::core::ffi::c_int {
                    while i_level_code
                        >= (1 as ::core::ffi::c_int) << i_level_prefix - 3 as ::core::ffi::c_int
                    {
                        i_level_code -=
                            (1 as ::core::ffi::c_int) << i_level_prefix - 3 as ::core::ffi::c_int;
                        i_level_prefix += 1;
                    }
                } else {
                    (*s).i_bits_encoded += 2000 as ::core::ffi::c_int;
                }
            }
            (*s).i_bits_encoded += i_level_prefix + 1 as ::core::ffi::c_int;
            (*s).i_bits_encoded += i_level_prefix - 3 as ::core::ffi::c_int;
        }
        if i_suffix_length == 0 as ::core::ffi::c_int {
            i_suffix_length += 1;
        }
        if abs_level > next_suffix[i_suffix_length as usize] as ::core::ffi::c_int {
            i_suffix_length += 1;
        }
        return i_suffix_length;
    }
    #[c2rust::src_loc = "121:1"]
    pub unsafe extern "C" fn cavlc_block_residual_internal(
        mut h: *mut x264_t,
        mut ctx_block_cat: ::core::ffi::c_int,
        mut l: *mut dctcoef,
        mut nC: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int {
        let mut s: *mut bs_t = &mut (*h).out.bs;
        pub static mut ctz_index: [uint8_t; 8] = [
            3 as ::core::ffi::c_int as uint8_t,
            0 as ::core::ffi::c_int as uint8_t,
            1 as ::core::ffi::c_int as uint8_t,
            0 as ::core::ffi::c_int as uint8_t,
            2 as ::core::ffi::c_int as uint8_t,
            0 as ::core::ffi::c_int as uint8_t,
            1 as ::core::ffi::c_int as uint8_t,
            0 as ::core::ffi::c_int as uint8_t,
        ];
        pub static mut count_cat: [uint8_t; 14] = [
            16 as ::core::ffi::c_int as uint8_t,
            15 as ::core::ffi::c_int as uint8_t,
            16 as ::core::ffi::c_int as uint8_t,
            0 as ::core::ffi::c_int as uint8_t,
            15 as ::core::ffi::c_int as uint8_t,
            64 as ::core::ffi::c_int as uint8_t,
            16 as ::core::ffi::c_int as uint8_t,
            15 as ::core::ffi::c_int as uint8_t,
            16 as ::core::ffi::c_int as uint8_t,
            64 as ::core::ffi::c_int as uint8_t,
            16 as ::core::ffi::c_int as uint8_t,
            15 as ::core::ffi::c_int as uint8_t,
            16 as ::core::ffi::c_int as uint8_t,
            64 as ::core::ffi::c_int as uint8_t,
        ];
        let mut runlevel: x264_run_level_t = x264_run_level_t {
            last: 0,
            mask: 0,
            level: [0; 18],
        };
        let mut i_total: ::core::ffi::c_int = 0;
        let mut i_trailing: ::core::ffi::c_int = 0;
        let mut i_total_zero: ::core::ffi::c_int = 0;
        let mut i_suffix_length: ::core::ffi::c_int = 0;
        let mut i_sign: ::core::ffi::c_uint = 0;
        i_total = (*h).quantf.coeff_level_run[ctx_block_cat as usize]
            .expect("non-null function pointer")(l, &mut runlevel);
        &mut *x264_10_run_before
            .as_mut_ptr()
            .offset(runlevel.mask as isize) as *mut uint32_t;
        i_total_zero = (runlevel.last + 1 as int32_t - i_total as int32_t) as ::core::ffi::c_int;
        runlevel.level[(i_total + 0 as ::core::ffi::c_int) as usize] =
            2 as ::core::ffi::c_int as dctcoef;
        runlevel.level[(i_total + 1 as ::core::ffi::c_int) as usize] =
            2 as ::core::ffi::c_int as dctcoef;
        i_trailing = ((runlevel.level[0 as ::core::ffi::c_int as usize] + 1 as dctcoef
            | 1 as dctcoef - runlevel.level[0 as ::core::ffi::c_int as usize])
            >> 31 as ::core::ffi::c_int
            & 1 as dctcoef
            | (runlevel.level[1 as ::core::ffi::c_int as usize] + 1 as dctcoef
                | 1 as dctcoef - runlevel.level[1 as ::core::ffi::c_int as usize])
                >> 31 as ::core::ffi::c_int
                & 2 as dctcoef
            | (runlevel.level[2 as ::core::ffi::c_int as usize] + 1 as dctcoef
                | 1 as dctcoef - runlevel.level[2 as ::core::ffi::c_int as usize])
                >> 31 as ::core::ffi::c_int
                & 4 as dctcoef) as ::core::ffi::c_int;
        i_trailing = ctz_index[i_trailing as usize] as ::core::ffi::c_int;
        i_sign = (runlevel.level[2 as ::core::ffi::c_int as usize] >> 31 as ::core::ffi::c_int
            & 1 as dctcoef
            | runlevel.level[1 as ::core::ffi::c_int as usize] >> 31 as ::core::ffi::c_int
                & 2 as dctcoef
            | runlevel.level[0 as ::core::ffi::c_int as usize] >> 31 as ::core::ffi::c_int
                & 4 as dctcoef) as ::core::ffi::c_uint;
        i_sign >>= 3 as ::core::ffi::c_int - i_trailing;
        (*s).i_bits_encoded += x264_coeff_token[nC as usize]
            [(i_total - 1 as ::core::ffi::c_int) as usize][i_trailing as usize]
            .i_size as ::core::ffi::c_int;
        i_suffix_length = (i_total > 10 as ::core::ffi::c_int
            && i_trailing < 3 as ::core::ffi::c_int)
            as ::core::ffi::c_int;
        (*s).i_bits_encoded += i_trailing;
        if i_trailing < i_total {
            let mut val: ::core::ffi::c_int = runlevel.level[i_trailing as usize];
            let mut val_original: ::core::ffi::c_int =
                runlevel.level[i_trailing as usize] + LEVEL_TABLE_SIZE / 2 as ::core::ffi::c_int;
            val -= (val >> 31 as ::core::ffi::c_int | 1 as ::core::ffi::c_int)
                & -((i_trailing < 3 as ::core::ffi::c_int) as ::core::ffi::c_int);
            val += LEVEL_TABLE_SIZE / 2 as ::core::ffi::c_int;
            if (val_original as ::core::ffi::c_uint) < LEVEL_TABLE_SIZE as ::core::ffi::c_uint {
                (*s).i_bits_encoded += x264_10_level_token[i_suffix_length as usize][val as usize]
                    .i_size as ::core::ffi::c_int;
                i_suffix_length = x264_10_level_token[i_suffix_length as usize]
                    [val_original as usize]
                    .i_next as ::core::ffi::c_int;
            } else {
                i_suffix_length = cavlc_block_residual_escape(
                    h,
                    i_suffix_length,
                    val - LEVEL_TABLE_SIZE / 2 as ::core::ffi::c_int,
                );
            }
            let mut i: ::core::ffi::c_int = i_trailing + 1 as ::core::ffi::c_int;
            while i < i_total {
                val = (runlevel.level[i as usize] + LEVEL_TABLE_SIZE as dctcoef / 2 as dctcoef)
                    as ::core::ffi::c_int;
                if (val as ::core::ffi::c_uint) < LEVEL_TABLE_SIZE as ::core::ffi::c_uint {
                    (*s).i_bits_encoded += x264_10_level_token[i_suffix_length as usize]
                        [val as usize]
                        .i_size as ::core::ffi::c_int;
                    i_suffix_length = x264_10_level_token[i_suffix_length as usize][val as usize]
                        .i_next as ::core::ffi::c_int;
                } else {
                    i_suffix_length = cavlc_block_residual_escape(
                        h,
                        i_suffix_length,
                        val - LEVEL_TABLE_SIZE / 2 as ::core::ffi::c_int,
                    );
                }
                i += 1;
            }
        }
        if ctx_block_cat == DCT_CHROMA_DC as ::core::ffi::c_int {
            if i_total < 8 as ::core::ffi::c_int >> (*h).mb.chroma_v_shift {
                let mut total_zeros: vlc_t = if (*(*h).sps.as_mut_ptr()).i_chroma_format_idc
                    == CHROMA_420 as ::core::ffi::c_int
                {
                    x264_total_zeros_2x2_dc[(i_total - 1 as ::core::ffi::c_int) as usize]
                        [i_total_zero as usize]
                } else {
                    x264_total_zeros_2x4_dc[(i_total - 1 as ::core::ffi::c_int) as usize]
                        [i_total_zero as usize]
                };
                (*s).i_bits_encoded += total_zeros.i_size as ::core::ffi::c_int;
            }
        } else if (i_total as uint8_t as ::core::ffi::c_int)
            < count_cat[ctx_block_cat as usize] as ::core::ffi::c_int
        {
            (*s).i_bits_encoded += x264_total_zeros[(i_total - 1 as ::core::ffi::c_int) as usize]
                [i_total_zero as usize]
                .i_size as ::core::ffi::c_int;
        }
        let mut zero_run_code: ::core::ffi::c_int =
            x264_10_run_before[runlevel.mask as usize] as ::core::ffi::c_int;
        (*s).i_bits_encoded += zero_run_code & 0x1f as ::core::ffi::c_int;
        return i_total;
    }
    #[c2rust::src_loc = "198:22"]
    pub static mut ct_index: [uint8_t; 17] = [
        0 as ::core::ffi::c_int as uint8_t,
        0 as ::core::ffi::c_int as uint8_t,
        1 as ::core::ffi::c_int as uint8_t,
        1 as ::core::ffi::c_int as uint8_t,
        2 as ::core::ffi::c_int as uint8_t,
        2 as ::core::ffi::c_int as uint8_t,
        2 as ::core::ffi::c_int as uint8_t,
        2 as ::core::ffi::c_int as uint8_t,
        3 as ::core::ffi::c_int as uint8_t,
        3 as ::core::ffi::c_int as uint8_t,
        3 as ::core::ffi::c_int as uint8_t,
        3 as ::core::ffi::c_int as uint8_t,
        3 as ::core::ffi::c_int as uint8_t,
        3 as ::core::ffi::c_int as uint8_t,
        3 as ::core::ffi::c_int as uint8_t,
        3 as ::core::ffi::c_int as uint8_t,
        3 as ::core::ffi::c_int as uint8_t,
    ];
    #[c2rust::src_loc = "211:1"]
    pub unsafe extern "C" fn cavlc_qp_delta(mut h: *mut x264_t) {
        let mut s: *mut bs_t = &mut (*h).out.bs;
        let mut i_dqp: ::core::ffi::c_int = (*h).mb.i_qp - (*h).mb.i_last_qp;
        if (*h).mb.i_type == I_16x16 as ::core::ffi::c_int
            && (*h).mb.i_cbp_luma | (*h).mb.i_cbp_chroma == 0
            && (*h).mb.cache.non_zero_count[x264_scan8[LUMA_DC as usize] as usize] == 0
            && (*h).mb.cache.non_zero_count
                [x264_scan8[(CHROMA_DC + 0 as ::core::ffi::c_int) as usize] as usize]
                == 0
            && (*h).mb.cache.non_zero_count
                [x264_scan8[(CHROMA_DC + 1 as ::core::ffi::c_int) as usize] as usize]
                == 0
            && (*h).mb.i_qp > (*h).mb.i_last_qp
        {
            i_dqp = 0 as ::core::ffi::c_int;
        }
        if i_dqp != 0 {
            if i_dqp < -(QP_MAX_SPEC + 1 as ::core::ffi::c_int) / 2 as ::core::ffi::c_int {
                i_dqp += QP_MAX_SPEC + 1 as ::core::ffi::c_int;
            } else if i_dqp > QP_MAX_SPEC / 2 as ::core::ffi::c_int {
                i_dqp -= QP_MAX_SPEC + 1 as ::core::ffi::c_int;
            }
        }
        (*s).i_bits_encoded += bs_size_se(i_dqp);
    }
    #[c2rust::src_loc = "241:1"]
    pub unsafe extern "C" fn cavlc_mvd(
        mut h: *mut x264_t,
        mut i_list: ::core::ffi::c_int,
        mut idx: ::core::ffi::c_int,
        mut width: ::core::ffi::c_int,
    ) {
        let mut s: *mut bs_t = &mut (*h).out.bs;
        let mut mvp: [int16_t; 2] = [0; 2];
        x264_10_mb_predict_mv(h, i_list, idx, width, mvp.as_mut_ptr());
        (*s).i_bits_encoded += bs_size_se(
            (*h).mb.cache.mv[i_list as usize][x264_scan8[idx as usize] as usize]
                [0 as ::core::ffi::c_int as usize] as ::core::ffi::c_int
                - mvp[0 as ::core::ffi::c_int as usize] as ::core::ffi::c_int,
        );
        (*s).i_bits_encoded += bs_size_se(
            (*h).mb.cache.mv[i_list as usize][x264_scan8[idx as usize] as usize]
                [1 as ::core::ffi::c_int as usize] as ::core::ffi::c_int
                - mvp[1 as ::core::ffi::c_int as usize] as ::core::ffi::c_int,
        );
    }
    #[inline]
    #[c2rust::src_loc = "250:1"]
    pub unsafe extern "C" fn cavlc_8x8_mvd(mut h: *mut x264_t, mut i: ::core::ffi::c_int) {
        match (*h).mb.i_sub_partition[i as usize] as ::core::ffi::c_int {
            3 => {
                cavlc_mvd(
                    h,
                    0 as ::core::ffi::c_int,
                    4 as ::core::ffi::c_int * i,
                    2 as ::core::ffi::c_int,
                );
            }
            1 => {
                cavlc_mvd(
                    h,
                    0 as ::core::ffi::c_int,
                    4 as ::core::ffi::c_int * i + 0 as ::core::ffi::c_int,
                    2 as ::core::ffi::c_int,
                );
                cavlc_mvd(
                    h,
                    0 as ::core::ffi::c_int,
                    4 as ::core::ffi::c_int * i + 2 as ::core::ffi::c_int,
                    2 as ::core::ffi::c_int,
                );
            }
            2 => {
                cavlc_mvd(
                    h,
                    0 as ::core::ffi::c_int,
                    4 as ::core::ffi::c_int * i + 0 as ::core::ffi::c_int,
                    1 as ::core::ffi::c_int,
                );
                cavlc_mvd(
                    h,
                    0 as ::core::ffi::c_int,
                    4 as ::core::ffi::c_int * i + 1 as ::core::ffi::c_int,
                    1 as ::core::ffi::c_int,
                );
            }
            0 => {
                cavlc_mvd(
                    h,
                    0 as ::core::ffi::c_int,
                    4 as ::core::ffi::c_int * i + 0 as ::core::ffi::c_int,
                    1 as ::core::ffi::c_int,
                );
                cavlc_mvd(
                    h,
                    0 as ::core::ffi::c_int,
                    4 as ::core::ffi::c_int * i + 1 as ::core::ffi::c_int,
                    1 as ::core::ffi::c_int,
                );
                cavlc_mvd(
                    h,
                    0 as ::core::ffi::c_int,
                    4 as ::core::ffi::c_int * i + 2 as ::core::ffi::c_int,
                    1 as ::core::ffi::c_int,
                );
                cavlc_mvd(
                    h,
                    0 as ::core::ffi::c_int,
                    4 as ::core::ffi::c_int * i + 3 as ::core::ffi::c_int,
                    1 as ::core::ffi::c_int,
                );
            }
            _ => {}
        };
    }
    #[inline(always)]
    #[c2rust::src_loc = "274:1"]
    pub unsafe extern "C" fn cavlc_macroblock_luma_residual(
        mut h: *mut x264_t,
        mut plane_count: ::core::ffi::c_int,
    ) {
        if (*h).mb.b_transform_8x8 != 0 {
            let mut p: ::core::ffi::c_int = 0 as ::core::ffi::c_int;
            while p < plane_count {
                let mut i8: ::core::ffi::c_int = 0 as ::core::ffi::c_int;
                while i8 < 4 as ::core::ffi::c_int {
                    if (*h).mb.cache.non_zero_count[x264_scan8
                        [(p * 16 as ::core::ffi::c_int + i8 * 4 as ::core::ffi::c_int) as usize]
                        as usize]
                        != 0
                    {
                        (*h).zigzagf
                            .interleave_8x8_cavlc
                            .expect("non-null function pointer")(
                            (*(*h).dct.luma4x4.as_mut_ptr().offset(
                                (p * 16 as ::core::ffi::c_int + i8 * 4 as ::core::ffi::c_int)
                                    as isize,
                            ))
                            .as_mut_ptr(),
                            (*(*h)
                                .dct
                                .luma8x8
                                .as_mut_ptr()
                                .offset((p * 4 as ::core::ffi::c_int + i8) as isize))
                            .as_mut_ptr(),
                            &mut *(*h).mb.cache.non_zero_count.as_mut_ptr().offset(
                                *x264_scan8.as_ptr().offset(
                                    (p * 16 as ::core::ffi::c_int + i8 * 4 as ::core::ffi::c_int)
                                        as isize,
                                ) as isize,
                            ),
                        );
                    }
                    i8 += 1;
                }
                p += 1;
            }
        }
        let mut p_0: ::core::ffi::c_int = 0 as ::core::ffi::c_int;
        while p_0 < plane_count {
            let mut i8_0: ::core::ffi::c_int = 0 as ::core::ffi::c_int;
            let mut msk: ::core::ffi::c_int = (*h).mb.i_cbp_luma;
            let mut skip: ::core::ffi::c_int = 0;
            while msk != 0 && {
                skip = x264_ctz_4bit(msk as uint32_t);
                i8_0 += skip;
                msk >>= skip + 1 as ::core::ffi::c_int;
                1 as ::core::ffi::c_int != 0
            } {
                let mut i4: ::core::ffi::c_int = 0 as ::core::ffi::c_int;
                while i4 < 4 as ::core::ffi::c_int {
                    let mut nC: ::core::ffi::c_int = if DCT_LUMA_4x4 as ::core::ffi::c_int
                        == DCT_CHROMA_DC as ::core::ffi::c_int
                    {
                        5 as ::core::ffi::c_int - (*h).mb.chroma_v_shift
                    } else {
                        ct_index[x264_mb_predict_non_zero_code(
                            h,
                            if DCT_LUMA_4x4 as ::core::ffi::c_int
                                == DCT_LUMA_DC as ::core::ffi::c_int
                            {
                                (i4 + i8_0 * 4 as ::core::ffi::c_int
                                    + p_0 * 16 as ::core::ffi::c_int
                                    - LUMA_DC)
                                    * 16 as ::core::ffi::c_int
                            } else {
                                i4 + i8_0 * 4 as ::core::ffi::c_int + p_0 * 16 as ::core::ffi::c_int
                            },
                        ) as usize] as ::core::ffi::c_int
                    };
                    let mut nnz: *mut uint8_t =
                        &mut *(*h).mb.cache.non_zero_count.as_mut_ptr().offset(
                            *x264_scan8.as_ptr().offset(
                                (i4 + i8_0 * 4 as ::core::ffi::c_int
                                    + p_0 * 16 as ::core::ffi::c_int)
                                    as isize,
                            ) as isize,
                        ) as *mut uint8_t;
                    if *nnz == 0 {
                        (*h).out.bs.i_bits_encoded +=
                            x264_coeff0_token[nC as usize].i_size as ::core::ffi::c_int;
                    } else {
                        *nnz = cavlc_block_residual_internal(
                            h,
                            DCT_LUMA_4x4 as ::core::ffi::c_int,
                            (*(*h).dct.luma4x4.as_mut_ptr().offset(
                                (i4 + i8_0 * 4 as ::core::ffi::c_int
                                    + p_0 * 16 as ::core::ffi::c_int)
                                    as isize,
                            ))
                            .as_mut_ptr(),
                            nC,
                        ) as uint8_t;
                    }
                    i4 += 1;
                }
                i8_0 += 1;
            }
            p_0 += 1;
        }
    }
    #[inline(always)]
    #[c2rust::src_loc = "293:1"]
    pub unsafe extern "C" fn cavlc_partition_luma_residual(
        mut h: *mut x264_t,
        mut i8: ::core::ffi::c_int,
        mut p: ::core::ffi::c_int,
    ) {
        if (*h).mb.b_transform_8x8 != 0
            && (*h).mb.cache.non_zero_count[x264_scan8
                [(i8 * 4 as ::core::ffi::c_int + p * 16 as ::core::ffi::c_int) as usize]
                as usize] as ::core::ffi::c_int
                != 0
        {
            (*h).zigzagf
                .interleave_8x8_cavlc
                .expect("non-null function pointer")(
                (*(*h).dct.luma4x4.as_mut_ptr().offset(
                    (i8 * 4 as ::core::ffi::c_int + p * 16 as ::core::ffi::c_int) as isize,
                ))
                .as_mut_ptr(),
                (*(*h)
                    .dct
                    .luma8x8
                    .as_mut_ptr()
                    .offset((i8 + p * 4 as ::core::ffi::c_int) as isize))
                .as_mut_ptr(),
                &mut *(*h).mb.cache.non_zero_count.as_mut_ptr().offset(
                    *x264_scan8.as_ptr().offset(
                        (i8 * 4 as ::core::ffi::c_int + p * 16 as ::core::ffi::c_int) as isize,
                    ) as isize,
                ),
            );
        }
        if (*h).mb.i_cbp_luma & (1 as ::core::ffi::c_int) << i8 != 0 {
            let mut i4: ::core::ffi::c_int = 0 as ::core::ffi::c_int;
            while i4 < 4 as ::core::ffi::c_int {
                let mut nC: ::core::ffi::c_int = if DCT_LUMA_4x4 as ::core::ffi::c_int
                    == DCT_CHROMA_DC as ::core::ffi::c_int
                {
                    5 as ::core::ffi::c_int - (*h).mb.chroma_v_shift
                } else {
                    ct_index[x264_mb_predict_non_zero_code(
                        h,
                        if DCT_LUMA_4x4 as ::core::ffi::c_int == DCT_LUMA_DC as ::core::ffi::c_int {
                            (i4 + i8 * 4 as ::core::ffi::c_int + p * 16 as ::core::ffi::c_int
                                - LUMA_DC)
                                * 16 as ::core::ffi::c_int
                        } else {
                            i4 + i8 * 4 as ::core::ffi::c_int + p * 16 as ::core::ffi::c_int
                        },
                    ) as usize] as ::core::ffi::c_int
                };
                let mut nnz: *mut uint8_t = &mut *(*h).mb.cache.non_zero_count.as_mut_ptr().offset(
                    *x264_scan8.as_ptr().offset(
                        (i4 + i8 * 4 as ::core::ffi::c_int + p * 16 as ::core::ffi::c_int) as isize,
                    ) as isize,
                ) as *mut uint8_t;
                if *nnz == 0 {
                    (*h).out.bs.i_bits_encoded +=
                        x264_coeff0_token[nC as usize].i_size as ::core::ffi::c_int;
                } else {
                    *nnz = cavlc_block_residual_internal(
                        h,
                        DCT_LUMA_4x4 as ::core::ffi::c_int,
                        (*(*h).dct.luma4x4.as_mut_ptr().offset(
                            (i4 + i8 * 4 as ::core::ffi::c_int + p * 16 as ::core::ffi::c_int)
                                as isize,
                        ))
                        .as_mut_ptr(),
                        nC,
                    ) as uint8_t;
                }
                i4 += 1;
            }
        }
    }
    #[c2rust::src_loc = "305:1"]
    pub unsafe extern "C" fn cavlc_mb_header_i(
        mut h: *mut x264_t,
        mut i_mb_type: ::core::ffi::c_int,
        mut i_mb_i_offset: ::core::ffi::c_int,
        mut chroma: ::core::ffi::c_int,
    ) {
        let mut s: *mut bs_t = &mut (*h).out.bs;
        if i_mb_type == I_16x16 as ::core::ffi::c_int {
            (*s).i_bits_encoded += bs_size_ue(
                (i_mb_i_offset
                    + 1 as ::core::ffi::c_int
                    + x264_mb_pred_mode16x16_fix[(*h).mb.i_intra16x16_pred_mode as usize]
                        as ::core::ffi::c_int
                    + (*h).mb.i_cbp_chroma * 4 as ::core::ffi::c_int
                    + (if (*h).mb.i_cbp_luma == 0 as ::core::ffi::c_int {
                        0 as ::core::ffi::c_int
                    } else {
                        12 as ::core::ffi::c_int
                    })) as ::core::ffi::c_uint,
            );
        } else {
            let mut di: ::core::ffi::c_int = if i_mb_type == I_8x8 as ::core::ffi::c_int {
                4 as ::core::ffi::c_int
            } else {
                1 as ::core::ffi::c_int
            };
            (*s).i_bits_encoded +=
                bs_size_ue((i_mb_i_offset + 0 as ::core::ffi::c_int) as ::core::ffi::c_uint);
            if (*(*h).pps.as_mut_ptr()).b_transform_8x8_mode != 0 {
                (*s).i_bits_encoded += 1 as ::core::ffi::c_int;
            }
            let mut i: ::core::ffi::c_int = 0 as ::core::ffi::c_int;
            while i < 16 as ::core::ffi::c_int {
                let mut i_pred: ::core::ffi::c_int = x264_mb_predict_intra4x4_mode(h, i);
                let mut i_mode: ::core::ffi::c_int =
                    x264_mb_pred_mode4x4_fix[((*h).mb.cache.intra4x4_pred_mode
                        [x264_scan8[i as usize] as usize]
                        as ::core::ffi::c_int
                        + 1 as ::core::ffi::c_int)
                        as usize] as ::core::ffi::c_int;
                if i_pred == i_mode {
                    (*s).i_bits_encoded += 1 as ::core::ffi::c_int;
                } else {
                    (*s).i_bits_encoded += 4 as ::core::ffi::c_int;
                }
                i += di;
            }
        }
        if chroma != 0 {
            (*s).i_bits_encoded += bs_size_ue(
                x264_mb_chroma_pred_mode_fix[(*h).mb.i_chroma_pred_mode as usize]
                    as ::core::ffi::c_uint,
            );
        }
    }
    #[inline(always)]
    #[c2rust::src_loc = "337:1"]
    pub unsafe extern "C" fn cavlc_mb_header_p(
        mut h: *mut x264_t,
        mut i_mb_type: ::core::ffi::c_int,
        mut chroma: ::core::ffi::c_int,
    ) {
        let mut s: *mut bs_t = &mut (*h).out.bs;
        if i_mb_type == P_L0 as ::core::ffi::c_int {
            if (*h).mb.i_partition == D_16x16 as ::core::ffi::c_int {
                (*s).i_bits_encoded += 1 as ::core::ffi::c_int;
                if (*h).mb.pic.i_fref[0 as ::core::ffi::c_int as usize] > 1 as ::core::ffi::c_int {
                    (*s).i_bits_encoded += bs_size_te(
                        (*h).mb.pic.i_fref[0 as ::core::ffi::c_int as usize]
                            - 1 as ::core::ffi::c_int,
                        (*h).mb.cache.ref_0[0 as ::core::ffi::c_int as usize]
                            [x264_scan8[0 as ::core::ffi::c_int as usize] as usize]
                            as ::core::ffi::c_int,
                    );
                }
                cavlc_mvd(
                    h,
                    0 as ::core::ffi::c_int,
                    0 as ::core::ffi::c_int,
                    4 as ::core::ffi::c_int,
                );
            } else if (*h).mb.i_partition == D_16x8 as ::core::ffi::c_int {
                (*s).i_bits_encoded += bs_size_ue(1 as ::core::ffi::c_uint);
                if (*h).mb.pic.i_fref[0 as ::core::ffi::c_int as usize] > 1 as ::core::ffi::c_int {
                    (*s).i_bits_encoded += bs_size_te(
                        (*h).mb.pic.i_fref[0 as ::core::ffi::c_int as usize]
                            - 1 as ::core::ffi::c_int,
                        (*h).mb.cache.ref_0[0 as ::core::ffi::c_int as usize]
                            [x264_scan8[0 as ::core::ffi::c_int as usize] as usize]
                            as ::core::ffi::c_int,
                    );
                    (*s).i_bits_encoded += bs_size_te(
                        (*h).mb.pic.i_fref[0 as ::core::ffi::c_int as usize]
                            - 1 as ::core::ffi::c_int,
                        (*h).mb.cache.ref_0[0 as ::core::ffi::c_int as usize]
                            [x264_scan8[8 as ::core::ffi::c_int as usize] as usize]
                            as ::core::ffi::c_int,
                    );
                }
                cavlc_mvd(
                    h,
                    0 as ::core::ffi::c_int,
                    0 as ::core::ffi::c_int,
                    4 as ::core::ffi::c_int,
                );
                cavlc_mvd(
                    h,
                    0 as ::core::ffi::c_int,
                    8 as ::core::ffi::c_int,
                    4 as ::core::ffi::c_int,
                );
            } else if (*h).mb.i_partition == D_8x16 as ::core::ffi::c_int {
                (*s).i_bits_encoded += bs_size_ue(2 as ::core::ffi::c_uint);
                if (*h).mb.pic.i_fref[0 as ::core::ffi::c_int as usize] > 1 as ::core::ffi::c_int {
                    (*s).i_bits_encoded += bs_size_te(
                        (*h).mb.pic.i_fref[0 as ::core::ffi::c_int as usize]
                            - 1 as ::core::ffi::c_int,
                        (*h).mb.cache.ref_0[0 as ::core::ffi::c_int as usize]
                            [x264_scan8[0 as ::core::ffi::c_int as usize] as usize]
                            as ::core::ffi::c_int,
                    );
                    (*s).i_bits_encoded += bs_size_te(
                        (*h).mb.pic.i_fref[0 as ::core::ffi::c_int as usize]
                            - 1 as ::core::ffi::c_int,
                        (*h).mb.cache.ref_0[0 as ::core::ffi::c_int as usize]
                            [x264_scan8[4 as ::core::ffi::c_int as usize] as usize]
                            as ::core::ffi::c_int,
                    );
                }
                cavlc_mvd(
                    h,
                    0 as ::core::ffi::c_int,
                    0 as ::core::ffi::c_int,
                    2 as ::core::ffi::c_int,
                );
                cavlc_mvd(
                    h,
                    0 as ::core::ffi::c_int,
                    4 as ::core::ffi::c_int,
                    2 as ::core::ffi::c_int,
                );
            }
        } else if i_mb_type == P_8x8 as ::core::ffi::c_int {
            let mut b_sub_ref: ::core::ffi::c_int = 0;
            if (*h).mb.cache.ref_0[0 as ::core::ffi::c_int as usize]
                [x264_scan8[0 as ::core::ffi::c_int as usize] as usize]
                as ::core::ffi::c_int
                | (*h).mb.cache.ref_0[0 as ::core::ffi::c_int as usize]
                    [x264_scan8[4 as ::core::ffi::c_int as usize] as usize]
                    as ::core::ffi::c_int
                | (*h).mb.cache.ref_0[0 as ::core::ffi::c_int as usize]
                    [x264_scan8[8 as ::core::ffi::c_int as usize] as usize]
                    as ::core::ffi::c_int
                | (*h).mb.cache.ref_0[0 as ::core::ffi::c_int as usize]
                    [x264_scan8[12 as ::core::ffi::c_int as usize] as usize]
                    as ::core::ffi::c_int
                == 0 as ::core::ffi::c_int
            {
                (*s).i_bits_encoded += bs_size_ue(4 as ::core::ffi::c_uint);
                b_sub_ref = 0 as ::core::ffi::c_int;
            } else {
                (*s).i_bits_encoded += bs_size_ue(3 as ::core::ffi::c_uint);
                b_sub_ref = 1 as ::core::ffi::c_int;
            }
            if (*h).param.analyse.inter & X264_ANALYSE_PSUB8x8 != 0 {
                let mut i: ::core::ffi::c_int = 0 as ::core::ffi::c_int;
                while i < 4 as ::core::ffi::c_int {
                    (*s).i_bits_encoded += bs_size_ue(
                        subpartition_p_to_golomb[(*h).mb.i_sub_partition[i as usize] as usize]
                            as ::core::ffi::c_uint,
                    );
                    i += 1;
                }
            } else {
                (*s).i_bits_encoded += 4 as ::core::ffi::c_int;
            }
            if b_sub_ref != 0 {
                (*s).i_bits_encoded += bs_size_te(
                    (*h).mb.pic.i_fref[0 as ::core::ffi::c_int as usize] - 1 as ::core::ffi::c_int,
                    (*h).mb.cache.ref_0[0 as ::core::ffi::c_int as usize]
                        [x264_scan8[0 as ::core::ffi::c_int as usize] as usize]
                        as ::core::ffi::c_int,
                );
                (*s).i_bits_encoded += bs_size_te(
                    (*h).mb.pic.i_fref[0 as ::core::ffi::c_int as usize] - 1 as ::core::ffi::c_int,
                    (*h).mb.cache.ref_0[0 as ::core::ffi::c_int as usize]
                        [x264_scan8[4 as ::core::ffi::c_int as usize] as usize]
                        as ::core::ffi::c_int,
                );
                (*s).i_bits_encoded += bs_size_te(
                    (*h).mb.pic.i_fref[0 as ::core::ffi::c_int as usize] - 1 as ::core::ffi::c_int,
                    (*h).mb.cache.ref_0[0 as ::core::ffi::c_int as usize]
                        [x264_scan8[8 as ::core::ffi::c_int as usize] as usize]
                        as ::core::ffi::c_int,
                );
                (*s).i_bits_encoded += bs_size_te(
                    (*h).mb.pic.i_fref[0 as ::core::ffi::c_int as usize] - 1 as ::core::ffi::c_int,
                    (*h).mb.cache.ref_0[0 as ::core::ffi::c_int as usize]
                        [x264_scan8[12 as ::core::ffi::c_int as usize] as usize]
                        as ::core::ffi::c_int,
                );
            }
            let mut i_0: ::core::ffi::c_int = 0 as ::core::ffi::c_int;
            while i_0 < 4 as ::core::ffi::c_int {
                cavlc_8x8_mvd(h, i_0);
                i_0 += 1;
            }
        } else {
            cavlc_mb_header_i(h, i_mb_type, 5 as ::core::ffi::c_int, chroma);
        };
    }
    #[inline(always)]
    #[c2rust::src_loc = "411:1"]
    pub unsafe extern "C" fn cavlc_mb_header_b(
        mut h: *mut x264_t,
        mut i_mb_type: ::core::ffi::c_int,
        mut chroma: ::core::ffi::c_int,
    ) {
        let mut s: *mut bs_t = &mut (*h).out.bs;
        if i_mb_type == B_8x8 as ::core::ffi::c_int {
            (*s).i_bits_encoded += bs_size_ue(22 as ::core::ffi::c_uint);
            let mut i: ::core::ffi::c_int = 0 as ::core::ffi::c_int;
            while i < 4 as ::core::ffi::c_int {
                (*s).i_bits_encoded += bs_size_ue(
                    subpartition_b_to_golomb[(*h).mb.i_sub_partition[i as usize] as usize]
                        as ::core::ffi::c_uint,
                );
                i += 1;
            }
            if (*h).mb.pic.i_fref[0 as ::core::ffi::c_int as usize] > 1 as ::core::ffi::c_int {
                let mut i_0: ::core::ffi::c_int = 0 as ::core::ffi::c_int;
                while i_0 < 4 as ::core::ffi::c_int {
                    if x264_mb_partition_listX_table[0 as ::core::ffi::c_int as usize]
                        [(*h).mb.i_sub_partition[i_0 as usize] as usize]
                        != 0
                    {
                        (*s).i_bits_encoded += bs_size_te(
                            (*h).mb.pic.i_fref[0 as ::core::ffi::c_int as usize]
                                - 1 as ::core::ffi::c_int,
                            (*h).mb.cache.ref_0[0 as ::core::ffi::c_int as usize]
                                [x264_scan8[(i_0 * 4 as ::core::ffi::c_int) as usize] as usize]
                                as ::core::ffi::c_int,
                        );
                    }
                    i_0 += 1;
                }
            }
            if (*h).mb.pic.i_fref[1 as ::core::ffi::c_int as usize] > 1 as ::core::ffi::c_int {
                let mut i_1: ::core::ffi::c_int = 0 as ::core::ffi::c_int;
                while i_1 < 4 as ::core::ffi::c_int {
                    if x264_mb_partition_listX_table[1 as ::core::ffi::c_int as usize]
                        [(*h).mb.i_sub_partition[i_1 as usize] as usize]
                        != 0
                    {
                        (*s).i_bits_encoded += bs_size_te(
                            (*h).mb.pic.i_fref[1 as ::core::ffi::c_int as usize]
                                - 1 as ::core::ffi::c_int,
                            (*h).mb.cache.ref_0[1 as ::core::ffi::c_int as usize]
                                [x264_scan8[(i_1 * 4 as ::core::ffi::c_int) as usize] as usize]
                                as ::core::ffi::c_int,
                        );
                    }
                    i_1 += 1;
                }
            }
            let mut i_2: ::core::ffi::c_int = 0 as ::core::ffi::c_int;
            while i_2 < 4 as ::core::ffi::c_int {
                if x264_mb_partition_listX_table[0 as ::core::ffi::c_int as usize]
                    [(*h).mb.i_sub_partition[i_2 as usize] as usize]
                    != 0
                {
                    cavlc_mvd(
                        h,
                        0 as ::core::ffi::c_int,
                        4 as ::core::ffi::c_int * i_2,
                        2 as ::core::ffi::c_int,
                    );
                }
                i_2 += 1;
            }
            let mut i_3: ::core::ffi::c_int = 0 as ::core::ffi::c_int;
            while i_3 < 4 as ::core::ffi::c_int {
                if x264_mb_partition_listX_table[1 as ::core::ffi::c_int as usize]
                    [(*h).mb.i_sub_partition[i_3 as usize] as usize]
                    != 0
                {
                    cavlc_mvd(
                        h,
                        1 as ::core::ffi::c_int,
                        4 as ::core::ffi::c_int * i_3,
                        2 as ::core::ffi::c_int,
                    );
                }
                i_3 += 1;
            }
        } else if i_mb_type >= B_L0_L0 as ::core::ffi::c_int
            && i_mb_type <= B_BI_BI as ::core::ffi::c_int
        {
            let mut b_list: *const [uint8_t; 2] =
                (*x264_mb_type_list_table.as_ptr().offset(i_mb_type as isize)).as_ptr()
                    as *const [uint8_t; 2];
            let i_ref0_max: ::core::ffi::c_int =
                (*h).mb.pic.i_fref[0 as ::core::ffi::c_int as usize] - 1 as ::core::ffi::c_int;
            let i_ref1_max: ::core::ffi::c_int =
                (*h).mb.pic.i_fref[1 as ::core::ffi::c_int as usize] - 1 as ::core::ffi::c_int;
            (*s).i_bits_encoded += bs_size_ue(
                mb_type_b_to_golomb[((*h).mb.i_partition - D_16x8 as ::core::ffi::c_int) as usize]
                    [(i_mb_type - B_L0_L0 as ::core::ffi::c_int) as usize]
                    as ::core::ffi::c_uint,
            );
            if (*h).mb.i_partition == D_16x16 as ::core::ffi::c_int {
                if i_ref0_max != 0
                    && (*b_list.offset(0 as ::core::ffi::c_int as isize))
                        [0 as ::core::ffi::c_int as usize]
                        as ::core::ffi::c_int
                        != 0
                {
                    (*s).i_bits_encoded += bs_size_te(
                        i_ref0_max,
                        (*h).mb.cache.ref_0[0 as ::core::ffi::c_int as usize]
                            [x264_scan8[0 as ::core::ffi::c_int as usize] as usize]
                            as ::core::ffi::c_int,
                    );
                }
                if i_ref1_max != 0
                    && (*b_list.offset(1 as ::core::ffi::c_int as isize))
                        [0 as ::core::ffi::c_int as usize]
                        as ::core::ffi::c_int
                        != 0
                {
                    (*s).i_bits_encoded += bs_size_te(
                        i_ref1_max,
                        (*h).mb.cache.ref_0[1 as ::core::ffi::c_int as usize]
                            [x264_scan8[0 as ::core::ffi::c_int as usize] as usize]
                            as ::core::ffi::c_int,
                    );
                }
                if (*b_list.offset(0 as ::core::ffi::c_int as isize))
                    [0 as ::core::ffi::c_int as usize]
                    != 0
                {
                    cavlc_mvd(
                        h,
                        0 as ::core::ffi::c_int,
                        0 as ::core::ffi::c_int,
                        4 as ::core::ffi::c_int,
                    );
                }
                if (*b_list.offset(1 as ::core::ffi::c_int as isize))
                    [0 as ::core::ffi::c_int as usize]
                    != 0
                {
                    cavlc_mvd(
                        h,
                        1 as ::core::ffi::c_int,
                        0 as ::core::ffi::c_int,
                        4 as ::core::ffi::c_int,
                    );
                }
            } else {
                if i_ref0_max != 0
                    && (*b_list.offset(0 as ::core::ffi::c_int as isize))
                        [0 as ::core::ffi::c_int as usize]
                        as ::core::ffi::c_int
                        != 0
                {
                    (*s).i_bits_encoded += bs_size_te(
                        i_ref0_max,
                        (*h).mb.cache.ref_0[0 as ::core::ffi::c_int as usize]
                            [x264_scan8[0 as ::core::ffi::c_int as usize] as usize]
                            as ::core::ffi::c_int,
                    );
                }
                if i_ref0_max != 0
                    && (*b_list.offset(0 as ::core::ffi::c_int as isize))
                        [1 as ::core::ffi::c_int as usize]
                        as ::core::ffi::c_int
                        != 0
                {
                    (*s).i_bits_encoded += bs_size_te(
                        i_ref0_max,
                        (*h).mb.cache.ref_0[0 as ::core::ffi::c_int as usize]
                            [x264_scan8[12 as ::core::ffi::c_int as usize] as usize]
                            as ::core::ffi::c_int,
                    );
                }
                if i_ref1_max != 0
                    && (*b_list.offset(1 as ::core::ffi::c_int as isize))
                        [0 as ::core::ffi::c_int as usize]
                        as ::core::ffi::c_int
                        != 0
                {
                    (*s).i_bits_encoded += bs_size_te(
                        i_ref1_max,
                        (*h).mb.cache.ref_0[1 as ::core::ffi::c_int as usize]
                            [x264_scan8[0 as ::core::ffi::c_int as usize] as usize]
                            as ::core::ffi::c_int,
                    );
                }
                if i_ref1_max != 0
                    && (*b_list.offset(1 as ::core::ffi::c_int as isize))
                        [1 as ::core::ffi::c_int as usize]
                        as ::core::ffi::c_int
                        != 0
                {
                    (*s).i_bits_encoded += bs_size_te(
                        i_ref1_max,
                        (*h).mb.cache.ref_0[1 as ::core::ffi::c_int as usize]
                            [x264_scan8[12 as ::core::ffi::c_int as usize] as usize]
                            as ::core::ffi::c_int,
                    );
                }
                if (*h).mb.i_partition == D_16x8 as ::core::ffi::c_int {
                    if (*b_list.offset(0 as ::core::ffi::c_int as isize))
                        [0 as ::core::ffi::c_int as usize]
                        != 0
                    {
                        cavlc_mvd(
                            h,
                            0 as ::core::ffi::c_int,
                            0 as ::core::ffi::c_int,
                            4 as ::core::ffi::c_int,
                        );
                    }
                    if (*b_list.offset(0 as ::core::ffi::c_int as isize))
                        [1 as ::core::ffi::c_int as usize]
                        != 0
                    {
                        cavlc_mvd(
                            h,
                            0 as ::core::ffi::c_int,
                            8 as ::core::ffi::c_int,
                            4 as ::core::ffi::c_int,
                        );
                    }
                    if (*b_list.offset(1 as ::core::ffi::c_int as isize))
                        [0 as ::core::ffi::c_int as usize]
                        != 0
                    {
                        cavlc_mvd(
                            h,
                            1 as ::core::ffi::c_int,
                            0 as ::core::ffi::c_int,
                            4 as ::core::ffi::c_int,
                        );
                    }
                    if (*b_list.offset(1 as ::core::ffi::c_int as isize))
                        [1 as ::core::ffi::c_int as usize]
                        != 0
                    {
                        cavlc_mvd(
                            h,
                            1 as ::core::ffi::c_int,
                            8 as ::core::ffi::c_int,
                            4 as ::core::ffi::c_int,
                        );
                    }
                } else {
                    if (*b_list.offset(0 as ::core::ffi::c_int as isize))
                        [0 as ::core::ffi::c_int as usize]
                        != 0
                    {
                        cavlc_mvd(
                            h,
                            0 as ::core::ffi::c_int,
                            0 as ::core::ffi::c_int,
                            2 as ::core::ffi::c_int,
                        );
                    }
                    if (*b_list.offset(0 as ::core::ffi::c_int as isize))
                        [1 as ::core::ffi::c_int as usize]
                        != 0
                    {
                        cavlc_mvd(
                            h,
                            0 as ::core::ffi::c_int,
                            4 as ::core::ffi::c_int,
                            2 as ::core::ffi::c_int,
                        );
                    }
                    if (*b_list.offset(1 as ::core::ffi::c_int as isize))
                        [0 as ::core::ffi::c_int as usize]
                        != 0
                    {
                        cavlc_mvd(
                            h,
                            1 as ::core::ffi::c_int,
                            0 as ::core::ffi::c_int,
                            2 as ::core::ffi::c_int,
                        );
                    }
                    if (*b_list.offset(1 as ::core::ffi::c_int as isize))
                        [1 as ::core::ffi::c_int as usize]
                        != 0
                    {
                        cavlc_mvd(
                            h,
                            1 as ::core::ffi::c_int,
                            4 as ::core::ffi::c_int,
                            2 as ::core::ffi::c_int,
                        );
                    }
                }
            }
        } else if i_mb_type == B_DIRECT as ::core::ffi::c_int {
            (*s).i_bits_encoded += 1 as ::core::ffi::c_int;
        } else {
            cavlc_mb_header_i(h, i_mb_type, 23 as ::core::ffi::c_int, chroma);
        };
    }
    #[c2rust::src_loc = "487:1"]
    pub unsafe extern "C" fn macroblock_size_cavlc(mut h: *mut x264_t) {
        let mut s: *mut bs_t = &mut (*h).out.bs;
        let i_mb_type: ::core::ffi::c_int = (*h).mb.i_type;
        let mut plane_count: ::core::ffi::c_int =
            if (*(*h).sps.as_mut_ptr()).i_chroma_format_idc == CHROMA_444 as ::core::ffi::c_int {
                3 as ::core::ffi::c_int
            } else {
                1 as ::core::ffi::c_int
            };
        let mut chroma: ::core::ffi::c_int = ((*(*h).sps.as_mut_ptr()).i_chroma_format_idc
            == CHROMA_420 as ::core::ffi::c_int
            || (*(*h).sps.as_mut_ptr()).i_chroma_format_idc == CHROMA_422 as ::core::ffi::c_int)
            as ::core::ffi::c_int;
        (*s).i_bits_encoded = 0 as ::core::ffi::c_int;
        if (*h).sh.b_mbaff != 0
            && ((*h).mb.i_mb_y & 1 as ::core::ffi::c_int == 0
                || (*(*h)
                    .mb
                    .type_0
                    .offset(((*h).mb.i_mb_xy - (*h).mb.i_mb_stride) as isize)
                    as ::core::ffi::c_int
                    == P_SKIP as ::core::ffi::c_int
                    || *(*h)
                        .mb
                        .type_0
                        .offset(((*h).mb.i_mb_xy - (*h).mb.i_mb_stride) as isize)
                        as ::core::ffi::c_int
                        == B_SKIP as ::core::ffi::c_int))
        {
            (*s).i_bits_encoded += 1 as ::core::ffi::c_int;
        }
        if (*h).sh.i_type == SLICE_TYPE_P as ::core::ffi::c_int {
            cavlc_mb_header_p(h, i_mb_type, chroma);
        } else if (*h).sh.i_type == SLICE_TYPE_B as ::core::ffi::c_int {
            cavlc_mb_header_b(h, i_mb_type, chroma);
        } else {
            cavlc_mb_header_i(h, i_mb_type, 0 as ::core::ffi::c_int, chroma);
        }
        if i_mb_type != I_16x16 as ::core::ffi::c_int {
            (*s).i_bits_encoded += bs_size_ue(
                cbp_to_golomb[chroma as usize][(i_mb_type == I_4x4 as ::core::ffi::c_int
                    || i_mb_type == I_8x8 as ::core::ffi::c_int
                    || i_mb_type == I_16x16 as ::core::ffi::c_int
                    || i_mb_type == I_PCM as ::core::ffi::c_int)
                    as ::core::ffi::c_int as usize][((*h).mb.i_cbp_chroma
                    << 4 as ::core::ffi::c_int
                    | (*h).mb.i_cbp_luma)
                    as usize] as ::core::ffi::c_uint,
            );
        }
        if x264_mb_transform_8x8_allowed(h) != 0 && (*h).mb.i_cbp_luma != 0 {
            (*s).i_bits_encoded += 1 as ::core::ffi::c_int;
        }
        if i_mb_type == I_16x16 as ::core::ffi::c_int {
            cavlc_qp_delta(h);
            let mut p: ::core::ffi::c_int = 0 as ::core::ffi::c_int;
            while p < plane_count {
                let mut nC: ::core::ffi::c_int = if DCT_LUMA_DC as ::core::ffi::c_int
                    == DCT_CHROMA_DC as ::core::ffi::c_int
                {
                    5 as ::core::ffi::c_int - (*h).mb.chroma_v_shift
                } else {
                    ct_index[x264_mb_predict_non_zero_code(
                        h,
                        if DCT_LUMA_DC as ::core::ffi::c_int == DCT_LUMA_DC as ::core::ffi::c_int {
                            (48 as ::core::ffi::c_int + p - LUMA_DC) * 16 as ::core::ffi::c_int
                        } else {
                            48 as ::core::ffi::c_int + p
                        },
                    ) as usize] as ::core::ffi::c_int
                };
                let mut nnz: *mut uint8_t = &mut *(*h).mb.cache.non_zero_count.as_mut_ptr().offset(
                    *x264_scan8
                        .as_ptr()
                        .offset((48 as ::core::ffi::c_int + p) as isize)
                        as isize,
                ) as *mut uint8_t;
                if *nnz == 0 {
                    (*h).out.bs.i_bits_encoded +=
                        x264_coeff0_token[nC as usize].i_size as ::core::ffi::c_int;
                } else {
                    *nnz = cavlc_block_residual_internal(
                        h,
                        DCT_LUMA_DC as ::core::ffi::c_int,
                        (*(*h).dct.luma16x16_dc.as_mut_ptr().offset(p as isize)).as_mut_ptr(),
                        nC,
                    ) as uint8_t;
                }
                if (*h).mb.i_cbp_luma != 0 {
                    let mut i: ::core::ffi::c_int = p * 16 as ::core::ffi::c_int;
                    while i < p * 16 as ::core::ffi::c_int + 16 as ::core::ffi::c_int {
                        let mut nC_0: ::core::ffi::c_int = if DCT_LUMA_AC as ::core::ffi::c_int
                            == DCT_CHROMA_DC as ::core::ffi::c_int
                        {
                            5 as ::core::ffi::c_int - (*h).mb.chroma_v_shift
                        } else {
                            ct_index[x264_mb_predict_non_zero_code(
                                h,
                                if DCT_LUMA_AC as ::core::ffi::c_int
                                    == DCT_LUMA_DC as ::core::ffi::c_int
                                {
                                    (i - LUMA_DC) * 16 as ::core::ffi::c_int
                                } else {
                                    i
                                },
                            ) as usize] as ::core::ffi::c_int
                        };
                        let mut nnz_0: *mut uint8_t = &mut *(*h)
                            .mb
                            .cache
                            .non_zero_count
                            .as_mut_ptr()
                            .offset(*x264_scan8.as_ptr().offset(i as isize) as isize)
                            as *mut uint8_t;
                        if *nnz_0 == 0 {
                            (*h).out.bs.i_bits_encoded +=
                                x264_coeff0_token[nC_0 as usize].i_size as ::core::ffi::c_int;
                        } else {
                            *nnz_0 = cavlc_block_residual_internal(
                                h,
                                DCT_LUMA_AC as ::core::ffi::c_int,
                                (*(*h).dct.luma4x4.as_mut_ptr().offset(i as isize))
                                    .as_mut_ptr()
                                    .offset(1 as ::core::ffi::c_int as isize),
                                nC_0,
                            ) as uint8_t;
                        }
                        i += 1;
                    }
                }
                p += 1;
            }
        } else if (*h).mb.i_cbp_luma | (*h).mb.i_cbp_chroma != 0 {
            cavlc_qp_delta(h);
            cavlc_macroblock_luma_residual(h, plane_count);
        }
        if (*h).mb.i_cbp_chroma != 0 {
            let mut nC_1: ::core::ffi::c_int = if DCT_CHROMA_DC as ::core::ffi::c_int
                == DCT_CHROMA_DC as ::core::ffi::c_int
            {
                5 as ::core::ffi::c_int - (*h).mb.chroma_v_shift
            } else {
                ct_index[x264_mb_predict_non_zero_code(
                    h,
                    if DCT_CHROMA_DC as ::core::ffi::c_int == DCT_LUMA_DC as ::core::ffi::c_int {
                        (49 as ::core::ffi::c_int + 0 as ::core::ffi::c_int - LUMA_DC)
                            * 16 as ::core::ffi::c_int
                    } else {
                        49 as ::core::ffi::c_int + 0 as ::core::ffi::c_int
                    },
                ) as usize] as ::core::ffi::c_int
            };
            let mut nnz_1: *mut uint8_t = &mut *(*h).mb.cache.non_zero_count.as_mut_ptr().offset(
                *x264_scan8
                    .as_ptr()
                    .offset((49 as ::core::ffi::c_int + 0 as ::core::ffi::c_int) as isize)
                    as isize,
            ) as *mut uint8_t;
            if *nnz_1 == 0 {
                (*h).out.bs.i_bits_encoded +=
                    x264_coeff0_token[nC_1 as usize].i_size as ::core::ffi::c_int;
            } else {
                *nnz_1 = cavlc_block_residual_internal(
                    h,
                    DCT_CHROMA_DC as ::core::ffi::c_int,
                    (*(*h)
                        .dct
                        .chroma_dc
                        .as_mut_ptr()
                        .offset(0 as ::core::ffi::c_int as isize))
                    .as_mut_ptr(),
                    nC_1,
                ) as uint8_t;
            }
            let mut nC_2: ::core::ffi::c_int = if DCT_CHROMA_DC as ::core::ffi::c_int
                == DCT_CHROMA_DC as ::core::ffi::c_int
            {
                5 as ::core::ffi::c_int - (*h).mb.chroma_v_shift
            } else {
                ct_index[x264_mb_predict_non_zero_code(
                    h,
                    if DCT_CHROMA_DC as ::core::ffi::c_int == DCT_LUMA_DC as ::core::ffi::c_int {
                        (49 as ::core::ffi::c_int + 1 as ::core::ffi::c_int - LUMA_DC)
                            * 16 as ::core::ffi::c_int
                    } else {
                        49 as ::core::ffi::c_int + 1 as ::core::ffi::c_int
                    },
                ) as usize] as ::core::ffi::c_int
            };
            let mut nnz_2: *mut uint8_t = &mut *(*h).mb.cache.non_zero_count.as_mut_ptr().offset(
                *x264_scan8
                    .as_ptr()
                    .offset((49 as ::core::ffi::c_int + 1 as ::core::ffi::c_int) as isize)
                    as isize,
            ) as *mut uint8_t;
            if *nnz_2 == 0 {
                (*h).out.bs.i_bits_encoded +=
                    x264_coeff0_token[nC_2 as usize].i_size as ::core::ffi::c_int;
            } else {
                *nnz_2 = cavlc_block_residual_internal(
                    h,
                    DCT_CHROMA_DC as ::core::ffi::c_int,
                    (*(*h)
                        .dct
                        .chroma_dc
                        .as_mut_ptr()
                        .offset(1 as ::core::ffi::c_int as isize))
                    .as_mut_ptr(),
                    nC_2,
                ) as uint8_t;
            }
            if (*h).mb.i_cbp_chroma == 2 as ::core::ffi::c_int {
                let mut step: ::core::ffi::c_int =
                    (8 as ::core::ffi::c_int) << (*h).mb.chroma_v_shift;
                let mut i_0: ::core::ffi::c_int = 16 as ::core::ffi::c_int;
                while i_0 < 3 as ::core::ffi::c_int * 16 as ::core::ffi::c_int {
                    let mut j: ::core::ffi::c_int = i_0;
                    while j < i_0 + 4 as ::core::ffi::c_int {
                        let mut nC_3: ::core::ffi::c_int = if DCT_CHROMA_AC as ::core::ffi::c_int
                            == DCT_CHROMA_DC as ::core::ffi::c_int
                        {
                            5 as ::core::ffi::c_int - (*h).mb.chroma_v_shift
                        } else {
                            ct_index[x264_mb_predict_non_zero_code(
                                h,
                                if DCT_CHROMA_AC as ::core::ffi::c_int
                                    == DCT_LUMA_DC as ::core::ffi::c_int
                                {
                                    (j - LUMA_DC) * 16 as ::core::ffi::c_int
                                } else {
                                    j
                                },
                            ) as usize] as ::core::ffi::c_int
                        };
                        let mut nnz_3: *mut uint8_t = &mut *(*h)
                            .mb
                            .cache
                            .non_zero_count
                            .as_mut_ptr()
                            .offset(*x264_scan8.as_ptr().offset(j as isize) as isize)
                            as *mut uint8_t;
                        if *nnz_3 == 0 {
                            (*h).out.bs.i_bits_encoded +=
                                x264_coeff0_token[nC_3 as usize].i_size as ::core::ffi::c_int;
                        } else {
                            *nnz_3 = cavlc_block_residual_internal(
                                h,
                                DCT_CHROMA_AC as ::core::ffi::c_int,
                                (*(*h).dct.luma4x4.as_mut_ptr().offset(j as isize))
                                    .as_mut_ptr()
                                    .offset(1 as ::core::ffi::c_int as isize),
                                nC_3,
                            ) as uint8_t;
                        }
                        j += 1;
                    }
                    i_0 += step;
                }
            }
        }
    }
    #[c2rust::src_loc = "605:1"]
    pub unsafe extern "C" fn partition_size_cavlc(
        mut h: *mut x264_t,
        mut i8: ::core::ffi::c_int,
        mut i_pixel: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int {
        let mut s: *mut bs_t = &mut (*h).out.bs;
        let i_mb_type: ::core::ffi::c_int = (*h).mb.i_type;
        let mut b_8x16: ::core::ffi::c_int =
            ((*h).mb.i_partition == D_8x16 as ::core::ffi::c_int) as ::core::ffi::c_int;
        let mut plane_count: ::core::ffi::c_int =
            if (*(*h).sps.as_mut_ptr()).i_chroma_format_idc == CHROMA_444 as ::core::ffi::c_int {
                3 as ::core::ffi::c_int
            } else {
                1 as ::core::ffi::c_int
            };
        let mut j: ::core::ffi::c_int = 0;
        (*h).out.bs.i_bits_encoded = 0 as ::core::ffi::c_int;
        if i_mb_type == P_8x8 as ::core::ffi::c_int {
            cavlc_8x8_mvd(h, i8);
            (*s).i_bits_encoded += bs_size_ue(
                subpartition_p_to_golomb[(*h).mb.i_sub_partition[i8 as usize] as usize]
                    as ::core::ffi::c_uint,
            );
        } else if i_mb_type == P_L0 as ::core::ffi::c_int {
            cavlc_mvd(
                h,
                0 as ::core::ffi::c_int,
                4 as ::core::ffi::c_int * i8,
                4 as ::core::ffi::c_int >> b_8x16,
            );
        } else if i_mb_type > B_DIRECT as ::core::ffi::c_int
            && i_mb_type < B_8x8 as ::core::ffi::c_int
        {
            if x264_mb_type_list_table[i_mb_type as usize][0 as ::core::ffi::c_int as usize]
                [(i8 != 0) as ::core::ffi::c_int as usize]
                != 0
            {
                cavlc_mvd(
                    h,
                    0 as ::core::ffi::c_int,
                    4 as ::core::ffi::c_int * i8,
                    4 as ::core::ffi::c_int >> b_8x16,
                );
            }
            if x264_mb_type_list_table[i_mb_type as usize][1 as ::core::ffi::c_int as usize]
                [(i8 != 0) as ::core::ffi::c_int as usize]
                != 0
            {
                cavlc_mvd(
                    h,
                    1 as ::core::ffi::c_int,
                    4 as ::core::ffi::c_int * i8,
                    4 as ::core::ffi::c_int >> b_8x16,
                );
            }
        } else {
            if x264_mb_partition_listX_table[0 as ::core::ffi::c_int as usize]
                [(*h).mb.i_sub_partition[i8 as usize] as usize]
                != 0
            {
                cavlc_mvd(
                    h,
                    0 as ::core::ffi::c_int,
                    4 as ::core::ffi::c_int * i8,
                    2 as ::core::ffi::c_int,
                );
            }
            if x264_mb_partition_listX_table[1 as ::core::ffi::c_int as usize]
                [(*h).mb.i_sub_partition[i8 as usize] as usize]
                != 0
            {
                cavlc_mvd(
                    h,
                    1 as ::core::ffi::c_int,
                    4 as ::core::ffi::c_int * i8,
                    2 as ::core::ffi::c_int,
                );
            }
        }
        j = (i_pixel < PIXEL_8x8 as ::core::ffi::c_int) as ::core::ffi::c_int;
        while j >= 0 as ::core::ffi::c_int {
            let mut p: ::core::ffi::c_int = 0 as ::core::ffi::c_int;
            while p < plane_count {
                cavlc_partition_luma_residual(h, i8, p);
                p += 1;
            }
            if (*h).mb.i_cbp_chroma != 0 {
                if (*(*h).sps.as_mut_ptr()).i_chroma_format_idc == CHROMA_422 as ::core::ffi::c_int
                {
                    let mut offset: ::core::ffi::c_int =
                        5 as ::core::ffi::c_int * i8 & 0x9 as ::core::ffi::c_int;
                    let mut nC: ::core::ffi::c_int = if DCT_CHROMA_AC as ::core::ffi::c_int
                        == DCT_CHROMA_DC as ::core::ffi::c_int
                    {
                        5 as ::core::ffi::c_int - (*h).mb.chroma_v_shift
                    } else {
                        ct_index[x264_mb_predict_non_zero_code(
                            h,
                            if DCT_CHROMA_AC as ::core::ffi::c_int
                                == DCT_LUMA_DC as ::core::ffi::c_int
                            {
                                (16 as ::core::ffi::c_int + offset - LUMA_DC)
                                    * 16 as ::core::ffi::c_int
                            } else {
                                16 as ::core::ffi::c_int + offset
                            },
                        ) as usize] as ::core::ffi::c_int
                    };
                    let mut nnz: *mut uint8_t =
                        &mut *(*h).mb.cache.non_zero_count.as_mut_ptr().offset(
                            *x264_scan8
                                .as_ptr()
                                .offset((16 as ::core::ffi::c_int + offset) as isize)
                                as isize,
                        ) as *mut uint8_t;
                    if *nnz == 0 {
                        (*h).out.bs.i_bits_encoded +=
                            x264_coeff0_token[nC as usize].i_size as ::core::ffi::c_int;
                    } else {
                        *nnz = cavlc_block_residual_internal(
                            h,
                            DCT_CHROMA_AC as ::core::ffi::c_int,
                            (*(*h)
                                .dct
                                .luma4x4
                                .as_mut_ptr()
                                .offset((16 as ::core::ffi::c_int + offset) as isize))
                            .as_mut_ptr()
                            .offset(1 as ::core::ffi::c_int as isize),
                            nC,
                        ) as uint8_t;
                    }
                    let mut nC_0: ::core::ffi::c_int = if DCT_CHROMA_AC as ::core::ffi::c_int
                        == DCT_CHROMA_DC as ::core::ffi::c_int
                    {
                        5 as ::core::ffi::c_int - (*h).mb.chroma_v_shift
                    } else {
                        ct_index[x264_mb_predict_non_zero_code(
                            h,
                            if DCT_CHROMA_AC as ::core::ffi::c_int
                                == DCT_LUMA_DC as ::core::ffi::c_int
                            {
                                (18 as ::core::ffi::c_int + offset - LUMA_DC)
                                    * 16 as ::core::ffi::c_int
                            } else {
                                18 as ::core::ffi::c_int + offset
                            },
                        ) as usize] as ::core::ffi::c_int
                    };
                    let mut nnz_0: *mut uint8_t =
                        &mut *(*h).mb.cache.non_zero_count.as_mut_ptr().offset(
                            *x264_scan8
                                .as_ptr()
                                .offset((18 as ::core::ffi::c_int + offset) as isize)
                                as isize,
                        ) as *mut uint8_t;
                    if *nnz_0 == 0 {
                        (*h).out.bs.i_bits_encoded +=
                            x264_coeff0_token[nC_0 as usize].i_size as ::core::ffi::c_int;
                    } else {
                        *nnz_0 = cavlc_block_residual_internal(
                            h,
                            DCT_CHROMA_AC as ::core::ffi::c_int,
                            (*(*h)
                                .dct
                                .luma4x4
                                .as_mut_ptr()
                                .offset((18 as ::core::ffi::c_int + offset) as isize))
                            .as_mut_ptr()
                            .offset(1 as ::core::ffi::c_int as isize),
                            nC_0,
                        ) as uint8_t;
                    }
                    let mut nC_1: ::core::ffi::c_int = if DCT_CHROMA_AC as ::core::ffi::c_int
                        == DCT_CHROMA_DC as ::core::ffi::c_int
                    {
                        5 as ::core::ffi::c_int - (*h).mb.chroma_v_shift
                    } else {
                        ct_index[x264_mb_predict_non_zero_code(
                            h,
                            if DCT_CHROMA_AC as ::core::ffi::c_int
                                == DCT_LUMA_DC as ::core::ffi::c_int
                            {
                                (32 as ::core::ffi::c_int + offset - LUMA_DC)
                                    * 16 as ::core::ffi::c_int
                            } else {
                                32 as ::core::ffi::c_int + offset
                            },
                        ) as usize] as ::core::ffi::c_int
                    };
                    let mut nnz_1: *mut uint8_t =
                        &mut *(*h).mb.cache.non_zero_count.as_mut_ptr().offset(
                            *x264_scan8
                                .as_ptr()
                                .offset((32 as ::core::ffi::c_int + offset) as isize)
                                as isize,
                        ) as *mut uint8_t;
                    if *nnz_1 == 0 {
                        (*h).out.bs.i_bits_encoded +=
                            x264_coeff0_token[nC_1 as usize].i_size as ::core::ffi::c_int;
                    } else {
                        *nnz_1 = cavlc_block_residual_internal(
                            h,
                            DCT_CHROMA_AC as ::core::ffi::c_int,
                            (*(*h)
                                .dct
                                .luma4x4
                                .as_mut_ptr()
                                .offset((32 as ::core::ffi::c_int + offset) as isize))
                            .as_mut_ptr()
                            .offset(1 as ::core::ffi::c_int as isize),
                            nC_1,
                        ) as uint8_t;
                    }
                    let mut nC_2: ::core::ffi::c_int = if DCT_CHROMA_AC as ::core::ffi::c_int
                        == DCT_CHROMA_DC as ::core::ffi::c_int
                    {
                        5 as ::core::ffi::c_int - (*h).mb.chroma_v_shift
                    } else {
                        ct_index[x264_mb_predict_non_zero_code(
                            h,
                            if DCT_CHROMA_AC as ::core::ffi::c_int
                                == DCT_LUMA_DC as ::core::ffi::c_int
                            {
                                (34 as ::core::ffi::c_int + offset - LUMA_DC)
                                    * 16 as ::core::ffi::c_int
                            } else {
                                34 as ::core::ffi::c_int + offset
                            },
                        ) as usize] as ::core::ffi::c_int
                    };
                    let mut nnz_2: *mut uint8_t =
                        &mut *(*h).mb.cache.non_zero_count.as_mut_ptr().offset(
                            *x264_scan8
                                .as_ptr()
                                .offset((34 as ::core::ffi::c_int + offset) as isize)
                                as isize,
                        ) as *mut uint8_t;
                    if *nnz_2 == 0 {
                        (*h).out.bs.i_bits_encoded +=
                            x264_coeff0_token[nC_2 as usize].i_size as ::core::ffi::c_int;
                    } else {
                        *nnz_2 = cavlc_block_residual_internal(
                            h,
                            DCT_CHROMA_AC as ::core::ffi::c_int,
                            (*(*h)
                                .dct
                                .luma4x4
                                .as_mut_ptr()
                                .offset((34 as ::core::ffi::c_int + offset) as isize))
                            .as_mut_ptr()
                            .offset(1 as ::core::ffi::c_int as isize),
                            nC_2,
                        ) as uint8_t;
                    }
                } else {
                    let mut nC_3: ::core::ffi::c_int = if DCT_CHROMA_AC as ::core::ffi::c_int
                        == DCT_CHROMA_DC as ::core::ffi::c_int
                    {
                        5 as ::core::ffi::c_int - (*h).mb.chroma_v_shift
                    } else {
                        ct_index[x264_mb_predict_non_zero_code(
                            h,
                            if DCT_CHROMA_AC as ::core::ffi::c_int
                                == DCT_LUMA_DC as ::core::ffi::c_int
                            {
                                (16 as ::core::ffi::c_int + i8 - LUMA_DC) * 16 as ::core::ffi::c_int
                            } else {
                                16 as ::core::ffi::c_int + i8
                            },
                        ) as usize] as ::core::ffi::c_int
                    };
                    let mut nnz_3: *mut uint8_t =
                        &mut *(*h).mb.cache.non_zero_count.as_mut_ptr().offset(
                            *x264_scan8
                                .as_ptr()
                                .offset((16 as ::core::ffi::c_int + i8) as isize)
                                as isize,
                        ) as *mut uint8_t;
                    if *nnz_3 == 0 {
                        (*h).out.bs.i_bits_encoded +=
                            x264_coeff0_token[nC_3 as usize].i_size as ::core::ffi::c_int;
                    } else {
                        *nnz_3 = cavlc_block_residual_internal(
                            h,
                            DCT_CHROMA_AC as ::core::ffi::c_int,
                            (*(*h)
                                .dct
                                .luma4x4
                                .as_mut_ptr()
                                .offset((16 as ::core::ffi::c_int + i8) as isize))
                            .as_mut_ptr()
                            .offset(1 as ::core::ffi::c_int as isize),
                            nC_3,
                        ) as uint8_t;
                    }
                    let mut nC_4: ::core::ffi::c_int = if DCT_CHROMA_AC as ::core::ffi::c_int
                        == DCT_CHROMA_DC as ::core::ffi::c_int
                    {
                        5 as ::core::ffi::c_int - (*h).mb.chroma_v_shift
                    } else {
                        ct_index[x264_mb_predict_non_zero_code(
                            h,
                            if DCT_CHROMA_AC as ::core::ffi::c_int
                                == DCT_LUMA_DC as ::core::ffi::c_int
                            {
                                (32 as ::core::ffi::c_int + i8 - LUMA_DC) * 16 as ::core::ffi::c_int
                            } else {
                                32 as ::core::ffi::c_int + i8
                            },
                        ) as usize] as ::core::ffi::c_int
                    };
                    let mut nnz_4: *mut uint8_t =
                        &mut *(*h).mb.cache.non_zero_count.as_mut_ptr().offset(
                            *x264_scan8
                                .as_ptr()
                                .offset((32 as ::core::ffi::c_int + i8) as isize)
                                as isize,
                        ) as *mut uint8_t;
                    if *nnz_4 == 0 {
                        (*h).out.bs.i_bits_encoded +=
                            x264_coeff0_token[nC_4 as usize].i_size as ::core::ffi::c_int;
                    } else {
                        *nnz_4 = cavlc_block_residual_internal(
                            h,
                            DCT_CHROMA_AC as ::core::ffi::c_int,
                            (*(*h)
                                .dct
                                .luma4x4
                                .as_mut_ptr()
                                .offset((32 as ::core::ffi::c_int + i8) as isize))
                            .as_mut_ptr()
                            .offset(1 as ::core::ffi::c_int as isize),
                            nC_4,
                        ) as uint8_t;
                    }
                }
            }
            i8 += x264_pixel_size[i_pixel as usize].h as ::core::ffi::c_int
                >> 3 as ::core::ffi::c_int;
            j -= 1;
        }
        return (*h).out.bs.i_bits_encoded;
    }
    #[c2rust::src_loc = "661:1"]
    pub unsafe extern "C" fn subpartition_size_cavlc(
        mut h: *mut x264_t,
        mut i4: ::core::ffi::c_int,
        mut i_pixel: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int {
        let mut plane_count: ::core::ffi::c_int =
            if (*(*h).sps.as_mut_ptr()).i_chroma_format_idc == CHROMA_444 as ::core::ffi::c_int {
                3 as ::core::ffi::c_int
            } else {
                1 as ::core::ffi::c_int
            };
        let mut b_8x4: ::core::ffi::c_int =
            (i_pixel == PIXEL_8x4 as ::core::ffi::c_int) as ::core::ffi::c_int;
        (*h).out.bs.i_bits_encoded = 0 as ::core::ffi::c_int;
        cavlc_mvd(
            h,
            0 as ::core::ffi::c_int,
            i4,
            1 as ::core::ffi::c_int + b_8x4,
        );
        let mut p: ::core::ffi::c_int = 0 as ::core::ffi::c_int;
        while p < plane_count {
            let mut nC: ::core::ffi::c_int =
                if DCT_LUMA_4x4 as ::core::ffi::c_int == DCT_CHROMA_DC as ::core::ffi::c_int {
                    5 as ::core::ffi::c_int - (*h).mb.chroma_v_shift
                } else {
                    ct_index[x264_mb_predict_non_zero_code(
                        h,
                        if DCT_LUMA_4x4 as ::core::ffi::c_int == DCT_LUMA_DC as ::core::ffi::c_int {
                            (p * 16 as ::core::ffi::c_int + i4 - LUMA_DC) * 16 as ::core::ffi::c_int
                        } else {
                            p * 16 as ::core::ffi::c_int + i4
                        },
                    ) as usize] as ::core::ffi::c_int
                };
            let mut nnz: *mut uint8_t = &mut *(*h).mb.cache.non_zero_count.as_mut_ptr().offset(
                *x264_scan8
                    .as_ptr()
                    .offset((p * 16 as ::core::ffi::c_int + i4) as isize) as isize,
            ) as *mut uint8_t;
            if *nnz == 0 {
                (*h).out.bs.i_bits_encoded +=
                    x264_coeff0_token[nC as usize].i_size as ::core::ffi::c_int;
            } else {
                *nnz = cavlc_block_residual_internal(
                    h,
                    DCT_LUMA_4x4 as ::core::ffi::c_int,
                    (*(*h)
                        .dct
                        .luma4x4
                        .as_mut_ptr()
                        .offset((p * 16 as ::core::ffi::c_int + i4) as isize))
                    .as_mut_ptr(),
                    nC,
                ) as uint8_t;
            }
            if i_pixel != PIXEL_4x4 as ::core::ffi::c_int {
                let mut nC_0: ::core::ffi::c_int = if DCT_LUMA_4x4 as ::core::ffi::c_int
                    == DCT_CHROMA_DC as ::core::ffi::c_int
                {
                    5 as ::core::ffi::c_int - (*h).mb.chroma_v_shift
                } else {
                    ct_index[x264_mb_predict_non_zero_code(
                        h,
                        if DCT_LUMA_4x4 as ::core::ffi::c_int == DCT_LUMA_DC as ::core::ffi::c_int {
                            (p * 16 as ::core::ffi::c_int + i4 + 2 as ::core::ffi::c_int
                                - b_8x4
                                - LUMA_DC)
                                * 16 as ::core::ffi::c_int
                        } else {
                            p * 16 as ::core::ffi::c_int + i4 + 2 as ::core::ffi::c_int - b_8x4
                        },
                    ) as usize] as ::core::ffi::c_int
                };
                let mut nnz_0: *mut uint8_t =
                    &mut *(*h).mb.cache.non_zero_count.as_mut_ptr().offset(
                        *x264_scan8.as_ptr().offset(
                            (p * 16 as ::core::ffi::c_int + i4 + 2 as ::core::ffi::c_int - b_8x4)
                                as isize,
                        ) as isize,
                    ) as *mut uint8_t;
                if *nnz_0 == 0 {
                    (*h).out.bs.i_bits_encoded +=
                        x264_coeff0_token[nC_0 as usize].i_size as ::core::ffi::c_int;
                } else {
                    *nnz_0 = cavlc_block_residual_internal(
                        h,
                        DCT_LUMA_4x4 as ::core::ffi::c_int,
                        (*(*h).dct.luma4x4.as_mut_ptr().offset(
                            (p * 16 as ::core::ffi::c_int + i4 + 2 as ::core::ffi::c_int - b_8x4)
                                as isize,
                        ))
                        .as_mut_ptr(),
                        nC_0,
                    ) as uint8_t;
                }
            }
            p += 1;
        }
        return (*h).out.bs.i_bits_encoded;
    }
    #[c2rust::src_loc = "677:1"]
    pub unsafe extern "C" fn cavlc_intra4x4_pred_size(
        mut h: *mut x264_t,
        mut i4: ::core::ffi::c_int,
        mut i_mode: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int {
        if x264_mb_predict_intra4x4_mode(h, i4)
            == x264_mb_pred_mode4x4_fix[(i_mode + 1 as ::core::ffi::c_int) as usize]
                as ::core::ffi::c_int
        {
            return 1 as ::core::ffi::c_int;
        } else {
            return 4 as ::core::ffi::c_int;
        };
    }
    #[c2rust::src_loc = "685:1"]
    pub unsafe extern "C" fn partition_i8x8_size_cavlc(
        mut h: *mut x264_t,
        mut i8: ::core::ffi::c_int,
        mut i_mode: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int {
        let mut plane_count: ::core::ffi::c_int =
            if (*(*h).sps.as_mut_ptr()).i_chroma_format_idc == CHROMA_444 as ::core::ffi::c_int {
                3 as ::core::ffi::c_int
            } else {
                1 as ::core::ffi::c_int
            };
        (*h).out.bs.i_bits_encoded =
            cavlc_intra4x4_pred_size(h, 4 as ::core::ffi::c_int * i8, i_mode);
        (*h).out.bs.i_bits_encoded += bs_size_ue(
            cbp_to_golomb[!((*(*h).sps.as_mut_ptr()).i_chroma_format_idc
                == CHROMA_444 as ::core::ffi::c_int) as ::core::ffi::c_int
                as usize][1 as ::core::ffi::c_int as usize]
                [((*h).mb.i_cbp_chroma << 4 as ::core::ffi::c_int | (*h).mb.i_cbp_luma) as usize]
                as ::core::ffi::c_uint,
        );
        let mut p: ::core::ffi::c_int = 0 as ::core::ffi::c_int;
        while p < plane_count {
            cavlc_partition_luma_residual(h, i8, p);
            p += 1;
        }
        return (*h).out.bs.i_bits_encoded;
    }
    #[c2rust::src_loc = "695:1"]
    pub unsafe extern "C" fn partition_i4x4_size_cavlc(
        mut h: *mut x264_t,
        mut i4: ::core::ffi::c_int,
        mut i_mode: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int {
        let mut plane_count: ::core::ffi::c_int =
            if (*(*h).sps.as_mut_ptr()).i_chroma_format_idc == CHROMA_444 as ::core::ffi::c_int {
                3 as ::core::ffi::c_int
            } else {
                1 as ::core::ffi::c_int
            };
        (*h).out.bs.i_bits_encoded = cavlc_intra4x4_pred_size(h, i4, i_mode);
        let mut p: ::core::ffi::c_int = 0 as ::core::ffi::c_int;
        while p < plane_count {
            let mut nC: ::core::ffi::c_int =
                if DCT_LUMA_4x4 as ::core::ffi::c_int == DCT_CHROMA_DC as ::core::ffi::c_int {
                    5 as ::core::ffi::c_int - (*h).mb.chroma_v_shift
                } else {
                    ct_index[x264_mb_predict_non_zero_code(
                        h,
                        if DCT_LUMA_4x4 as ::core::ffi::c_int == DCT_LUMA_DC as ::core::ffi::c_int {
                            (p * 16 as ::core::ffi::c_int + i4 - LUMA_DC) * 16 as ::core::ffi::c_int
                        } else {
                            p * 16 as ::core::ffi::c_int + i4
                        },
                    ) as usize] as ::core::ffi::c_int
                };
            let mut nnz: *mut uint8_t = &mut *(*h).mb.cache.non_zero_count.as_mut_ptr().offset(
                *x264_scan8
                    .as_ptr()
                    .offset((p * 16 as ::core::ffi::c_int + i4) as isize) as isize,
            ) as *mut uint8_t;
            if *nnz == 0 {
                (*h).out.bs.i_bits_encoded +=
                    x264_coeff0_token[nC as usize].i_size as ::core::ffi::c_int;
            } else {
                *nnz = cavlc_block_residual_internal(
                    h,
                    DCT_LUMA_4x4 as ::core::ffi::c_int,
                    (*(*h)
                        .dct
                        .luma4x4
                        .as_mut_ptr()
                        .offset((p * 16 as ::core::ffi::c_int + i4) as isize))
                    .as_mut_ptr(),
                    nC,
                ) as uint8_t;
            }
            p += 1;
        }
        return (*h).out.bs.i_bits_encoded;
    }
    #[c2rust::src_loc = "704:1"]
    pub unsafe extern "C" fn chroma_size_cavlc(mut h: *mut x264_t) -> ::core::ffi::c_int {
        (*h).out.bs.i_bits_encoded = bs_size_ue(
            x264_mb_chroma_pred_mode_fix[(*h).mb.i_chroma_pred_mode as usize]
                as ::core::ffi::c_uint,
        );
        if (*h).mb.i_cbp_chroma != 0 {
            let mut nC: ::core::ffi::c_int = if DCT_CHROMA_DC as ::core::ffi::c_int
                == DCT_CHROMA_DC as ::core::ffi::c_int
            {
                5 as ::core::ffi::c_int - (*h).mb.chroma_v_shift
            } else {
                ct_index[x264_mb_predict_non_zero_code(
                    h,
                    if DCT_CHROMA_DC as ::core::ffi::c_int == DCT_LUMA_DC as ::core::ffi::c_int {
                        (49 as ::core::ffi::c_int + 0 as ::core::ffi::c_int - LUMA_DC)
                            * 16 as ::core::ffi::c_int
                    } else {
                        49 as ::core::ffi::c_int + 0 as ::core::ffi::c_int
                    },
                ) as usize] as ::core::ffi::c_int
            };
            let mut nnz: *mut uint8_t = &mut *(*h).mb.cache.non_zero_count.as_mut_ptr().offset(
                *x264_scan8
                    .as_ptr()
                    .offset((49 as ::core::ffi::c_int + 0 as ::core::ffi::c_int) as isize)
                    as isize,
            ) as *mut uint8_t;
            if *nnz == 0 {
                (*h).out.bs.i_bits_encoded +=
                    x264_coeff0_token[nC as usize].i_size as ::core::ffi::c_int;
            } else {
                *nnz = cavlc_block_residual_internal(
                    h,
                    DCT_CHROMA_DC as ::core::ffi::c_int,
                    (*(*h)
                        .dct
                        .chroma_dc
                        .as_mut_ptr()
                        .offset(0 as ::core::ffi::c_int as isize))
                    .as_mut_ptr(),
                    nC,
                ) as uint8_t;
            }
            let mut nC_0: ::core::ffi::c_int = if DCT_CHROMA_DC as ::core::ffi::c_int
                == DCT_CHROMA_DC as ::core::ffi::c_int
            {
                5 as ::core::ffi::c_int - (*h).mb.chroma_v_shift
            } else {
                ct_index[x264_mb_predict_non_zero_code(
                    h,
                    if DCT_CHROMA_DC as ::core::ffi::c_int == DCT_LUMA_DC as ::core::ffi::c_int {
                        (49 as ::core::ffi::c_int + 1 as ::core::ffi::c_int - LUMA_DC)
                            * 16 as ::core::ffi::c_int
                    } else {
                        49 as ::core::ffi::c_int + 1 as ::core::ffi::c_int
                    },
                ) as usize] as ::core::ffi::c_int
            };
            let mut nnz_0: *mut uint8_t = &mut *(*h).mb.cache.non_zero_count.as_mut_ptr().offset(
                *x264_scan8
                    .as_ptr()
                    .offset((49 as ::core::ffi::c_int + 1 as ::core::ffi::c_int) as isize)
                    as isize,
            ) as *mut uint8_t;
            if *nnz_0 == 0 {
                (*h).out.bs.i_bits_encoded +=
                    x264_coeff0_token[nC_0 as usize].i_size as ::core::ffi::c_int;
            } else {
                *nnz_0 = cavlc_block_residual_internal(
                    h,
                    DCT_CHROMA_DC as ::core::ffi::c_int,
                    (*(*h)
                        .dct
                        .chroma_dc
                        .as_mut_ptr()
                        .offset(1 as ::core::ffi::c_int as isize))
                    .as_mut_ptr(),
                    nC_0,
                ) as uint8_t;
            }
            if (*h).mb.i_cbp_chroma == 2 as ::core::ffi::c_int {
                let mut step: ::core::ffi::c_int =
                    (8 as ::core::ffi::c_int) << (*h).mb.chroma_v_shift;
                let mut i: ::core::ffi::c_int = 16 as ::core::ffi::c_int;
                while i < 3 as ::core::ffi::c_int * 16 as ::core::ffi::c_int {
                    let mut j: ::core::ffi::c_int = i;
                    while j < i + 4 as ::core::ffi::c_int {
                        let mut nC_1: ::core::ffi::c_int = if DCT_CHROMA_AC as ::core::ffi::c_int
                            == DCT_CHROMA_DC as ::core::ffi::c_int
                        {
                            5 as ::core::ffi::c_int - (*h).mb.chroma_v_shift
                        } else {
                            ct_index[x264_mb_predict_non_zero_code(
                                h,
                                if DCT_CHROMA_AC as ::core::ffi::c_int
                                    == DCT_LUMA_DC as ::core::ffi::c_int
                                {
                                    (j - LUMA_DC) * 16 as ::core::ffi::c_int
                                } else {
                                    j
                                },
                            ) as usize] as ::core::ffi::c_int
                        };
                        let mut nnz_1: *mut uint8_t = &mut *(*h)
                            .mb
                            .cache
                            .non_zero_count
                            .as_mut_ptr()
                            .offset(*x264_scan8.as_ptr().offset(j as isize) as isize)
                            as *mut uint8_t;
                        if *nnz_1 == 0 {
                            (*h).out.bs.i_bits_encoded +=
                                x264_coeff0_token[nC_1 as usize].i_size as ::core::ffi::c_int;
                        } else {
                            *nnz_1 = cavlc_block_residual_internal(
                                h,
                                DCT_CHROMA_AC as ::core::ffi::c_int,
                                (*(*h).dct.luma4x4.as_mut_ptr().offset(j as isize))
                                    .as_mut_ptr()
                                    .offset(1 as ::core::ffi::c_int as isize),
                                nC_1,
                            ) as uint8_t;
                        }
                        j += 1;
                    }
                    i += step;
                }
            }
        }
        return (*h).out.bs.i_bits_encoded;
    }
    use super::base_h::{
        x264_scan8, CHROMA_420, CHROMA_422, CHROMA_444, CHROMA_DC, LUMA_DC, PROFILE_HIGH,
        SLICE_TYPE_B, SLICE_TYPE_P,
    };
    use super::bitstream_h::{
        bs_size_se, bs_size_te, bs_size_ue, bs_t, x264_10_level_token, x264_10_run_before,
        x264_run_level_t, LEVEL_TABLE_SIZE,
    };
    use super::common_h::{dctcoef, x264_t, QP_BD_OFFSET, QP_MAX_SPEC};
    use super::macroblock_h::{
        x264_10_mb_predict_mv, x264_mb_partition_listX_table, x264_mb_predict_intra4x4_mode,
        x264_mb_predict_non_zero_code, x264_mb_transform_8x8_allowed, x264_mb_type_list_table,
        B_8x8, DCT_LUMA_4x4, D_16x16, D_16x8, D_8x16, I_16x16, I_4x4, I_8x8, P_8x8, B_BI_BI,
        B_DIRECT, B_L0_L0, B_SKIP, DCT_CHROMA_AC, DCT_CHROMA_DC, DCT_LUMA_AC, DCT_LUMA_DC, I_PCM,
        P_L0, P_SKIP,
    };
    use super::osdep_h::x264_ctz_4bit;
    use super::pixel_h::{x264_pixel_size, PIXEL_4x4, PIXEL_8x4, PIXEL_8x8};
    use super::predict_h::{
        x264_mb_chroma_pred_mode_fix, x264_mb_pred_mode16x16_fix, x264_mb_pred_mode4x4_fix,
    };
    use super::stdint_intn_h::{int16_t, int32_t, int8_t};
    use super::stdint_uintn_h::{uint16_t, uint32_t, uint8_t};
    use super::tables_h::{
        vlc_t, x264_coeff0_token, x264_coeff_token, x264_total_zeros, x264_total_zeros_2x2_dc,
        x264_total_zeros_2x4_dc,
    };
    use super::x264_h::X264_ANALYSE_PSUB8x8;
}
#[c2rust::header_src = "/home/nwplayer123/Hacks/hex264/x264/encoder/ratecontrol.h:28"]
pub mod ratecontrol_h {
    use super::common_h::x264_t;
    extern "C" {
        #[c2rust::src_loc = "65:1"]
        pub fn x264_10_ratecontrol_slice_type(
            _: *mut x264_t,
            i_frame: ::core::ffi::c_int,
        ) -> ::core::ffi::c_int;
        #[c2rust::src_loc = "73:1"]
        pub fn x264_10_ratecontrol_mb_qp(h: *mut x264_t) -> ::core::ffi::c_int;
    }
    use super::frame_h::x264_frame_t;
    extern "C" {
        #[c2rust::src_loc = "43:1"]
        pub fn x264_10_ratecontrol_new(_: *mut x264_t) -> ::core::ffi::c_int;
        #[c2rust::src_loc = "45:1"]
        pub fn x264_10_ratecontrol_delete(_: *mut x264_t);
        #[c2rust::src_loc = "48:1"]
        pub fn x264_10_ratecontrol_init_reconfigurable(h: *mut x264_t, b_init: ::core::ffi::c_int);
        #[c2rust::src_loc = "53:1"]
        pub fn x264_10_adaptive_quant_frame(
            h: *mut x264_t,
            frame: *mut x264_frame_t,
            quant_offsets: *mut ::core::ffi::c_float,
        );
        #[c2rust::src_loc = "55:1"]
        pub fn x264_10_macroblock_tree_read(
            h: *mut x264_t,
            frame: *mut x264_frame_t,
            quant_offsets: *mut ::core::ffi::c_float,
        ) -> ::core::ffi::c_int;
        #[c2rust::src_loc = "57:1"]
        pub fn x264_10_reference_build_list_optimal(h: *mut x264_t) -> ::core::ffi::c_int;
        #[c2rust::src_loc = "59:1"]
        pub fn x264_10_thread_sync_ratecontrol(
            cur: *mut x264_t,
            prev: *mut x264_t,
            next: *mut x264_t,
        );
        #[c2rust::src_loc = "61:1"]
        pub fn x264_10_ratecontrol_zone_init(_: *mut x264_t);
        #[c2rust::src_loc = "63:1"]
        pub fn x264_10_ratecontrol_start(
            _: *mut x264_t,
            i_force_qp: ::core::ffi::c_int,
            overhead: ::core::ffi::c_int,
        );
        #[c2rust::src_loc = "67:1"]
        pub fn x264_10_ratecontrol_set_weights(h: *mut x264_t, frm: *mut x264_frame_t);
        #[c2rust::src_loc = "69:1"]
        pub fn x264_10_ratecontrol_mb(
            _: *mut x264_t,
            bits: ::core::ffi::c_int,
        ) -> ::core::ffi::c_int;
        #[c2rust::src_loc = "71:1"]
        pub fn x264_10_ratecontrol_qp(_: *mut x264_t) -> ::core::ffi::c_int;
        #[c2rust::src_loc = "75:1"]
        pub fn x264_10_ratecontrol_end(
            _: *mut x264_t,
            bits: ::core::ffi::c_int,
            filler: *mut ::core::ffi::c_int,
        ) -> ::core::ffi::c_int;
        #[c2rust::src_loc = "77:1"]
        pub fn x264_10_ratecontrol_summary(_: *mut x264_t);
        #[c2rust::src_loc = "81:1"]
        pub fn x264_10_threads_distribute_ratecontrol(h: *mut x264_t);
        #[c2rust::src_loc = "83:1"]
        pub fn x264_10_threads_merge_ratecontrol(h: *mut x264_t);
        #[c2rust::src_loc = "85:1"]
        pub fn x264_10_hrd_fullness(h: *mut x264_t);
    }
}
#[c2rust::header_src = "/usr/lib/clang/21/include/limits.h:28"]
pub mod limits_h {
    #[c2rust::src_loc = "50:9"]
    pub const INT_MAX: ::core::ffi::c_int = __INT_MAX__;
    use super::internal::__INT_MAX__;
}

#[c2rust::header_src = "/home/nwplayer123/Hacks/hex264/x264/encoder/analyse.h:28"]
pub mod analyse_h {
    use super::common_h::x264_t;
    use super::frame_h::x264_frame_t;
    extern "C" {
        #[c2rust::src_loc = "31:1"]
        pub fn x264_10_analyse_init_costs(h: *mut x264_t) -> ::core::ffi::c_int;
        #[c2rust::src_loc = "33:1"]
        pub fn x264_10_analyse_free_costs(h: *mut x264_t);
        #[c2rust::src_loc = "35:1"]
        pub fn x264_10_analyse_weight_frame(h: *mut x264_t, end: ::core::ffi::c_int);
        #[c2rust::src_loc = "37:1"]
        pub fn x264_10_macroblock_analyse(h: *mut x264_t);
        #[c2rust::src_loc = "45:1"]
        pub fn x264_10_lookahead_init(
            h: *mut x264_t,
            i_slicetype_length: ::core::ffi::c_int,
        ) -> ::core::ffi::c_int;
        #[c2rust::src_loc = "47:1"]
        pub fn x264_10_lookahead_is_empty(h: *mut x264_t) -> ::core::ffi::c_int;
        #[c2rust::src_loc = "49:1"]
        pub fn x264_10_lookahead_put_frame(h: *mut x264_t, frame: *mut x264_frame_t);
        #[c2rust::src_loc = "51:1"]
        pub fn x264_10_lookahead_get_frames(h: *mut x264_t);
        #[c2rust::src_loc = "53:1"]
        pub fn x264_10_lookahead_delete(h: *mut x264_t);
    }
}

#[c2rust::header_src = "/home/nwplayer123/Hacks/hex264/x264/encoder/set.h:28"]
pub mod encoder_set_h {
    use super::bitstream_h::bs_t;
    use super::common_h::x264_t;
    use super::set_h::{x264_pps_t, x264_sps_t};
    use super::stdint_uintn_h::uint8_t;
    use super::x264_h::x264_param_t;
    extern "C" {
        #[c2rust::src_loc = "31:1"]
        pub fn x264_10_sps_init(
            sps: *mut x264_sps_t,
            i_id: ::core::ffi::c_int,
            param: *mut x264_param_t,
        );
        #[c2rust::src_loc = "33:1"]
        pub fn x264_10_sps_init_reconfigurable(sps: *mut x264_sps_t, param: *mut x264_param_t);
        #[c2rust::src_loc = "35:1"]
        pub fn x264_10_sps_init_scaling_list(sps: *mut x264_sps_t, param: *mut x264_param_t);
        #[c2rust::src_loc = "37:1"]
        pub fn x264_10_sps_write(s: *mut bs_t, sps: *mut x264_sps_t);
        #[c2rust::src_loc = "39:1"]
        pub fn x264_10_pps_init(
            pps: *mut x264_pps_t,
            i_id: ::core::ffi::c_int,
            param: *mut x264_param_t,
            sps: *mut x264_sps_t,
        );
        #[c2rust::src_loc = "41:1"]
        pub fn x264_10_pps_write(s: *mut bs_t, sps: *mut x264_sps_t, pps: *mut x264_pps_t);
        #[c2rust::src_loc = "43:1"]
        pub fn x264_10_sei_recovery_point_write(
            h: *mut x264_t,
            s: *mut bs_t,
            recovery_frame_cnt: ::core::ffi::c_int,
        );
        #[c2rust::src_loc = "45:1"]
        pub fn x264_10_sei_version_write(h: *mut x264_t, s: *mut bs_t) -> ::core::ffi::c_int;
        #[c2rust::src_loc = "47:1"]
        pub fn x264_10_validate_levels(
            h: *mut x264_t,
            verbose: ::core::ffi::c_int,
        ) -> ::core::ffi::c_int;
        #[c2rust::src_loc = "49:1"]
        pub fn x264_10_sei_buffering_period_write(h: *mut x264_t, s: *mut bs_t);
        #[c2rust::src_loc = "51:1"]
        pub fn x264_10_sei_pic_timing_write(h: *mut x264_t, s: *mut bs_t);
        #[c2rust::src_loc = "53:1"]
        pub fn x264_10_sei_dec_ref_pic_marking_write(h: *mut x264_t, s: *mut bs_t);
        #[c2rust::src_loc = "55:1"]
        pub fn x264_10_sei_frame_packing_write(h: *mut x264_t, s: *mut bs_t);
        #[c2rust::src_loc = "57:1"]
        pub fn x264_10_sei_mastering_display_write(h: *mut x264_t, s: *mut bs_t);
        #[c2rust::src_loc = "59:1"]
        pub fn x264_10_sei_content_light_level_write(h: *mut x264_t, s: *mut bs_t);
        #[c2rust::src_loc = "61:1"]
        pub fn x264_10_sei_alternative_transfer_write(h: *mut x264_t, s: *mut bs_t);
        #[c2rust::src_loc = "63:1"]
        pub fn x264_10_sei_avcintra_umid_write(h: *mut x264_t, s: *mut bs_t) -> ::core::ffi::c_int;
        #[c2rust::src_loc = "65:1"]
        pub fn x264_10_sei_avcintra_vanc_write(
            h: *mut x264_t,
            s: *mut bs_t,
            len: ::core::ffi::c_int,
        ) -> ::core::ffi::c_int;
        #[c2rust::src_loc = "67:1"]
        pub fn x264_10_sei_write(
            s: *mut bs_t,
            payload: *mut uint8_t,
            payload_size: ::core::ffi::c_int,
            payload_type: ::core::ffi::c_int,
        );
        #[c2rust::src_loc = "69:1"]
        pub fn x264_10_filler_write(h: *mut x264_t, s: *mut bs_t, filler: ::core::ffi::c_int);
    }
}

#[c2rust::header_src = "/usr/include/pthread.h:28"]
pub mod pthread_h {
    use super::pthreadtypes_h::{
        pthread_cond_t, pthread_condattr_t, pthread_mutex_t, pthread_mutexattr_t,
    };
    extern "C" {
        #[c2rust::src_loc = "781:1"]
        pub fn pthread_mutex_init(
            __mutex: *mut pthread_mutex_t,
            __mutexattr: *const pthread_mutexattr_t,
        ) -> ::core::ffi::c_int;
        #[c2rust::src_loc = "786:1"]
        pub fn pthread_mutex_destroy(__mutex: *mut pthread_mutex_t) -> ::core::ffi::c_int;
        #[c2rust::src_loc = "794:1"]
        pub fn pthread_mutex_lock(__mutex: *mut pthread_mutex_t) -> ::core::ffi::c_int;
        #[c2rust::src_loc = "835:1"]
        pub fn pthread_mutex_unlock(__mutex: *mut pthread_mutex_t) -> ::core::ffi::c_int;
        #[c2rust::src_loc = "1112:1"]
        pub fn pthread_cond_init(
            __cond: *mut pthread_cond_t,
            __cond_attr: *const pthread_condattr_t,
        ) -> ::core::ffi::c_int;
        #[c2rust::src_loc = "1117:1"]
        pub fn pthread_cond_destroy(__cond: *mut pthread_cond_t) -> ::core::ffi::c_int;
        #[c2rust::src_loc = "1125:1"]
        pub fn pthread_cond_broadcast(__cond: *mut pthread_cond_t) -> ::core::ffi::c_int;
    }
    use super::pthreadtypes_h::{pthread_attr_t, pthread_t};
    extern "C" {
        #[c2rust::src_loc = "202:1"]
        pub fn pthread_create(
            __newthread: *mut pthread_t,
            __attr: *const pthread_attr_t,
            __start_routine: Option<
                unsafe extern "C" fn(*mut ::core::ffi::c_void) -> *mut ::core::ffi::c_void,
            >,
            __arg: *mut ::core::ffi::c_void,
        ) -> ::core::ffi::c_int;
        #[c2rust::src_loc = "219:1"]
        pub fn pthread_join(
            __th: pthread_t,
            __thread_return: *mut *mut ::core::ffi::c_void,
        ) -> ::core::ffi::c_int;
        #[c2rust::src_loc = "1133:1"]
        pub fn pthread_cond_wait(
            __cond: *mut pthread_cond_t,
            __mutex: *mut pthread_mutex_t,
        ) -> ::core::ffi::c_int;
    }
}
